<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 注解</title>
    <url>/2017/07/08/Java%20%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="http://docs.oracle.com/javase/tutorial/java/annotations/index.html">原文链接：</a>注解是元数据的一种形式，它提供了一个不属于程序本身的关于程序的数据。注解对他们注释的代码的操作没有直接的影响。</p>
<p>注解有很多用途，其中：</p>
<ul>
<li><strong>编译器的信息</strong>—注解可以被编译器使用，用来探测错误或者抑制警告。</li>
<li><strong>编译时或部署时进行处理</strong>—软件工具可以处理注解信息用来生成代码，XML文件等等。</li>
<li><strong>运行时处理</strong>—一些注解可在运行时检查。</li>
</ul>
<p>本课介绍了可以使用注解的位置，如何应用注解，有哪些预定义注解类型在Java平台标准版（Java SE API）中可用，如何将类型注解与可插拔型系统结合使用，以更强类型检查来编写代码，以及如何实现重复注解。</p>
<span id="more"></span>
<hr>
<h1 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h1><hr>
<h2 id="注解的格式"><a href="#注解的格式" class="headerlink" title="注解的格式"></a>注解的格式</h2><hr>
<p>在其最简单的形式中，注解如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br></pre></td></tr></table></figure>
<p>at符号（@）向编译器指出以下是注解。下面这个示例，注解的名称是Override</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">void mySuperMethod() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注解可以包含已命名或未命名的元素，并且这些元素有值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(</span></span><br><span class="line"><span class="meta">   name = &quot;Benjamin Franklin&quot;,</span></span><br><span class="line"><span class="meta">   date = &quot;3/27/2003&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>() &#123; ... &#125;</span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如有只有一个名为value的元素，那么这个名称可以省略，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果一个注解没有元素，那么括号可以被省略，如之前的@Override示例。</p>
<p>同样的声明也可以使用多个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(name = &quot;Jane Doe&quot;)</span></span><br><span class="line"><span class="meta">@EBook</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果几个注解是相同的类型，那么这个被称作一个重复注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(name = &quot;Jane Doe&quot;)</span></span><br><span class="line"><span class="meta">@Author(name = &quot;John Smith&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>从Java SE 8版本开始支持重复注解</strong>。有关详细信息，请参阅重复注解。</p>
<p>注解类型可以是Java SE API的java.lang或java.lang.annotation包中定义的类型之一。在前面的示例中，Override和SuppressWarning是Java预定义注解。而前面示例中Author和Ebook是自定义注解。</p>
<h2 id="注解可以在哪里使用"><a href="#注解可以在哪里使用" class="headerlink" title="注解可以在哪里使用"></a>注解可以在哪里使用</h2><hr>
<p>注解可以应用于声明：类，字段，方法以及其他程序元素的声明。在声明中使用时，每个注解通常按照惯例出现在它的行上。</p>
<p>从Java SE 8版本开始，注解也可以应用于类型的使用。这里有些例子：</p>
<ul>
<li>类实例创建表达式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</span><br></pre></td></tr></table></figure></li>
<li>类型转换<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myString = (<span class="meta">@NonNull</span> String) str;</span><br></pre></td></tr></table></figure></li>
<li>implements语句<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;T&gt; implements  <span class="meta">@Readonly</span> List&lt;<span class="meta">@Readonly</span> T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>异常抛出声明<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">monitorTemperature</span><span class="params">()</span> <span class="keyword">throws</span> <span class="meta">@Critical</span> TemperatureException &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这种形式的注解叫做类型注解。更多信息请参阅<a href="http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html">类型注解与可插拔型系统</a></p>
<hr>
<h1 id="声明一个注解类型"><a href="#声明一个注解类型" class="headerlink" title="声明一个注解类型"></a>声明一个注解类型</h1><hr>
<p>许多注解取代了代码内的注释。</p>
<p>假设一个软件组传统上在每个类体的开始使用注释来提供一些重要信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generation3List</span> <span class="keyword">extends</span> <span class="title class_">Generation2List</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Author: John Doe</span></span><br><span class="line">   <span class="comment">// Date: 3/17/2002</span></span><br><span class="line">   <span class="comment">// Current revision: 6</span></span><br><span class="line">   <span class="comment">// Last modified: 4/12/2004</span></span><br><span class="line">   <span class="comment">// By: Jane Doe</span></span><br><span class="line">   <span class="comment">// Reviewers: Alice, Bill, Cindy</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// class code goes here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解来添加这些相同的元数据，你首先必须定义注解类型。这样做的语法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> ClassPreamble &#123;</span><br><span class="line">   String <span class="title function_">author</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">date</span><span class="params">()</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">currentRevision</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">   String <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">   String <span class="title function_">lastModifiedBy</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">   <span class="comment">// Note use of array</span></span><br><span class="line">   String[] reviewers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解类型定义看起来和接口定义很相似，其中关键字interface前面添加了at符号(@)（@ &#x3D; AT，作为注释类型）。注解类型是是接口的一种形式。</p>
<p>前面注解体内的定义包含了注解类型元素声明，它们看来了很像方法。注意，它们可以定义一个可选的默认值。</p>
<p>在注解类型被定义后，你可以填充上值使用这个类型的注解，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ClassPreamble</span> (</span><br><span class="line">   author = <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">   date = <span class="string">&quot;3/17/2002&quot;</span>,</span><br><span class="line">   currentRevision = <span class="number">6</span>,</span><br><span class="line">   lastModified = <span class="string">&quot;4/12/2004&quot;</span>,</span><br><span class="line">   lastModifiedBy = <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line">   <span class="comment">// Note array notation</span></span><br><span class="line">   reviewers = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cindy&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generation3List</span> <span class="keyword">extends</span> <span class="title class_">Generation2List</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class code goes here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：要使@ClassPreamble中的信息显示在Javadoc生成的文档中，您必须使用@Documented注解对@ClassPreamble定义进行注解：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import this to use @Documented</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> ClassPreamble &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Annotation element definitions</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="预定义注解类型"><a href="#预定义注解类型" class="headerlink" title="预定义注解类型"></a>预定义注解类型</h1><hr>
<p>一组注解释类型是在Java SE API中预定义的。一些注解类型由Java编译器使用，一些注解类型也用于其他注解。</p>
<h2 id="Java语言使用的注解类型"><a href="#Java语言使用的注解类型" class="headerlink" title="Java语言使用的注解类型"></a>Java语言使用的注解类型</h2><hr>
<p>java.lang中定义的预定义注解类型为@Deprecated，@Override和@SuppressWarnings。</p>
<p><strong>@Deprecated</strong>注解表示标记的元素已被弃用，不应再使用。无论程序什么时候使用一个被@Deprecated注解的方法，类或者字段，编译器都会产生一个警告。当一个元素已经弃用，，还应使用Javadoc @deprecated标签进行记录，如以下示例所示。在Javadoc注释和注解中使用at符号（@）不是巧合的：它们在概念上是相关的。另外请注意，Javadoc标签以小写d开头，而注解以大写D开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// Javadoc comment follows</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     * explanation of why it was deprecated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deprecatedMethod</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Override</strong>注解通知编译器这个元素意图重写在超类中声明的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标记方法作为被重写的超类方法</span></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">overriddenMethod</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>虽然在重写方法时不需要使用此注解，但它有助于防止错误。如果一个使用@Override标记的方法没有能够正确重写一个它的超类中的方法，编译器会产生一个错误。</p>
<p><strong>@SuppressWarnings</strong>注解告诉编译器去抑制一个它可能会产出的特定警告。在下面的示例中，使用了一个弃用方法，并且编译器经常会产生一个警告。然而，在这种情况下，这个注解到这警告被抑制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用弃用方法并且告诉编译器不要产生警告</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">useDeprecatedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// deprecation warning</span></span><br><span class="line">       <span class="comment">// - suppressed</span></span><br><span class="line">       objectOne.deprecatedMethod();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>每个编译器警告都属于一个类别。Java语言规范列举了两种分类：deprcation和unchecked。在泛型出现之前编写的遗留代码进行接口事，可能会发生unchecked警告。要想抑制多个种类的警告，使用以下语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>@SafeVarargs</strong>注解，当应用于一个方法或构造器，断言该代码不会对它的可变参数执行潜在的不安全操作。当这个注解类型被使用，与可变参数相关连的unchecked警告被抑制。</p>
<p><strong>@FunctionallInterface</strong>注解在Java8中被引入，它表示类型声明旨在作为一个Java语言规范定义的函数式接口。</p>
<h2 id="应用于其他注解的注解"><a href="#应用于其他注解的注解" class="headerlink" title="应用于其他注解的注解"></a>应用于其他注解的注解</h2><hr>
<p>一个应用于其他注解的注解被称为元注解（meta-annotations）。这有几个定义在java.lang.annotation中的元注解类型。</p>
<p><strong>@Retention</strong>注解指示被标记的注解如何储存：</p>
<ul>
<li>RetentionPolicy.SOURCE – 被标记注解仅在源代码阶段被保留，并被编译器忽略。</li>
<li>RetentionPolicy.CLASS – 被标记注解在编译时期由编译器保留，但是被Java虚拟机（JVM）忽略。</li>
<li>RetentionPolicy.RUNTIME – 被标记注解被JVM保留，所以它可以由运行时环境使用。</li>
</ul>
<p><strong>@Documented</strong>注解表示无论什么时候使用被指定注解，都应该使用Javadoc工具记录这些元素。（默认情况下，注解不包括在Javadoc中。）更多信息，参阅<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc工具页面</a><br><strong>@Target</strong>注解表示另一个注解，以限制这个注解可以应用的Java元素类型。一个target注解指定以下元素类型之一作为它的值：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE可以应用于一个注解类型</li>
<li>ElementType.CONSTRUCTOR可以应用于一个构造器。</li>
<li>ElementType.FIELD可以应用一个字段或属性。</li>
<li>ElementType.LOCAL_VARIABLE可以应用于一个本地变量</li>
<li>ElementType.METHOD可以应用于一个方法级注解</li>
<li>ElementType.PACKAGE可以应用于一个包声明</li>
<li>ElementType.PARAMETER可以应用于方法的参数</li>
<li>ElementType.TYPE可以应用于任何类元素</li>
</ul>
<p><strong>@Inherited</strong>注解表示这个注解类型可以从超类继承（默认下是不可以的）。当用户查询注解类型，而类没有此类型注解时，会在类的超类进行查询。这个注解只能应用于类声明。</p>
<p><strong>@Repeatable</strong>注解，在JavaSE 8中引入，表示被标记的注解可以被多次应用于相同的声明或类型使用。更多信息请看<a href="#%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3">重复注解</a></p>
<hr>
<h1 id="类型注解和可插拔类型系统"><a href="#类型注解和可插拔类型系统" class="headerlink" title="类型注解和可插拔类型系统"></a>类型注解和可插拔类型系统</h1><hr>
<p>在Java SE 8发布之前，注解只能应用于声明。从Java SE 8版本开始，注解也可以应用于任何的类型使用。这意味着注解可以在你使用类型的任何位置使用。使用类型的几个例子是类实例创建表达式（new），类型转换。implements语句，以及throws语句。这个形式的注解被称为一个类型注解，并且在<a href="#%E6%B3%A8%E8%A7%A3%E5%9F%BA%E7%A1%80">注解基础</a>中提供了几个示例。类型注解被创建是用来支持提升Java语言的分析方式，以确保更强大的类型坚持。JavaSe 8没有提供一个类型检查框架，但是它运行你编写（或下载）一个类型检查框架，该框架实现为与Java编译器结合使用的一个或多个可插拔模块。</p>
<p>比如，你需要确保一个在你的程序中的特定的变量永远不会被赋值为null；因为想要避免一个NullPointerException。您可以编写一个自定义插件来检查。然后你会修改你的代码来注解该变量，指示它永远不会被赋值为null。这个变量声明可能看起来是这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> String str；</span><br></pre></td></tr></table></figure>
<p>当你编译代码时，将NonNull模块包含在命令行内，如果编译器探测到一个潜在的问题，就会打印一个警告，运行你修改代码来避免这个问题。在你正确修改代码移除所有警告后，这个特定的错误不会在程序运行时发生。</p>
<p>你可以使用多类型检查模块，其中每个模块检查一种类型的错误。以这种方式，你可以在Java类型系统之上构建，在你想要的任何时期或位置添加指定的检查。</p>
<p>在恰当的使用类型注解和可插拔类型检查的存在下，你可以编写更加健壮和更不容易出错的代码。</p>
<p>以在很多情况下，你不需要编写你自己的类型检查模块。这是第三方已经为你做过的工作。比如，例如，您可能希望利用华盛顿大学创建的Checker Framework 。这个框架包含了NonNull模块，以及一个正则表达式模块和一个互斥锁模块。更多信息查看<a href="http://types.cs.washington.edu/checker-framework/">Checker Framework</a>。</p>
<hr>
<h1 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h1><hr>
<p>很多情景下你想要应用相同的注解到一个声明或类型使用上。从Java SE 8版本开始，重复注解使你能够做到这一点。</p>
<p>比如，你正在编写代码使用了一个时间服务，使你可以在给定时间或者在某个时间表上运行一个方法，这类似于UNIX的cron服务。现在你想要设置一个定时器来运行一个方法-doPeriodicCleanup，在这个月的最后一天和每个星期五晚上11点。要设置这个定时器运行，创建一个@Schedule注解并且在doPeriodicCleanup方法上应用两次。第一次使用指定这个月的最后一天，第二次指定周五的下午11点，如下代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Schedule(dayOfMonth=&quot;last&quot;)</span></span><br><span class="line"><span class="meta">@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPeriodicCleanup</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>前一个示例应用一个注解到方法上。你可以在使用标准注解的任何地方使用重复注解。比如，比有一个类用来处理未经授权的访问异常。你使用<br>@Alert注解，一个为manager，另一个为admin来注解这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alert(role=&quot;Manager&quot;)</span></span><br><span class="line"><span class="meta">@Alert(role=&quot;Administrator&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnauthorizedAccessException</span> <span class="keyword">extends</span> <span class="title class_">SecurityException</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>出于兼容性原因，重复注解存储在由Java编译器自动生成的容器注解中。为了使编译器执行此操作，您的代码中需要两个声明。</p>
<h2 id="步骤1-声明一个重复注解类型"><a href="#步骤1-声明一个重复注解类型" class="headerlink" title="步骤1:声明一个重复注解类型"></a>步骤1:声明一个重复注解类型</h2><hr>
<p>这个注解类型必须使用@Repeatable元注解标记。下面示例定义了一个自定义@Schedule重复注解类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Schedules.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Schedule &#123;</span><br><span class="line">  String <span class="title function_">dayOfMonth</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;first&quot;</span>;</span><br><span class="line">  String <span class="title function_">dayOfWeek</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">hour</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在括号中@Repeatable元注解的值是Java编译器生成的用于存储重复注解的容器注解的类型。在这个示例中，容器注解类型是Schedules，所以重复注解@Schedule被存储在一个@Schedules注解中。</p>
<p>没有声明注解是重复注解就应用相同的该注解到一个声明上会导致编译时期错误。</p>
<h2 id="步骤2-声明容器注解类型"><a href="#步骤2-声明容器注解类型" class="headerlink" title="步骤2:声明容器注解类型"></a>步骤2:声明容器注解类型</h2><hr>
<p>容器注解类型必须有一个数组类型的value元素。数组类型的组件类型必须是重复注解类型。Schedules容器注解类型的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Schedules &#123;</span><br><span class="line">    Schedule[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检索注解"><a href="#检索注解" class="headerlink" title="检索注解"></a>检索注解</h2><hr>
<p>Reflection API中有几种可用于检索注解的方法。有的方法可以返回单个注解，比如AnnotatedElement.getAnnotationByType(Class&lt;T&gt;),如果一个请求的注解类型存在的话，它们只返回一个单独的注解。如果请求类型的注解超过一个的话，你可以通过首先获取它们的容器注解来获取它们。以这种方式，遗留代码可以继续运行。在Java SE 8中引入了其他方法，扫描容器注解以一次返回多个注解，比如AnnotatedElement.getAnnotations(Class&lt;T&gt;),有关所有可用方法的信息，请参阅AnnotatedElement()类规范。</p>
<h2 id="设计注意事项"><a href="#设计注意事项" class="headerlink" title="设计注意事项"></a>设计注意事项</h2><hr>
<p>在设计注解类型时，必须考虑一个注解类型的基数。如果注解的类型被标记为@Repeatable，则可以使用一个注解零次，一次或多次。也可以通过使用@Target元注解来限制注解类型的使用位置。比如你可以创建一个注解，只能用在方法和字段上。重要的是设计注解的时候要仔细确保程序员使用注解时发现它尽可能灵活和强大。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 注解</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Date-Time（一）概述</title>
    <url>/2017/07/12/Java-Date-Time%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>时间似乎是一个简单的主题;即使是便宜的手表也能提供相当准确的日期和时间。不过，仔细检查一下，你会意识到微妙的复杂性和许多因素，这会影响你对时间的理解。例如，闰年比1月31日增加的结果与其他年份不同。时区也增加了复杂性。例如，一个国家可能在短时间内进出夏令时，或者每年多于一次，或者可能会在一年内完全跳过夏令时。</p>
<p>Date-Time API使用ISO-8601中定义的日历系统作为默认日历。该日历基于公历日历系统，并在全球范围内用作代表日期和时间的标准。Date-Time API中的核心类有有一些比如LocalDateTime，ZonedDateTime和OffsetDateTime等的名字。所有这些都使用ISO日历系统。如果你想要使用其他的日历系统，比如伊历或者泰国佛历，他的java.time.chrono包允许您使用预定义的日历系统之一。或者你可以创建你自己的日历系统。</p>
<span id="more"></span>

<p>Date-Time API使用Unicode通用区域设置数据存储库（CLDR）。该存储库支持世界语言，并且包含世界上最大的可用的区域设置数据集。该存储库中的信息已被本地化为数百种语言。Date-Time API还使用时区数据库（TZDB）。该数据库提供自1970年以来有关全球范围内每个时区变化的信息，以及自从引入时区概念依赖，主时区的历史记录。</p>
<hr>
<h1 id="Date-Time-API历史"><a href="#Date-Time-API历史" class="headerlink" title="Date-Time API历史"></a>Date-Time API历史</h1><hr>
<p>在Java刚刚发布，也就是版本1.0的时候，对时间和日期仅有的支持就是java.util.Date类。大多数开发者对它的第一印象就是，它根本不代表一个“日期”。实际上，它只是简单的表示一个，从1970-01-01Z开始计时的，精确到毫秒的瞬时点。由于标准的toString()方法，按照JVM的默认时区输出时间和日期，有些开发人员把它误认为是时区敏感的。</p>
<p>在升级Java到1.1期间，Date类被认为是无法修复的。由于这个原因，java.util.Calendar类被添加了进来。悲剧的是，Calendar类并不比java.util.Date好多少。它们面临的部分问题是：</p>
<ul>
<li><strong>可变性</strong>。像时间和日期这样的类应该是不可变的。</li>
<li><strong>偏移性</strong>。Date中的年份是从1900开始的，而月份都是从0开始的。</li>
<li><strong>命名</strong>。Date不是“日期”，而Calendar也不真实“日历”。</li>
<li><strong>格式化</strong>。格式化只对Date有用，Calendar则不行。另外，它也不是线程安全的。</li>
</ul>
<p>大约在2001年，Joda-Time项目开始了。它的目的很简单，就是给Java提供一个高质量的时间和日期类库。尽管被耽搁了一段时间，它的1.0版还是被发布。很快，它就成为了广泛使用和流行的类库。随着时间的推移，有越来越多的需求，要在JDK中拥有一个像Joda-Time的这样类库。在来自巴西的Michael Nascimento Santos的帮助下，官方为JDK开发新的时间&#x2F;日期API的进程：JSR-310，启动了。</p>
<hr>
<h1 id="Date-Time设计原则"><a href="#Date-Time设计原则" class="headerlink" title="Date-Time设计原则"></a>Date-Time设计原则</h1><hr>
<p>新的Date-Time API使用以下几个设计原则来开发</p>
<p><strong>简洁</strong><br>API中的方法被很好地定义，它们的行为是明确和预期的。例如，使用一个null参数值调用Date-Time方法通常会触发一个NullPointerException。<br><strong>流畅</strong><br>Date-Time API提供了一个流畅的接口，使代码简单易读。因为大多数方法不允许具有null值的参数并且不返回null值，方法调用可以链接在一起，所以代码可以被快速理解。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">payday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth()).minusDays(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>不可变</strong><br>大多数在Date-Time API中的类创建的对象都是不可变的，这意味着在对象创建后，它不可以被修改。要想改变一个不可变对象，只有构建一个新的对象，作为原始对象的修改拷贝副本。这也意味着Date-Time API根据定义是线程安全的。这回影响API，因为用于创建时期和时间对象的方法都是以of,from或with开头的，而不是使用构造方法，并且这里没有set方法。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">dateOfBirth</span> <span class="operator">=</span> LocalDate.of(<span class="number">2012</span>, Month.MAY, <span class="number">14</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">firstBirthday</span> <span class="operator">=</span> dateOfBirth.plusYears(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>可拓展</strong><br>Date-Time API是尽可能可扩展的。例如，您可以定义自己的时间调整器和查询，或构建自己的日历系统。</p>
<hr>
<h1 id="Date-Time-包"><a href="#Date-Time-包" class="headerlink" title="Date-Time 包"></a>Date-Time 包</h1><hr>
<p>Date-time API由主包java.time和四个子包组成：</p>
<ul>
<li>java.time<br>这个API的核心表示日期和时间。它包含用于日期，时间，日期和时间结合，瞬间，持续时间和时钟的类。这些类基于定义在ISO-8601中的日历系统，并且都是不可变和线程安全的。</li>
<li>java.time.chrono<br>这个API表示默认ISO-8601以外的日历系统。你同样可以定义自己的日历系统。本教程没有详细介绍这个包。</li>
<li>java.time.format<br>用于格式化和解析日期与时间的类。</li>
<li>java.time.temporal<br>拓展API，主要面向框架和库的编写者，允许日期和时间类之间的互操作，查询和调整。字段（TemporalField和ChronoField）和单位（TemporalUnit和ChronoUnit）在此包中定义。</li>
<li>java.time.zone<br>支持时区，时区偏移和时区规则的类。如果使用时区，大多数开发人员只需要使用ZonedDateTime和ZoneId或ZoneOffset。</li>
</ul>
<hr>
<h1 id="方法命名约定"><a href="#方法命名约定" class="headerlink" title="方法命名约定"></a>方法命名约定</h1><hr>
<p>Date-Time API在丰富的类中提供了丰富的方法。并且尽可能在类之间使方法名称一致。比如，许多类提供一个now方法，它捕获与该类相关的当前时刻的日期或时间值还有一个from方法，它允许从一个类转换为另一个类。</p>
<p>还有关于方法名称前缀的标准化。因为Date-Time API中的大多数类是不可变的，所以API不包括set方法。（在创建之后，一个不可变对象的值不能被改变。不可变对象等同于set方法的是with方法）下面表格列举了通常使用的前缀。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>方法类型</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>of</td>
<td>静态工厂</td>
<td>创建一个实例，其中工厂主要验证输入参数，而不转换它们。</td>
</tr>
<tr>
<td>from</td>
<td>静态工厂</td>
<td>将输入参数转换为目标类的实例，这可能涉及从输入中丢失信息。</td>
</tr>
<tr>
<td>parse</td>
<td>静态工厂</td>
<td>解析输入字符串来产生一个目标类的实例</td>
</tr>
<tr>
<td>format</td>
<td>实例</td>
<td>使用指定的formater来格式化事件对象中的值，产生一个字符串</td>
</tr>
<tr>
<td>get</td>
<td>实例</td>
<td>返回目标对象状态的一部分</td>
</tr>
<tr>
<td>is</td>
<td>实例</td>
<td>查询目标对象的状态</td>
</tr>
<tr>
<td>with</td>
<td>实例</td>
<td>返回一个目标对象修改了一个元素的副本。这是不可变对象等同于JavaBean中set方法的方法。</td>
</tr>
<tr>
<td>plus</td>
<td>实例</td>
<td>返回目标对象增加了一段时间的副本</td>
</tr>
<tr>
<td>minus</td>
<td>实例</td>
<td>返回目标对象扣除了一段时间的副本</td>
</tr>
<tr>
<td>to</td>
<td>实例</td>
<td>将这个对象转换为另一种类型</td>
</tr>
<tr>
<td>at</td>
<td>实例</td>
<td>将这个对象与另一个组合在一起</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java Date-Time</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Object</title>
    <url>/2017/08/26/Java-Object/</url>
    <content><![CDATA[<hr>
<h1 id="Object作为超类"><a href="#Object作为超类" class="headerlink" title="Object作为超类"></a>Object作为超类</h1><hr>
<p><strong>Object</strong>类在<strong>java.lang</strong>包中，它位于类层次结构树的顶部。每个类都是直接或间接派生自<strong>Object</strong>。你使用或编写的每个子类都继承了<strong>Object</strong>的实例方法。你不需要使用任何这些方法，但如果你使用的话，你可能需要使用特定于你的类的代码来重写它们。从<strong>Object</strong>继承的方法有以下几个：</p>
<span id="more"></span>

<ul>
<li>protected Object clone() throws CloneNotSupportedException<br>创建并返回这个对象的副本</li>
<li>public boolean equals(Object obj)<br>指示一些其他对象是否等于这个对象。</li>
<li>protected void finalize() throws Throwable<br>当垃圾回收确定不再引用这个对象时，由垃圾回收器在对象上调用</li>
<li>public final Class getClass()<br>返回对象的运行时期的class。</li>
<li>public int hashCode()<br>返回对象的哈希码值。</li>
</ul>
<p>Object的notify，notifyAll和wait方法都在同步程序中独立运行的线程的活动中发挥作用，有以下五种方法：</p>
<ul>
<li>public final void notify()</li>
<li>public final void notifyAll()</li>
<li>public final void wait()</li>
<li>public final void wait(long timeout)</li>
<li>public final void wait(long timeout, int nanos)</li>
</ul>
<blockquote>
<p>注意：这些方法有一些微妙的方面，特别是clone方法</p>
</blockquote>
<hr>
<h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h1><hr>
<p>如果类或它的一个超类实现了<strong>Cloneable</strong>接口，则可以使用**clone()**方法从现有对象创建副本。要创建克隆，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aCloneableObject.clone();</span><br></pre></td></tr></table></figure>
<p>这个方法的<strong>Object</strong>实现检查调用<strong>clone()<strong>的对象是否实现了</strong>Cloneable</strong>接口。如果这个对象没有实现，方法会抛出一个<strong>CloneNotSupportedException</strong>异常。目前，你需要知道**clone()**必须声明为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br></pre></td></tr></table></figure>
<p>如果要编写一个clone()方法来重写Object中的话。</p>
<p>如果调用clone()的对象实现了Cloneable接口，Object的clone()方法实现创建与原始对象相同类的对象，并初始化新对象的成员变量，使其具有与原始对象的相应成员变量相同的值。</p>
<p>使你的类变得可复制的最简单的方法是将<strong>implements Cloneable</strong>添加到你的类的声明中。那么你的对象可以调用**clone()**方法。</p>
<p>对于某些类，Object的clone()方法的默认行为足够了。但是，如果对象包含对外部对象的引用，叫做ObjExternal，则可能需要重写clone()以获取正确的行为。否则一个对象对ObjExternal所做的更改也将对它的克隆对象可见。这意味着原始对象和它的克隆对象不再独立—需要解耦它们，你必须重写clone()以便它可以克隆对象和ObjExternal。然后原始对象引用ObjExternal，克隆对象引用ObjExternal的克隆，以便对象及其克隆对象是真正独立的。</p>
<hr>
<h1 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h1><hr>
<p><strong>equals()<strong>方法比较两个对象的相等性，如果它们相等，则返回</strong>true</strong>。<strong>Object</strong>类中提供的<strong>equals()<strong>方法中是使用等式操作符（&#x3D;&#x3D;）来确定两个对象是否相等。对于原始数据类型，这会有正确的结果。然而对于对象，则不会。</strong>Object</strong>提供的**equals()**方法测试对象引用是否相等——即如果所比较的对象是完全相同的对象。</p>
<p>要测试两个对象在等价意义（包含相同的信息）上是否相等，你必须重写<strong>equals()<strong>方法。这有一个重写了</strong>equals</strong>方法的Book类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Book)</span><br><span class="line">            <span class="keyword">return</span> ISBN.equals((Book)obj.getISBN()); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这个测试Book类的两个实例的相等性的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swing Tutorial, 2nd edition</span></span><br><span class="line"><span class="type">Book</span> <span class="variable">firstBook</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;0201914670&quot;</span>);</span><br><span class="line"><span class="type">Book</span> <span class="variable">secondBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;0201914670&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (firstBook.equals(secondBook)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;objects are equal&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;objects are not equal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使firstBook和secondBook引用两个不同的对象，此程序也显示”objects are equal”。它们被认为是相等的，因为所比较的对象包含相同的ISBN号码。</p>
<p>如果等式操作符不适用你的类，你应该始终重写equals()方法。</p>
<blockquote>
<p>如果你重写了equals()，你也必须重写hashCode()。</p>
</blockquote>
<hr>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h1><hr>
<p><strong>Object</strong>类提供了一个回调方法**finalize()**，当对象变成垃圾时可以调用它。Object的finalize()实现什么也没不做，你可以重写finalize()来执行清理，比如释放资源。</p>
<p>**finalize()<strong>方法可能会被系统自动调用，但是什么时候被调用，是不确定的。因此，你不应该依靠此方法为您进行清理。例如，如果在执行I&#x2F;O后不关闭代码中的文件描述符，并且期望</strong>finalize()**关闭它们，则可能会用尽文件描述符。</p>
<hr>
<h1 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h1><hr>
<p>你无法重写<strong>getClass</strong>。</p>
<p><strong>getClass()<strong>方法返回一个</strong>Class</strong>对象，它有可用于获取有关该类信息的方法，例如获取名称（getSimpleName()），超类（getSuperclass()）以及它实现的接口（getInterfaces()）。例如，以下方法获取并显示对象的类名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printClassName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;The object&#x27;s&quot;</span> + <span class="string">&quot; class is &quot;</span> +</span><br><span class="line">        obj.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Class</strong>类在<strong>java.lang</strong>包中，它有大量的方法（超过50个）。例如，你可以测试以查看类是否是一个注解（isAnnotation()，一个接口(isInterface())，或者是一个枚举(isEnum())。你可以看对象的字段 (getFields()) 或者它的方法(getMethods())，等等。</p>
<hr>
<h1 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h1><hr>
<p>**hashCode()**返回的值是对象的哈希码，它是对象的十六进制内存地址。</p>
<p>根据定义，如果两个对象相等，它们的哈希码也必须相等。如果你重写equal()方法，你改变了两个相等的方式，Object的hashCode()实现不再有效。因此，如果您重写equals()方法，还必须覆盖hashCode()方法。否则的话，将违反Object.hashCode()的一般合同，这将阻止你的类与所有基于哈希的集合（包括HashMap，HashSet和Hashtable）结合使用。</p>
<hr>
<h1 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h1><hr>
<p>你应该始终考虑在你的类中重写toString()方法。</p>
<p>Object的toString()方法返回一个对象的String表示，当debugg时这非常有用。一个对象的String表示完全取决于对象，这就是为什么你需要重写你的类中的toString()。</p>
<p>你可以使用toString()和System.out.println()来显示对象的文本表示，例如Book的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(firstBook.toString());</span><br></pre></td></tr></table></figure>
<p>对于正确重写的toString（）方法，这将打印有用的东西，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISBN: 0201914670; The Swing Tutorial; A Guide to Constructing GUIs, 2nd Edition</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 重要类</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础学习（七）远程登陆工具</title>
    <url>/2017/05/20/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h1><ul>
<li>对称加密算法</li>
</ul>
<p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为但密钥加密。</p>
<ul>
<li>非堆成加密算法<br>非对称加密算法又名“公开密钥加密算法”，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥(privatkey)</li>
</ul>
<blockquote>
<p>SSH安全外壳协议，只保证传输过程中的数据安全</p>
</blockquote>
<h2 id="ssh-用户名-IP"><a href="#ssh-用户名-IP" class="headerlink" title="ssh 用户名@IP"></a>ssh 用户名@IP</h2><p>远程管理指定的Linux服务器</p>
<h2 id="scp-r-用户名-ip-文件路径-本地路径"><a href="#scp-r-用户名-ip-文件路径-本地路径" class="headerlink" title="scp [-r] 用户名@ip:文件路径 本地路径"></a>scp [-r] 用户名@ip:文件路径 本地路径</h2><p>下载文件</p>
<h2 id="scp-r-本地文件-用户名-ip-上传路径"><a href="#scp-r-本地文件-用户名-ip-上传路径" class="headerlink" title="scp [-r] 本地文件 用户名@ip:上传路径"></a>scp [-r] 本地文件 用户名@ip:上传路径</h2><p>上传文件</p>
<h1 id="SecureCRT远程管理工具"><a href="#SecureCRT远程管理工具" class="headerlink" title="SecureCRT远程管理工具"></a>SecureCRT远程管理工具</h1>]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（一）介绍</title>
    <url>/2017/04/25/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Linux分两个版本"><a href="#Linux分两个版本" class="headerlink" title="Linux分两个版本"></a>Linux分两个版本</h1><ul>
<li>linux 内核版本 ：linux 内核版本<a href="http://www.kernel.org/">www.kernel.org</a>,</li>
</ul>
<blockquote>
<p>内核版本说明：2.6.18  最新是4.104新版本作为测试等，不稳定</p>
</blockquote>
<ul>
<li>Linux发行版本:在内核版本技术上进行裁剪，ubuntu，图形界面好，redhat流行<ul>
<li>ubuntu，其实在服务器上很少装图形界面。</li>
<li>redhat，可以免费使用,但是有些功能收费,这个版本较为常用</li>
<li>centos,与redhat几乎一样,</li>
<li>fedora:个人版本，不同与windows个人版。fedora,是完整功能版。全功能版，不适合个人操纵。</li>
<li>suse, debian 等开发版本</li>
</ul>
</li>
</ul>
<blockquote>
<p>服务器用的比较多：centos</p>
</blockquote>
<h1 id="Linux常见开源软件"><a href="#Linux常见开源软件" class="headerlink" title="Linux常见开源软件"></a>Linux常见开源软件</h1><ul>
<li>apache</li>
<li>nginx 占用服务器资源更少,提高并发吞吐量</li>
<li>mysql</li>
<li>python</li>
<li>monogoDB</li>
<li>Ruby</li>
</ul>
<h1 id="Linux应用场景"><a href="#Linux应用场景" class="headerlink" title="Linux应用场景"></a>Linux应用场景</h1><ul>
<li>Linux企业服务器</li>
<li>嵌入式应用</li>
</ul>
<h1 id="Linux与Windows的区别"><a href="#Linux与Windows的区别" class="headerlink" title="Linux与Windows的区别"></a>Linux与Windows的区别</h1><ul>
<li>Linux严格区分大小写,Windows的dos界面是不去分别大小写的</li>
<li>Linux一切以文件的形式存在,包括硬件,用户等等,而Windows中硬件以设备管理器方式管理</li>
<li>Linux不靠文件拓展名区分文件类型,而是以权限的方式管理,但实际使用时,会用不同后缀方便用户区分</li>
</ul>
<h1 id="Linux分区与挂载"><a href="#Linux分区与挂载" class="headerlink" title="Linux分区与挂载"></a>Linux分区与挂载</h1><p>　　Linux没有盘符概念,而是称为挂载点.Linux用目录作为分区,而不是像windows一样用C,D等字母</p>
<ul>
<li>必须分区<ul>
<li>&#x2F; 根分区</li>
<li>swap分区,相当于windows的虚拟内存</li>
</ul>
</li>
<li>推荐分区<ul>
<li>&#x2F;boot 启动分区(200M)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（三）Shell基础</title>
    <url>/2017/05/01/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89Shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><hr>
<p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动，挂起，停止甚至编写一些程序。<br>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言</p>
<span id="more"></span>
<h2 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h2><ul>
<li><strong>Bourne Shell</strong>：从1979年起Unix就开始使用Bourne Shell，它的主文件名为sh</li>
<li><strong>C Shell</strong>:C Shell主要在BSD版的Unix系统中使用，其语法和C语言类似而得名</li>
</ul>
<blockquote>
<p>Shell主要语法类型有上面两种，这两种语法彼此不兼容。Bourne家族主要包括sh,ksh,Bash，psh,zsh;C家族主要包括csh,tcsh<br>Linux就是使用Bash作为用户的基本Shell.Bash可以和sh互相兼容</p>
</blockquote>
<hr>
<h1 id="脚本执行方式"><a href="#脚本执行方式" class="headerlink" title="脚本执行方式"></a>脚本执行方式</h1><hr>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo [选项] [输出内容] 输出后面的字符 </p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-e</strong></td>
<td>支持转义字符</td>
</tr>
</tbody></table>
<h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>创建脚本文件名以.sh结尾，表示是一个脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#this is the first program</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>#!&#x2F;bin&#x2F;bash  标称下面是linux标准脚本，不能省略</p>
</blockquote>
<h2 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h2><p>脚本运行有两种方式</p>
<ul>
<li>赋予执行权限，直接运行<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 hello.sh</span><br><span class="line">./hello.sh</span><br></pre></td></tr></table></figure></li>
<li>通过bash调用执行脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash hello.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h1><hr>
<h2 id="命令别名与快捷键"><a href="#命令别名与快捷键" class="headerlink" title="命令别名与快捷键"></a>命令别名与快捷键</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ul>
<li>alias<br>查看系统中所有的别名  </li>
<li>alias [别名]&#x3D;[原命令]<br>将命令命名为别名<blockquote>
<p>这种定义别名只是临时有效，系统重启后就会失效   </p>
</blockquote>
</li>
<li>vi ~&#x2F;.bashrc<br>将别名写入环境变量配置文件<blockquote>
<p>这种定义别名永久生效，但需要重新登陆，如果不想重新登陆，执行source ~&#x2F;.bashrc</p>
</blockquote>
</li>
<li>unalias [别名]<br>删除别名</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ctrl+c</strong></td>
<td>强制终止当前命令</td>
</tr>
<tr>
<td><strong>ctrl+l</strong></td>
<td>清屏</td>
</tr>
<tr>
<td><strong>ctrl+a</strong></td>
<td>光标移动到命令行首</td>
</tr>
<tr>
<td><strong>ctrl+e</strong></td>
<td>光标移动到命令行尾</td>
</tr>
<tr>
<td><strong>ctrl+u</strong></td>
<td>从光标所在位置删除到行首</td>
</tr>
<tr>
<td><strong>ctrl+z</strong></td>
<td>将命令放入后台</td>
</tr>
<tr>
<td><strong>ctrl+r</strong></td>
<td>在历史命令中搜索</td>
</tr>
</tbody></table>
<h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history [选项][历史命令保存文件]<br>显示目前的历史命令  </p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-c</strong></td>
<td>清空历史命令</td>
</tr>
<tr>
<td><strong>-w</strong></td>
<td>将缓存中历史命令写入文件</td>
</tr>
</tbody></table>
<blockquote>
<p>显示历史命令保存文件在~&#x2F;.bash_history中，每个用户都有一份，它会在每次用户注销时写入本次登陆的所有历史命令，使用history -w 可以立即将缓存中历史命令写人文件。<br>历史文件会默认记录1000条历史命令，可以在系统配置文件&#x2F;etc&#x2F;profile中修改HISTZSIZE&#x3D;1000</p>
</blockquote>
<ul>
<li>上下箭头调用以前的历史命令</li>
<li>“!n”重复执行第n条历史命令</li>
<li>“!!”重复执行上一条命令</li>
<li>“!字符串”重复执行最后一条以该字符串开头的命令</li>
</ul>
<h3 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h3><p><strong>Tab</strong> 键根据输入命令进行命令补全</p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>键盘</td>
<td>&#x2F;dev&#x2F;stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;sdtout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;sdterr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<h3 id="输出重定向-1"><a href="#输出重定向-1" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>命令 [文件描述符] &gt; | &gt;&gt; 文件名</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&gt;</strong></td>
<td>覆盖输出</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td>追加输出</td>
</tr>
</tbody></table>
<p>正确错误信息同时输出</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件 2&gt;&amp;1</td>
<td>覆盖模式 ，正确错误输出都保存到同一个文件中</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1</td>
<td>追加模式，正确错误输出都保存到同一个文件中</td>
</tr>
<tr>
<td>命令 &amp;&gt; 文件</td>
<td>追加模式，正确错误输出都保存到同一个文件中</td>
</tr>
<tr>
<td>命令 &amp;&gt;&gt; 文件</td>
<td>追加模式，正确错误输出都保存到同一个文件中</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件1 2&gt;&gt;文件2</td>
<td>把正确的输出追加到文件1，错误的输出追加到文件2</td>
</tr>
</tbody></table>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>输入重定向用的比较少</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&lt;</strong></td>
<td>把文件内容作为命令的输入</td>
</tr>
<tr>
<td><strong>&lt;&lt;</strong></td>
<td>把标识符之间内容作为命令的输入</td>
</tr>
</tbody></table>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><h3 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h3><table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>;</strong></td>
<td>命令1 ; 命令2</td>
<td>多命令顺序执行</td>
</tr>
<tr>
<td><strong>&amp;&amp;</strong></td>
<td>命令1 &amp;&amp; 命令2</td>
<td>逻辑与</td>
</tr>
<tr>
<td><strong>&amp;#124;&amp;#124;</strong></td>
<td>命令1 &amp;#124;&amp;#124; 命令2</td>
<td>逻辑或</td>
</tr>
</tbody></table>
<h3 id="管道符-1"><a href="#管道符-1" class="headerlink" title="管道符"></a>管道符</h3><p>命令1 | 命令2  命令1的输出结果作为命令2的输入</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>？</strong></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><strong>*</strong></td>
<td>匹配0个或多个任意字符</td>
</tr>
<tr>
<td><strong>*</strong></td>
<td>匹配0个或多个任意字符</td>
</tr>
<tr>
<td><strong>[X]</strong></td>
<td>匹配括号内一个字符</td>
</tr>
<tr>
<td><strong>[X-X]</strong></td>
<td>匹配括号内给定范围内的要给字符</td>
</tr>
<tr>
<td><strong>[^]</strong></td>
<td>逻辑非</td>
</tr>
</tbody></table>
<h2 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>‘’</strong></td>
<td>单引号内特殊符号都没有意义</td>
</tr>
<tr>
<td><strong>“”</strong></td>
<td>双引号内特殊符号都没有意义</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>用于调用变量，使用$变量名的形式调用</td>
</tr>
<tr>
<td><strong>&#x2F;</strong></td>
<td>转义符</td>
</tr>
<tr>
<td><strong>``</strong></td>
<td>反引号先执行系统命令后，将结果赋值</td>
</tr>
<tr>
<td><strong>$()</strong></td>
<td>和反引号作用一样</td>
</tr>
<tr>
<td><strong>#</strong></td>
<td>表示注释</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（二）基本命令</title>
    <url>/2017/04/26/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<hr>
<h1 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h1><hr>
<p>命令行头部显示字符意义</p>
<blockquote>
<p>[root@localhost ~] #</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>root</strong></td>
<td>用户名</td>
</tr>
<tr>
<td><strong>localhost</strong></td>
<td>主机名</td>
</tr>
<tr>
<td><strong>~</strong></td>
<td>当前所在目录，~表示当前用户home目录</td>
</tr>
<tr>
<td><strong>#</strong></td>
<td>用户权限，**#<strong>表示超级管理员用户，</strong>$**表示普通用户</td>
</tr>
</tbody></table>
<blockquote>
<p>Linux管理员账号是root </p>
</blockquote>
<span id="more"></span>
<hr>
<h1 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h1><hr>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>ls 　[选项] 　[目录名]　<strong>查看目录下的文件</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-a</strong></td>
<td>显示所有文件,包括隐藏文件</td>
</tr>
<tr>
<td><strong>-l</strong></td>
<td>显示详细信息,可简写为ll</td>
</tr>
<tr>
<td><strong>-d</strong></td>
<td>查看目录属性</td>
</tr>
<tr>
<td><strong>-h</strong></td>
<td>人性化显示文件大小</td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td>显示inode</td>
</tr>
</tbody></table>
<p>使用ls -l(ll)显示文件详细信息时，会显示</p>
<blockquote>
<p><font color="blue">- rw- r– r–.</font> 1 root root 24772 1月  14 18:17 install.log</p>
</blockquote>
<p>蓝色部分表示文件权限，共有十位，第一位表示文件的类型，Linux系统没有文件扩展名</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-</strong></td>
<td>文件</td>
</tr>
<tr>
<td><strong>d</strong></td>
<td>目录</td>
</tr>
<tr>
<td><strong>l</strong></td>
<td>软链接</td>
</tr>
</tbody></table>
<p>后九位三个为一组，分别表示<strong>所有者</strong>，<strong>所属组</strong>，和<strong>其他人</strong>，字母表示该权限下用户的权限</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>权限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td>读取</td>
</tr>
<tr>
<td><strong>w</strong></td>
<td>写入</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>执行</td>
</tr>
</tbody></table>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>mkdir　[选项]　[目录名]　创建目录，是makedirectories的缩写</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>p</strong></td>
<td>递归创建,也就是多级创建</td>
</tr>
</tbody></table>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>cd　[目录名]　切换目录 change directory</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>cd ~</strong></td>
<td>进入当前用户的home目录</td>
</tr>
<tr>
<td><strong>cd</strong></td>
<td>显示详细信息,可简写为ll</td>
</tr>
<tr>
<td><strong>cd -</strong></td>
<td>进入上次目录</td>
</tr>
<tr>
<td><strong>cd ..</strong></td>
<td>进入上一级目录</td>
</tr>
<tr>
<td><strong>cd .</strong></td>
<td>进入当前目录，基本没用</td>
</tr>
</tbody></table>
<h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p>rmdir　[目录名]　删除目录　remove empty directory　只能用来删除空目录</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>rm　[选项]　[文件名]　删除文件  remove</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-r</strong></td>
<td>删除目录</td>
</tr>
<tr>
<td><strong>-f</strong></td>
<td>强制删除</td>
</tr>
</tbody></table>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>cp　[选项]　[原文件或目录]　[目标目录]　复制文件或目录　copy</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>**-r **</td>
<td>复制目录，不带的话只能复制文件</td>
</tr>
<tr>
<td><strong>-p</strong></td>
<td>连带文件属性复制</td>
</tr>
<tr>
<td><strong>-d</strong></td>
<td>若源文件是链链接文件,则复制链接属性</td>
</tr>
<tr>
<td><strong>-a</strong></td>
<td>相当于-pdr</td>
</tr>
</tbody></table>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>mv　[源文件或目录]　[目标目录]　剪切目录或者重命名　move</p>
<hr>
<h1 id="链接处理命令"><a href="#链接处理命令" class="headerlink" title="链接处理命令"></a>链接处理命令</h1><hr>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>ln　[选项]　[目标文件]　生成链接文件 link</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>**-s **</td>
<td>创建软链接</td>
</tr>
</tbody></table>
<p>硬链接,一般不建议使用</p>
<ol>
<li>相同的inode和存储block,可以看作同一个文件,类比百度云上的文件  </li>
<li>可以通过inode识别  </li>
<li>不能跨区  </li>
<li>不能针对目录操作<br>软连接,类似windows中的快捷方式,</li>
<li>虽然有自己的inode和存储block,但block中只保存链接文件的文件名和inode </li>
<li>修改任意文件,另一个都改变</li>
<li>删除原文件,软连接不能使用</li>
</ol>
<p>软链接和硬链接有很多相似的地方,比如,两个文件之间只要修改然后一个另一个都会改变,但硬链接两个文件间没有依赖关系,删除其中一个另一个还存在,但是软链接删除原文件,链接文件就会显示错误.</p>
<blockquote>
<p>软链接如果要链接到的目标目录不再同一个目录下,原文件目录一定要用绝对路径.</p>
</blockquote>
<hr>
<h1 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h1><hr>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>locate　[文件名]　在后台数据库按文件名搜索,搜索速度更快</p>
<blockquote>
<p>locate并不是在系统中搜索文件而是在  &#x2F;var&#x2F;lib&#x2F;mlocate 这个后台数据库中搜索,新创建的文件需要先使用updatedb更新数据库才能搜索的到。此外有些目录下文件无法被locate搜索，因为这些目录被mlocate.db数据库所忽略，被忽略的目录在&#x2F;etc&#x2F;updatedb.conf里面进行配置。</p>
</blockquote>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>whereis　[选项]　[命令名]　搜索命令二进制文件所在的路径以及帮助文档、配置文件所在位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>**-b **</td>
<td>只看二进制文件</td>
</tr>
<tr>
<td>**-m **</td>
<td>只看帮助文件</td>
</tr>
</tbody></table>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>which　[命令名]　搜索命令所在的路径以及别名</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find　[搜索范围]　[搜索条件]</p>
<blockquote>
<p>find 应当避免大范围搜索，会非常耗费系统资源<br>find 搜索文件名时是完全匹配，如果要模糊搜索需要使用通配符</p>
</blockquote>
<p><strong>搜索条件</strong></p>
<table>
<thead>
<tr>
<th>搜索命令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-iname</strong></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><strong>-user</strong></td>
<td>按所有者搜索</td>
</tr>
<tr>
<td><strong>-nouser</strong></td>
<td>查找没有所有者的文件</td>
</tr>
<tr>
<td><strong>-mtime</strong></td>
<td>按文件内容修改时间搜索</td>
</tr>
<tr>
<td><strong>-atime</strong></td>
<td>按文件访问时间搜索</td>
</tr>
<tr>
<td><strong>-ctime</strong></td>
<td>按文件属性修改时间搜索</td>
</tr>
<tr>
<td>**-size **</td>
<td>按文件大小搜索</td>
</tr>
<tr>
<td><strong>-inum</strong></td>
<td>按inode编号搜索</td>
</tr>
</tbody></table>
<p>按时间搜索时，后面带时间范围，默认单位是天，  </p>
<ul>
<li>+10  表示&gt;十天前，+理解为&gt;号   </li>
<li>10     表示十天前当天   </li>
<li>-10    表示十天内，-理解为&lt;号</li>
</ul>
<p>按文件大小搜索时，后面带文件大小，默认单位是一个扇区块大小，512字节，千字节是k,兆是M，注意大小写　</p>
<blockquote>
<p>如要要对搜索到的文件执行处理命令，在搜索命令后加上 -exec 命令 {} 、；</p>
</blockquote>
<p><strong>常用通配符</strong></p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>** * **</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>** ？ **</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>** [X] **</td>
<td>匹配任意一个括号内字符</td>
</tr>
</tbody></table>
<p><strong>逻辑条件</strong></p>
<table>
<thead>
<tr>
<th>逻辑命令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>**-a **</td>
<td>and与命令</td>
</tr>
<tr>
<td>**-o **</td>
<td>or 或命令</td>
</tr>
</tbody></table>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep　[选项]　[字符串]　[文件名]　文件内容搜索，在文件中匹配符合条件的字符串</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>**-i **</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>**-v **</td>
<td>排除指定字符串</td>
</tr>
</tbody></table>
<blockquote>
<p>grep使用正则表达式匹配</p>
</blockquote>
<hr>
<h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><hr>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p> man　[命令等级]　|　[选项]　［命令］　获取制定命令的帮助文档　manual</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-f</strong></td>
<td>查看命令作用和它的命令等级,<strong>等同whatiis</strong></td>
</tr>
<tr>
<td><strong>-k</strong></td>
<td>查看所有包含给定命令的帮助文档,<strong>等同aproros</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>查看帮助文档时,可以输入“&#x2F;”后输入要在命令文档中查找的字符，“n”键是查找下一个，“shift”查找上一个</p>
</blockquote>
<h2 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h2><p>命令  –help　直接查看该命令的帮助</p>
<h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>help [命令]  获取shell自带命令的帮助</p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>info [命令] 更详细的帮助文档</p>
<hr>
<h1 id="压缩与解压缩命令"><a href="#压缩与解压缩命令" class="headerlink" title="压缩与解压缩命令"></a>压缩与解压缩命令</h1><hr>
<p>linux系统中常见的压缩格式有 .zip .gz .bz2 .tar.gz  .tar.bz2</p>
<h2 id="zip格式"><a href="#zip格式" class="headerlink" title=".zip格式"></a>.zip格式</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip　[压缩文件名]　[源文件名]　压缩指定的文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>** -r **</td>
<td>压缩目录</td>
</tr>
</tbody></table>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>unzip　[压缩文件名]　解压缩指定的压缩文件</p>
<h2 id="gizp格式"><a href="#gizp格式" class="headerlink" title=".gizp格式"></a>.gizp格式</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip　[源文件]　压缩并删除文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>** -r **</td>
<td>压缩指定目录下所有子文件，但是不会压缩目录本身</td>
</tr>
<tr>
<td>** -d **</td>
<td>解压缩指定文件</td>
</tr>
</tbody></table>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p>gunzip　[压缩文件]　解压指定文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>** -r **</td>
<td>解压缩指定目录下所有文件</td>
</tr>
</tbody></table>
<h2 id="bz2格式"><a href="#bz2格式" class="headerlink" title=".bz2格式"></a>.bz2格式</h2><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>bzip2　[源文件]　压缩指定文件，不保留源文件，不能压缩目录</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-k</strong></td>
<td>压缩时保留源文件</td>
</tr>
</tbody></table>
<h3 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h3><p>bunzip2　[压缩文件名]　解压缩指定文件，不保留源文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-k</strong></td>
<td>保留压缩文件</td>
</tr>
</tbody></table>
<p>这三种压缩格式，压缩时对文件的处理方式不同　　　　</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>压缩目录</th>
<th>保留源文件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>.zip</strong></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><strong>.gz</strong></td>
<td>O</td>
<td>√</td>
</tr>
<tr>
<td><strong>.bz2</strong></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>这些压缩格式中.zip格式可以压缩目录，而.gz只能压缩目录下所有文件，.bz2则根本不能压缩目录，对于这个问题，可以先使用打包命令，将目录打包后再进行压缩</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar是进行打包和解包的命令，当执行打包操作时，需要指定需要打包目录，和打包后的包名，解包时只需要给定包名</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>** -cvf **</td>
<td>打包指定文件</td>
</tr>
<tr>
<td>** -xvf **</td>
<td>解包指定文件</td>
</tr>
<tr>
<td>** -tvf  **</td>
<td>查看打包文件夹内容</td>
</tr>
<tr>
<td>** -cvf **</td>
<td>打包指定文件</td>
</tr>
<tr>
<td>以上是直接打包解包操作，为了方便操作，还可以和压缩解压命令结合使用，只需要在打包解包前加上一个字母，即可压缩解压特定格式</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字母</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>z</strong></td>
<td>.gz</td>
</tr>
<tr>
<td><strong>j</strong></td>
<td>.bz2</td>
</tr>
</tbody></table>
<blockquote>
<p>如果要指定解包位置的话，在命令后加-C [目录名]</p>
</blockquote>
<hr>
<h1 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h1><hr>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>shutdown [选项] 时间</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-c</strong></td>
<td>取消前一个关机命令</td>
</tr>
<tr>
<td><strong>-h</strong></td>
<td>关机</td>
</tr>
<tr>
<td><strong>-r</strong></td>
<td>重启</td>
</tr>
</tbody></table>
<blockquote>
<p>其他的关机命令，halt ,poweroff, init 0但这些命令不能保证安全关机<br>其他重启命令 ，reboot ,init 6，reboot是比较安全的重启命令</p>
</blockquote>
<hr>
<h1 id="查看登陆用户信息命令"><a href="#查看登陆用户信息命令" class="headerlink" title="查看登陆用户信息命令"></a>查看登陆用户信息命令</h1><hr>
<h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>查看系统中所有登陆用户详细信息</p>
<h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><p>查看系统中所有登陆用户简略信息</p>
<ul>
<li>命令输出<ul>
<li>用户名</li>
<li>登陆终端</li>
<li>登陆时间（以及登陆ip）</li>
</ul>
</li>
</ul>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>查看系统中所有用户的登陆信息</p>
<ul>
<li>last命令默认读取&#x2F;var&#x2F;log&#x2F;wtmp文件</li>
<li>命令输出 <ul>
<li>用户名</li>
<li>登陆终端</li>
<li>登陆ip</li>
<li>登陆时间</li>
<li>退出时间（在线时间）</li>
</ul>
</li>
</ul>
<h2 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h2><p>查看所有用户的最后一次登录时间</p>
<ul>
<li>lastlog命令默认读取的是&#x2F;var&#x2F;log&#x2F;lastlog文件内容</li>
<li>命令输出<ul>
<li>用户名</li>
<li>登陆终端</li>
<li>登陆ip</li>
<li>最后一次登录时间</li>
</ul>
</li>
</ul>
<hr>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><hr>
<h2 id="mout"><a href="#mout" class="headerlink" title="mout"></a>mout</h2><p>mout 查看系统中已经挂载的设备</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-a</strong></td>
<td>根据&#x2F;etc&#x2F;fstab配置文件，自动挂载设备</td>
</tr>
</tbody></table>
<p>mout [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点</p>
<blockquote>
<p>-t 文件系统：加入文件系统来指定挂在的类型，可以ext3,ext4,iso9660等文件系统<br>-o 特殊选项：可以指定挂在的额外选项</p>
</blockquote>
<h2 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h2><p>umount [设备文件名或挂载点]   卸载挂载设备</p>
<ul>
<li><p>挂载光盘<br> mount -t iso9660 &#x2F;dev&#x2F;cdrom&#x2F; &#x2F;mnt&#x2F;cdrom<br> umount &#x2F;mnt&#x2F;cdrom</p>
</li>
<li><p>挂载u盘<br> mount -t vfat &#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;usb<br> umout &#x2F;mnt&#x2F;usb</p>
</li>
</ul>
<hr>
<h1 id="常用目录作用"><a href="#常用目录作用" class="headerlink" title="常用目录作用"></a>常用目录作用</h1><hr>
<table>
<thead>
<tr>
<th>目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>**&#x2F;　**</td>
<td>根目录</td>
</tr>
<tr>
<td><strong>&#x2F;bin</strong></td>
<td>命令保存目录</td>
</tr>
<tr>
<td><strong>&#x2F;sbin</strong></td>
<td>命令保存目录(超级用户才能使用目录)</td>
</tr>
<tr>
<td><strong>&#x2F;proc 、&#x2F;sys</strong></td>
<td>内存挂载点,不能操作,直接写入内存的</td>
</tr>
<tr>
<td><strong>&#x2F;boot</strong></td>
<td>启动目录,启动相关文件</td>
</tr>
<tr>
<td><strong>&#x2F;dev</strong></td>
<td>设备文件保存目录</td>
</tr>
<tr>
<td><strong>&#x2F;etc</strong></td>
<td>配置文件保存目录</td>
</tr>
<tr>
<td><strong>&#x2F;usr</strong></td>
<td>系统软件资源目录</td>
</tr>
<tr>
<td><strong>&#x2F;var</strong></td>
<td>系统文档目录</td>
</tr>
<tr>
<td><strong>&#x2F;home</strong></td>
<td>普通用户家目录</td>
</tr>
<tr>
<td><strong>&#x2F;root</strong></td>
<td>管理员用户目录</td>
</tr>
<tr>
<td><strong>&#x2F;lib</strong></td>
<td>系统库目录</td>
</tr>
<tr>
<td><strong>&#x2F;mnt</strong></td>
<td>系统挂载目录，U盘之类</td>
</tr>
<tr>
<td><strong>&#x2F;media</strong></td>
<td>挂载目录,光盘之类</td>
</tr>
<tr>
<td><strong>&#x2F;misc</strong></td>
<td>挂载目录，磁带之类</td>
</tr>
<tr>
<td>**&#x2F;tmp **</td>
<td>临时目录</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（五）网络配置</title>
    <url>/2017/05/17/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Linux配置IP地址"><a href="#Linux配置IP地址" class="headerlink" title="Linux配置IP地址"></a>Linux配置IP地址</h1><h2 id="ifconfig命令临时配置"><a href="#ifconfig命令临时配置" class="headerlink" title="ifconfig命令临时配置"></a>ifconfig命令临时配置</h2><ul>
<li><strong>ifconfig</strong><br>查看配置网络状态   </li>
<li><strong>ifconfig</strong> eth0 192.168.0.1 netmask 255.255.255.0<br>临时设置etho0网卡的ip地址与子网掩码</li>
</ul>
<h2 id="setup工具永久配置"><a href="#setup工具永久配置" class="headerlink" title="setup工具永久配置"></a>setup工具永久配置</h2><p>setup是redhat中专有图形界面工具，按照选项，直接配置</p>
<span id="more"></span>

<h2 id="修改网络配置文件"><a href="#修改网络配置文件" class="headerlink" title="修改网络配置文件"></a>修改网络配置文件</h2><ol>
<li>网卡信息文件<br>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</li>
</ol>
<table>
<thead>
<tr>
<th>配置</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>DEVICE&#x3D;eth0</td>
<td>网卡设备名称</td>
</tr>
<tr>
<td>BOOTPROTO&#x3D;none</td>
<td>是否自动获取ip(none,static,dhcp)</td>
</tr>
<tr>
<td>HWADDR&#x3D;00:0c:29:17:c4:09</td>
<td>MAC地址</td>
</tr>
<tr>
<td>NM_CONTROLLED&#x3D;yes</td>
<td>是否可以由Network Manager图形工具托管</td>
</tr>
<tr>
<td>ONBOOT&#x3D;yes</td>
<td>是否随网络服务启动，eth0生效</td>
</tr>
<tr>
<td>TYPE&#x3D;Ethernet</td>
<td>类型为以太网</td>
</tr>
<tr>
<td>UUID&#x3D;”XXX”</td>
<td>唯一标识码</td>
</tr>
<tr>
<td>IPADDR&#x3D;192.168.0.252</td>
<td>IP地址</td>
</tr>
<tr>
<td>NETMASK&#x3D;255.255.255.0</td>
<td>子网掩码</td>
</tr>
<tr>
<td>GATEWAY&#x3D;192.168.0.1</td>
<td>网关</td>
</tr>
<tr>
<td>DNS1&#x3D;202.106.0.20</td>
<td>DNS</td>
</tr>
<tr>
<td>IPV6INIT&#x3D;no</td>
<td>IPV6没有启用</td>
</tr>
<tr>
<td>USERCTL&#x3D;no</td>
<td>不允许非root用户控制此网卡</td>
</tr>
</tbody></table>
<ol start="2">
<li>主机名文件<br>&#x2F;etc&#x2F;sysconfig&#x2F;network</li>
</ol>
<blockquote>
<p>linux主机名不需要唯一，不影响局域网内互相联网，修改该配置文件中主机名，不会立即生效，需要重启计算机，但可以使用hostname 主机名，临时修改，立即生效</p>
</blockquote>
<ol start="3">
<li>DNS配置文件<br>&#x2F;etc&#x2F;resolv.conf</li>
</ol>
<table>
<thead>
<tr>
<th>配置</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>nameserver 202.106.0.20</td>
<td>名称服务器，DNS的ip</td>
</tr>
<tr>
<td>search localhost</td>
<td></td>
</tr>
</tbody></table>
<h2 id="图形界面配置IP"><a href="#图形界面配置IP" class="headerlink" title="图形界面配置IP"></a>图形界面配置IP</h2><p>easy</p>
<h1 id="虚拟机网络参数配置"><a href="#虚拟机网络参数配置" class="headerlink" title="虚拟机网络参数配置"></a>虚拟机网络参数配置</h1>]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（八）软件安装</title>
    <url>/2017/05/20/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h1><ul>
<li>源码包</li>
<li>二进制包（RPM包，系统默认包）</li>
</ul>
<h1 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h1><h2 id="RPM命名规则"><a href="#RPM命名规则" class="headerlink" title="RPM命名规则"></a>RPM命名规则</h2><p>httpd-2.2.15-15.el6.centos.1.i686.rpm</p>
<ul>
<li>httpd软件包名</li>
<li>2.2.15软件版本</li>
<li>15软件发布次数</li>
<li>el6.centos适合的Linux平台</li>
<li>I686适合的硬件平台</li>
<li>rpm包拓展名</li>
</ul>
<h2 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h2><ol>
<li>树形依赖：a→b→c</li>
<li>环形依赖：a→b→c→a</li>
<li>模块依赖：模块依赖，查询网站：<a href="http://www.rpmfind.net/">www.rpmfind.net</a></li>
</ol>
<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><ul>
<li>包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径</li>
<li>包名：操作已经安装的软件包时，使用包名，是搜索&#x2F;var&#x2F;lib&#x2F;rpm&#x2F;中的数据库</li>
</ul>
<h3 id="rpm-ivh-包全名"><a href="#rpm-ivh-包全名" class="headerlink" title="rpm -ivh 包全名"></a>rpm -ivh 包全名</h3><p>安装软件包</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-i（install）</strong></td>
<td>安装</td>
</tr>
<tr>
<td><strong>-v（verbos）</strong></td>
<td>显示详细信息</td>
</tr>
<tr>
<td><strong>-h(（Hash）</strong></td>
<td>显示进度</td>
</tr>
<tr>
<td><strong>–nodeps</strong></td>
<td>不检查依赖性</td>
</tr>
</tbody></table>
<h3 id="rpm-Uvh-包全名"><a href="#rpm-Uvh-包全名" class="headerlink" title="rpm -Uvh 包全名"></a>rpm -Uvh 包全名</h3><p>升级RPM包<br>该命令如果此包之前没有安装，则直接安装，如果已经安装则是升级。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-U（update）</strong></td>
<td>升级</td>
</tr>
</tbody></table>
<h3 id="rpm-e-包名"><a href="#rpm-e-包名" class="headerlink" title="rpm -e 包名"></a>rpm -e 包名</h3><p>卸载RPM包</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-e（erase）</strong></td>
<td>卸载</td>
</tr>
<tr>
<td><strong>–nodeps</strong></td>
<td>不检查依赖性</td>
</tr>
</tbody></table>
<h2 id="RPM包查询"><a href="#RPM包查询" class="headerlink" title="RPM包查询"></a>RPM包查询</h2><h3 id="rpm-q-包名"><a href="#rpm-q-包名" class="headerlink" title="rpm -q 包名"></a>rpm -q 包名</h3><p>查询包是否安装</p>
<h3 id="rpm-qa"><a href="#rpm-qa" class="headerlink" title="rpm -qa"></a>rpm -qa</h3><p>查询所有已经安装的RPM包</p>
<h3 id="rpm-qi-包名"><a href="#rpm-qi-包名" class="headerlink" title="rpm -qi 包名"></a>rpm -qi 包名</h3><p>查询软件包详细信息</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-i</strong></td>
<td>包的详细信息</td>
</tr>
<tr>
<td><strong>-p</strong></td>
<td>查询未安装包信息</td>
</tr>
</tbody></table>
<h3 id="rpm-ql-包名"><a href="#rpm-ql-包名" class="headerlink" title="rpm -ql 包名"></a>rpm -ql 包名</h3><p>查询包中文件安装的位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-l</strong></td>
<td>列表</td>
</tr>
<tr>
<td><strong>-p</strong></td>
<td>查询未安装包信息</td>
</tr>
</tbody></table>
<h3 id="rpm-qf-系统文件名"><a href="#rpm-qf-系统文件名" class="headerlink" title="rpm -qf 系统文件名"></a>rpm -qf 系统文件名</h3><p>查询系统文件属于那个npm包中</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-f</strong></td>
<td>查询系统文件属于那个npm包中</td>
</tr>
</tbody></table>
<h3 id="rpm-qR-系统文件名"><a href="#rpm-qR-系统文件名" class="headerlink" title="rpm -qR 系统文件名"></a>rpm -qR 系统文件名</h3><p>查询依赖npm包中</p>
<p>查询出无意义的依赖太多，基本没有太大用处</p>
<h2 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h2><h3 id="rpm-V-包名"><a href="#rpm-V-包名" class="headerlink" title="rpm -V 包名"></a>rpm -V 包名</h3><p>校验安装的RPM包是否被修改</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-V</strong></td>
<td>校验指定RPM包中的文件</td>
</tr>
</tbody></table>
<h3 id="rpm2cpio-包全名-cpio-idv-文件绝对路径"><a href="#rpm2cpio-包全名-cpio-idv-文件绝对路径" class="headerlink" title="rpm2cpio 包全名 | cpio -idv.文件绝对路径"></a>rpm2cpio 包全名 | cpio -idv.文件绝对路径</h3><table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-rpm2cpio</strong></td>
<td>将rpm包转换为cpio格式命令</td>
</tr>
<tr>
<td><strong>cpio</strong></td>
<td>是一个标准工具，用于创建软件档案文件和从档案文件中提取文件</td>
</tr>
</tbody></table>
<h1 id="RPM包默认安装位置"><a href="#RPM包默认安装位置" class="headerlink" title="RPM包默认安装位置"></a>RPM包默认安装位置</h1><table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<h1 id="yum在线安装"><a href="#yum在线安装" class="headerlink" title="yum在线安装"></a>yum在线安装</h1><p>rpm包依赖性太强，如果使用手动安装的话，则非常繁琐。所以提供了yum在线安装，将所有的软件包放在官方服务器上，可以自动解决依赖性问题。</p>
<blockquote>
<p>redhat的yum安装是付费功能</p>
</blockquote>
<h2 id="yum源文件"><a href="#yum源文件" class="headerlink" title="yum源文件"></a>yum源文件</h2><p>在目录&#x2F;etc&#x2F;yum.repos.d下有四个yum配置源文件，其中只有一个是默认生效的，里面配置着yum安装的一些信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[base]</strong></td>
<td>容器名称，一定要放在[]中</td>
</tr>
<tr>
<td><strong>name</strong></td>
<td>容器说明，可以自己随便写</td>
</tr>
<tr>
<td><strong>mirrorlist</strong></td>
<td>镜像站点，这个可以自己注释掉</td>
</tr>
<tr>
<td><strong>baseurl</strong></td>
<td>我们的yum源服务器的地址</td>
</tr>
<tr>
<td><strong>enabled</strong></td>
<td>此容器是否生效，不写或者1都是生效，0为不生效</td>
</tr>
<tr>
<td><strong>gpgcheck</strong></td>
<td>RPM数字证书是否生效，1为生效，0为不生效</td>
</tr>
<tr>
<td><strong>gpgkey</strong></td>
<td>数字证书的公钥文件保存位置，不用修改</td>
</tr>
</tbody></table>
<h2 id="光盘yum源搭建"><a href="#光盘yum源搭建" class="headerlink" title="光盘yum源搭建"></a>光盘yum源搭建</h2><ol>
<li>将原来在线yum配置文件重命名，使其失效</li>
<li>配置光盘yum配置文件，修改光盘挂载点，将多余的注释掉，设置enabled&#x3D;1</li>
<li>yum list 查看是否可用</li>
</ol>
<h2 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h2><h3 id="yum-list"><a href="#yum-list" class="headerlink" title="yum list"></a>yum list</h3><p>查询所有可用软件包列表</p>
<h3 id="yum-search-关键字"><a href="#yum-search-关键字" class="headerlink" title="yum search 关键字"></a>yum search 关键字</h3><p>搜索服务器上和关键字相关的包</p>
<h3 id="yum-y-install-包名"><a href="#yum-y-install-包名" class="headerlink" title="yum -y install 包名"></a>yum -y install 包名</h3><p>在线安装rpm包</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>install</strong></td>
<td>安装</td>
</tr>
<tr>
<td><strong>-y</strong></td>
<td>自动回答yes</td>
</tr>
</tbody></table>
<h3 id="yum-y-update-包名"><a href="#yum-y-update-包名" class="headerlink" title="yum -y update 包名"></a>yum -y update 包名</h3><p>在线升级rpm包，不加包名会升级所有包，包括linux内核</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>update</strong></td>
<td>安装</td>
</tr>
<tr>
<td><strong>-y</strong></td>
<td>自动回答yes</td>
</tr>
</tbody></table>
<h3 id="yum-y-remove-包名"><a href="#yum-y-remove-包名" class="headerlink" title="yum -y remove 包名"></a>yum -y remove 包名</h3><p>卸载包,yum卸载没有提示，非常容易造成系统崩溃，服务器使用最小化安装，用什么装什么</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（六）网络命令</title>
    <url>/2017/05/17/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="网络环境查看命令"><a href="#网络环境查看命令" class="headerlink" title="网络环境查看命令"></a>网络环境查看命令</h1><ul>
<li><strong>ifconfig</strong><br>查看与配置网络状态命令</li>
<li><strong>ifdown</strong> [网卡设备名]<br>禁用该网卡设备</li>
<li><strong>ifup</strong> [网卡设备名]<br>启用该网卡设备</li>
<li><strong>netstat</strong> [选项]<br>查询网络状态</li>
</ul>
<span id="more"></span>

<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-t</strong></td>
<td>列出TCP协议端口</td>
</tr>
<tr>
<td><strong>-u</strong></td>
<td>列出UDP协议端口</td>
</tr>
<tr>
<td><strong>-n</strong></td>
<td>不使用域名与服务名，而是用IP和端口号</td>
</tr>
<tr>
<td><strong>-l</strong></td>
<td>仅列出在监听状态的网络服务</td>
</tr>
<tr>
<td><strong>-a</strong></td>
<td>列出所有网络连接</td>
</tr>
<tr>
<td><strong>-r</strong></td>
<td>列出路由器列表,功能与route命令一致</td>
</tr>
</tbody></table>
<ul>
<li><strong>route</strong><br>查看路由列表（可以看到网关）<br>route add default gw 192.168.1.1<br>临时设定网关<blockquote>
<p>只有连接外网的网卡才能设置网关，否则无法连接网络</p>
</blockquote>
</li>
</ul>
<p>-<strong>nsloopup</strong> [域名]<br>翻译域名对应的IP<br>直接执行nsloopup然乎输入server可以查看DNS</p>
<h1 id="网络测试命令"><a href="#网络测试命令" class="headerlink" title="网络测试命令"></a>网络测试命令</h1><ul>
<li><strong>ping</strong> [选项] ip或域名<br>探测指定IP或域名的网络状况</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-c</strong></td>
<td>指定ping包的次数</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>telnet</strong>  [域名或IP] 、[端口]<br>远程管理与端口探测命令</p>
<blockquote>
<p>这种远程管理协议是明文不加密的，非常不安全，目前已经被SSH协议取代，但是可以用来做端口探测</p>
</blockquote>
</li>
<li><p><strong>traceroute</strong> [选项] IP或域名<br>路由跟踪命令</p>
</li>
</ul>
<blockquote>
<p>ping命令和traceroute命令都是使用的ICMP（Internet Control Message Protocol）Internet控制报文协议</p>
</blockquote>
<ul>
<li><p><strong>wget</strong>  [URL]<br>下载命令 </p>
</li>
<li><p><strong>tcpdump</strong>  -i eht0 -nnX port 21<br>抓包命令</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-i</strong></td>
<td>指定网卡接口</td>
</tr>
<tr>
<td><strong>-nn</strong></td>
<td>将数据包中的域名与服务转为IP和端口</td>
</tr>
<tr>
<td><strong>-X</strong></td>
<td>以十六进制和ASCII码显示数据包内容</td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>指定监听端口</td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td>指定网卡接口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习（四）网络基础</title>
    <url>/2017/05/05/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ISO-x2F-OSI七层模型"><a href="#ISO-x2F-OSI七层模型" class="headerlink" title="ISO&#x2F;OSI七层模型"></a>ISO&#x2F;OSI七层模型</h1><p>现代网络中为了实现计算机之间的通信，双方发送的数据必须遵循一定的协议，为了减少协议设计的复杂性，大多数网络都按层或级的方式来组织，每一层都建立在它的下层之上。</p>
<p>ISO 在 1983 年推出的 OSI 七层网络模型，值得注意的是， OSI 参考模型本身并不是一个完整的网络体系结构，因为它并未确切地描述用于各层的协议和服务，它仅仅告诉我们每层应该做什么。</p>
<span id="more"></span>

<p>下图是OSI 参考模型示意图<br>![ISO&#x2F;OSI七层模型](\images\linux\ISO Modle.jpg)</p>
<table>
<thead>
<tr>
<th>功能层</th>
<th>作用</th>
<th>传输单位</th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用层</strong></td>
<td>用户接口</td>
<td>APDU</td>
</tr>
<tr>
<td><strong>表示层</strong></td>
<td>数据形式表现形式，特定功能的实现如加密等</td>
<td>PPDU</td>
</tr>
<tr>
<td><strong>会话层</strong></td>
<td>对应会话的管理、同步</td>
<td>SPDU</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>可靠与不可靠的传输，传输前的错误检测，流控</td>
<td>TPDU</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>提供逻辑地址，选路</td>
<td>报文（packet）</td>
</tr>
<tr>
<td><strong>数据链路层</strong></td>
<td>成帧，用MAC地址访问媒介，错误检测与修正</td>
<td>帧（frame）</td>
</tr>
<tr>
<td><strong>物理层</strong></td>
<td>设备之间的比特流的传输，物理接口，电气特性等</td>
<td>比特（bit）</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>物理层</strong></p>
<p> 物理层（physical layer）是OSI模型的最底层，它建立在物理通信介质的基础上，用来实现数据链路实体间透明的比特流传输。</p>
<p> 物理层协议定义了硬件接口的一系列标准，典型地如用多少伏特电压表示“ 1 ”，多少伏特表示“ 0 ”；一个比特持续多少时间；传输是双向的还是单向的；最初的连接如何建立和完成通信后连接如何终止；一次通信中发送方和接收方如何应答；设备之间连接件的 尺寸和接头数；每根线的用途等。</p>
</li>
<li><p><strong>数据链路层</strong></p>
<p> 数据链路层（data link layer）传输数据链路数据单元<strong>帧</strong>（frame）,写入设备的MAC地址，用来与局域网内定位。</p>
<blockquote>
<p>MAC地址被称为物理地址或硬件地址，用来定义网络设备的位置，由网卡来决定，是固定不变的。</p>
</blockquote>
</li>
<li><p><strong>网络层</strong></p>
<p> 网络层（network layer）关系到子网的运行控制，用来确定从源端到目的地之间如何选择路由器。本层维护路由表，并确定最快捷的路由线路。</p>
<p>网络层提供两种类型网络服务   </p>
<ul>
<li>无连接的服务（数据包服务）</li>
<li>面向连接服务（虚电路服务）</li>
</ul>
</li>
</ol>
<p>　　IP协议工作在本层，网路层会写入客户端IP ,以及目标端IP<br>4. <strong>传输层</strong><br>    传输层（transport layer）基本功能是从会话层接收数据，在必要时把它们划分成较小的单元传递给网络层。传输层是在网络层的基础上再增添一层软件，使之能屏蔽掉各类通信子网的差异.<br>   传输层是真正的从源到目标“端到端”的层，是源端机和目标机进行对话的地方，它之下的各层，协议是和通信线路中各通信设备之间的协议，结构图中说明了这种区别， 1 层 -3 层是链接起来的， 4 层 -7 层是端到端的。<br>   <strong>传输层定义了传输协议和端口号</strong>，主要使用的协议由两个</p>
<ul>
<li>TCP（Transmission Control Protocol 传输控制协议）</li>
<li>UDP（用户数据包协议）</li>
</ul>
<ol start="5">
<li><p><strong>会话层</strong></p>
<p> 会话层（ session layer ）允许不同机器上的用户之间建立会话关系，即正式的连接。这种正式的连接使得信息的收发具有高可靠性。</p>
</li>
<li><p><strong>表示层</strong></p>
<p> 表示层（ presentation layer ）完成某些特定的功能，表示层以下的各层只关心可靠的传输比特流，而表示层关心的是所传输的信息的语法和语义。</p>
</li>
<li><p><strong>应用层</strong></p>
<p> 应用层（ application layer ）包含大量人们普遍需要的协议。本层处理安全问题与资源的可用性。最近几年，应用层协议发展很快，经常用到的应用层协议有： FTP（文件传输协议） 、 TELNET （Internet远程登陆服务的标准协议）、 HTTP（超文本传输协议） 、 SMTP（简单邮件传输协议） 等。</p>
</li>
</ol>
<h1 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h1><p>ISO&#x2F;OSI七层模型由于结构过多，层次复杂，因此只是一个理论上的模型，实际应用中广泛使用的是参考ISO&#x2F;OSI七层模型而设计的TCP&#x2F;IP四层模型，两者对应关系如下图<br>![TCP&#x2F;IP四层模型](\images\linux\TCP Modle.png)</p>
<ol>
<li><strong>网络接口层</strong><br>网络接入层与OSI参考模型中中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上TCP&#x2F;IP模型并未定义该层的协议，而由参与互联的各个网络使用自己的物理层和数据链路层的协议，然后与TCP&#x2F;IP的网络接入层进行连接。<strong>地址解析协议（ARP）</strong>工作在测层，既OSI参考模型的数据数据链路层。</li>
<li><strong>网络互连层</strong><br>网际互连层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。该层有三个主要协议：<strong>网际协议（IP）</strong>,<strong>互联网组管协议（IGMP）</strong>和<strong>互联网控制报文协议（ICMP）</strong></li>
<li><strong>传输层</strong><br>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送以及数据的完整性。该层定义类两个主要的协议：<strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议(UDP)</strong></li>
<li><strong>应用层</strong><br>应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP,Telnet,DNS,SMTP等。</li>
</ol>
<p><strong>数据封装过程</strong><br><img src="/%5Cimages%5Clinux%5CDataEncapsulation.png" alt="数据封装过程"></p>
<p>TCP&#x2F;IP四层模型与ISO&#x2F;OSI七层模型异同</p>
<ul>
<li><strong>相同点</strong></li>
<li>都采用了层次结构的概念</li>
<li>都能够提供面向连接（TCP）和无连接（UDP）两种通信服务机制</li>
<li><strong>不同点</strong></li>
<li>层数不同</li>
<li>对可靠性要求不同（后者更高）</li>
<li>OSI模型是在协议开发前设计的，具有通用性。TCP&#x2F;IP是先有协议然后建立模型，不使用于非TCP&#x2F;IP网络。</li>
<li>实际市场应用不同（OSI模型只是理论模型，并没有成熟的产品，而TCP&#x2F;IP已经称为“实际上的国际标准”）</li>
</ul>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><img src="/%5Cimages%5Clinux%5CIPAddressCategories.png" alt="数据封装过程"><br>IP4有32位8个字节，以8个为一组，共四组，<br>大小从0.0.0.0至255.255.255.255.<br>ip地址分为ABCDE五个级别，但是只有ABC三个对民用组织可用，而每个网络类别第一个IP地址（比如1.0.0.0）表示网络本身，不能分配，最后一个地址（比如1.255.255.255）表示网络的广播地址，也不能分配</p>
<p>图中ABC网段缺少127.XXX.XXX地址，是因为127开头只分配了一个IP:127.0.0.1,表示主机自己。</p>
<p>A级IP中第一个表示不同网段，后三个表示网段中不同主机<br>B级IP中前两个表示不同网段，后两个表示网段中不同主机<br>C级IP中前三个个表示不同网段，后一个表示网段中不同主机</p>
<p>公网中IP地址都需要付费开通的，而私有IP地址用来做内网IP,可以有效节约公网IP,但是私网IP地址无法在公网访问。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>IP有不同的网段和主机，但是主机数是由子网掩码来决定，子网掩码和IP不能分开使用，前面说的IP地址决定了多少网段和主机数，这样说是用了默认的子网掩码来匹配的。<br>子网掩码同IP一样的位数，配合子网掩码可以改变IP地址的网段，比如B类IP,默认子网掩码是255.255.0.0，子网掩码二进制表示时开头必须是连续的1，255.255就是12个连续的1，然后它决定了IP前两位变化时，就表明了不同的网段，如果我们使用255.255.255.0作为B类IP的子网掩码，那么IP前三位变化时，就表示不同的网段。子网掩码与IP地址用二进制表示时，进行与操作是该网段本身IP，进行非操作是该网段广播地址IP.</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>传输层TCP头中最主要的是包含端口号。<br>端口号表示。<br>常见端口</p>
<table>
<thead>
<tr>
<th>协议名称</th>
<th>端口号</th>
</tr>
</thead>
<tbody><tr>
<td>FTP（文件传输）</td>
<td>20 21</td>
</tr>
<tr>
<td>SSH（安全啊hell协议）</td>
<td>22</td>
</tr>
<tr>
<td>telnet（远程登陆协议）</td>
<td>23</td>
</tr>
<tr>
<td>DNS（域名系统）</td>
<td>53</td>
</tr>
<tr>
<td>http（超文本传输协议）</td>
<td>80</td>
</tr>
<tr>
<td>SMTP（简单邮件传输协议）</td>
<td>25</td>
</tr>
<tr>
<td>POP3（邮局协议3代）</td>
<td>110</td>
</tr>
</tbody></table>
<p>查看本机启用端口的命令（Linux与Windows相同）</p>
<p><strong>netstat</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-a</strong></td>
<td>查看所有连接和监听端口</td>
</tr>
<tr>
<td><strong>-n</strong></td>
<td>显示IP地址和端口号，而不显示域名服务名</td>
</tr>
</tbody></table>
<h2 id="DNS作用"><a href="#DNS作用" class="headerlink" title="DNS作用"></a>DNS作用</h2><p>DNS（Domain Name System）是域名解析系统，因为IP地址难以记忆，而域名更加好记忆，所以需要域名与IP地址之间的转换</p>
<h2 id="网关作用"><a href="#网关作用" class="headerlink" title="网关作用"></a>网关作用</h2><ol>
<li>网关（Gateway）又称网间连接器，协议转换器</li>
<li>网关在网络层以上实现网络互联，是最复杂的网络连接设备，仅用于两个高层协议不同的网络互联</li>
<li>网管既可以用于广域网互联，也可以用于局域网互联。</li>
<li>网关是一种充当转换重任的服务器或路由器。</li>
</ol>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag> Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习（一）基础</title>
    <url>/2017/10/23/Mysql%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java 8 Lambda表达式(翻译自Stackoverflow)</title>
    <url>/2017/04/29/java-8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%BF%BB%E8%AF%91%E8%87%AAStackoverflow/</url>
    <content><![CDATA[<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><hr>
<p><a href="http://stackoverflow.com/documentation/java/91/lambda-expressions#t=201703170153070549388">原文链接</a>Lambda只能作用于一个只有一个抽象方法的函数式接口(Function Interface),不过函数式接口可以有任意数量default或static修饰的方法(因此,它们有时也被当做单抽象方法类型接口或者说是SAM类型接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">boolean</span> baz)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo3</span> &#123;</span><br><span class="line">    String <span class="title function_">bar</span><span class="params">(Object baz, <span class="type">int</span> mink)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo4</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">bar</span><span class="params">()</span> &#123; <span class="comment">// default so not counted</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;baz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quux</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们声明一个函数式接口,可以添加上@FunctionalInterface声明符.这并没有什么特别的效果,只是添加了这个声明符的接口如果不是函数式的,那么编译器便会报错,因此它实际是一个提醒,告诉我们这个接口不应该被修改(被添加更多的抽象方法).</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo5</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BlankFoo1</span> <span class="keyword">extends</span> <span class="title class_">Foo3</span> &#123; <span class="comment">// 从Foo3中继承抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo6</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>; <span class="comment">// 重写Object的方法并不会被计入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反的,下面并不是一个函数式接口,因为它有超过一个的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BadFoo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quux</span><span class="params">()</span>; <span class="comment">// &lt;-- 第二个方法会导致禁用lambda,因为lambda会不知道到底要实现哪一个抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面同样不是一个函数式接口,因为它没有任何方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BlankFoo2</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>注意下面的例子,假设你有一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span> &#123; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parentMethod</span><span class="params">()</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>并且有一个子接口继承自它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ChildMethod</span><span class="params">()</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>那么这个子类并不是一个函数式接口因为它有两个方法</p>
<p>Java 8同样在java.util.funciton中提供了一系列的通用函数式接口模版.例如内置接口Predicate&lt;T&gt;,它只包含一个方法,这个方法需要传入一个T类型参数,并返回一个布尔类型的值.</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><hr>
<p>下面是Lambda表达式的基本结构</p>
<p><img src="https://i.stack.imgur.com/RRcfc.png?_=6564813" alt="Lambda表达式"><br>上图中fi是一个类的单例,就和实现了<strong>FuctionalInterface</strong>接口的匿名类一样,它以{System.out.println(“Hello”); }这段方法体重写了接口的抽象方法,换而言之,上面的等同于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FunctionalInterface</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FunctionalInterface</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">theOneMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式只是等效于一个匿名类,因为在Lambda表达式中,像this,super或toString()这些引用的是被调用的类本身,而不是新建的对象.</p>
<p>使用Lambda表达式你可以不必特别指定方法的名称—这也不需要,因为在一个函数式接口中有且只有一个抽象方法,这样java也只会重写这一个;</p>
<p>在这种情况下,Lambda表达式的类型并不确定(如重载方法),因此你可以在Lambda表达式中添加一个类型转换,来告诉编译器它应该是什么类型,就如下面例子一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">fooHolder</span> <span class="operator">=</span> (Foo1) () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(fooHolder <span class="keyword">instanceof</span> Foo1); <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure>
<p>如果函数式接口的方法有参数的话,那么参数名应该写在Lambda表达式括号中.这里并不需要声明参数或返回值的类型,因为java会自动从接口中获取(如果愿意声明的话,即使你声明了类型,java并也不会报错),因此,下面两个例子是等效的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo2</span> <span class="variable">longFoo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo2</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">boolean</span> baz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baz ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Foo2</span> <span class="variable">shortFoo</span> <span class="operator">=</span> (x) -&gt; &#123; <span class="keyword">return</span> x ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>如果这个方法只有一个参数的话,参数外的括号也可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo2</span> <span class="variable">np</span> <span class="operator">=</span> x -&gt; &#123; <span class="keyword">return</span> x ? <span class="number">1</span> : <span class="number">0</span>; &#125;; <span class="comment">// 可以省略</span></span><br><span class="line"><span class="type">Foo3</span> <span class="variable">np2</span> <span class="operator">=</span> x, y -&gt; x.toString() + y    <span class="comment">//error 不可以省略</span></span><br></pre></td></tr></table></figure>

<h1 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h1><hr>
<p>如果lambda表达式内的代码是一个java表达式而不是代码块的话,它会被当做一个方法返回的表达式值.因此下面两个例子是等效的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntUnaryOperator</span> <span class="variable">addOneShort</span> <span class="operator">=</span> (x) -&gt; (x + <span class="number">1</span>);</span><br><span class="line"><span class="type">IntUnaryOperator</span> <span class="variable">addOneLong</span> <span class="operator">=</span> (x) -&gt; &#123; <span class="keyword">return</span> (x + <span class="number">1</span>); &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="访问局部变量-闭包值"><a href="#访问局部变量-闭包值" class="headerlink" title="访问局部变量(闭包值)"></a>访问局部变量(闭包值)</h1><hr>
<p>lambda表达式只是匿名类简写的语法糖,因此它也同样遵守访问作用域内局部变量的规则;局部变量必须被当做以final关键字修饰,在lambda表达式中无法被修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntUnaryOperator <span class="title function_">makeAdder</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (x) -&gt; (x + amount); <span class="comment">// 这是合法的,即使amount会超出作用域,因为amount没有被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntUnaryOperator <span class="title function_">makeAccumulator</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (x) -&gt; &#123; value += x; <span class="keyword">return</span> value; &#125;; <span class="comment">// error  将无法编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有必要以这种方式包含一个变量,应该用一个普通对象复制该变量,想了解更多请查看Java Closures with lambda expressions.;</p>
<h1 id="接收Lambda表达式"><a href="#接收Lambda表达式" class="headerlink" title="接收Lambda表达式"></a>接收Lambda表达式</h1><hr>
<p>因为lambda是一个接口的实现,所以没有特别需要做的当一个方法接收lambda作为参数时:任何一个接收函数式接口的方法都可以接收lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passMeALambda</span><span class="params">(Foo1 f)</span> &#123;</span><br><span class="line">    f.bar();</span><br><span class="line">&#125;</span><br><span class="line">passMeALambda(() -&gt; System.out.println(<span class="string">&quot;Lambda called&quot;</span>));</span><br></pre></td></tr></table></figure>
<h1 id="Lambda表达式的类型"><a href="#Lambda表达式的类型" class="headerlink" title="Lambda表达式的类型"></a>Lambda表达式的类型</h1><hr>
<p>一个lambda表达式自己没有什么特定的类型,显然的是,参数的数量和类型,连同返回值的类型能够传达一些信息,这些信息能够唯一限制它将被赋予的类型.当lambda用以下一些方式被分配给一个函数式接口类型时,它将接收一个特定类型;</p>
<ul>
<li>直接被赋值一个函数类型,比如  myPredicate &#x3D; s -&gt; s.isEmpty()</li>
<li>将它作为参数传递当需要一个函数类型参数时,比如 stream.filter(s -&gt; s.isEmpty())</li>
<li>将它作为返回值从一个返回函数类型的方法中返回,比如 return s -&gt; s.isEmpty()</li>
<li>将它转换为一个函数类型,比如 (Predicate&lt;String&gt;) s -&gt; s.isEmpty()</li>
<li>直到任何一个赋值给函数类型操作执行前,lambda都没有一个确定类型.为了举例,可以看下这个lambda表达式 o -&gt; o.isEmpty().相同的lambda表达式会被赋予不同的函数类型.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; javaStringPred = o -&gt; o.isEmpty();</span><br><span class="line">Function&lt;String, Boolean&gt; javaFunc = o -&gt; o.isEmpty();</span><br><span class="line">Predicate&lt;List&gt; javaListPred = o -&gt; o.isEmpty();</span><br><span class="line">Consumer&lt;String&gt; javaStringConsumer = o -&gt; o.isEmpty(); <span class="comment">// 返回值被忽略</span></span><br><span class="line">com.google.common.base.Predicate&lt;String&gt; guavaPredicate = o -&gt; o.isEmpty();</span><br></pre></td></tr></table></figure>
<p>现在他们被指定类型,这些例子展示了即使看起来一样的lambda表达式,但他们是完全不同的类型,不能够相互之间再被赋值;</p>
]]></content>
      <categories>
        <category>java其他</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架（四）文件流</title>
    <url>/2017/05/04/java-I-O%E6%A1%86%E6%9E%B6-%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%87%E4%BB%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><p>　　FileInputStream和FileReader是文件字节输入流和文件字符输入流,都是提供文件读取功能,只是读取形式不同,一个以字节为最小单位读取,一个以字符为最小单位读取,并且两者都必须从文件头开始,按顺序读取,读取结束后需要调用close()方法释放流对象.  </p>
<blockquote>
<p>两个文件输入流都不支持mark(int),reset()操作，其markSupported()方法都返回false</p>
</blockquote>
<p>两个文件输入流的有参构造方法一致,以FileInputStream为例</p>
<ul>
<li>public FileInputStream(String name)  </li>
<li>public FileInputStream(File file)      </li>
<li>public FileInputStream(FileDesciptor fd)</li>
</ul>
<span id="more"></span>

<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>　　FileInputStream直接继承自InputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在桌面创建一个input.txt文本,内容为&quot;The quick brown fox jumps over a lazy dog.&quot;,文件大小是42字节,</span></span><br><span class="line"><span class="comment"> * 下面分别测试FileInputStream成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\input.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read()方法单字节读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read(byte[] b)方法使用数组读取,read(byte[] b,int off,int len)相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readByteArrayCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.read(bytes);</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,data));   <span class="comment">//每次读入到bytes数组中时,会按索引重复覆盖数据,</span></span><br><span class="line">            data=input.read(bytes);                       <span class="comment">//最后一次读入可能会残留上一次的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试skip(int)方法,使流可以跳过一定字节数据,最大跳过字节数为2048</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">skipCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        InputStream input=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        input.skip(<span class="number">4</span>);                                     <span class="comment">//跳过四个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> data=input.read();</span><br><span class="line">        <span class="keyword">while</span>(data!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            data=input.read();</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试available()方法,获取文件的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">availableCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        InputStream input=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        System.out.print(input.available());</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试markSupported()等方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markSupportedCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        InputStream input=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line">        System.out.print(input.markSupported());</span><br><span class="line">        input.mark(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.reset();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.print(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试获取属性等方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getPropertiesCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        FileInputStream input=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        System.out.println(input.getChannel());                    <span class="comment">//获取文件FileChannel对象</span></span><br><span class="line">        System.out.print(input.getFD());                           <span class="comment">//获取文件FileDescriptor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        readCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------------------------------&quot;</span>);</span><br><span class="line">        readByteArrayCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------------------------------&quot;</span>);</span><br><span class="line">        skipCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------------------------------&quot;</span>);</span><br><span class="line">        availableCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------------------------------&quot;</span>);</span><br><span class="line">        markSupportedCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------------------------------&quot;</span>);</span><br><span class="line">        getPropertiesCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面是控制台输出结果</p>
<blockquote>
<p>The quick brown fox jumps over a lazy dog.<br>-——————————<br>The quick brown fox jumps over a lazy dog.<br>-——————————<br>quick brown fox jumps over a lazy dog.<br>-——————————<br>42　　　　　　　　　　　　　　　　　　　　　　　　　<br>-——————————<br>falsemark&#x2F;reset not supported<br>-——————————<br>sun.nio.ch.FileChannelImpl@1540e19d<br>java.io.FileDescriptor@677327b6   </p>
</blockquote>
<p>由输出结果可以看出FileInputStream并没有重写markSupported()方法,所以FileInputStream并不支持mark()和reset()方法,读取文件时无法标记读取位置和重置.</p>
<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>　　FileReader直接继承自InputStreamReader,而InputStreamReader是一个输入转换流,将输入字节转换为字符形式,这说明FileReader底层还是依靠字节流读取,只不过java帮我们进行了编码工作.</p>
<h1 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h1><p>　　FileOutputStream和FileWriter是文件字节输出流和文件字符输出流,都是提供文件写入功能,只是写入形式不同,一个以字节为最小单位写入,一个以字符为最小单位写入,此外还可以选择是在原来文件基础上重新写入还是追加写入,写入结束后需要调用close()方法释放流对象.</p>
<blockquote>
<p>FileOutputStream没有缓冲区，其flush方法没有意义，而FileWriter有缓冲区，需要立即写入的话需要调用flush方法。</p>
</blockquote>
<p>两个文件输出流的有参构造方法一致,以FileOutputStream为例</p>
<ul>
<li>public FileOutputStream(String name)</li>
<li>public FileOutputStream(String name, boolean append)</li>
<li>public FileOutputStream(File file)</li>
<li>public FileOutputStream(File file, boolean append)</li>
<li>public FileOutputStream(FileDescriptor fdObj)</li>
</ul>
<p>其中有两个构造方法带有一个boolean类型形式参数,它规定写入形式,当为true时,表明要在原来文件尾追加写入,为false时是重写文件,不带此参数默认为false.</p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>　　FileOutputStream直接继承自OutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/20 0020.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePath=<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\outStream.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lineSeparator</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;line.separator&quot;</span>, <span class="string">&quot;/n&quot;</span>);  <span class="comment">//获取当前系统的文本分隔符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writeCase();</span><br><span class="line">        constructorCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入方法方法测试,分别是write(int a),write(byte[] b),write(byte[] b,int off,int len)三种写入方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        OutputStream output=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);         <span class="comment">//如果文件不存在,则创建该文件</span></span><br><span class="line"></span><br><span class="line">        output.write(<span class="number">98</span>);</span><br><span class="line">        output.write(lineSeparator.getBytes());</span><br><span class="line">        output.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        output.write(lineSeparator.getBytes());</span><br><span class="line">        output.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">        output.write(lineSeparator.getBytes());</span><br><span class="line">        output.write(<span class="string">&quot;hello world&quot;</span>.getBytes(),<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法测试,主要看追加写入效果演示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">constructorCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        OutputStream output1=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);</span><br><span class="line">        output1.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        output1.close();</span><br><span class="line"></span><br><span class="line">        OutputStream output2=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath,<span class="literal">true</span>);</span><br><span class="line">        output2.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        output2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中当执行writeCase()方法后,桌面创建了outStream.txt文件夹,内容为</p>
<blockquote>
<p>b<br>a<br>hello world<br>llo  </p>
</blockquote>
<p>需要注意的是FileOutputStream执行write()方法时,文件会立即写入内容,不需要调用flush()方法刷入,FileOutputStream也没有重写flush()方法,其方法体为空<br>执行constructorCase()方法第一次创建output1并写入时,文件outStream.txt被重新创建,文本内容为</p>
<blockquote>
<p>a  </p>
</blockquote>
<p>第二次创建output2,写入模式变为追加写入,文件内容变为  </p>
<blockquote>
<p>ab</p>
</blockquote>
<h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><p>　　FileWriter直接继承自OutputStreamWriter,而OutputStreamWriter是一个输出转换流,将输出的字符转换为字节形式,这说明FileWriter底层还是依靠字节流写入,只不过java帮我们进行了编码工作.<br>　　此外需要注意的是FileWriter具有一个缓冲区,写入的字符首先会存在缓冲区内,因此write()方法并不会直接写入到文本,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/20 0020.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String filePath=<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\writer.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lineSeparator</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;line.separator&quot;</span>, <span class="string">&quot;/n&quot;</span>);  <span class="comment">//获取当前系统的文本分隔符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writeAndFlushCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试 write()方法各种形式,一时flush()方法作用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeAndFlushCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        Writer writer=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line"></span><br><span class="line">        writer.write(<span class="number">98</span>);</span><br><span class="line">        writer.write(lineSeparator);</span><br><span class="line">        writer.write(<span class="string">&quot;你好,世界&quot;</span>.toCharArray());</span><br><span class="line">        writer.write(lineSeparator);</span><br><span class="line">        writer.write(<span class="string">&quot;你好,世界&quot;</span>.toCharArray(),<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        writer.flush();                                       <span class="comment">//调用flush(),将缓冲区内字符刷入到文本</span></span><br><span class="line">        writer.write(lineSeparator);</span><br><span class="line">        writer.write(<span class="string">&quot;你好,世界&quot;</span>);</span><br><span class="line">        writer.write(lineSeparator);</span><br><span class="line">        writer.write(<span class="string">&quot;你好,世界&quot;</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了测试FileWriter的缓冲区效果,我们在debug模式下一行行执行,实例化FileWriter对象后,java会自动帮我们在所写路径下创建相应文件,如果原来不存在的话</p>
<p>在代码执行到flush()方法调用前,打开文本内容一直为空,调用flush()方法后,文本内容为</p>
<blockquote>
<p>b<br>你好,世界<br>世界</p>
</blockquote>
<p>执行完close()前文本内容一直不变,调用close()后,再次查看文本内容为</p>
<blockquote>
<p>b<br>你好,世界<br>世界<br>你好,世界<br>好,世界</p>
</blockquote>
<p>　　可见FileWriter使用写入方法时,会首先将字符写入到一个字符缓冲区,等缓冲区满后才会真正写入到文本,这样设计的目的我想不是为了提高写入速度,因为一是相对应的FileOutputStream类没有使用缓冲区,二是后面有专门的缓冲流,我们知道FileWriter继承自OutputStreamWriter,这是一个转换流,说明FileWriter本质上还是以字节的形式写入.只不过java自动帮我们编码,而之所以要使用一个缓冲区,就是为了每执行一次写入,确保写入的是一个字符.</p>
<p>　　此外FileWriter方法最后调用close()方法时并没有执行flush()方法,后面的同样被写入,说明FileWriter的close()方法会自动执行一次flush()操作,通过源码也会发现这一点.</p>
<h1 id="随机文件读写"><a href="#随机文件读写" class="headerlink" title="随机文件读写"></a>随机文件读写</h1><p>　　上面无论文件的读取只能从文件头开始,写入可以重写或者追加写入,而通过文件随机读写流RandomAccessFile,我们可以在任意指定位置进行读写</p>
<p>　　RandomAccessFile操作文件就像操作一个byte数组一样,可以通过一个文件指针(就像数组的索引),来实现从文件随机位置读写,</p>
<p>　　此外RandomAccessFile和上面文件流不同的是,它不是java IO四个基本流的直接或间接子类,而是实现了DataOutput,DataIntput,Closeable三个接口,它有两个构造方法</p>
<ul>
<li>public RandomAccessFile(String name ,String mode)</li>
<li>public RandomAccessFile(File file ,String mode)</li>
</ul>
<p>需要注意两个构造方法的第二个参数,String mode,它表示对文件操作的类型,分以下四种形式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读模式，如果对文件进行写操作，会报IOException错误</td>
</tr>
<tr>
<td>rw</td>
<td>读写模式,如果文件不存在,将会创建文件</td>
</tr>
<tr>
<td>rws</td>
<td>同步读写模式,任何对文件的修改(内容和元数据),都会立即被同步到底层存储设备ddd</td>
</tr>
<tr>
<td>rwｄ</td>
<td>同步读写模式,任何对文件的修改(内容),都会立即被同步到底层存储设备</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在桌面创建一个file.txt文本,内容为&quot;The quick brown fox jumps over a lazy dog.&quot;,文件大小是42字节,</span></span><br><span class="line"><span class="comment"> * 主要测试以下方法</span></span><br><span class="line"><span class="comment"> *    read()              读取字节</span></span><br><span class="line"><span class="comment"> *    write(byte[] byte)  写入字节数组</span></span><br><span class="line"><span class="comment"> *    seek(long pos)      设置当前文件指针</span></span><br><span class="line"><span class="comment"> *    getFilePointer()    获取当前文件指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccesseFileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\file.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lineSeparator</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;line.separator&quot;</span>, <span class="string">&quot;/n&quot;</span>);  <span class="comment">//获取当前系统的文本分隔符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        readCase();</span><br><span class="line">        writeCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(filePath, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> file.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = file.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(lineSeparator + <span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        file.seek(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件现在指针位置  &quot;</span> + file.getFilePointer());</span><br><span class="line">        data = file.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = file.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.write(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(lineSeparator + <span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeCase</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(filePath, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        file.write(<span class="string">&quot;The tardy&quot;</span>.getBytes());</span><br><span class="line">        file.seek(<span class="number">4</span>);</span><br><span class="line">        file.write(<span class="string">&quot;quick&quot;</span>.getBytes());</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完readCase()后控制台打出</p>
<blockquote>
<p>The quick brown fox jumps over a lazy dog.<br>-—————————<br>文件现在指针位置  4<br>quick brown fox jumps over a lazy dog.<br>-—————————<br>java.io.IOException: 拒绝访问。  </p>
</blockquote>
<p>在debug模式下执行writeCase()第一次写入时,打开file.txt,文件内容是</p>
<blockquote>
<p>The tardy brown fox jumps over a lazy dog. </p>
</blockquote>
<p>重新设置文件指针为4,第二次写入后,查看文件,内容是  </p>
<blockquote>
<p>The quick brown fox jumps over a lazy dog.</p>
</blockquote>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架（一）总览</title>
    <url>/2017/05/04/java-I-O%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<p>　　一个I&#x2F;O流是指一系列的数据，包含了一个输入的数据源和一个输出的目的地，而我们程序在其中起到一个操作中转的作用，input就是数据从数据源流向我们程序内存的过程，output则是从内存流向输出的目的地，可以用下图表示</p>
<p>![IO Stream](\images\java io\IO Stream.jpg)</p>
<span id="more"></span>

<p>　　数据源和输出目的地可以包含多种形式，下面是一些常见的形式。</p>
<ul>
<li>文件(file)</li>
<li>网络(network)</li>
<li>内存缓存(Buffer)</li>
<li>线程内部通信(Pipe管道)</li>
<li>缓冲</li>
<li>过滤</li>
<li>解析</li>
<li>文本 (Readers &#x2F; Writers Text)</li>
<li>基本类型数据 (long, int etc.)</li>
<li>对象(Object)</li>
</ul>
<p>　　I&#x2F;O流中传输的数据存在着两种基本的形式，一种是字节（byte）,一种是字符（char）,这样就组成了Java I&#x2F;O框架四种基本流的形式。</p>
<ul>
<li><strong>InputStrem</strong></li>
<li><strong>Reader</strong></li>
<li><strong>OutputStream</strong></li>
<li><strong>Writer</strong></li>
</ul>
<p>　　InputStream和OutputStream是字节输入输出流,Reader和Writer是字符输入输出流,I&#x2F;O框架中其他字节字符流都是由这四种基本流派生而来。<br> 　 依照数据源、数据输出目的地与数据形式组合，Java I&#x2F;O 中提供了一系列不同用途的通用实现类，下面表格中是这些通用实现的组合。</p>
<table>
<thead>
<tr>
<th></th>
<th>Byte Based Input</th>
<th>Output</th>
<th>Character Based Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Basic</strong></td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader InputStreamReader</td>
<td>Writer OutputStreamWriter</td>
</tr>
<tr>
<td><strong>Arrays</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td><strong>Files</strong></td>
<td>FileInputStream RandomAccessFile</td>
<td>FileOutputStream RandomAccessFile</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>Pipes</strong></td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td><strong>Buffering</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td><strong>Filtering</strong></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td><strong>Parsing</strong></td>
<td>PushbackInputStream StreamTokenizer</td>
<td></td>
<td>PushbackReader LinenumberReader</td>
<td></td>
</tr>
<tr>
<td><strong>Strings</strong></td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Data-Formatted</strong></td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrinrWriter</td>
</tr>
<tr>
<td><strong>Objects</strong></td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Utilities</strong></td>
<td>SequenceInputStream</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>文件操作(File)</li>
<li>基本流(InputStream,OutputStream,Reader,Writer)</li>
<li>文件流(FileInputStream,FileOutputStream,FileReader,FileWriter,RadomAccessFile)</li>
<li>转换流(InputStreamReader,OutputStreamWriter)</li>
<li>IO异常处理(IOException)</li>
<li>缓冲流(BufferedInputStream,BufferedOutputStream,BufferdeReader,BufferedWriter)</li>
<li>回退流(PushBackInputStream,PushBackReader)</li>
<li>管道流(PipeInputStream,PipeOutputStream,PipeReader,PipeWriter)</li>
<li>数组流(ByteArrayInputStream,ByteArrayOutputStream,CharArrayReader,CharArrayWriter)</li>
<li>打印流(PrinteStream,PrintWriter)</li>
<li>对象流(ObjectInputStream,ObjectOutputStream)</li>
<li>字符串流(StringReader,StringWriter)</li>
<li>数据流(DataInputStream,DataOutputStream)</li>
<li>其他流(StreamTokenizer,LineNumberReader,SequenceInputStream)</li>
<li>System.in和System.out 以及System.error</li>
<li>序列化(Serializable)</li>
<li>Java IO与装饰者模式</li>
<li>java NIO</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://tutorials.jenkov.com/java-io/outputstream.html">《Java IO教程》   ——–  作者：Jakob Jenkov</a><br><a href="http://www.cnblogs.com/skywang12345/p/io_01.html">Java IO教程 系列  ——–  skywang12345</a><br><a href="http://blog.csdn.net/lin_bei/article/details/1067506">从Decorator，Adapter模式看Java&#x2F;IO库（一）    ——–  lin_bei </a><br><a href="http://hold-on.iteye.com/blog/1017449">关于inputStream.available()方法获取下载文件的总大小 - 无知者无畏 - ITeye技术网站       ——– hold_on </a></p>
</blockquote>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架 （七）缓冲流</title>
    <url>/2017/05/06/java-I-O%E6%A1%86%E6%9E%B6-%EF%BC%88%E4%B8%83%EF%BC%89%E7%BC%93%E5%86%B2%E6%B5%81/</url>
    <content><![CDATA[<p>前面我们使用I&#x2F;O都是无缓存的I&#x2F;O。这样意味着每个读写请求都是直接直接由底层操作系统处理的。频繁的读写请求对于硬盘，和网络都是都有很大的性能消耗，为了减少这种支出，提高读写性能，Java实现了缓冲I&#x2F;O流。</p>
<p>缓冲流对数据的读写都是间接通过内存里的一块缓冲区，缓冲输入流从内存缓冲区读取数据，只有当缓冲区清空时，本地输入API才会被调用，缓冲输出流将数据写入内存缓冲区，只有当缓冲区满时，才会调用本地输出API，将数据写入硬盘或网络传输。</p>
<span id="more"></span>

<p>缓冲流提供了四个类，分别是字节输入输出缓冲流BufferedInputStream,BufferedOutputStream和字符输入输出流：BufferReader,BufferedWriter.缓冲流是通过包装一些无缓冲的I&#x2F;O流对象，为他们添加缓冲区，生成缓冲流对象，所有的缓冲流有相同形式的构造方法，以BufferedInputStream为例。</p>
<ul>
<li>public BufferedInputStream(InputStream in)</li>
<li>public BufferedInputStream(InputStream in,int size)</li>
</ul>
<p>两种构造函数中，第一种需要传入需要包装添加缓冲区的I&#x2F;O流对象，第二种还可以传入一个int类型参数，用来指定缓冲区大小，当不指定时，缓冲流会有一个默认8192字节&#x2F;字符的缓冲区，这已经足够大部分使用场景。</p>
<h2 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h2><p>当我们使用输出缓冲流的时候，写入的数据是先到内存缓冲区内，只有当缓冲区满时，才会执行实际写入。我们可以在比要的时候调用flush方法手动刷入缓冲区，flush在所有的输出流中都是可用的。<br>还有一些缓冲输出流是支持自动刷新的，只不过需要在构造函数内开启，这样在调用一些操作时，就会自动刷入缓冲区数据，比如PrintWriter可以在调用println或format方法时自动掉用flush.</p>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架 （五）转换流</title>
    <url>/2017/05/06/java-I-O%E6%A1%86%E6%9E%B6-%EF%BC%88%E4%BA%94%EF%BC%89%E8%BD%AC%E6%8D%A2%E6%B5%81/</url>
    <content><![CDATA[<p>转换流是字节流与字符流之间的桥梁，转换流有两个</p>
<ul>
<li><strong>InputStreamReader</strong></li>
<li><strong>OutputStreamWriter</strong></li>
</ul>
<p>这两个转换流分别直接继承自Reader和Writer,他们的构造函数提供一个包装器功能，传入一个相应的字节流，使用这个底层的字节流进行相应的读取写入工作，然后转换流附加上字符的解码编码功能。</p>
<p>InputStreamReader是字节通向字符的桥梁，它读取字节并通过给定的字符集将字节解码为字符，而OutputStreamWriter则相反，它是字符通向字节的桥梁，将字符以给定的字符集进行编码，用字节的形式写入。字符集我们自己可以指定，不指定的话则由转换流自动获取系统使用的默认字符集。</p>
<span id="more"></span>


<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>InputStreamReader和OutputStreamWriter构造函数形式一致，以InputStreamReader为例</p>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>InputStreamReader(InputStream in)</td>
<td>使用默认字符集新建一个InputStreamReader</td>
</tr>
<tr>
<td>InputStreamReader(InputStream in, String charsetName)</td>
<td>使用给定字符集名字新建一个InputStreamReader</td>
</tr>
<tr>
<td>InputStreamReader(InputStream in, Charset cs)</td>
<td>使用给定字符集新建一InputStreamReader</td>
</tr>
<tr>
<td>InputStream in, CharsetDecoder dec</td>
<td>使用给定字符解码器新建一InputStreamReader</td>
</tr>
</tbody></table>
<p>使用转换流的时候我们需要给定一个正确的字符集，否则可能出现乱码现象，在第二种构造方法中如果给的字符集名称不存在的话，会抛出UnsupportedEncodingException: XXX异常。</p>
<h1 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h1><p>转换流都和字符编码有关，所以都有一个getEncodeing()方法，用来获取当前流要使用的字符集编码形式。转换流是包装的一个普通字节流，我们知道I&#x2F;O流使用结束后都需要关闭的，但是使用转换流的时候只需要调用转换流close()方法，它会自动关闭内部的字节流，不需要我们再去关闭。其他方法则和其父类用法相同。</p>
<h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><table>
<thead>
<tr>
<th>修饰符和类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>close</strong>()</td>
<td>关闭流，并释放相应的系统资源</td>
</tr>
<tr>
<td>String</td>
<td><strong>getEncoding</strong>()</td>
<td>获取流使用的字符编码名字</td>
</tr>
<tr>
<td>int</td>
<td><strong>read</strong>()</td>
<td>读取一个字符</td>
</tr>
<tr>
<td>int</td>
<td><strong>read</strong>(char[] cbuf,int offset,int length)</td>
<td>将字符读入到给定的数组中一部分</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>ready</strong>()</td>
<td>告诉流是否准备好读取操作</td>
</tr>
</tbody></table>
<h1 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h1><table>
<thead>
<tr>
<th>修饰符和类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Writer</td>
<td><strong>append</strong>(CharSequence csq)</td>
<td>在这个wirter后追加一个指定字符</td>
</tr>
<tr>
<td>Writer</td>
<td><strong>append</strong>(CharSequence csq, int start, int end)</td>
<td>在这个wirter后追加一个指定字符序列的子序列</td>
</tr>
<tr>
<td>void</td>
<td><strong>close</strong>()</td>
<td>先刷新缓冲区数据，再关闭流</td>
</tr>
<tr>
<td>void</td>
<td><strong>flush</strong>()</td>
<td>刷新流</td>
</tr>
<tr>
<td>String</td>
<td><strong>getEncoding</strong>()</td>
<td>获取流使用的字符编码名字</td>
</tr>
<tr>
<td>void</td>
<td><strong>write</strong>(char[] cbuf,int off,int len)</td>
<td>将一个字符数组的一部分写入</td>
</tr>
<tr>
<td>void</td>
<td><strong>write</strong>(int c)</td>
<td>写入一个字符</td>
</tr>
<tr>
<td>void</td>
<td><strong>write</strong>(String str,ing off,int len)</td>
<td>将给定的字符串中一部分写入</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架（三）基本流</title>
    <url>/2017/05/04/java-I-O%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%B5%81/</url>
    <content><![CDATA[<p>基本流有字节输入输出流(InputStream,OutputStream),和字符输入输出流(Reader,Writer),它们都是抽象类,作为Java I&#x2F;O中其他所有字节字符流的父类存在.基本流定义了I&#x2F;O读写的最基本的读写方法。每个基本流都实现了Closeable接口接口，其继承的close方法，在使用I&#x2F;O流结束后释放对资源的占用。</p>
<p>　　我们知道计算机数据都是以二进制的形式存在,用字节(byte)形式就可以实现读写,在最初的JDK1.0版本中也只有字节流的存在,在之后的1.1版本才加入了字符输入输出流(Reader,Writer)。这是为了方便文本格式文件读写，在Java中存储字符是使用的Unicode编码集，使用字符流的时候Java可以自动帮我们实现与系统本地字符集之间的编码解码转换。</p>
<p>　　实际字符流通用子类大多是包装了一个相同用途的字节流，字符流做的是将字节与字符之间的转换，比如字符流的一个子类FileReader,底层就是包装的一个FileInputStream.具体实现字节字符转换的是两个转换流来完成，InputStreamReader和OutputStreamWriter。</p>
<span id="more"></span>
<hr>
<h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><hr>
<p>　　InputStream和Reader作为输入流的父类，其方法功能是基本一致的，InputStream中子类必须实现的抽象方法是read(),而Reader中子类必须实现的抽象方法有read(char[],int,int),close()。</p>
<p>　　需要注意的是一直到输入的数据可用时输入流的read方法都是阻塞式的，比如读取本地文件，而此文件被其他程序占用时，read方法会一直等待取得读取权限，或者在网络传输过程中，read方法会一直阻塞直到数据传输进来。</p>
<p>　　此外两个基本输入流除了读取方法外，都有markSupported(),mark(int)和reset()方法，mark(int)是在读取时标记一个读取位置，然后可以调用reset()方法在任何时候重置到该读取位置，这适用于一些分析器,这些分析器有时需要预读后面一部分字节,如果没有发现目标,则返回重写读取.而markSupported()则是返回一个布尔值表示是否支持这种标记重置方法，当不支持时如果调用以上方法，则会抛出IOException(“mark&#x2F;reset not supported”)异常，基本流输入中markSupportered方法默认返回flase,由子类重写选择是否实现此功能。</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>![InputStream](\images\java io\InputStream.png)<br>　　InputStream是java IO所有字节输入流的超类,如果你自己想要实现一个字节输入流组件,最好直接继承InputStream而不是他的子类,这样你可以处理所有类型的输入流.</p>
<ul>
<li><p>public abstract int  <strong>read()</strong> throws IOException;<br>　　read()是一个抽象方法,由子类重写具体实现方式,它用来读取数据,且每次只读取一个字节,并以int类型返回该字节,当InputStream读取到文件末尾,再也没有数据时,则返回-1;  </p>
</li>
<li><p>public int <strong>read(byte b[])</strong> throws IOException{…}<br>　　read(byte[])方法一次读取多个字节,并将其储存在传入的byte数组中,相比read(),其速度提高了很多.read(byte[])返回的是int类型所读取字节数,和read()一样,到文件末尾时,返回-1.  </p>
</li>
<li><p>public int <strong>read(byte[] b,int off,int len)</strong> throws IOException{…}<br>　　read(byte[],int,int) 与 read(byte[])类似,不同的是read(byte[] b ,int off,int len)可以通过传入参数off选择开始要写入到的数组索引位置,以及len确定要读取的字节数</p>
</li>
<li><p>public long <strong>skip(long n)</strong> throws IOException{…}<br>　　skip(long)用来跳过不读一些字节数,InputStream定义了一个MAX_SKIP_BUFFER_SIZE常量,大小为2048,这是一次所能跳过的最大字节数,其返回值为long类型的实际跳过字节数; </p>
</li>
<li><p>public int <strong>available()</strong> throws IOException{…}<br>　　available()用来获取流中可读取数据大小,InputStream中此方法默认返回0,由其子类重写来实现具体方法;   </p>
</li>
<li><p>public void <strong>close()</strong> throws IOException{}<br>　　close()方法用来读取结束后,关闭流,释放系统资源,InputStream中此方法不执行任何操作，由子类来实现。</p>
</li>
</ul>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>![Reader](\images\java io\Reader.png)</p>
<p>Reader相比InputStream多实现了一个Readerable接口,它使Reader可以将读取的数据存储在一个缓冲区内.而且Reader有两个构造方法,可以使用自己或者传入的对象作为同步锁,以保持读取同步。</p>
<ul>
<li><p>public int <strong>read(java.nio.CharBuffer target)</strong> throws IOException {…}</p>
</li>
<li><p>public int <strong>read()</strong> throws IOException {…}<br>　　一次读取一个字符,并将该字符以int类型返回,当读到文件尾没有数据时,返回-1</p>
</li>
<li><p>public int <strong>read(char cbuf[])</strong> throws IOException {…}<br>　　一次读取多个字符,并将字符放到传入的字符数组中,返回值为实际读取的字符数,到文件尾没有数据时返回-1</p>
</li>
<li><p>abstract public int <strong>read(char cbuf[], int off, int len)</strong> throws IOException;<br>　　一次读取多个字符,并将字符放入传入的字符数组中,并且可以指定传入字符数组索引和传入的字符数,返回值同样为实际读取字符数,到文件尾没有数据时返回-1</p>
</li>
<li><p>public boolean <strong>ready()</strong> throws IOException {…}<br>　　ready()告诉程序字符流是否可以被读取,Reader中默认返回false</p>
</li>
</ul>
<hr>
<h1 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h1><hr>
<p>　　基本输出流中，Writer与OutputStream方法也大致相同，只是Writer多了一种append类型方法。OutStream中子类必须实现的抽象方法是write(int),而Writer中子类必须实现的抽象方法有write(char[],int,int),close(),flush()。</p>
<blockquote>
<p><strong>Writer会有一个缓冲区存在，它的close()方法会先调用flush刷新缓冲区，然后再关闭流</strong></p>
</blockquote>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>![OutputStream](\images\java io\OutputStream.png)</p>
<p> 　　OutputStream是java IO所有字节输出流的超类,它实现了两个接口,Closeable和Flushable,其中Flushable接口的flush()方法是将缓冲区的数据直接刷入到输入流所要写入的对象,具体将在讲缓冲流的时候分析.下面我们看OutputStream的成员方法;</p>
<ul>
<li><p>public abstract void <strong>write(int b)</strong> throws IOException;<br>　　write(int)方法用来写入一个字节的数据,但方法里传入的是一个int类型数据,不过这里只会写入int类型数据第一个字节,后面三个字节将被抛弃,也就是写入低8位，忽略高24位</p>
</li>
<li><p>public void <strong>write(byte b[])</strong> throws IOException<br>　　write(byte[])方法是将一个数组的数据写入到字节输出流中</p>
</li>
<li><p>public void <strong>write(byte b[], int off, int len)</strong> throws IOException<br>　　和write(byte[])一样的用法,不同的是这里可以从数组指定索引处开始写入,并且可以设定要写入的字节长度,细节可以查看源码</p>
</li>
<li><p>public void <strong>flush()</strong> throws IOException {}<br>　　在使用缓冲流时,写入到流的数据并不会立即写入磁盘中,而是存在一个缓冲区,等到缓冲区满后才会执行实际写入,如果调用flush()方法,则立即执行将缓冲区数据写入到文件,flush()方法在OutputStream中方法体为空,需要子类重写去实现.　　</p>
</li>
<li><p>public void <strong>close()</strong> throws IOException {}　  　　　　　<br>　　close()方法用来读取结束后,关闭流,释放系统资源,OutputStream中此方法不执行任何操作，由子类来实现。</p>
</li>
</ul>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>![Writer](\images\java io\Writer.png)</p>
<p>Writer是java IO中所有字符输出流的超类,同Reader一样Writer有两个构造方法,可以使用自己或者传入的对象作为同步锁,以保证写入同步,,此外Writer还实现了一个Appenderable接口,可以追加写入字符。</p>
<ul>
<li><p>public void <strong>write(char cbuf[])</strong> throws IOException<br>　写入一个数组的字符</p>
</li>
<li><p>abstract public void <strong>write(char cbuf[], int off, int len)</strong> throws IOException; </p>
</li>
<li><p>public void <strong>write(String str)</strong> throws IOException {…}<br>  一次写入一个字符串</p>
</li>
<li><p>public void <strong>write(String str, int off, int len)</strong> throws IOException {…}<br>  一次写入一个字符串，并可以只写入字符串的一小片段，off,len指定该片段在字符串中的首尾位置。</p>
</li>
<li><p>public Writer <strong>append</strong>(char c) throws IOException {…}<br>  append方法同write(int)功能一样，但是返回流对象本身，可以连续调用，它内部是直接调用的write(int)方法。</p>
</li>
<li><p>public Writer <strong>append(CharSequence csq)</strong> throws IOException {}<br>  append方法同write(String)功能一样，但是返回流对象本身，可以连续调用，它内部是直接调用的write(String)方法。当CharSequence为null时，写入字符串null.</p>
</li>
<li><p>public Writer <strong>append(CharSequence csq, int start, int end)</strong> throws IOException {}<br>  append方法同write(String)功能一样，但是返回流对象本身，可以连续调用，它内部是直接调用的write(String)方法。当CharSequence为null时，写入字符串null.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java I/O框架（二）文件操作</title>
    <url>/2017/05/04/java-I-O%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>java io中最常操作的就是我们电脑中的文件,将这些文件以流的形式本地读写,或者上传到网络上.java中的File类就是对这些存储于磁盘上文件的虚拟映射,这也体现了java面向对象的思想,在学习io流对文件的读写前,我们要先学习下如何通过File何操作文件;</p>
  <span id="more"></span>

<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>　　File类直接继承自Object,并且实现了Serializable和Comparable两个接口,实现Sericalizable接口表示File对象可以序列化,对象的序列化在最后我们还会提到,而实现Comparable接口,表示File对象可以用来比较排序,File的源码中重写了Comparable接口的compareTo()方法,通过获取底层操作系统,来对File路径名按字母排序;</p>
<p>　　首先我们看如何实例化一个File对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　File提供了几个构造方法,大部分大同小异,上面是我们常用的一种,通过传入文件的路径名,来实例化File对象,不过需要注意的两点是</p>
<p>　　　　1. 这个路径名并不需要在磁盘中真正存在,构造方法也不会检查这一点<br>　　　　2. 文件路径名写法取决于你的操作系统,上面例子是在Windows系统中使用两个反斜线(\)转义字符来表示一个反斜线(),而在Unix系统中则是这样的”&#x2F;home&#x2F;myfile&#x2F;data&#x2F;a.txt”,不过经测试,单斜线这种分隔符在Windows中同样可以,大家可以自己试一下  </p>
<p>此外File还有以下几种构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent, String child)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent, String child)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(URI uri)</span></span><br></pre></td></tr></table></figure>

<h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><h2 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h2><ul>
<li>public boolean <strong>createNewFile</strong>()     创建新文件</li>
<li>public boolean <strong>mkdir</strong>()                创建单级目录</li>
<li>public boolean <strong>mkdirs</strong>()               创建多级目录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\a\\b&quot;</span>);</span><br><span class="line">       System.out.println(dir.mkdir());           <span class="comment">//false   mkdir()只能创建单级目录</span></span><br><span class="line"></span><br><span class="line">       System.out.println(dir.mkdirs());          <span class="comment">//true    mkdirs()用于创建多级目录</span></span><br><span class="line">       System.out.println(dir.mkdirs());          <span class="comment">//false    已经存在的目录再次创建,则返回false</span></span><br><span class="line"></span><br><span class="line">       File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\a\\b\\test.txt&quot;</span>);</span><br><span class="line">       System.out.println(file.createNewFile());   <span class="comment">//true    createNewFile()用于创建新文件,其上级路径必须存在,否则创建失败</span></span><br><span class="line">       System.out.println(file.createNewFile());   <span class="comment">//false   文件已存在则创建失败</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><ul>
<li>public boolean delete()        　　　　删除文件</li>
</ul>
<h2 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h2><ul>
<li>public boolean <strong>isDirectory</strong>()    判断是否为文件夹</li>
<li>public boolean <strong>isFile</strong>()       判断是否为文件</li>
<li>public boolean <strong>exists</strong>()       判断路径是否存在</li>
<li>public boolean <strong>canRead</strong>()      判断文件是否可读</li>
<li>public boolean <strong>canWrite</strong>()      判断文件是否可写</li>
<li>public boolean <strong>isHidden</strong>()      判断是否是隐藏文件</li>
</ul>
<h2 id="重命名功能"><a href="#重命名功能" class="headerlink" title="重命名功能"></a>重命名功能</h2><ul>
<li>public boolean <strong>renameTo</strong>(File dest)  重命名原文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileDeleteTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\a\\b\\test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">boolean</span> a= file.renameTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\renameTest.txt&quot;</span>));   </span><br><span class="line">　　　　 <span class="comment">//重命名文件的同时,还可以移动文件到新的位置</span></span><br><span class="line">　　　　 System.out.print(a);                                                                       </span><br><span class="line">　　　　 <span class="comment">//true  返回值表示重命名成功</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本获取功能"><a href="#基本获取功能" class="headerlink" title="基本获取功能"></a>基本获取功能</h2><ul>
<li>public String <strong>getAbsolutePath</strong>()  获取绝对路径</li>
<li>public String <strong>getPath</strong>()       获取全部路径</li>
<li>public String <strong>getName</strong>()       获取文件或目录名</li>
<li>public long <strong>length</strong>()         获取文件大小</li>
<li>public long <strong>lastModified</strong>()     获取上次修改的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileGetMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">       File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\a\\b\\test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(file.getAbsolutePath());　　　　　　 <span class="comment">//  &quot;C:\\Users\\Administrator\\Desktop\\a\\b\\test.txt&quot;</span></span><br><span class="line">       System.out.println(file.getName());　　　　　　　　　 　 <span class="comment">//   test.txt</span></span><br><span class="line">       System.out.println(file.getPath());　　　　　　　　　 　 <span class="comment">//  &quot;C:\\Users\\Administrator\\Desktop\\a\\b\\test.txt&quot;</span></span><br><span class="line">       System.out.println(file.length());　　　　　　　　　　 　<span class="comment">//   0</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(file.lastModified()));　　<span class="comment">//   Wed Mar 15 13:58:50 GMT+08:00 2017</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级获取功能"><a href="#高级获取功能" class="headerlink" title="高级获取功能"></a>高级获取功能</h2><ul>
<li>public String[] <strong>list</strong>()  获取该目录下所有文件和文件夹，返回他们文件名字符串数组</li>
<li>public File[] <strong>listFiles</strong>()  获取该目录下所有文件和文件夹，返回他们的文件File对象数组</li>
</ul>
]]></content>
      <categories>
        <category>java I/O框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java JDBC（一）概要</title>
    <url>/2017/06/30/java-JDBC%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<h1 id="JDBC-介绍"><a href="#JDBC-介绍" class="headerlink" title="JDBC 介绍"></a>JDBC 介绍</h1><p>JDBC API是一种可以访问任何类型表格数据，特别是存储在关系数据库中的数据的Java API。<br>JDBC帮你编写一个Java应用程序，用来管理以下三种编程活动。<br>1.	连接数据源比如一个数据库。<br>2.	向数据库发送查询和更新语句。<br>3.	接收并处理从数据库收到的作为对你查询回应的结果。</p>
<span id="more"></span>

<p>以下简单的代码片段给出了以上三个步骤的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectToAndQueryDatabase</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">                         <span class="string">&quot;jdbc:myDriver:myDatabase&quot;</span>,</span><br><span class="line">                         username,</span><br><span class="line">                         password);</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT a, b, c FROM Table1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码片段实例化一个DriverManager对象连接到数据库驱动并登录数据库，它实例化一个Statement对象，将SQL查询语句传递给数据库；实例化一个ResultSet对象，用来获取你的查询结果，并且执行一个简单的while循环，该循环获取并显示这些结果。</p>
<h2 id="JDBC产品组件"><a href="#JDBC产品组件" class="headerlink" title="JDBC产品组件"></a>JDBC产品组件</h2><p>JDBC包括四个组件：</p>
<ol>
<li><p><strong>The JDBC API</strong> —JDBC™API提供了从Java™编程语言到关系型数据的编程访问。使用JDBC API，应用程序可以执行SQL语句，获取结果，并将更改传播到底层数据源。JDBC API还可以在分布式异构环境中与多个数据源进行交互。 </p>
<p> JDBC API是Java平台的一部分，它包括Java™标准版（Java™SE）和Java™企业版（Java™EE）。JDBC 4.0 API分为两个包：java.sql和javax.sql。这两个包都包含在Java SE和Java EE平台中。</p>
</li>
<li><p><strong>JDBC Driver Manager</strong>  —JDBC <em>DriverManager</em>类定义可以将Java应用程序连接到JDBC驱动的对象。在传统上<em>DriverManager</em>已经是JDBC架构的骨干。它相当小而简单。    </p>
<p> 标准扩展包javax.naming 和javax.sql允许你用Java命名和目录接口（Java Naming and Directory Interface）™（JNDI）的命名服务注册一个DataSource对象，使用用它来建立与数据源的连接。也可以使用其他的连接机制，但建议尽可能使用DataSource对象。 </p>
</li>
<li><p><strong>JDBC Test Suite</strong> —  JDBC驱动测试套件可帮助您确定JDBC驱动将运行您的程序。这些测试并不全面和具体，但它们检测了许多JDBC API的重要功能。</p>
</li>
<li><p><strong>JDBC-ODBC Bridge</strong> —Java Software桥接器通过ODBC驱动程序提供JDBC访问。请注意，您需要将ODBC二进制代码加载到使用此驱动程序的每个客户端计算机上。因此，ODBC驱动程序最适合在一个公司网络，这样客户端安装不是主要问题，或者是在一个在三层架构中服务端代码是用Java编写的应用程序上。</p>
</li>
</ol>
<p>本教程使用这四个JDBC组件的前两个连接到数据库，然后构建一个使用SQL命令的java程序与测试用关系型数据库进行通信。最后两个组件用于专门的环境中以测试Web应用程序，或与ODBC-aware DBMS进行通信。</p>
<h2 id="JDBC架构"><a href="#JDBC架构" class="headerlink" title="JDBC架构"></a>JDBC架构</h2><p>JDBC API支持用来数据库访问的两层和三层处理模型。<br><img src="/images/javaweb/intro.anc2.gif" alt="数据访问两层模型"><br>在两层模型中，Java applet或应用程序直接与数据源进行通信。这需要一个能够与被访问的特定数据源通信的JDBC驱动。它将用户的命令传递给数据库或其他数据源，并将这些语句的结果发回给用户。数据源可能部署在其他的机器上，用户需要通过网络进行连接。这被称为客户端&#x2F;服务器配置，用户的机器是客户端，而托管数据源的机器是服务器。网络可以是内联网，例如在公司内部将员工连接起来，也可以是互联网。    </p>
<p>在三层模型中，命令被发送给服务的中间层，然后它再将命令发给数据源。数据源处理命令并且将结果发回中间层，然后中间层再将结果发给用户。在管理信息系统中三层模型非常有吸引力，因为中间层可以保持对访问的控制以及对企业数据可以进行的更新种类。另一个优点是它简化了应用程序的部署。最后，在许多情景下，三层架构可以提供更好的性能优势。<br><img src="/images/javaweb/intro.anc1.gif" alt="数据访问三层模型"><br>直到最近，中间层还经常用C或C ++等语言编写，这提供了更快的性能。然而，随着能将Java字节码转换为高效的机器特定代码的编译器的优化，以及一些技术比如Enterprise JavaBeans™的引进，Java平台正在迅速成为中间层开发的标准平台。这是一个很大的加分，使它可以利用Java的健壮性，多线程和安全功能。</p>
<p>随着使用Java编程语言来编写服务端代码的企业的增长，JDBC API正在三层架构的中间层中被越来越多地使用。JDBC的一些功能使它称为了一项服务器技术，如支持连接池，分布式事务以及disconnected rowsets。JDBC API同样也允许从Java中间层访问数据源。</p>
<h1 id="使用JDBC处理SQL语句"><a href="#使用JDBC处理SQL语句" class="headerlink" title="使用JDBC处理SQL语句"></a>使用JDBC处理SQL语句</h1><p>通常，要使用JDBC处理任何SQL语句，请按照下列步骤操作：<br>1.	建立连接。<br>2.	创建statement<br>3.	执行查询<br>4.	处理ResultSet对象<br>5.	关闭连接</p>
<p>这节使用下面的CoffeesTables.viewTable方法来演示这些步骤。此方法输出COFFEES表里的内容。在后面的章节中会讨论该方法更多细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewTable</span><span class="params">(Connection con, String dbName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select COF_NAME, SUP_ID, PRICE, &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;SALES, TOTAL &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;from &quot;</span> + dbName + <span class="string">&quot;.COFFEES&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;COF_NAME&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SUP_ID&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SALES&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;TOTAL&quot;</span>);</span><br><span class="line">            System.out.println(coffeeName + <span class="string">&quot;\t&quot;</span> + supplierID +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + price + <span class="string">&quot;\t&quot;</span> + sales +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>首先与你要使用的数据源建立一个连接。数据源可以是一个DBMS，一个传统的文件系统，或者其他具有相应JDBC驱动的数据源。连接由Connection对象表示。更多信息参阅之后的“建立连接”。</p>
<h2 id="创建Statement"><a href="#创建Statement" class="headerlink" title="创建Statement"></a>创建Statement</h2><p>Statement是一个代表一个SQL语句的接口。执行Statement对象，并生成ResultSet对象，ResultSet是一个表示数据库结果集的数据表。要创建Statament对象，你需要一个Connection对象。<br>比如，CoffeesTables.viewTable用以下代码创建了一个Statement对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stmt = con.createStatement();</span><br></pre></td></tr></table></figure>
<p>有以下三种形式的statement：</p>
<ul>
<li><strong>Statement</strong>：用来实现简单的不带参数的SQL语句</li>
<li><strong>PrepareStatement</strong>：（继承自Statement）用来预编译可能包含输入参数的SQL语句。更多信息参阅“使用预编译语句”。</li>
<li><strong>CallableStatement</strong>：（继承自PreparedStatement）用来执行可能同时包含输入输出参数的存储过程。更多信息参阅“存储过程”</li>
</ul>
<h2 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h2><p>要执行查询操作，调用Statement中的execute方法，如下所示</p>
<ul>
<li><strong>execute</strong>：如果查询返回的第一个对象是ResuleSet对象的话，则返回true。如果查询可能返回一个或多个ResultSet对象的话使用这个方法。可以通过反复调用Statement.getResultSet方法，获取查询返回的ResulteSet对象。</li>
<li><strong>executeQuery</strong>：返回一个Resultset对象。</li>
<li><strong>executeUpdate</strong>：返回一个表示受SQL语句影响行数的整数值。当执行INSERT,DELETE,或者UPDATE这些SQL语句时，使用该方法。<br>例如，CoffeesTables.viewTable使用以下代码执行Statement对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br></pre></td></tr></table></figure>
更多信息参阅“从ResulteSet中获取和修改值”</li>
</ul>
<h2 id="处理ResultSet对象"><a href="#处理ResultSet对象" class="headerlink" title="处理ResultSet对象"></a>处理ResultSet对象</h2><p>比如CoffeesTables.viewTable方法反复调用ResultSet.next来将游标向前移动一行。每次调用next，这个方法都输出一个游标目前所在行的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    stmt = con.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;COF_NAME&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SUP_ID&quot;</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SALES&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;TOTAL&quot;</span>);</span><br><span class="line">        System.out.println(coffeeName + <span class="string">&quot;\t&quot;</span> + supplierID +</span><br><span class="line">                           <span class="string">&quot;\t&quot;</span> + price + <span class="string">&quot;\t&quot;</span> + sales +</span><br><span class="line">                           <span class="string">&quot;\t&quot;</span> + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>更多信息参阅“从ResulteSet中获取和修改值”</p>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>当你结束使用Statement时，调用Statement.close方法来立即释放它使用的资源。当你调用这个方法时，它的ResultSet对象也被关闭。<br>比如，CoffeesTables.viewTable方法通过使用finally块包裹执行关闭的代码，来确保Statement对象在方法结束时被关闭，无论过程中是否有任何一个SQLException被抛出，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当与数据源交互遇到错误的时候，JDBC会抛出一个SQLException异常。更多信息参阅“处理SQL异常”<br>在Java SE 7或更高版本可用的JDBC4.1中，你可以使用try-with-resources语句来自动关闭Connection，Statement以及ResultSet对象，无论是否有SQLException抛出。自动关闭资源语句由一个try语句以及一个或多个声明的资源组成。比如，比可以修改CoffeesTables.viewTable方法使它的Statement对象可以自动关闭，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewTable</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select COF_NAME, SUP_ID, PRICE, &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;SALES, TOTAL &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;from COFFEES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;COF_NAME&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SUP_ID&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SALES&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;TOTAL&quot;</span>);</span><br><span class="line">            System.out.println(coffeeName + <span class="string">&quot;, &quot;</span> + supplierID +</span><br><span class="line">                               <span class="string">&quot;, &quot;</span> + price + <span class="string">&quot;, &quot;</span> + sales +</span><br><span class="line">                               <span class="string">&quot;, &quot;</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个try-with-resources语句，它声明了一个资源stmt，当try块终止时，它将自动关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>java xml（一）概览 </title>
    <url>/2017/06/14/java-xml%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>Java API for XML Processing (JAXP) 是使用以Java编程语言编写的应用程序处理XML数据。JAXP使用解析器标准Simple API for XML Parsing（SAX）和文档对象模型（DOM），以便你可以选择以事件流的或者构建表示对象的方式来解析数据。JAXP还支持可扩展样式表语言转换（XSLT）标准，使您能够控制数据的呈现，并使您能够将数据转换为其他XML文档或其他格式，例如HTML。JAXP还提供了命名空间支持，允许您使用可能具有命名冲突的DTD。最后，从版本1.4开始，JAXP实现了Streaming API for XML（StAX）标准。</p>
<span id="more"></span>
<p>为了设计上的最大灵活性，JAXP允许您在应用程序中使用任何兼容XML的解析器。这是通过被称作一种可插拔层来实现的，可以让您插入SAX或DOM API的实现。可插拔层还允许您插入XSL处理器，让您控制XML数据的显示方式。</p>
<h1 id="包概览"><a href="#包概览" class="headerlink" title="包概览"></a>包概览</h1><p>SAX和DOM API分别由XML-DEV组织和W3C定义。定义了这些API的库如下所示：</p>
<ul>
<li><p><strong>javax.xml.parsers</strong>: JAXP API，为不同厂商的SAX和DOM解析器提供了一个通用接口。</p>
</li>
<li><p><strong>org.w3c.dom</strong>: 定义Document类（一个DOM）以及DOM的所有组件的类。</p>
</li>
<li><p><strong>org.xml.sax</strong>: 定义基本的SAX API。</p>
</li>
<li><p><strong>javax.xml.transform</strong>: 定义可将XML转换为其他表单的XSLT API。</p>
</li>
<li><p><strong>javax.xml.stream</strong>: 提供StAX指定转换API。</p>
<p>Simple API for XML(SAX)是一个事件驱动，序列访问的机制，它以一个元素接一个元素的方式进行处理。该级别的API将XML读取并写入数据存储库或Web中。对于服务器端和高性能应用程序，您需要充分了解此级别。但是对于大多数应用来说，简单的理解就足够了。</p>
</li>
</ul>
<p>　　DOM API是一个更容易使用的API。它提供了一个熟悉的对象树结构。您可以使用DOM API来操纵其封装的应用程序对象的层次结构。DOM API是交互式应用程序的理想选择，因为整个对象模型都存在于内存中，这样用户可以访问和操作DOM对象。<br>　　另一方面，构建DOM需要读取整个XML结构并将对象树保存在内存中，因此它是CPU和内存密集型的。基于这个原因，SAX API倾向用于服务器端应用程序和数据过滤器，它不需要在内存中表示数据。<br>　　在javax.xml.transform中定义的XSLT API可以将XML数据写入文件或将其转换为其他形式。如本教程的XSLT部分所示，您甚至可以将其与SAX API结合使用，将旧数据转换为XML。<br>　　最后，javax.xml.stream中定义的StAX API提供了一个基于Java技术的流形式，事件驱动，pull式解析的API，用来读取和写入XML文档。StAX提供比SAX更简单的编程模型和比DOM更有效的内存管理。   </p>
<h1 id="Simple-API-for-XML-APIs"><a href="#Simple-API-for-XML-APIs" class="headerlink" title="Simple API for XML APIs"></a>Simple API for XML APIs</h1><p>AX解析API的基本概要如图1-1所示。要想启动处理，需要一个SAXParserFactory类的实例用于生成解析器的实例。<br>![jaxpintro-saxApi](&#x2F;images&#x2F;java base&#x2F;jaxpintro-saxApi.gif)</p>
<p>解析器包装一个SAXReader对象。当解析器的parse()方法被调用时，reader调用应用程序中实现的几个回调方法中的一个。这些回调方法由接口ContentHandler，ErrorHandler，DTDHandler和EntityResolver定义。</p>
<p>以下是SAX API的关键摘要：</p>
<ul>
<li><p><strong>SAXParserFactory</strong><br>SAXParserFactory对象创建解析器的实例，它是由系统属性javax.xml.parsers.SAXParserFactory决定的。 </p>
</li>
<li><p><strong>SAXParser</strong><br>SAXParser接口定义了几种parse()方法。 通常，需要传递给解析器一个XML数据源和一个DefaultHandler对象，用来处理XML并在handler对象中调用适当的方法。  </p>
</li>
<li><p><strong>SAXReader</strong><br>SAXParser包装一个了SAXReader。通常情况下，您并不需要关注这一点，但是当你需要获取它的时候，使用SAXParser的getXMLReader()，这样您可以对它进行配置。实际上是SAXReader负责与你定义的SAX事件handler进行对话。</p>
</li>
<li><p><strong>DefaultHandler</strong><br>图中未显示，DefaultHandler实现了ContentHandler，ErrorHandler，DTDHandler和EntityResolver接口（实现都是空方法），这样你可以只需要重写你需要的方法。</p>
</li>
<li><p><strong>ContentHandler</strong><br>当识别XML标签时，会调用诸如startDocument，endDocument，startElement和endElement之类的方法。该接口还定义了character()和processingInstruction()方法，当解析遇到XML元素中的文本或内联处理指令时会调用这两个方法。</p>
</li>
<li><p><strong>ErrorHandler</strong><br>当解析遇到各种错误时，会调用error()，fatalError(),和warning()方法。默认的错误handler会为发生的致命错误抛出异常，但是忽略其他错误（包括验证错误）。这是您需要了解有关SAX解析器的一个原因，即使您正在使用DOM。有时，应用程序可能能够从验证错误中恢复。其他时候，它可能需要产生一个异常。为了确保正确的处理，您需要将自己实现的错误处理handler提供给解析器。</p>
</li>
<li><p><strong>DTDHandler</strong><br>你通常不会被要求使用它定义的方法。这时用于处理DTD以识别和对未解析实体的声明采取行动。</p>
</li>
<li><p><strong>EntityResolver</strong><br>当解析器必须辨别由URI标识的数据时，会调用resolveEntity方法。在大多数情况下，URI只是一个URL，用于指定文档的位置，但在某些情况下，文档可能由网络空间中唯一的URN（公共标识符或名称）标识。除了URL之外，还可以指定公共标识符。然后，EntityResolver可以使用公共标识符而不是URL来查找文档，例如，如果文档存在，则访问文档的本地副本。</p>
</li>
</ul>
<p>一个典型的应用程序至少实现了大部分ContentHandler方法。因为这个接口的默认实现DefaultHandler会忽略除致命错误之外的所有输入，所以一个健壮的实现也可能需要实现ErrorHandler方法。</p>
<h2 id="SAX-包"><a href="#SAX-包" class="headerlink" title="SAX 包"></a>SAX 包</h2><p>SAX解析器在下表中列出的包中定义。</p>
<table>
<thead>
<tr>
<th>Packages</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>org.xml.sax</td>
<td>定义了SAX接口。org.xml是由定义了SAX API的组织确定的包前缀名称。</td>
</tr>
<tr>
<td>org.xml.sax.ext</td>
<td>定义用于执行更复杂的SAX处理的SAX扩展，例如处理文档类型定义（DTD）或查看文件的详细语法。</td>
</tr>
<tr>
<td>org.xml.sax.helpers</td>
<td>包含一些使其更容易使用SAX帮助类。比如，通过定义了一个实现所有接口并且都是空方法的默认handler，以便您只需要重写那些实际要实现的方法。</td>
</tr>
<tr>
<td>javax.xml.parsers</td>
<td>定义SAXParserFactory类，返回SAXParser。还定义了用于报告错误的异常类。</td>
</tr>
</tbody></table>
<h1 id="Document-Object-Model-APIs"><a href="#Document-Object-Model-APIs" class="headerlink" title="Document Object Model APIs"></a>Document Object Model APIs</h1><p>下图显示了的DOM API的工作机制。<br>![jaxpintro-domApi](&#x2F;images&#x2F;java base&#x2F;jaxpintro-domApi.gif)</p>
<p>您可以使用javax.xml.parsers.DocumentBuilderFactory类获取DocumentBuilder实例，并使用该实例来生成符合DOM规范的Document对象。事实上，您获得的builder由系统属性javax.xml.parsers.DocumentBuilderFactory决定，该属性选择用于生成builder的工厂类实现（java平台的默认值可以用命令行覆盖重写）。<br>您还可以使用DocumentBuilder newDocument（）方法来创建一个实现org.w3c.dom.Document接口的空Document 对象。或者，您可以使用其中一个builder的解析方法从现有XML数据创建一个Document对象。方法会返回一个如上图所示的DOM树。</p>
<blockquote>
<p>注意-虽然它们被称为对象，但DOM树中的实体实际上是相当低级的数据结构。例如，考虑这个结构：&lt;color&gt; blue &lt;&#x2F; color&gt;。这是一个color标签的元素节点，并且在它里面有一个包含数据blue的文本节点。这个问题将在本教程的DOM课程中详细探讨，但是开发人员期望返回的对象，会惊讶的发现当在元素节点上调用getNodeValue（）方法却不会返回任何内容。对于一个真正面向对象的树，请参阅<a href="http://www.jdom.org/">http://www.jdom.org</a> 上的JDOM API。</p>
</blockquote>
<h2 id="DOM包"><a href="#DOM包" class="headerlink" title="DOM包"></a>DOM包</h2><table>
<thead>
<tr>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>org.w3c.dom</td>
<td>定义W3C指定的XML（和可选的HTML）文档的DOM编程接口。</td>
</tr>
<tr>
<td>javax.xml.parsers</td>
<td>定义DocumentBuilderFactory类和DocumentBuilder类，它返回一个实现W3C Document接口的对象。用于创建builder的factroy由javax.xml.parsers系统属性决定，该属性可以在调用新的实例方法时从命令行设置或覆盖。此包还定义了用于报告错误的ParserConfigurationException类。</td>
</tr>
</tbody></table>
<h1 id="Extensible-Stylesheet-Language-Transformations-APIs"><a href="#Extensible-Stylesheet-Language-Transformations-APIs" class="headerlink" title="Extensible Stylesheet Language Transformations APIs"></a>Extensible Stylesheet Language Transformations APIs</h1><p>下图显示了XSLT API的操作<br>![jaxpintro-xsltApi](&#x2F;images&#x2F;java base&#x2F;jaxpintro-xsltApi.gif)</p>
<p>TransformerFactory对象被实例化并用于创建Transformer。Source对象是转换过程的输入。Source对象可以由SAX reader，DOM或从输入流创建。<br>类似地，Result对象是转换过程的结果。该对象可以是SAX事件处理程序，DOM或输出流。<br>当创建transformer时，可以从一组转换指令中来创建transformer，在这种情况下，执行指定的转换。如果不是由任何特定的指令来创建，那么transformer对象只是简单的把source复制到result中。</p>
<h2 id="XSLT包"><a href="#XSLT包" class="headerlink" title="XSLT包"></a>XSLT包</h2><table>
<thead>
<tr>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>javax.xml.transform</td>
<td>定义TransformerFactory和Transformer类，您可以使用它来获取能够进行转换的对象。创建transformer 对象后，调用其transform（）方法，并且为其提供一个输入（源）和一个输出（结果）。</td>
</tr>
<tr>
<td>javax.xml.transform.dom</td>
<td>从DOM创建输入（源）和输出（结果）对象的类。</td>
</tr>
<tr>
<td>javax.xml.transform.sax</td>
<td>从SAX解析器创建输入（源）对象并从SAX事件handler创建输出（结果）对象的类。</td>
</tr>
<tr>
<td>javax.xml.transform.stream</td>
<td>从I &#x2F; O流创建输入（源）对象和输出（结果）对象的类。</td>
</tr>
</tbody></table>
<h1 id="Streaming-API-for-XML-APIs"><a href="#Streaming-API-for-XML-APIs" class="headerlink" title="Streaming API for XML APIs"></a>Streaming API for XML APIs</h1><p>StAX是JAXP系列中最新的API，为希望能进行高性能流式过滤，处理和修改的开发人员提供一个SAX，DOM，TrAX和DOM的替代方案，特别是对于低内存和有限的可扩展性要求。<br>总之，StAX为流式XML处理提供了一个标准的双向pull式解析器接口，提供比SAX更简单的编程模型和比DOM更有效的内存管理。StAX使开发人员以事件形式解析和修改XML流，并扩展XML信息模型以允许特定于应用程序的添加。</p>
<h2 id="StAX-包"><a href="#StAX-包" class="headerlink" title="StAX 包"></a>StAX 包</h2><table>
<thead>
<tr>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>javax.xml.stream</td>
<td>定义XMLStreamReader接口，用于迭代XML文档的元素。 XMLStreamWriter接口指定如何写入XML。</td>
</tr>
<tr>
<td>javax.xml.transform.stax</td>
<td>提供特定于StAX的转换API。</td>
</tr>
</tbody></table>
<h2 id="API选择"><a href="#API选择" class="headerlink" title="API选择"></a>API选择</h2><p>针对以上各种解析模式，下面给出了一个选择何种解析方式的简单指导。</p>
<ul>
<li>如果数据结构已经确定，并且正在编写需要快速处理的服务器应用程序或XML过滤器，使用Simple API for XML.</li>
<li>如果您需要从XML数据构建一个对象树，以便您可以在应用程序中进行操作，或将内存中的对象树转换为XML，使用Document Object Model.</li>
<li>如果您需要将XML标签转换为其他形式，如果要生成XML输出，或者（与SAX API结合使用）想要将旧数据结构转换为XML，使用Extensible Stylesheet Language Transformations.</li>
<li>如果您想要一种基于Java技术的流形式的，基于事件驱动的pull式解析API来读取和写入XML文档，或者想要创建快速，相对易于编程和轻量级内存占用的双向XML解析器，使用Streaming API for XML.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>java xml（三）DOM</title>
    <url>/2017/06/14/java-xml%EF%BC%88%E4%B8%89%EF%BC%89DOM/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java xml（二）SAX</title>
    <url>/2017/06/14/java-xml%EF%BC%88%E4%BA%8C%EF%BC%89SAX/</url>
    <content><![CDATA[<p>SAX是“Simple API for XML“的缩写。它是一种事件驱动的序列访问流式解析XML的API。SAX常被需要传输和接收XML文档的servlet和面向网络的程序所使用，因为它是目前可用于处理XML文档的最快和最少的内存占用的机制。</p>
<span id="more"></span>
<p>　　SAX解析器是在XML文档遍历期间按一个实体接一个实体（元素，文本，注释等）进行处理。 当您使用SAX解析器时，需要将一个handler对象传递给SAX解析器。在遍历XML文档的过程中，handler对象对于你想处理的每个“事件”都有一个对应方法。并且SAX解析器主要适用于处理可以单独处理每个元素的XML文档，它的事件模型使其对于不依赖状态的过滤最有用。例如，当遇到元素标签时，SAX解析器调用应用程序中的一个方法，并在遇到文本时调用另一个不同的方法。如果你正在做的处理是与状态无关的（这意味着它不依赖于之前的元素），则SAX可以很好的工作。。 </p>
<blockquote>
<p>简而言之，SAX面向状态独立处理，其中处理元素不依赖于以前的元素。而StAX则是面向状态依赖的处理。</p>
</blockquote>
<p>　　建立一个使用SAX的程序比建立一个使用文档对象模型（DOM）的程序需要更多的工作。SAX是一个事件驱动模型（你提供回调方法，并且解析器在读取XML数据时调用它们），并且更加难以可视化。最后，您不能“备份”到文档的较早部分，或重新排列它，不能备份序列数据流或重新排列您从该流中读取的字符。<br>　　由于这个原因，一个开发人员如果编写一个面向用户的用来展示XML文档并且可能会修改文档的应用程序，可能会更倾向使用在Document Object Model.中描述的DOM机制。<br>但是，即使您打算专门构建DOM应用程序，有几个可以让您熟悉SAX模型的重要的原因：</p>
<ul>
<li><strong>Same Error Handling</strong>: SAX和DOM API生成相同种类的异常，因此错误处理代码几乎相同。</li>
<li><strong>Handling Validation Errors</strong>: 默认情况下，规范要求忽略验证错误。如果你想在验证错误的事件下抛出一个异常（你可能你会这么做），那么你需要了解SAX错误处理的工作原理。</li>
<li><strong>Converting Existing Data</strong>: 正如您将在Document Object Model中看到的，您可以使用一种将现有数据集转换为XML的机制，然而，利用该机制需要了解SAX模型。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>java xml（五）StAX</title>
    <url>/2017/06/14/java-xml%EF%BC%88%E4%BA%94%EF%BC%89StAX/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java xml（四）XSLT</title>
    <url>/2017/06/14/java-xml%EF%BC%88%E5%9B%9B%EF%BC%89XSLT/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java 反射（一）类</title>
    <url>/2017/05/09/java-%E5%8F%8D%E5%B0%84%EF%BC%88%E4%B8%80%EF%BC%89%E7%B1%BB/</url>
    <content><![CDATA[<p>每个对象不是一个引用类型是一个原始类型，引用类型全部继承自java.lang.Object.类，枚举，数组，和接口都是引用类型，还有一组固定的原始类型：boolean,byte,short,in,long,char,float,和double.引用类型的例子还包括java.lang.String,以及其他所有原始类型的包装器类，比如java.lang.Double等等。<br>对于每种类型的对象，JVM都会实例化一个java.lang.Class类型的不可变实例，也就是说所有类型包括原始类型都有一个相应的Class对象，它可以提供了一系列的方法来检查对象运行时期的属性，比如它的成员和类型信息。Class同样可以用来创建一个新的Class和对象.Class是所有java反射API的入口。</p>
<span id="more"></span>
<hr>
<h1 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h1><hr>
<p>对一个类执行反射操作的入口点是首先获得该类的java.lang.Class对象，Class对象的获取有三种方式，有的所有类型都使用，有的只能用于引用类型。</p>
<h2 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a>Object.getClass()</h2><p>如果我们拥有一个类的实例的话，获取Class最简单的方法就是调用该实例的getClass()方法，该方法是继承自所有引用类型的父类Object,所以该方式只适用于引用类型。如一下例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&quot;foo&quot;</span>.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> System.console().getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span> &#123; A, B &#125;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> A.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> bytes.getClass();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>
<h2 id="class语法"><a href="#class语法" class="headerlink" title=".class语法"></a>.class语法</h2><p>如果我们有一个可用类型，而没有它的实例的话，我们那可以在类型名后添加.class获取其Class对象，这种方式适用于原始类型，如例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> b;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> b.getClass();   <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="type">boolean</span>.class;  <span class="comment">// correct</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里boolean.getClass()将会产生一个编译时期异常，因为boolean是原始类型，不能够被引用。而.class语法则可以正确返回一个对应boolean类型的Class。</p>
</blockquote>
<p>对于引用类型同样适用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> java.io.PrintStream.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="type">int</span>[][][].class;</span><br></pre></td></tr></table></figure>

<h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h2><p>还可以通过类名来获取Class对象，这需要使用Class的静态方法forName(),这种方式不能用于原始类型，只能用于引用类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里类名必须使用完全限定类名，如果查找不到该类的话，会抛出ClassNotFoundException异常</p>
</blockquote>
<p>数组也是引用类型，因此也可以使用这种方式，但是数组类型完全限定名我们可能不知道，这里可以先通过其他方式获得数组的Class对象，再使用Class的getName()方法来查看其完全限定名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="type">int</span>[].class.getName());</span><br><span class="line">System.out.println(<span class="type">int</span>[][].class.getName());</span><br><span class="line">System.out.println(<span class="type">double</span>[][][].class.getName());</span><br><span class="line">System.out.println(String[][].class.getName());</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>[I<br>[[I<br>[[[D<br>[[Ljava.lang.String;  </p>
</blockquote>
<h2 id="原始类型Class另一种方式"><a href="#原始类型Class另一种方式" class="headerlink" title="原始类型Class另一种方式"></a>原始类型Class另一种方式</h2><p>上面方式中我们获取原始类型的Class对象，只能使用.class语法，此外我们还可以通过原始类型的包装类的TYPE字段来获取相应原始类型的Class.比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Double.TYPE</span><br></pre></td></tr></table></figure>
<p>这里Double.TYPE完全够等同于double.class。</p>
<blockquote>
<p>void同样可以通过其包装类Void.TYPE来获得它的Class对象。</p>
</blockquote>
<hr>
<h1 id="获取类信息"><a href="#获取类信息" class="headerlink" title="获取类信息"></a>获取类信息</h1><hr>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>获取类名的方式有三种<br>第一种使用***getName()***方法获取类的完整名称.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="type">int</span>.class.getName());</span><br><span class="line">System.out.println(<span class="type">boolean</span>[].class.getName());</span><br><span class="line">System.out.println(ArrayList.class.getName());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;&#125;.getClass().getName());</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>int<br>[Z<br>java.util.ArrayList<br>com.java.reflection.reflectionCase$3   </p>
</blockquote>
<p>第二种使用**getCanonicalName()**方法获取该类在Java语言规范里的名称，没有时返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="type">int</span>.class.getCanonicalName());</span><br><span class="line">System.out.println(<span class="type">boolean</span>[].class.getCanonicalName());</span><br><span class="line">System.out.println(ArrayList.class.getCanonicalName());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;&#125;.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>int<br>boolean[]<br>java.util.ArrayList<br>null </p>
</blockquote>
<p>第三种使用**getSimpleName()**方法只获取类名，不包含包名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="type">int</span>.class.getSimpleName());</span><br><span class="line">System.out.println(<span class="type">boolean</span>[].class.getSimpleName());</span><br><span class="line">System.out.println(ArrayList.class.getSimpleName());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;&#125;.getClass().getSimpleName());</span><br></pre></td></tr></table></figure>


<p>控制台输出</p>
<blockquote>
<p>int<br>boolean[]<br>ArrayList  </p>
</blockquote>
<h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>在获取类的完全限定名时就已经包含了包名，如果想要只获取包名的话，使用getPackage()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Package</span> <span class="variable">aPackage</span> <span class="operator">=</span> List.class.getPackage(); </span><br><span class="line">System.out.println(aPackage.getName());</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>java.util</p>
</blockquote>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>一个类可能声明了一个或多个影响其运行时的行为的修饰符。</p>
<ul>
<li>访问权限修饰符：public,protected,private</li>
<li>重写要求修饰符：abstract</li>
<li>单例限制修饰符：static</li>
<li>最终修饰符：final</li>
<li>精确浮点修饰符：strictfp</li>
<li>注解</li>
</ul>
<p>并不是所有的修饰符都可以用在任何类上，比如final无法修饰一个接口，abstract也无法用在枚举类上。Java.lang.reflect.Modifier包含了所有可能修饰符的声明，它还包含了一些可用于解码Class.getModifiers()返回的遗嘱修饰符的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> Set.class.getModifiers(); </span><br><span class="line">System.out.println(Modifier.toString(modifiers));</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>public abstract interface</p>
</blockquote>
<p>这里Set是一个接口，接口会有默认的修饰符，编译器会给每个接口自动添加public abstract。</p>
<h2 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h2><p>使用getSuperClass()方法，通过基类的Class对象，我们可以获取父类的Class对象。如果该类没有父类的话，则会返回null,比如Object或接口的Class对象调用getSuperClass.</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java中类是可以多实现的，所以一个类的接口可能有多个。使用getInterfaces()方法可以获取一个类的接口Class对象数组，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] interfaces = ArrayList.class.getInterfaces();</span><br><span class="line">       <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">           System.out.println(anInterface.getName());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>java.util.List<br>java.util.RandomAccess<br>java.lang.Cloneable<br>java.io.Serializable</p>
</blockquote>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>使用getAnnotations()方法获取类的所有注解，或者使用getAnnotations(Class)来获取一个指定的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Identity.class;</span><br><span class="line">Annotation[] annotations = c.getAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    System.out.println(annotation.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(c.getAnnotation(Deprecated.class));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>@java.lang.Deprecated()<br>@java.lang.Deprecated()</p>
</blockquote>
<p>需要注意的是并不是所有的注解都可以通过反射获得，只有该注解对象的标示为Retention(value&#x3D;RUNTIME)才可以，它表明该注解在运行时期可用。Java中有三个预设注解@Deprecated, @Override, and @SuppressWarnings 其中只有@Deprecated在运行时期是可用的。</p>
<h1 id="创建一个新的类实例"><a href="#创建一个新的类实例" class="headerlink" title="创建一个新的类实例"></a>创建一个新的类实例</h1><p>有两个可以利用反射创建新的类实例的方法，一个通过Class.newInstance()，一个Constructor.newInstance()，后面一个是构造器对象的方法，在后面类成员的学习里有。通常我们使用后者，他们之间有一下差异。</p>
<ul>
<li>Class.newInstance()只能调用无参构造，而Constructor.newInstance()可以调用任何一个构造器，无论是否有参数</li>
<li>Class.newInstance() 可能会抛出任何异常，无论此异常是否被检查，而 Constructor.newInstance()则会使用InvocationTargetException包装抛出的异常</li>
<li>Class.newInstance()需要构造器是可见的，而 Constructor.newInstance()在某种环境下可以调用私有构造器。</li>
</ul>
<p>下面看Class.newInstance()的实际例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;ArrayList&gt; c1 = ArrayList.class;</span><br><span class="line"> Class&lt;Math&gt; c2 = Math.class;</span><br><span class="line"></span><br><span class="line"> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> c1.newInstance();  <span class="comment">//success</span></span><br><span class="line"> <span class="type">Math</span> <span class="variable">math</span> <span class="operator">=</span> c2.newInstance();     <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>java.lang.Math是一个工具类，只有一个私有无参构造</p>
</blockquote>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>java 反射（三）动态代理</title>
    <url>/2017/05/12/java-%E5%8F%8D%E5%B0%84%EF%BC%88%E4%B8%89%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>一个动态代理类是一个在在运行时期被指定实现一系列接口的类，使得一个类实例上的接口方法被调用时，将会通过一个统一的接口来编码转发给另一个对象。因此一个动态代理类可以用来为一系列接口创建一个类型安全的代理对象，而不用需要预先生成代理字节码文件。一个动态代理类实例的方法调用会被转发给该类实例 invocation handler中的一个单独的方法，该方法也会被编码成java.lang.reflect.Method对象，来标识此方法被调用。</p>
<p>动态代理有很多用途，比如数据库连接，事务管理，单元测试的动态对象模拟，和其他的AOP类似的方法拦截等用途。</p>
<span id="more"></span>
<p>无论是代理类或者它们的实例对象，都是使用java.lang.reflect.Proxy的静态方法来创建的。</p>
<h1 id="动态代理API"><a href="#动态代理API" class="headerlink" title="动态代理API"></a>动态代理API</h1><ul>
<li><strong>动态代理类</strong>：简称代理类，它是一个在JVM运行时期创建并实现了一系列接口的类。</li>
<li><strong>代理接口</strong>：由代理类实现的接口</li>
<li><strong>代理实例</strong>：代理类的实例</li>
</ul>
<h1 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)<span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Proxy.getProxyClass方法通过传入一个类加载器和一个接口数组,返回一个代理的Class对象。这个代理类将会由指定的类加载器加载，并且实现所有我们提供的接口。如果在一个类加载器内，已经存在了实现同样接口的代理类，那我们再创建时，则会直接返回该已经存在的代理类。需要注意的是，这需要给定的接口顺序一致，一个类加载器内，实现了相同的接口，但是顺序不同的话，产生的代理类并不不是同一个。</p>
<p>此外，对传递给Proxy.getProxyClass的参数有几个限制：</p>
<ul>
<li>在interfaces数组中所有的Class对象都必须是代表接口，而不是类或者原始类型。</li>
<li>interfaces数组中的任意两个元素不能引用相同的Class对象。</li>
<li>所有接口类型必须通过指定的类加载器的按照它们的名称可见。换句话说，对于类加载器cl和每个接口i，以下表达式必须为true：<br>  Class.forName(i.getName(), false, cl) &#x3D;&#x3D; i</li>
<li>所有的非公开接口必须在同一个包中，否则代理类将不可能实现所有的接口，无论它定义在哪个包中。</li>
<li>对于具有相同签名的指定接口的任何成员方法：   <ul>
<li>如果任何方法的返回类型是原始类型或void，那么所有方法必须具有相同的返回类型。</li>
<li>否则，其中一个方法必须具有可以分配给其余方法的所有返回值类型的返回值类型（是其他返回类型的基类）。</li>
</ul>
</li>
<li>生成的代理类不能超过虚拟机对类施加的任何限制。例如，VM可以将类可以实现的接口数量限制为65535;在这种情况下，interfaces数组的大小不能超过65535。</li>
</ul>
<p>如果以上任何一种限制被违反了，Proxy.getProxyClass都会抛出一个IllegalArgumentException异常。如果interfaces数组参数或它的任何元素为null的话，则抛出NullPointerException。</p>
<p>请注意，指定的代理接口的顺序是重要的：对于创建具有两个相同组合的接口但以不同顺序的代理类的请求将导致两个不同的代理类。代理类通过其代理接口的顺序来区分，以便在两个或多个代理接口共享具有相同名称和参数签名的方法的情况下提供确定性方法调用编码;</p>
<p>所以每次使用相同的类加载器和接口列表调用Proxy.getProxyClass时，不需要生成新的代理类，动态代理类API的实现应该保留生成的代理类的缓存，缓存中以它们对应的类加载器和接口列表为键。实现时应当小心引用类加载器，接口和代理类，在这种情况下它会阻止类加载器及其所有类在适当时被垃圾回收。</p>
<h2 id="代理类属性"><a href="#代理类属性" class="headerlink" title="代理类属性"></a>代理类属性</h2><ul>
<li>代理类都是以public final修饰，而不是abstract</li>
<li>代理类名称以“$Proxy”开头</li>
<li>代理类都是继承自java.lang.reflect.Proxy</li>
<li>代理类按顺序实现了所有接口</li>
<li>如果一个代理类实现了一个非公开接口，那么代理类会被定义在和该接口一个包中。否则的话代理类的包是未指定的。</li>
<li>因为一个代理类创建时实现了所有指定的接口，所以调用getInterfaces方法时会返回该接口数组，并且顺序和创建时给定的接口数组一致。</li>
<li>Proxy.isProxyClass方法当传入一个代理类时，将会返回true,无论这个代理类是Proxy.getProxyClass创建还是Proxy.newProxyInstance创建的。</li>
</ul>
<h1 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h1><p>每一个代理类都有一个公开构造器，该构造器只有一个参数，是InvocationHandle接口的实现类。<br>与其通过反射API来获取代理类的公开构造器去创建一个代理类实例，我们同样可以通过Proxy.newProxyInstance方法来新建一个代理实例。</p>
<h2 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance()"></a>Proxy.newProxyInstance()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure>

<p>newProxyInstance方法会创建一个代理类，并通过传入的InvocationHandle来实例化该类，它有三个参数</p>
<ul>
<li>ClassLoader loader  指定了加载代理对象的类加载器</li>
<li>Class&lt;?&gt;[] interfaces 表示代理对象要实现的一系列接口</li>
<li>InvocationHandler h  代理对象的所有方法调用都会被转发到InvocationHandle中</li>
</ul>
<h2 id="InvocationHandle"><a href="#InvocationHandle" class="headerlink" title="InvocationHandle"></a>InvocationHandle</h2><p>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个invocation handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>方法有三个参数</p>
<ul>
<li>Object proxy 指动态生成的代理对象,由Proxy.newProxyInstance()方法生成代理对象传入，不需要我们指定</li>
<li>Method 指我们要调用的真实对象方法的Mehthod对象</li>
<li>Object[] 调用方法的参数，<strong>这里原始类型数据(int ,boolean…)会被包装为其对应的包装类(Integer,Boolean…)</strong></li>
</ul>
<p>invoke方法返回值会成为代理对象调用真实方法的返回值，如果接口方法声明的返回值是原始类型，那么这个返回值通过invoke调用后，必须是该原始类型包装类的实例对象。<strong>如果接口中方法定义返回值为原始类型，而invoke返回null,则会抛出NullPointerException异常</strong>。如果接口中定义方法返回指与invoke返回指类型不兼容，则会抛出ClassCastException 异常。</p>
<p>对于一个代理对象实例，如果我们想要获取和它关联的invocation handle,可以使用Proxy.getInvocationHandle(Object proxy)方法。该方法如果传入对象不是代理对象，则会抛出IllegalArgumentException异常。</p>
<h2 id="代理实例"><a href="#代理实例" class="headerlink" title="代理实例"></a>代理实例</h2><p>先定义一个接口UserIn</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserIn</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然会定义一个实现了该接口的类User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserIn</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User say hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是定义一个动态代理类，该类实现了InvocationHandle接口，定义了我们要实际执行的代理操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;   <span class="comment">//构造方法传入我们要代理的真实对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****before User say*****&quot;</span>); <span class="comment">//这里在我们调用真实对象方法前，附加一些操作</span></span><br><span class="line">        method.invoke(obj,args);               <span class="comment">//调用真实对象obj的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****after User say*****&quot;</span>);  <span class="comment">//这里在我们调用真实对象方法后，附加一些操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">//因为要代理的只有一个方法，其没有返回值，这里直接返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面创建代理对象，并调用它的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入一个User对象作为真实对象给动态代理类</span></span><br><span class="line">      <span class="type">DynamicProxy</span> <span class="variable">dynamicProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用动态代理类的类加载器来加载代理对象</span></span><br><span class="line">      <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> dynamicProxy.getClass().getClassLoader();</span><br><span class="line">      <span class="comment">//使用真实对象实现的接口,这样代理对象就与真实对象“相同”类型，并且可以调用同样的方法</span></span><br><span class="line">      Class[] classes = &#123;UserIn.class&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里就是使用以上参数直接生成代理对象，因为我们给定接口类型为UserIn,所以这里可以直接强制转换类型</span></span><br><span class="line">      <span class="type">UserIn</span> <span class="variable">user</span> <span class="operator">=</span> (UserIn) Proxy.newProxyInstance(cl, classes, dynamicProxy);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//因为生成代理对象时，实现的是UserIn接口，所以可以调用其方法</span></span><br><span class="line">      user.say();            </span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Proxy Object Type: &quot;</span> + user.getClass().getName());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行程序后，控制台输出</p>
<blockquote>
<p>*****before User say*****<br>User say hello<br>*****after User say*****<br>-——————————-<br>Proxy Object Type: com.sun.proxy.$Proxy0</p>
</blockquote>
<p>从输出可以看出，调用代理对象的方法后，其方法实际执行会转发到动态代理类DynamicProxy中的invoke方法中。此外我们输出的代理对象类型为com.sun.proxy.$Proxy0，而不是我们是使用的UserIn接口，这是因为代理对象是由JVM在运行时动态生成的，由JVM动态生成的代理对象名称都以$Proxy开头，后加上该代理对象的标号。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>java.lang.reflect.Proxy实现了序列化接口，所以所有的代理实例都可以被序列化。如果一个代理实例包含的invocation handler没有实现序列化接口的话，将该实例写入java.io.ObjectOutputStream时会抛出NotSerializableException异常</p>
<p>。。。。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html">java的动态代理机制详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>java 反射（二）类成员</title>
    <url>/2017/05/11/java-%E5%8F%8D%E5%B0%84%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<p>在Java反射的包中定义一个接口java.lang.reflect.Member，它有三个实现类java.lang.reflect.Field, java.lang.reflect.Method, and java.lang.reflect.Constructor.同时这三个类的成员对象直接或间接还都继承了AccessibleObject,当类成员是私有的时候，如果我们使用反射来对这些类成员进行修改或调用，需要使用AccessibleObject的setAccessible()方法来绕过默认的Java访问权限检测，来实现对私有成员的使用。</p>
<blockquote>
<p>根据Java语言规范，类成员是可继承的类组件，包括字段，方法，以及嵌套的类，接口，枚举类型。因为构造器是不可继承的，所以它不是类成员，这与java.lang.reflect.Member.的实现类是有些差别的。</p>
</blockquote>
<p>在Class中提供获取类成员的方式有两种，一种获取不同数量类成员，一种根据类成员性质，根据类成员数量的是要么我们获取所有成员列表，要么根据给定参数获取指定的类成员。而根据类成员性质的，则是一种获取类所有公共成员，包括从父类继承而来的，一种则是获取类内声明所有成员，不包含从父类继承，但是包含私有成员。</p>
<span id="more"></span>

<hr>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><hr>
<h2 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h2><table>
<thead>
<tr>
<th>Class API</th>
<th>列举成员</th>
<th>继承成员</th>
<th>私有成员</th>
</tr>
</thead>
<tbody><tr>
<td>getDeclaredField()</td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>getField()</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>getFields()</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
</tbody></table>
<p>我们既可以列举类中所有字段，也可以根据已知的名称来获取一个特定的字段，如果该名称字段不存在的话，会抛出NoSuchFieldException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldSpy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String s;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[][] b;</span><br><span class="line">    <span class="keyword">public</span> ArrayList arrayList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">fieldSpy</span> <span class="operator">=</span> FieldSpy.class;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------公共字段列表---------------&quot;</span>);</span><br><span class="line">        Field[] fields = fieldSpy.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.toGenericString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------私有字段i---------------&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field3</span> <span class="operator">=</span> fieldSpy.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        System.out.println(field3.toGenericString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出  </p>
<blockquote>
<p>———公共字段列表—————<br>public java.lang.String com.java.reflection.FieldSpy.s<br>public boolean[][] com.java.reflection.FieldSpy.b<br>public java.util.ArrayList com.java.reflection.FieldSpy.arrayList<br>———私有字段i—————<br>private int com.java.reflection.FieldSpy.i  </p>
</blockquote>
<h2 id="获取设置Field值"><a href="#获取设置Field值" class="headerlink" title="获取设置Field值"></a>获取设置Field值</h2><p>获取Filed对象后，我们可以使用它的get(Object obj)和set(Object obj,Object value)来获取和设置一个申明该字段的对象的字段值，需要注意的是如果该字段为类私有，我们要先通过setAccessible()方法来设置访问权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i.setAccessible(<span class="literal">true</span>);</span><br><span class="line">       <span class="type">FieldSpy</span> <span class="variable">fieldSpyInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FieldSpy</span>();</span><br><span class="line"></span><br><span class="line">       System.out.println(i.get(fieldSpyInstance));</span><br><span class="line">       i.set(fieldSpyInstance,<span class="number">25</span>);</span><br><span class="line">       System.out.println(i.get(fieldSpyInstance));</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>0<br>25</p>
</blockquote>
<hr>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><hr>
<h2 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h2><table>
<thead>
<tr>
<th>Class API</th>
<th>列举成员</th>
<th>继承成员</th>
<th>私有成员</th>
</tr>
</thead>
<tbody><tr>
<td>getDeclaredMethod()</td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>getMethod()</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>getMethods()</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
</tbody></table>
<p>我们既可以获取类的成员方法列表，也可以根据已知的方法名和参数来获取指定的方法Method对象。当获取指定的方法时，如getMethod(String name, Class&lt;?&gt;… parameterTypes)我们需要传入两种参数，第一种是方法名，第二种该方法需要的参数，如果该方法的参数是泛型类型的，我们需要传入的是Object.class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Reader.class;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;---------方法声明列表---------------&quot;</span>);</span><br><span class="line">     Method[] methods = c.getDeclaredMethods();</span><br><span class="line">     <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         System.out.println(method.toGenericString());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;---------公共方法read---------------&quot;</span>);</span><br><span class="line">     <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">     System.out.println(method.toGenericString());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>———方法声明列表—————<br>public boolean java.io.Reader.ready() throws java.io.IOException<br>public int java.io.Reader.read() throws java.io.IOException<br>public abstract int java.io.Reader.read(char[],int,int) throws java.io.IOException<br>public int java.io.Reader.read(char[]) throws java.io.IOException<br>public int java.io.Reader.read(java.nio.CharBuffer) throws java.io.IOException<br>public abstract void java.io.Reader.close() throws java.io.IOException<br>public void java.io.Reader.mark(int) throws java.io.IOException<br>public boolean java.io.Reader.markSupported()<br>public void java.io.Reader.reset() throws java.io.IOException<br>public long java.io.Reader.skip(long) throws java.io.IOException<br>———公共方法read—————<br>public int java.io.Reader.read() throws java.io.IOException  </p>
</blockquote>
<h2 id="调用Method"><a href="#调用Method" class="headerlink" title="调用Method"></a>调用Method</h2><p>获取Method对象后，使用它的invoke(Object obj,Object… args)来调用该方法，invoke需要传入一个声明该方法的对象，否则则会抛出IllegalArgumentException异常，后面是一个可变参数，传入该方法所需的实际参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;toUpperCase&quot;</span>);</span><br><span class="line">System.out.println(toUpperCase.invoke(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>HELLO</p>
</blockquote>
<p>这里需要注意的是，当方法是私有方法时，同样需要先设置Method对象访问权限。</p>
<hr>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><hr>
<h2 id="获取Constructor-1"><a href="#获取Constructor-1" class="headerlink" title="获取Constructor"></a>获取Constructor</h2><p>|Class API|列举成员|私有成员|<br>|———|——–|——–|——–|<br>|getDeclaredConstructor()|X|O|<br>|getConstructor()|X|X|<br>|getDeclaredConstructors()|O|O|<br>|getConstructors()|O|X|</p>
<blockquote>
<p>构造器是无法继承的</p>
</blockquote>
<p>以获取公开构造器为例，我们既可以列举类中所有构造器，也可以根据构造器的参数来获取特定的一个构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> ArrayList.class;</span><br><span class="line"></span><br><span class="line">   Constructor&lt;?&gt;[] constructors = c.getConstructors();</span><br><span class="line">   System.out.println(<span class="string">&quot;---------构造方法列表---------------&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">       System.out.println(constructor.toGenericString());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">&quot;----------有参构造（int）--------------&quot;</span>);</span><br><span class="line">   <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">   System.out.printf(constructor.toGenericString());</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>———构造方法列表—————<br>public java.util.ArrayList(java.util.Collection&lt;? extends E&gt;)<br>public java.util.ArrayList()<br>public java.util.ArrayList(int)<br>———-有参构造（int）————–<br>public java.util.ArrayList(int)  </p>
</blockquote>
<h2 id="利用Constructor初始化对象"><a href="#利用Constructor初始化对象" class="headerlink" title="利用Constructor初始化对象"></a>利用Constructor初始化对象</h2><p>我可以通过Constructor对象的newInstance(Object… initargs)来新建一个对象，它接收一个可变参数.需要注意的是Constructor是采用泛型机制的，如果我们没有指定Constructor的泛型参数，初始化一个对象的时候需要进行强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> ArrayList.class;</span><br><span class="line"></span><br><span class="line"> Constructor&lt;ArrayList&gt; constructor = c.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span>  constructor.newInstance(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常（一）概述</title>
    <url>/2017/05/27/java-%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>当一个方法发生错误时，该方法将创建一个对象，并且将其移交给运行系统。该对象就被称为异常（exception）对象，它包含有关错误的相关信息，比如错误类型以及错误发生时程序的状态。而这个异常对象的创建和移交就被称为抛出异常。</p>
<p>在方法抛出异常后，运行时期系统将会尝试寻找处理它的方法。处理异常的方式是获取调用发生错误的方法的有序方法列表，这个方法列表被称为调用栈（call stack）。<br>![call stack](&#x2F;images&#x2F;java base&#x2F;call stack.gif)</p>
<span id="more"></span>
<p>运行时系统在调用栈中搜索一个包含可以处理异常的代码块的方法。这个代码块被称为异常处理程序（exception handler）。这个搜索从最初发生错误的方法开始，然后以方法被调用相反的顺序搜索调用栈。当找到适当的处理程序时，运行时期系统将异常传递给处理程序。如果抛出的异常对象的类型与处理程序可以处理的类型匹配，则异常处理程序被认为是适当的。</p>
<p>所选择的异常处理程序被称为捕获（catch）异常。如果运行时系统彻底搜索调用堆栈上的所有方法，而不会找到适当的异常处理程序，如下图所示，运行时系统（以及因此程序）终止。<br>![catch exception](&#x2F;images&#x2F;java base&#x2F;catch exception.gif)</p>
<h1 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h1><p>在方法发生错误时，有效的Java编程语言代码必须符合Catch或规范要求。这意味着可能会抛出某些异常的代码必须由以下两种方式进行处理</p>
<ul>
<li>使用try-catch语句捕获异常。try语句必须为捕获的异常提供一个异常处理。</li>
<li>使用throws抛出异常，将其传播到调用栈上进行处理。</li>
</ul>
<p>并不是所有的异常都需要Catch或规范要求的限制。有三种基本异常类别， 只有其中一种需要以上处理。</p>
<h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p>第一种异常是检查型异常（checked exception）。一个编写良好的程序应当能预期并捕获这些异常，并且提醒用户可能出现的错误。</p>
<p>检查型异常是唯一需要进行Catch或指定处理的异常。除了由Error，RuntimeException及其子类指示的异常外，所有异常都是检查型。</p>
<p>第二种异常是错误异常（Error）,它们产生异常条件来自程序外部，并且通常不能预期和恢复。为了通知用户该问题，应用程序可以选择来捕获这个异常，但是打印栈跟踪并退出程序可能更有意义的。</p>
<p>错误异常不受Catch或规范要求的约束。错误异常是由Error及其子类指定的异常。</p>
<p>第三种异常是运行时期异常（RuntimeException ）。它们产生异常条件是由程序内部造成的，并且应用程序通常不能预期和恢复。比如最常见的空指针异常（NullPointException）就是一个运行时期异常。这些异常通常表示程序编写错误，例如逻辑错误或API的不当使用。尽管Java能够捕获这些异常，但是消除导致异常的bug才是更有意义的。</p>
<p>运行时期异常也不受制于Catch或规范要求。运行时期异常是由RuntimeException及其子类指示的。</p>
<p>错误和运行时异常被统称为非检查型异常（unchecked exception）。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常（三）异常处理</title>
    <url>/2017/05/28/java-%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%89%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>捕获异常有三个组件——try,catch和finally代码块。在Java SE 7后新引进了try-with-resources语句。try-with-resources语句特别适用于使用可关闭资源（如流）的情况。</p>
<h2 id="try代码块"><a href="#try代码块" class="headerlink" title="try代码块"></a>try代码块</h2><p>构造异常处理程序的第一步是使用try代码块将可能抛出异常的代码括起来。通常try代码块看起来如下面一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>用code标记的部分包含一行或多行可能抛出异常的合法代码。如果try块中发生异常，该异常由与其关联的异常处理程序处理。要将异常处理程序与try块相关联，您必须在其后面加上一个catch代码块;</p>
<h2 id="catch代码块"><a href="#catch代码块" class="headerlink" title="catch代码块"></a>catch代码块</h2><p>通过在try代码块之后直接提供一个或多个catch代码块，将异常处理程序与try块相关联。try代码块的末尾和第一个catch代码块的开始之间没有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType name) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType name) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个catch块都是一个异常处理程序，用于处理其参数标示的异常类型。这个类型参数ExceptionType声明了处理程序可以处理的异常类型，并且它必须是继承自Throwable。</p>
<p>catch块包含在异常处理程序被调用时和执行时执行的代码。当调用栈抛出一个异常时，系统会匹配与该异常相符的ExceptionType的catch代码块,然后执行其内的代码，用来打印错误、停止程序，或者其他更多操作，比如进行错误恢复，提示用户做出决定，或者使用链接异常将错误传播到更高级别的处理程序。</p>
<p>在Java 7以及之后版本，单个catch块可以处理多种类型的异常，在catch后小括号中，可以指定多个处理的异常类型，并使用垂直条（|）分隔每个异常类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ExceptionType | ExceptionType ex) &#123;</span><br><span class="line"> 	code</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果一个catch块处理多个异常类型，那么catch参数是隐式的final。在这个例子中，catch参数ex是final，因此你不能在catch块内给它赋值。</strong></p>
</blockquote>
<h2 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h2><p>finally代码块总是在try代码块退出时执行。这确保即使发生意外异常也会执行finally。但是finally不仅是用来做异常处理，它还允许程序员由于意外的绕过了return,continue或break时做代码清除工作。将清理代码放在finally块中始终是一个很好的做法，甚至即使没有预期到异常。</p>
<p><strong>需要注意的是finally块中代码总会执行，如果在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</strong></p>
<blockquote>
<p>如果在执行try或catch代码时JVM退出，那么finally块可能不会执行。同样，如果执行try或catch代码的线程被中断或者被杀死，即使应用程序整体上继续，finally块也可能不会执行。</p>
</blockquote>
<p>在使用I&#x2F;O流时，应当确保最终的流的关闭。使用finally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="literal">null</span>)&#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>finally块是防止资源泄漏的关键工具。关闭文件或以其他方式恢复资源时，请将代码放在finally块中，以确保资源最终能够被释放。但是这种情况应当考虑使用try-with-resources语句，在不再需要时会自动释放系统资源。</p>
<h2 id="try-with-resource语句"><a href="#try-with-resource语句" class="headerlink" title="try-with-resource语句"></a>try-with-resource语句</h2><p>try-with-resources语句是在一个try语句中声明一个或多个资源。一个资源是程序完成后必须关闭的对象。try-with-resources语句确保每个资源在语句结尾处被关闭。实现java.lang.AutoCloseable的任何对象（包括实现java.io.Closeable的所有对象）都可以被看作一个资源使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">readFirstLineFromFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此示例中，在try-with-resources语句中声明的资源是BufferedReader。BufferedReader在Java 7之后实现了java.lang.AutoCloseable接口由于它被声明在try-with-resource语句中，所以不管try语句是正常结束还是突然结束（由于方法BufferedReader.readLine抛出IOException），它都会被调用资源的close()方法来关闭，如果资源close()方法抛出异常的话，需要在try-with-resources语句后进行捕获，或者在方法上抛出。</p>
<p>try-with-resources语句也可以包含多个资源声明，它们之间使用分号分割。并且在语句结束时，都会调用它们的close方法来关闭资源。需要注意的是，资源的close方法是与资源创建的相反顺序进行调用的。</p>
<p>一个try-with-resources语句同样可以有一个catch代码块和finally代码块，就如普通的try语句一样。在一个try-with-resources语句中，**<font color=tomato >任何catch或finally块都在关闭资源声明之后运行</font>**。比如下面使用try-with-resources语句自动关闭java.sql.Statement对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewTable</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()) &#123;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;COF_NAME&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SUP_ID&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SALES&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;TOTAL&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(coffeeName + <span class="string">&quot;, &quot;</span> + supplierID + <span class="string">&quot;, &quot;</span> + </span><br><span class="line">                               price + <span class="string">&quot;, &quot;</span> + sales + <span class="string">&quot;, &quot;</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><p>在异常的处理上，有时我们不需要在方法产生异常的地方进行处理，而是进一步在调用栈上来处理该异常。这时候不必再使用try catch代码块来捕获异常，而是在方法体上使用throws抛出可能出现的异常，由调用该方法的部分来进行异常处理。这种异常处理方法写法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throws抛出的异常可以是一个或多个，多个异常时使用逗号来分割开。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常（二）抛出异常</title>
    <url>/2017/05/28/java-%E5%BC%82%E5%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>在我们处理一个异常前，一定是在代码某个部分抛出了一个异常。任何代码都可以引发异常：你的代码，来自其他人（例如Java平台附带的软件包）或Java运行时环境的程序包编写的代码。无论要抛出什么异常，都要使用throw语句。</p>
<h1 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h1><p>所有方法都使用throw语句抛出异常。 throw语句需要一个单个参数：一个可抛出的对象（a throwable object）。可抛出对象是任何一个Throwable类的子类的实例。throw语句写法如下。</p>
<blockquote>
<p><strong>throw</strong> someThrowableObject</p>
</blockquote>
<p>在使用throw语句抛出异常后，程序会在抛出语句后立即终止，它后面的语句将会执行不到。如果抛出异常是检查型对象的话，任何调用该方法的方法都必须对此抛出的异常进行处理，要么使用catch进行捕获，要么使用throws进一步将此异常在调用栈上传播。</p>
<h1 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h1><p>Java平台提供了许多异常类。所有类都是Throwable类的后代，并且所有类都允许程序区分在程序执行期间可能发生的各种异常的类型。从Throwable类继承的对象包括直接子类（从Throwable类直接继承的对象）和间接子类（继承自Throwable类的子级或子级的对象）。下图说明了Throwable类及其最重要子类的类层次结构。如你所见，Throwable有两个直接后代：Error和Exception。<br>![Throwable](&#x2F;images&#x2F;java base&#x2F;Throwable.gif)</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>当Java虚拟机中发生动态链接故障或其他硬故障时，虚拟机会抛出Error。简单的程序通常不会捕获或抛出Error。</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>大多数程序抛出并捕获从Exception类派生的对象。Exception表示程序发生了问题，但不是严重的系统问题。你编写的大多数程序都会抛出并捕获Exception而不是Error。</p>
<p>Java平台定义了Exception类的许多子类。这些子类表示可能发生的各种类型的异常。Exception子类有两种，一种直接继承实现Excetion，一种实现Exception的子类RuntimeException.</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常（五）异常层次结构</title>
    <url>/2017/05/29/java-%E5%BC%82%E5%B8%B8%EF%BC%88%E4%BA%94%EF%BC%89%E5%BC%82%E5%B8%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>在java中异常可以以分层结构组织，我们可以通过使一个（或多个）异常扩展另一个异常来创建层次结构。这样第一个异常成为第二个异常的子类。在前面也展示过Java中所有的异常都是Exception的子类，异常层次结构的优点是，如果您决定在层次结构中捕获（使用try-catch）某个异常，那么您还将自动捕获该异常的所有子类。比如下面示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;c://example.txt&quot;</span>);</span><br><span class="line">          input.read();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p>上面代码中，有两处会抛出异常的地方</p>
<ul>
<li>input &#x3D; new FileInputStream(“c:&#x2F;&#x2F;example.txt”);<br>此处会抛出FileNotFoundException</li>
<li>input.read();<br>此处会抛出IOException</li>
</ul>
<p>由于IOException是FileNotFoundException的父类，所以代码中使用IOException就可以这两个可能的异常。</p>
<h2 id="多catch捕获"><a href="#多catch捕获" class="headerlink" title="多catch捕获"></a>多catch捕获</h2><p>在一个try块后可能跟随多个catch代码块，这种形式用在try块中的代码抛出了多种类型的异常。当这些异常存在继承关系时，同样适用多个catch捕获的形式，但是这时需要注意catch的顺序，父类异常必须放在子类异常之后，否则子类异常将无法被对应catcht块捕获，比如上面示例要想用多个catch捕获</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;c://example.txt&quot;</span>);</span><br><span class="line">           input.read();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果我们想要使用Java 7之后的，一个catch捕获多个异常机制，其异常参数不能存在父子关系。</p>
<h2 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h2><p>同样，当我们在方法声明上抛出一个异常，任何该异常的子类也能够被抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，如果方法中有FileNotFoundException异常的话，由于它是IOException的子类，同样可以被正常抛出。当使用throws抛出多个异常，异常之间存在继承关系时，父类应当在子类的后面，否则声明抛出子类是没有意义的，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里FileNotFoundException放在IOException的后面，是没有意义的话，因为如果抛出FileNotFoundException的话，它已经会被声明的IOException捕获抛出了。如果调换顺序，则两个抛出声明都有实际作用，FileNotFoundException或被抛出自己以及子类异常，IOException则会抛出自己已经所有除了FileNotFoundException的子类异常。</p>
<p>在设计应用程序API时，应当为该API创建一个基础Exception，这样使用这一个基础Exception就可以处理API中所有类型的异常。当处理异常需要更细的颗粒度时，例如异常应当有不同的处理方式，这是就可以通过拓展基础Exception来添加新的异常类。这样通过层级的形式来构建异常结构，可以方便进行异常的管理与处理。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常（四）异常抑制</title>
    <url>/2017/05/29/java-%E5%BC%82%E5%B8%B8%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BC%82%E5%B8%B8%E6%8A%91%E5%88%B6/</url>
    <content><![CDATA[<p>在我们使用一些I&#x2F;O类的时候，我们必须保证在I&#x2F;O操作结束后，关闭流来释放资源，看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.read();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="literal">null</span>)&#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p>这里在new FileInputStream(“file.txt”),input.read()和input.close()处都可能会抛出异常，我们知道无论是否从try块抛出异常，finally块中代码总会执行，这样我们假设在try块中代码出现异常，在抛出异常前执行finally块中代码，如果此时input.close()同样出现了异常，那么最终会抛出哪个异常呢？看下面实验代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.doSomething();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            resource.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Resource is doing something&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们自定义了一个类Resource来模拟一个I&#x2F;O类，它的两个方法都会抛出异常，doSomething()中会抛出IOException，close()方法中将抛出IndexOutOfBoundsException，它是一个非检查型异常，在运行程序后，控制台输出</p>
<blockquote>
<p>Resource is doing something<br>Exception in thread “main” java.lang.IndexOutOfBoundsException</p>
</blockquote>
<p>可以发现finally块内的异常最终被抛出，而try块中的异常被抑制了，这样会带来一个问题，对于I&#x2F;O类实际使用中，我们需要处理产生异常的原因在try块中，而抛出的却是finally块中的，这会对我们程序问题分析检查带来误导，为了解决这个问题，应当使用tyr-with-resource。上面代码我们修改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>()) &#123;</span><br><span class="line">    resource.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Resource类实现了AutoCloseable接口，所以可以声明在try-with-resource语句中，Resource对象的close方法会无论什么情况，最后会被系统自动调用来，此时运行程序，控制台输出</p>
<blockquote>
<p>Resource is doing something<br>Exception in thread “main” java.io.IOException</p>
</blockquote>
<p>可以发现try-with-resource语句与try…finally相反，它的close方法抛出异常被抑制，抛出的是代码块内异常，这是try-with-resource的异常处理机制，它只会抛出在代码块内的异常，try()语句中的异常将被抑制，但是被抑制的异常并没有被丢弃，在Java 7后java.lang.Throwable类中新加入两个方法，是我们可以添加或获取抑制异常</p>
<ul>
<li>public final void <strong>addSuppressed</strong>(Throwable exception)</li>
<li>public final Throwable[] <strong>getSuppressed</strong>()</li>
</ul>
<p>这里需要注意的是，这两个方法需要在异常的构造方法中开启才能使用</p>
<ul>
<li>protected Throwable(String message,Throwable cause,boolean enableSuppression,boolean writableStackTrace)</li>
</ul>
<p>try-with-resource语句中会开启使用这两个方法，并且在try()抛出的异常自动调用addSuppressed()方法将其加入到被抑制异常的数组中,为了获取被抑制的异常，我们将try()中抛出的异常使用catch捕获，而不是在方法体上抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>()) &#123;</span><br><span class="line">    resource.doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    Throwable[] suppressed = e.getSuppressed();</span><br><span class="line">    <span class="keyword">for</span> (Throwable throwable : suppressed) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行程序，控制台将会输出</p>
<blockquote>
<p>Resource is doing something<br>java.io.IOException<br>　　…<br>java.lang.IndexOutOfBoundsException<br>　　…  </p>
</blockquote>
<p>这样就获取到了被抑制的异常信息。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（一）概览</title>
    <url>/2017/05/24/java-%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="控制流程概述"><a href="#控制流程概述" class="headerlink" title="控制流程概述"></a>控制流程概述</h1><p>应用程序在Logger对象上进行日志记录调用。Logger以分层式命名空间组织并且自Logger可能会在命名空间中的父Logger继承一些日志记录属性.</p>
<p>Logger会分配LogRecord，将其传递给Handler进行发布。Logger和Handler都有一个日志级别Level和(可选的)Filter来决定是否接收特定的LogRecord。当有必要发布一个LogRecord到外部时，一个Handler可以（可选地）在将其发布到一个I&#x2F;O流之前，使用Formatter来本地化和格式化该消息。<br>![logging flow](&#x2F;images&#x2F;java base&#x2F;logging1.gif)</p>
<span id="more"></span>
<p>每个Logger跟踪一组输出Handlers。默认情况下，所有的Logger会发送它们的消息输出到它们的父级的Handlers中。但是也可以设置关闭这一向父级的消息输出。</p>
<p>一些Handler可能会将日志消息输出到其他的Handler上。比如MemoryHandler维持一个存储LogRecord的内部循环缓冲，并且当一个指定事件被触发时，它就会通过一个目标Handler来发布它的缓冲区上的LogRecords。在这种情况下，格式化工作由最后一个Handler来进行处理。<br>![MemoryHandler](&#x2F;images&#x2F;java base&#x2F;logging2.gif)<br>这样的API结构可以使当日志被禁用时，能够轻易的来调用Logger API。如果对于一个给定的被禁用的级别日志记录，则Logger可以进行轻易的进行比较测试并返回。如果启用一个日志级别记录，在将LogRecord传递到处理程序之前，Logger仍然会小心的降低成本开销。特别是，本地化和格式化（它们相对开销更大）被推迟到直到Handler请求处理它们时。比如MemoryHandler能够维持LogRecord的循环缓冲区，而不必执行格式化工作。</p>
<h1 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h1><p>每条日志信息都有一个关联的日志Level。Level对日志消息的重要性和紧迫性进行了大概的描述。日志Level对象封装了一个整数值，更高的值表示了更高的优先度。</p>
<p>Level类定义了七个标准日志级别，范围从FINEST(最低的优先度，最低的整数值)到SEVERE（最高的有限度，最高的值）</p>
<p>Logger可以设置一个最小的日志级别，它决定是否将消息转发到处理程序。这不是通过Filter来进行过滤的，即使它具有相同的效果。这样，可以抑制低于一定级别的所有消息。</p>
<h1 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h1><p>像前面所说的，客户端代码要发送日志请求到Logger对象中。每个Logger跟踪其感兴趣的日志级别，并抛弃低于此级别的日志请求。</p>
<p>Logger一般以实体命名，使用点分隔的名称，如“java.awt”。命名空间是分层式的并且由LogManager来管理。命名空间通常应该基于java类的包名（java.net）或者子系统的类名(javax.swing)，但不需要严格遵守。例如，名为“java.awt”的Logger可能会处理java.awt包中的类的记录请求，但它也可能会处理sun.awt中的类的日志记录，该类支持java.awt包中定义的客户端可见抽象。</p>
<p>除了命名为Logger外，也可能创建一个不在共享命名空间中的匿名Logger，可以看章节1.14。</p>
<p>Logger在日志命名空间中保持追踪他们父logger。logger的父级是日志记录命名空间中最近的上级，比如创建一个logger名为“java.net.Logger”，另一个logger名为“java.net”,则后者logger是前者的父级。根Logger(名为“”)没有父级。匿名logger都将根logger作为他们的父级。logger可能从他们的父级继承多种属性在日志命名空间内。特别的，一个logger可能继承一下属性</p>
<ul>
<li>日志级别。如果一个Logger的级别被设置为null,那么这个Logger会使用从遍历父级树并且使用第一个非null的Level作为其有效Level。</li>
<li>Handler。默认情况下，Logger会将任何输出消息记录到其父级的handler中，如此在在树状上递归传递。</li>
<li>资源束名称（Resource bundle names）。如果记录器具有空资源束名称，那么它将继承任何为其父级定义的资源束名称，以及递归上传树。</li>
</ul>
<h1 id="日志方法"><a href="#日志方法" class="headerlink" title="日志方法"></a>日志方法</h1><p>Logger类为生成日志消息提供了一大堆方便的方法。为方便起见，每个日志记录级别都有以日志记录级别名称命名的方法。因此相比调用“logger.log(Level.WARNING)”一个开发者可能会简单的调用更便易的方法“logger.warning(..)”</p>
<p>有两种不同风格的日志记录方法，以满足不同社区的用户需求。</p>
<p>第一种，这些方法接收一个明确的调用日志记录所在类名和方法名。这种方法适用于希望能够快速找到任何给定日志记录消息源的开发人员。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">warning</span><span class="params">(String sourceClass, String sourceMethod, String msg)</span>;</span><br></pre></td></tr></table></figure>
<p>第二种，这类方法不接受明确的调用日志记录所在类名和方法名。这些适用于希望易于使用的日志记录并且不需要详细的源信息的开发人员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">warning</span><span class="params">(String msg)</span>;</span><br></pre></td></tr></table></figure>

<p>对于第二种方法，日志框架将作出最大努力来确定调用到日志框架中的类和方法，并将此信息添加到LogRecord中。但是需要意识到这个自动推断信息可能只是近似的。因为最新一代的Java虚拟机在JITing时会进行广泛的优化，并且可能会完全删除堆栈帧，从而无法肯靠地定位调用类和方法。</p>
<h1 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h1><p>Java SE提供一下几种Handlers:</p>
<ul>
<li>StreamHandler:一个用于将格式化记录信息写入到OutputStream的简单的handler;</li>
<li>ConsoleHandler:一个用于将格式化记录信息写入到System.err的简单的handler;</li>
<li>FileHandler:一个用于将格式化日志记录信息写入到单个文件，或者一系列日志记录文件的handler。</li>
<li>SocketHanler:一个用于将格式化日志记录信息写入到远程的TCP端口的handler.</li>
<li>MemoryHandler:一个缓存日志记录信息到内存的handler。</li>
</ul>
<p>开发一个新的Handler是相当直接的。需要特定功能的开发者可以从头开发一个Handler，也可以从继承自以上提供的Handler的子类进行开发。</p>
<h1 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h1><p>Java SE 同样包括两种标准的Formatter。</p>
<ul>
<li>SimpleFormatter:写出简洁易读的日志记录摘要。</li>
<li>XMLFormatter:写详细的XML结构化信息。</li>
</ul>
<p>与Handlers一样，开发新的Formatter是相当直接的。</p>
<h1 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h1><p>有一个全局LogManager对象跟踪全局日志记录信息。这包括：</p>
<ul>
<li>管理Logger对象的分层命名空间,所有命名的Loggers都存储在这个命名空间中。</li>
<li>管理一系列的日志控制属性。控制属性从配置类或配置文件读取，属性都是简单的键值对，用来配置Handler和其他Logger对象。</li>
</ul>
<p>可以使用静态LogManager.getLogManager方法获取一个单例的LogManager对象。这是在LogManager初始化期间根据系统属性创建的。此属性允许容器应用程序（如EJB容器）用自己的LogManager子类代替默认类。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>可以通过使用一个在启动时读取的日志配置文件来初始化日志配置。此日志记录配置文件采用标准的java.util.Properties格式。</p>
<p>或者，可以通过指定可用于读取初始化属性的类来初始化日志记录配置。这种机制允许可以从任意资源比如配置数据的LDAP，JDBC等等读取配置数据。详细的请看 LogManager API Specification。</p>
<p>有一小组全局配置信息。这在LogManager类的描述中指定，并包括在启动期间安装的根级别Handler的列表。</p>
<p>初始配置可以指定特定Logger的日志级别。这些日志级别应用于指定名称的Logger以及该命名层级之下的所有Logger。这些日志级别按照它们在配置文件中定义的顺序应用。</p>
<p>初始配置可能包含任意属性，供Handler或子系统进行日志记录使用。按照惯例，这些属性应该使用以Handler类名或子系统的主Logger的名称开头的名称。</p>
<p>比如，MemoryHandler使用一个属性“java.util.logging.MemoryHandler.size”来决定它的循环缓冲区的大小。</p>
<h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><p>JRE附带的默认日志记录配置只是默认的，可以被ISV，系统管理员和最终用户覆盖。<br>默认配置只是限制使用的磁盘空间。它不会向用户灌输信息，而是确保始终捕获关键故障信息。<br>默认配置在根Logger上只建立一个单独的handler，用于将日志输出发送到控制台。</p>
<h1 id="动态配置更新"><a href="#动态配置更新" class="headerlink" title="动态配置更新"></a>动态配置更新</h1><p>程序员可以通过多种方式在运行时更新日志记录配置：</p>
<ul>
<li>FileHandlers，MemoryHandler和PrintHandler都可以使用各种属性创建。</li>
<li>可以添加新的Handlers ，并删除旧Handlers 。</li>
<li>可以创建新的Loggers ，并可以提供特定的Handlers。</li>
<li>可以在目标Handler上设置Level.</li>
</ul>
<h1 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h1><p>日志中没有本地API.<br>希望使用Java Logging机制的本地代码应该使Java Logging API正常进行JNI调用。</p>
<h1 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h1><p>XMLFormatter使用的XML DTD在附录A中指定。<br>DTD设计有一个“&lt;log&gt;”元素作为顶级文档。然后每个日志记录写作“&lt;record&gt;”元素的形式。<br>请注意，在JVM崩溃的情况下，可能无法使用适当的关闭&lt;&#x2F; log&gt;清理终止XMLFormatter流。因此，分析日志记录的工具应该准备好应对未终止的流。</p>
<h1 id="唯一信息ID"><a href="#唯一信息ID" class="headerlink" title="唯一信息ID"></a>唯一信息ID</h1><p>Java日志API不提供任何对唯一信息ID的直接支持。那些需要唯一消息ID的应用程序或子系统应该定义自己的惯例，并在消息字符串中适当地写入唯一的ID。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>主要的安全性要求是不受信任的代码不能更改日志记录的配置。具体来说，如果日志配置已设置为将特定类别的信息记录到特定的Handler中，则不受信任的代码不应该能够阻止或中断该日志记录。</p>
<p>新的安全权限LoggingPermission被定义用来控制日志配置的更新。</p>
<p>受信任的应用程序将提供适当的LoggingPermission，以便它们可以调用任何日志记录配置API。不信任的程序就是另一回事了。不受信任的小应用程序可以以常规方式创建和使用命名logger，但不允许更改日志记录控制设置，例如添加或删除处理程序或更改日志级别。但是，不信任的applet可以使用Logger.getAnonymousLogger来创建和使用自己的“匿名”记录器。这些匿名记录器未在全局命名空间中注册，并且它们的方法不进行访问检查，甚至允许不可信代码更改其日志控制设置。</p>
<p>日志框架不会阻止欺骗。日志记录调用的源头不能被可靠地确定，因此当发布声明来自特定源类和源方法的LogRecord时，它可能是伪造的。类似地，诸如XMLFormatter之类的格式化程序不会尝试保护自身免受消息字符串内的嵌套日志消息的影响。因此，欺骗性LogRecord可能在其消息字符串中包含一组恶意的XML，以使其看起来像输出中有一个额外的XML记录。</p>
<p>此外，日志框架不会尝试保护自身免遭拒绝服务攻击。任何给定的日志客户端都可以使用无意义的消息来淹没日志框架，以试图隐藏一些重要的日志消息。</p>
<h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><p>API使得初始配置信息被一属性的形式从一个配置文件中读取。这些配置信息可以通过调用各种日志类和对象来被编程式修改。</p>
<p>另外，LogManager上还有一些可以重新读取配置文件的方法。发生这种情况时，配置文件的属性值将覆盖已经以编程方式进行的任何更改。</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>所有的日志记录类都在java.util.logging包中的java.*部分命名空间中。</p>
<h1 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h1><p>日志消息可能需要本地化<br>每个Logger可能具有与其关联的资源包名称。相应的资源包可用于在原始消息字符串和本地化消息字符串之间映射。</p>
<p>通常，本地化将由Formatters执行。为了方便起见，formatter类提供了一种formatMessage方法，它提供了一些基本的本地化和格式化支持。</p>
<h1 id="远程访问和序列化"><a href="#远程访问和序列化" class="headerlink" title="远程访问和序列化"></a>远程访问和序列化</h1><p>与大多数Java平台API一样，日志API旨在在单个地址空间内使用。所有的调用都是本地的。但是预计一些Handler希望将输出转发到其他的系统。这里有各种方式来实现这一点。<br>一些Handler(比如SocketHandler)可能会使用XMLFormatter来将数据写入到其他系统。这提供了可以在各种系统上解析和处理的简单，标准的互换格式。<br>一些Handler可能希望通过RMI传递LogRecord对象。因此LogRecord类是可序列化的。但是，这有一个问题是如何处理LogRecord参数。一些参数可能不是可序列化的，并且其他参数可能被设计为序列化比日志记录要求更多的状态。为了避免这个问题,LogRecord类有一个自定义的wirteObject方法，在将它们写入之前将参数转换为字符串（使用Object.toString（））。<br>大多数日志记录类不是没有必要序列化的。<br>Loggers 和Handlers 都是绑定到特定虚拟机中的状态类。在这方面，它们类似于java.io类，它们也不是可序列化的。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（三）Level和Filter</title>
    <url>/2017/05/26/java-%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%89%EF%BC%89Level%E5%92%8CFilter/</url>
    <content><![CDATA[<p>Level和Filter都可以控制一个LogRecord是否被转发。对于Logger和Handler都拥有一个Level,但是Filter是可选的，可以设置也可以不设置。</p>
<h1 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h1><p>Level中有七个日志级别，预设在Level的常量中，从低到高排列为</p>
<ul>
<li><strong>FINEST</strong> (lowest value)</li>
<li><strong>FINER</strong></li>
<li><strong>FINE</strong></li>
<li><strong>CONFIG</strong></li>
<li><strong>INFO</strong></li>
<li><strong>WARNING</strong></li>
<li><strong>SEVERE</strong> (highest value)</li>
</ul>
<span id="more"></span>

<p>除了这七个日志级别外还有两个常量<strong>OFF</strong>和<strong>ALL</strong>,OFF用来关闭日志记录，不接受任何日志消息，而ALL则是接收任何日志信息。当Logger和Handler没有设置Level的时候，其默认的日志级别为Level.INFO，任何低于该级别的消息都不会被转发和记录。</p>
<p>当LogRecord在Logger的分级命名空间上传播时，先看该消息是否符合记录它的Logger的日志等级，如果符合的话，还会被传播至其父级Logger上，此时会再次验证其是否符合父级设置的日志等级，如此在命名空间树上一级级传播，直到被某一级所拒绝。</p>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>可以选择性的给Logger和Handler设置一个Filter，用来过滤所要记录的日志消息。Filter在java.util.logging包中是一个函数式接口，下面是它的类声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(LogRecord record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isLoggalble()方法接收一个传递来需要验证LogRecord参数，该方法由我们自己实现一定的逻辑验证然后返回一个boolean类型参数，决定该LogRecord是否被发布。</p>
<p>需要注意的是Filter只会过滤一个Logger直接调用日志记录方法传递来的信息，也就是当一个Logger记录的日志信息向父级传播时，父级不会调用Filter来过滤消息。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（二）Logger</title>
    <url>/2017/05/24/java-%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%8C%EF%BC%89Logger/</url>
    <content><![CDATA[<p>下图是Java Logging API的工作图<br>![Logging Overview](&#x2F;images&#x2F;java base&#x2F;Logging Overview.png)<br>所有的日志记录都是通过Logger实例来完成。Logger收集要记录的日志数据到一个LogRcord对象中。然后LogRecord被转发到一个Handler。Handler决定如何来处理LogRecord。比如将LogRecord写入到硬盘，或者通过网络发送到监控系统。</p>
<p>Logger和Handler都可以通过一个Filter来传递LogRecord。而Filter是来决定LogRecord是否应该被转发。</p>
<p>一个Handler还可以在LogRecord被发送到外部硬盘或系统前，使用Formatter将其格式化为一个字符串。</p>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Java Logging API的最常使用方式是在每个我们需要记录日志的类里创建一个Logger对象。该Logger实例通常我们会用static和final修饰，这意味着所有这个类的实例都使用同一个Logger实例。<br>Logger类并没有公开构造器，我们要想创建一个Logger对象，需要使用它的两个静态方法</p>
<ul>
<li>getLogger(String name)</li>
<li>getLogger(String name, String resourceBundleName)</li>
</ul>
<p>前面我们知道Logger使用分级式以点分割的命名空间，通常基于所在类的包名，下面是一个示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingExamples</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span></span><br><span class="line">        Logger.getLogger(LoggingExamples.class.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="日志记录方法"><a href="#日志记录方法" class="headerlink" title="日志记录方法"></a>日志记录方法</h1><p>Logger记录日志信息的方法有很多，主要的有下面这些</p>
<h2 id="log-方法"><a href="#log-方法" class="headerlink" title="log()方法"></a>log()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log  (Level level, String message);  </span><br><span class="line">log  (Level level, String message, Object param1);  </span><br><span class="line">log  (Level level, String message, Object[] params);  </span><br><span class="line"></span><br><span class="line">log  (Level level, String message, Throwable t);  </span><br><span class="line"></span><br><span class="line">log  (LogRecord record);</span><br></pre></td></tr></table></figure>

<p>log()方法会在一定日志级别上记录日志信息。log()方法会接收一个Level类型参数作为日志级别，一般都是使用Level中的常量，Level预定义了其中日志级别常数。</p>
<p>一些log()方法会接收一个Object类型参数，在日志被记录前，这个Object类型参数会被插入到日志消息指定的位置中。但是这种合并需要该日志消息没有被Filter过滤掉，或者没有因为日志等级太低没有被记录。这种机制可以提高系统性能。</p>
<p>下面是log(Level level,String message)方法的示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(LoggingCase.class.getName());</span><br><span class="line">logger.log(Level.SEVERE,<span class="string">&quot;logMessage&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>控制台输出（没有设置Handler时会使用父级默认的ConsoleHandler）</p>
<blockquote>
<p>五月 25, 2017 7:19:36 下午 &gt;com.java.logging.LoggingCase doIt<br>严重: logMessage  </p>
</blockquote>
<p>然后是log(Level level, String message, Object param1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.log(Level.SEVERE,<span class="string">&quot;logMessage &#123;0&#125;&quot;</span>,<span class="string">&quot;Object param&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>五月 25, 2017 7:28:33 下午 com.java.logging.LoggingCase main<br>严重: logMessage :Object param   </p>
</blockquote>
<p>这里会将Object参数插入到消息字符串中，消息字符串要使用{0}形式指定其位置，如果要使用Object[]参数，则使用{0}，{1}…分别指定每一个元素</p>
<p>还有一种log(Level level, String message, Throwable t)方法形式，这种适合做异常日志记录，放在try-catch代码块总，捕获异常时，输出到日志;<br>比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    logger.log(Level.SEVERE,<span class="string">&quot;math error&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>五月 25, 2017 7:37:57 下午 com.java.logging.LoggingCase main<br>严重: math error<br>java.lang.ArithmeticException: &#x2F; by zero<br>    at com.java.logging.LoggingCase.main(LoggingCase.java:22)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>    at java.lang.reflect.Method.invoke(Method.java:497)<br>    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)   </p>
</blockquote>
<h2 id="logp-methods"><a href="#logp-methods" class="headerlink" title="logp() methods"></a>logp() methods</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logp (Level level, String sourceClass, String sourceMethod, String msg);  </span><br><span class="line">logp (Level level, String sourceClass, String sourceMethod, String msg,Object param1);</span><br><span class="line">logp (Level level, String sourceClass, String sourceMethod, String msg,Object[] params);  </span><br><span class="line">logp (Level level, String sourceClass, String sourceMethod, String msg,Throwable t); </span><br></pre></td></tr></table></figure>
<p>logp()方法同log()方法类似，出来每个方法都会多接收两个参数sourceClass和sourceMethod参数。</p>
<p>这两个参数用来标识日志记录调用所在的类和方法名。</p>
<h2 id="logrb-methods"><a href="#logrb-methods" class="headerlink" title="logrb() methods"></a>logrb() methods</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logrb(Level level, String sourceClass, String sourceMethod,String bundle, String msg);   </span><br><span class="line">logrb(Level level, String sourceClass, String sourceMethod,String bundle, String msg, Object param1);   </span><br><span class="line">logrb(Level level, String sourceClass, String sourceMethod,String bundle, String msg, Object[] params);   </span><br><span class="line">logrb(Level level, String sourceClass, String sourceMethod,String bundle, String msg, Throwable t); </span><br><span class="line"></span><br><span class="line">logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Object... params)</span><br><span class="line">logrb(Level level, String sourceClass, String sourceMethod, ResourceBundle bundle, String msg, Throwable thrown)</span><br><span class="line">logrb(Level level, ResourceBundle bundle, String msg, Object... params)</span><br><span class="line">logrb(Level level, ResourceBundle bundle, String msg, Throwable thrown)</span><br></pre></td></tr></table></figure>

<p>logrb()方法和logp()方法也类似，但是一种多了一个String bundle参数，一种多了一个ResourceBundle bundle参数。Sting bundle参数表示一个资源束（resource bundle）所在的位置，资源束是一组包含很多键值对的文本文件，就像property属性文件一样，每个这样的文本文件都包含相同的键，但是它对应的值，在不同的文件使用了不同的语言,因此资源束是用来做国际化功能的，但这种使用文本文件形式方法已经被弃用，在Java 8后新添了ResourceBundle类，由一个ResourceBundle来代表一个资源束文件。多数日志输出方法都会有一个“msg”参数，在对消息字符串格式化的时候，如果Logger有一个关联的ResourceBundle对象，并且在ResourceBundle中有和“msg”相匹配的信息，那么该msg字符串就会被ResourceBundle本地化的字符串取代，否则的话还是使用msg。</p>
<p><strong>String bundle</strong><br>当使用带有String bundle参数形式的logrb方法时，假如我们有一个资源束文件resources.myresources,其内容是</p>
<blockquote>
<p>key1 : This is message 1<br>key2 : this is message 2  </p>
</blockquote>
<p>然后使用日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.logrb(Level.SEVERE, <span class="string">&quot;logging.LoggingExamples&quot;</span>, <span class="string">&quot;main&quot;</span>,<span class="string">&quot;resources.myresources&quot;</span>,<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>控制台会输出</p>
<blockquote>
<p>五月 26, 2017 12:21:13 下午 logging.LoggingExamples main<br>严重: This is message 1  </p>
</blockquote>
<p><strong>ResourceBundle bundle</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(LoggingCase.class.getName());</span><br><span class="line"></span><br><span class="line">        logger.logrb(Level.SEVERE, <span class="string">&quot;logging.LoggingExamples&quot;</span>, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyResourceBundle</span>(), <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyResourceBundle</span> <span class="keyword">extends</span> <span class="title class_">ListResourceBundle</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object[][] getContents() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[][]&#123;&#123;<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;This is message 1&quot;</span>&#125;,&#123;<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;This is message 2&quot;</span>&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时控制台同样输出</p>
<blockquote>
<p>五月 26, 2017 12:30:01 下午 logging.LoggingExamples main<br>严重: This is message 1  </p>
</blockquote>
<h2 id="convenience-methods"><a href="#convenience-methods" class="headerlink" title="convenience methods"></a>convenience methods</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">entering(String sourceClass, String sourceMethod);  </span><br><span class="line">entering(String sourceClass, String sourceMethod, Object param1);  </span><br><span class="line">entering(String sourceClass, String sourceMethod, Object[] params);  </span><br><span class="line"></span><br><span class="line">exiting (String sourceClass, String sourceMethod);  </span><br><span class="line">exiting (String sourceClass, String sourceMethod, Object result);  </span><br><span class="line"></span><br><span class="line">fine   (String message);  </span><br><span class="line">finer   (String message);  </span><br><span class="line">finest  (String message);  </span><br><span class="line"></span><br><span class="line">config  (String message);  </span><br><span class="line">info   (String message);  </span><br><span class="line">warning (String message);  </span><br><span class="line">severe  (String message);  </span><br><span class="line"></span><br><span class="line">throwing(String sourceClass, String sourceMethod, Throwable t);</span><br></pre></td></tr></table></figure>
<p>fine,finer,finest,config,info,warning,sever这七种方法每个对应一种日志级别，它等同于使用log方法传入相应的Level参数，是一种便易调用方法。<br>entering,exiting和throwing方法分别用来追踪方法进入、方法返回以及对抛出异常的日志记录。</p>
<h1 id="Logger设置方法"><a href="#Logger设置方法" class="headerlink" title="Logger设置方法"></a>Logger设置方法</h1><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>一个Logger可以有多个Handler，当记录日志消息时，就会将消息转发给Handler。如果想要给Logger添加一个Handler，使用addHandler(Handler)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;myLogger&quot;</span>);</span><br><span class="line">logger.addHandler(<span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>()); <span class="comment">//将消息输出到控制台</span></span><br></pre></td></tr></table></figure>
<p>如果要想获取Logger的所有Handler使用getHandlers()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler[] handlers = logger.getHandlers();</span><br></pre></td></tr></table></figure>
<p>如果要删除Logger的一个Handler，使用removeHandler(Handler)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line"></span><br><span class="line">logger.addHandler(handler);</span><br><span class="line"></span><br><span class="line">logger.remove(handler))</span><br></pre></td></tr></table></figure>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>我们可以在Logger中设置一个Filter来过滤哪些LogRecord要转发到Handler中。使用setFilter方法来配置Filter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFilterImpl</span>();</span><br><span class="line"></span><br><span class="line">logger.setFilter(filter);</span><br></pre></td></tr></table></figure>
<p>MyFilterImpl需要我们自己来实现Filter接口，具体在Filter章节中查看。<br>同样，我们可以使用getFilter()方法来获取Logger中的Filter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> logger.getFilter();</span><br></pre></td></tr></table></figure>
<h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><p>我们在调用log()方法的时候，可以传入Level参数来指定一条消息的日志级别。也可以在Logger中设置日志级别，任何低于Logger中设置的日志级别的消息都不会被转发到Handler中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;myLogger&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.setLevel(Level.INFO);</span><br></pre></td></tr></table></figure>
<p>如果想要获取Logger中设置的日志级别使用getLevel()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Level</span> <span class="variable">level</span> <span class="operator">=</span> logger.getLevel();</span><br></pre></td></tr></table></figure>
<p>我们也可以检测一个给定的日志级别的消息是否会被Logger转发，可以使用isLoggable()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isInfoLoggable</span> <span class="operator">=</span> logger.isLoggable(Level.INFO);</span><br></pre></td></tr></table></figure>
<h1 id="父级"><a href="#父级" class="headerlink" title="父级"></a>父级</h1><p>前面提到Logger是以分级命名空间形式组织起来的，每个Logger都会追踪它的父级Logger,并且可能会从父级继承一些属性。如果我们想获取Logger的父级，使用getParent()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">parent</span> <span class="operator">=</span> logger.getParent();</span><br></pre></td></tr></table></figure>
<p>默认情况下，Logger会将任何输出消息记录到其父级的handler中,如果我们不想这么做的话，使用serUseParenthandlers()来关闭这种转发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.setUseParentHandlers(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>同时也可以调用getUserParentHandlers()来查看我们是否使用了父级的Handlers</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">useParentLogger</span> <span class="operator">=</span> logger.getUseParentHandlers();</span><br></pre></td></tr></table></figure>


<h1 id="翻译来源"><a href="#翻译来源" class="headerlink" title="翻译来源"></a>翻译来源</h1><blockquote>
<p><a href="http://tutorials.jenkov.com/java-logging/index.html">Java Logging–Jakob Jenkov</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（五）Formatter和LogRecord</title>
    <url>/2017/05/26/java-%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%94%EF%BC%89Formatter%E5%92%8CLogRecord/</url>
    <content><![CDATA[<h1 id="LogRecord"><a href="#LogRecord" class="headerlink" title="LogRecord"></a>LogRecord</h1><p>LogRecord对象用于在日志框架和各个日志handler之间传递日志请求,它包装了一系列的日志记录信息。LogRecord有许多get方法来获取这些信息，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getLevel()</span><br><span class="line">getLoggerName()</span><br><span class="line">getMessage()</span><br><span class="line">getMillis()</span><br><span class="line">getParameters()</span><br><span class="line">getResourceBundle()</span><br><span class="line">getResourceBundleName()</span><br><span class="line">getSequenceNumber()</span><br><span class="line">getSourceClassName()</span><br><span class="line">getSourceMethodName()</span><br><span class="line">getThreadID()</span><br><span class="line">getThrown()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>每个get方法都有一个相应的set方法，但是除非我们自己创建一个LogRecord对象，否则不需要使用这些set方法，并且当LogRecord被传递到日志框架中时，它逻辑上属于框架，也不应再被客户端应用程序使用或更新。<br>下面是这些方法的简介</p>
<ul>
<li><strong>getLevel()</strong>  获取这条消息记录的日志等级。  </li>
<li><strong>getLoggerName()</strong> 返回记录这条消息的Logger的名字。</li>
<li><strong>getMesseage()</strong>  获取在本地化或格式化之前获取“原始”日志消息，是一个字符串形式。  </li>
<li><strong>getMillis()</strong>  方法返回记录LogRecord的时间（以毫秒为单位）。</li>
<li><strong>getParameters()</strong>  返回要插入此LogRecord消息的参数。</li>
<li><strong>getResourceBundle()</strong>  方法返回用于本地化LogRecord消息的ResourceBundle（如果有的话）。如果没有使用ResourceBundle，则此方法返回null。 </li>
<li><strong>getResourceBundleName()</strong>  返回用于本地化LogRecord消息的ResourceBundle（如果有）的名称。如果没有使用ResourceBundle，则返回null。</li>
<li><strong>getSequenceNumber()</strong>  方法返回当创建LogRecord时，在LogRecord构造函数内部生成的序列号。</li>
<li><strong>getSourceClassName()<strong>和</strong>getSourceMethodName()</strong>  分别返回记录该消息所在的类名和方法名，它或者是由我们调用log方法时手动传入的，或者是由虚拟机自动添加上去。需要注意的是当由虚拟机自动添加时，该信息不能保证准确。</li>
<li><strong>getThreadID()</strong> 返回记录由该LogRecord表示的消息的线程的ID。</li>
<li><strong>getThrown()</strong> 返回由此LogRecord记录消息时标记的Throwable。这个Throwable要么是直接作为参数传递给Logger日志记录方法，要么是直接设置在LogRecord上，然后传递给Logger。这种Throwable通常是导致要调用日志记录的原因。</li>
</ul>
<h1 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h1><p>Formatter是在Handler中在写入到外部之前用来格式化LogRecord中的信息的。<br>java.util.logging提供了Formatter抽象类，还为我们提供了两个实现类</p>
<ul>
<li><strong>SimpleFormatter</strong></li>
<li><strong>XMLFormatter</strong></li>
</ul>
<p>Java Logging API中各种Handler默认使用上面两种Formatter中的一种用来格式化日志消息。我们还可以实现自己的子类，Formatter中只有一个format(LogRecord record)抽象方法需要我们来实现，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFormatter</span> <span class="keyword">extends</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(LogRecord record)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> record.getLevel() + <span class="string">&quot;:&quot;</span> + record.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类必须覆盖Formatter类中的抽象方法format()。由format()返回的String是由handler转发到外部系统的。字符串应该如何格式化取决于你。<br>此外Formatter中还给子类提供了一个便易方法formatMessage(LogRecord record)，它从LogRecord中本地化和格式化消息字符串，子类实现时我们可以直接调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFormatter</span> <span class="keyword">extends</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(LogRecord record)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> formatMessage(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（六）LogManager与日志配置</title>
    <url>/2017/05/26/java-%E6%97%A5%E5%BF%97%EF%BC%88%E5%85%AD%EF%BC%89LogManager%E4%B8%8E%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<h1 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h1><hr>
<h2 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h2><hr>
<p>LogManager用来管理Java Logging API的配置，在整个JVM运行期间只存在一个LogManager实例，使用它的静态方法来获取该实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LogManager</span> <span class="variable">manager</span> <span class="operator">=</span> LogManager.getLogManager();</span><br></pre></td></tr></table></figure>
<p>LogManager是随着虚拟机的启动而进行初始化，在这期间它通过readConfiguration()方法初始化日志记录配置。缺省情况下，JVM使用LogManager默认配置。在启动虚拟机后，如果想要重新加载配置文件，可以使用一下两个方法</p>
<ul>
<li>readConfiguration()</li>
<li>readConfiguration(inputStream)</li>
</ul>
<span id="more"></span>
<p>第一种是再次读取配置类或配置文件，防止在虚拟机启动后这些配置信息发生改变。第二种使用输入流来重设日志配置。<br>如果我们要想使用自己的日志管理类，在虚拟机启动时通过java.util.logging.manager参数指定要使用的manager。</p>
<h2 id="命名空间管理"><a href="#命名空间管理" class="headerlink" title="命名空间管理"></a>命名空间管理</h2><hr>
<p>LogMananger管理着命名空间中的所有命名Logger对象和对象的属性设置，LogManager也提供方法来获取这些被管理的对象和属性。以下是主要获取方法。  </p>
<h3 id="对象管理"><a href="#对象管理" class="headerlink" title="对象管理"></a>对象管理</h3><ul>
<li>addLogger(Logger logger)</li>
<li>getLogger(String name)</li>
<li>getLoggerNames()</li>
</ul>
<p>addLogger()是向命名空间内新添加一个Logger对象，并返回一个boolean值表示是否添加成功，如果该命名Logger已经存在的话，就会添加失败返回false。getLogger()依据命名获取特定的Logger对象，getLoggerNames()获取获取已知Logger名称的枚举。</p>
<h3 id="属性管理"><a href="#属性管理" class="headerlink" title="属性管理"></a>属性管理</h3><ul>
<li>getProperty(String name)</li>
<li>reset()</li>
</ul>
<p>getProperty()可以依据属性名，获取读取的配置属性的值。reset()方法会重置所有的日志配置，对于所有的命名Logger,reset()会移除并关闭它的所有Hanlder,并将其Level设置为null,对于根Logger,它的Level会被设置为Level.INFO。</p>
<blockquote>
<p>LogManager所有的方法都是线程安全的。</p>
</blockquote>
<hr>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><hr>
<p>Java Logging API可以通过两种方式进行配置：</p>
<ol>
<li>通过配置类</li>
<li>通过配置文件</li>
</ol>
<p>这两种配置方式分别是通过一个java类或property文件来存储日志配置的属性键值对。配置的初始化由java.util.logging.LogManager类负责，而LogManager在JVM启动时就会根据系统属性初始化，并且在初始化的时候会读取日志配置属性，所以我们需要在要启动JVM时，通过命令行来指定这两种配置方式属性。下面分别是配置类和配置文件的JVM属性</p>
<ul>
<li>java.util.logging.config.class</li>
<li>java.util.logging.config.file</li>
</ul>
<p>在属性后加类或文件的路径信息，如“java.util.logging.config.class&#x3D;com.config.LoggerConfig”</p>
<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><hr>
<p>您可以使用Java类来配置Java Logging API。您可以通过在JVM参数java.util.logging.config.class中指定类的名称来实现。该类的构造函数应该加载日志配置并将其应用于分层命名空间中的Logger。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><hr>
<p>不使用配置类，也可以使用配置文件来配置日志记录。Java Logging API中有一个默认配置文件，路径为JRE目录下的“lib&#x2F;logging.properties”，如果编辑该文件的话，就改变了整个JRE的默认日志配置，这会影响所有的运行程序。<br>通常我们会为应用程序建立一个单独的配置文件，并且可以通过将JVM属性java.util.logging.config.file设置为指向此文件来实现。</p>
<p>在写配置文件的时候需要注意，配置属性按照它们在配置文件中列出的顺序应用的，也就是说，应当先配置父Logger的属性，然后再配置子Logger,否则，父Logger的配置将覆盖子Logger的配置。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 日志（四）Handler</title>
    <url>/2017/05/26/java-%E6%97%A5%E5%BF%97%EF%BC%88%E5%9B%9B%EF%BC%89Handler/</url>
    <content><![CDATA[<p>Handler是负责实际将记录消息发布到外部的组件。我们可以在一个Logger上添加多个Hanlder,实现日志信息发送到不同的目的地。</p>
<h1 id="Handler设置方法"><a href="#Handler设置方法" class="headerlink" title="Handler设置方法"></a>Handler设置方法</h1><p>　　Handler和Logger一样拥有Level和Filter，此外由于Handler负责实际发布消息到外部，它还有一个负责将字符格式化的Formatter,对此Handler有一系列的设置方法  </p>
<span id="more"></span>
<ul>
<li>setFilter(Filter newFilter) </li>
<li>getFilter() </li>
<li>setLevel(Level newLevel) </li>
<li>getLevel() </li>
<li>setFormatter(Formatter newFormatter) </li>
<li>getFormatter()</li>
</ul>
<h1 id="内置Handler"><a href="#内置Handler" class="headerlink" title="内置Handler"></a>内置Handler</h1><p>　　java.util.logging提供了Handler接口，但是也为我们提供了几个内置的Handler：</p>
<ul>
<li><strong>Handler</strong><ul>
<li><strong>StreamHandler</strong></li>
<li><strong>ConsoleHandler</strong></li>
<li><strong>FileHandler</strong></li>
<li><strong>SocketHandler</strong></li>
<li><strong>MemoryHandler</strong></li>
</ul>
</li>
</ul>
<h2 id="StreamHandler"><a href="#StreamHandler" class="headerlink" title="StreamHandler"></a>StreamHandler</h2><p>　　StreamHandler会将日志消息写到一个OutputStream中，它有两种构造方法可供初始化一个StreamHandler</p>
<blockquote>
<p>StreamHandler()<br>StreamHandler(OutputStream out,Formatter formatter)</p>
</blockquote>
<p>　　第一种为无参构造，没有指定日志消息要写入的OutputStream和要使用的Formatter，此时可以不用再设定Formatter,因为StreamHanderl会使用一个默认的SimpleFormatter，但还需要调用StreamHandler的setOutputStream(OutputStream)来指定一个输出流。<br>　　第二种构造器接收一个OutputStream和Formatter,这时setOutputStream(OutputStream)方法可以用来更改原有的输出流。</p>
<h2 id="ConsoleHandler"><a href="#ConsoleHandler" class="headerlink" title="ConsoleHandler"></a>ConsoleHandler</h2><p>　　ConsoleHanderl将所有的日志信息输出到System.err中，它默认使用SimpleFormatter来格式化日志信息。ConsoleHandler只用一个无参构造。</p>
<h2 id="FileHandler"><a href="#FileHandler" class="headerlink" title="FileHandler"></a>FileHandler</h2><p>　　FiletHandler将所有的日志信息写入到文件中，既可以是一个单独文件，也可以是一系列的滚动记录文件。如果采用滚动文件的形式，需要指定每个文件的大小限制，达到该限制后就会创建一个新的记录文件，并且还需要指定文件的命名形式，每个文件名由基本名称和序列号组成。比如mylog.0.txt, mylog.1.txt 等等。<br>　　FileHanderl默认使用XMLFormatter来格式化日志信息。下面是FileHandler的所有构造方法。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p>FileHandler()<br>FileHandler(String pattern)<br>FileHandler(String pattern, boolean append)<br>FileHandler(String pattern, int limit, int count)<br>FileHandler(String pattern, int limit, int count, boolean append)</p>
</blockquote>
<p>　　第一种构造方法是无参构造，使用这种构造方法，将完全由LogManager读取的配置文件属性（或其默认值）来配置。<br>　　第二个构造方法创建一个具有预定义模式的FileHandler，用于生成日志文件的文件名。<br>　　第三个构造方法使用一个文件名模式和一boolean值来创建一个FileHandler,这里没有指定最大日志文件数，其默认为1，也就是只会使用一个日志文件，boolean值参数决定FileHandler是每次追加写入原有的日志文件，还是覆盖写入。<br>　　第四个构造方法使用一个文件名模式，一个文件大小限制，一个最大文件数来创建一个FileHandler,当日志文件达到大小限制后，就会新建一个日志文件，如此一直达到最大文件数后，会删除最早的文件继续记录。<br>　　第五个构造方法相比第四个，只是多了一个boolean值，用来决定FileHandler是否应该追加写入到已有的日志文件。</p>
<h3 id="文件名模式"><a href="#文件名模式" class="headerlink" title="文件名模式"></a>文件名模式</h3><p>　　文件名的模式是通过字符串来表示的，它使用一些字符来告诉FileHandler生成文件名的方式</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&#x2F;</strong></td>
<td>系统文件分隔符，通常是\或者&#x2F;</td>
</tr>
<tr>
<td><strong>%t</strong></td>
<td>系统的临时目录</td>
</tr>
<tr>
<td><strong>%h</strong></td>
<td>系统的用户主目录</td>
</tr>
<tr>
<td><strong>%g</strong></td>
<td>将滚动日志文件彼此区分开的代号</td>
</tr>
<tr>
<td><strong>%u</strong></td>
<td>避免命名冲突的唯一编号</td>
</tr>
<tr>
<td><strong>%%</strong></td>
<td>单个百分号，%的转义字符</td>
</tr>
</tbody></table>
<p>　　如果命名模式中没有指定％g，并且FileHandler的文件数大于1，则会将文件序列号直接添加到文件名后，并且以一个“.”分割开。<br>　　%u是用来避免文件命名冲突的，当同时有两个程序运行的时候。%u通常被设置为0，当产生的日志文件名已经存在的时候，会依照数字顺序增加1，知道产生一个不会冲突的文件名。如果命名模式中没有指定%u,而文件名又发生冲突的话，会直接在文件名后添加不冲突的序号。</p>
<blockquote>
<p>%u只保证在本机文件系统上才会添加唯一序列号。</p>
</blockquote>
<p>　　这举一个例子表示，文件命名模式字符串为“logfile.%g%u.txt”，则滚动产生的文件名为logfile0.0.txt, logfile.1.0txt，logfile.2.0txt…..此时如果logfile.3.0txt文件名已经存在，则会使用logfile.3.1txt。</p>
<h2 id="SocketHandler"><a href="#SocketHandler" class="headerlink" title="SocketHandler"></a>SocketHandler</h2><p>　　SocketHandler会通过一个socket将日志信息发送出去，默认使用XMLFormatter进行日志信息格式化。它有两种构造方法</p>
<blockquote>
<p>SocketHandler()<br>SocketHandler(String host, int port)</p>
</blockquote>
<p>　　第一种构造方法只能使用LogManager从配置文件读取的属性来配置。<br>　　第二种构造方法指定了要日志消息发送到的主机名和端口号。<br>　　SocketHandler默认使用XMLFormatter进行日志信息格式化。</p>
<h2 id="MemoryHandler"><a href="#MemoryHandler" class="headerlink" title="MemoryHandler"></a>MemoryHandler</h2><p>　　MemoryHandler是一个将LogRecords内部的保留在缓冲区中的handler。当内部缓冲区已满时，新的LogRecords开始覆盖缓冲区中最旧的部分。<br>　　当发生某个触发事件时，内部缓冲区中的LogRecord将被刷新到目标Handler，该Handler将将LogRecords写入外部系统。例如，当一个最小日志级别的LogRecord被记录时，就可以刷出LogRecord的整个缓冲区。此外我们也可以调用它的push()方法强制刷出缓冲区。<br>　　MemoryHandler也有两种构造方法</p>
<blockquote>
<p>MemoryHandler()<br>MemoryHandler(Handler target, int size, Level pushLevel)</p>
</blockquote>
<p>　　第一种是无参构造，需要根据LogManager配置属性进行配置。<br>　　第二种构造方法指定了目标Handler,缓冲区大小，以及最小刷出缓冲区的日志级别</p>
<blockquote>
<p>需要注意的是MemoryHandler没有Formatter，它不会进行格式化工作。</p>
</blockquote>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 日志</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（一）泛型类型</title>
    <url>/2017/06/07/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>泛型在定义类，接口，和方法时使类型变得参数化。这很像在方法声明中使用的形式参数，参数化类型为我们提供了在不同的输入参数下重用代码的方式。不同的是，形式参数的输入是值，而类型参数的输入是类型。<br>使用泛型的代码比非泛型代码有很多好处：</p>
<ul>
<li>编译时期更加强大的类型检查<br>Java编译器对泛型代码提供强类型检查，如果代码违反了类型安全，编译器将报错。修复编译时期错误要比运行时期错误更加容易，因为编译时期错误很难发现。</li>
</ul>
<span id="more"></span>
<ul>
<li>消除类型转换<br>不使用泛型的代码片段<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
  当使用泛型重写时，代码不需要进行类型转换<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure></li>
<li>通过使用泛型，程序员可以实现对不同类型的集合进行操作的通用算法，可以自定义，并且类型安全易于阅读</li>
</ul>
<p>一个泛型类型是一个对类型进行参数化的泛型类或者接口。下面将通过修改以下Box类来演示该概念。</p>
<h1 id="一个简单的Box类"><a href="#一个简单的Box类" class="headerlink" title="一个简单的Box类"></a>一个简单的Box类</h1><p>首先检查对任意类型的对象进行操作的非泛型Box类。它只需要提供两个方法:向box中添加对象的set方法，以及检索对象的get方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object object)</span> &#123; <span class="built_in">this</span>.object = object; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于它的方法接受或返回一个Object，所以你可以随意传入任何你想要的传入的，只要它不是一个原始类型。这些方法在编译时期无法验证类的使用方式。在代码的某一部分可能在box中放入了一个Integer，并期望从其中获取Integer，而另一部分代码中可能会错误地传入一个String，从而导致运行时错误。</p>
<h1 id="泛型版本的Box类"><a href="#泛型版本的Box类" class="headerlink" title="泛型版本的Box类"></a>泛型版本的Box类</h1><p>泛型类使用以下格式定义：  </p>
<blockquote>
<p>class name&lt;T1, T2, …, Tn&gt; { &#x2F;* … *&#x2F; }</p>
</blockquote>
<p>类型参数部分由尖括号（&lt;&gt;）分隔，跟在类名之后。它指定类型参数（也称为类型变量）T1，T2，…和Tn。</p>
<p>要更新Box类以使用泛型，您可以通过将代码“public class Box”更改为“public class Box &lt;T&gt;”来创建泛型类型声明。这引入了可以在类中任何地方使用的类型变量T。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic version of the Box class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the value being boxed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您可以看到，所有出现的Object都被替换为T。类型变量可以是您指定的任何非基本类型：任何类类型，任何接口类型，任何数组类型，或甚至其他类型变量。  </p>
<h1 id="类型参数命名约定"><a href="#类型参数命名约定" class="headerlink" title="类型参数命名约定"></a>类型参数命名约定</h1><p>按照惯例，类型参数名称是单个大写字母。这与您已经知道的变量命名惯例形成鲜明对照，并且有很好的理由：没有这个约定，很难说出类型变量和普通类或接口名称之间的区别。<br>最常用的类型参数名称是：</p>
<ul>
<li><pre><code>E——元素（Java Collections Framework广泛使用）
</code></pre>
<ul>
<li><pre><code>K——键（key）
</code></pre>
<ul>
<li><pre><code>N——数字（Number）
</code></pre>
<ul>
<li><pre><code>T——类型（Type）
</code></pre>
<ul>
<li><pre><code>V——值（Value）
</code></pre>
<ul>
<li><pre><code>S,U,V——第二，三，四类型
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>您将看到这些名称在整个Java SE API和本课程的其余部分使用。</p>
<h1 id="调用和实例化泛型类型"><a href="#调用和实例化泛型类型" class="headerlink" title="调用和实例化泛型类型"></a>调用和实例化泛型类型</h1><p>要从你的代码中引用泛型的Box类，你必须执行一个泛型类型的调用，用一些具体的值替换T，比如Integer： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox;  </span><br></pre></td></tr></table></figure>
<p>您可以将泛型类型调用视为与普通方法调用相似，但不是将参数传递给方法，而是将类型参数（在这种情况下为Integer）传递给Box类本身。  </p>
<blockquote>
<p>Type Parameter 和 Type Argument<br>许多开发人员可以互换使用术语Type Parameter和Type Argument，但是这些术语是不一样的。当编写代码时，为了创建要给参数化类型，提供了一个type argument。因此，T在Foo&lt;T&gt;中是一个type parameter而String在Foo&lt;String&gt;中是一个type argument。使用这些术语时，本课程将遵守此定义。</p>
</blockquote>
<p>像任何其他变量声明一样，此代码实际上并没有创建一个新的Box对象。它只是声明integerBox会保存一个“Box of Ingteger“的引用，该引用指明如何读取Box &lt;Integer&gt;。<br>泛型类型的调用通常称为参数化类型。<br>要实例化此类，请像往常一样使用new关键字，但在类名和括号之间放置&lt;Integer&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;(); </span><br></pre></td></tr></table></figure>

<h1 id="菱形符号（The-Diamond）"><a href="#菱形符号（The-Diamond）" class="headerlink" title="菱形符号（The Diamond）"></a>菱形符号（The Diamond）</h1><p>在Java SE 7及更高版本中，只要编译器可以从上下文中确定或推断类型参数，就可以使用一组空的类型参数（&lt;&gt;）替换调用泛型构造函数所需的类型参数。例如，您可以使用以下语句创建Box &lt;Integer&gt;的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box &lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span> &lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>有关菱形符号和类型推断的更多信息，请参阅类型推断。</p>
<h1 id="多类型参数"><a href="#多类型参数" class="headerlink" title="多类型参数"></a>多类型参数</h1><p>如前所述，泛型类可以有多个类型参数。例如，泛型的OrderedPair类，它实现了泛型的Pair接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedPair</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderedPair</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.key = key;</span><br><span class="line">	<span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>	&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下语句创建了OrderedPair类的两个实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String,Integer&gt; p1 = newOrderedPair&lt;String, Integer&gt;(<span class="string">&quot;Even&quot;</span>, <span class="number">8</span>);</span><br><span class="line">Pair&lt;String,String&gt; p2 = <span class="keyword">new</span> <span class="title class_">OrderedPair</span>&lt;String, String&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码中，new OrderedPair&lt;String,Integer&gt;实例化K为一个String,V为一个Integer。因此OrderedPair的构造方法的类型参数分别为String和Integer。由于自动装箱，将String和int传递给该类也是有效的。</p>
<p>如The Diamond所述，由于Java编译器可以从声明OrderedPair &lt;String，Integer&gt;推断出K和V类型，所以可以使用菱形符号来缩短这些语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrderedPair&lt;String, Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">OrderedPair</span>&lt;&gt;(<span class="string">&quot;Even&quot;</span>, <span class="number">8</span>);</span><br><span class="line">OrderedPair&lt;String, String&gt;  p2 = <span class="keyword">new</span> <span class="title class_">OrderedPair</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>要创建泛型接口，请遵循与创建泛型类相同的规定。</p>
<h1 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h1><p>您也可以使用参数化类型（即List &lt;String&gt;）来作为类型参数（即K或V）。例如，使用OrderedPair &lt;K，V&gt;示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = <span class="keyword">new</span> <span class="title class_">OrderedPair</span>&lt;&gt;(<span class="string">&quot;primes&quot;</span>, <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;(...));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（七）通配符</title>
    <url>/2017/06/09/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%83%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    <content><![CDATA[<p>在泛型代码中，问号（？）被称为通配符，表示一个未知类型。通配符可以用在多种情景下：作为参数的类型，字段，或者局部变量；有时也作为返回类型（尽管具体指定类型会是更好的编程实践）。通配符从不被用作泛型方法调用类型参数，泛型类实例创建或超类型。</p>
<h1 id="上边界通配符"><a href="#上边界通配符" class="headerlink" title="上边界通配符"></a>上边界通配符</h1><p>您可以使用上边界通配符来放宽对变量的限制。例如，假设你想编写一个适用于List &lt;Integer&gt;，List &lt;Double&gt;和List &lt;Number&gt;的方法;您可以通过使用上限通配符来实现此目的。 </p>
<span id="more"></span>
<p>要声明一个上限通配符，请使用通配符（’？’），后跟extends关键字，再后跟其上边界。请注意，在这种情况下，extends在一般意义上用于表示“extends”（如在类中）或“implements”（如在接口中）。<br>要写一个适用于Number以及它的子类型，比如Integer，Double和Float的list的方法，应当指定 List&lt;? extends Number&gt;。List &lt;Number&gt;一词比List &lt;？extends Number&gt;限制更大，因为前者匹配一个类型为Number的list，而后者匹配一个类型为Number或其任何子类的list。<br>考虑下面的process方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Foo&gt; list)</span> &#123; <span class="comment">/* ... */</span> &#125;  </span><br></pre></td></tr></table></figure>
<p>上边界通配符&lt;? extends Foo&gt;中，其中Foo是任何类型，匹配Foo和任何Foo的子类。Process方法可以以Foo类型来访问集合元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Foo&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Foo elem : list) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在foreach子句中，elem变量遍历列表中的每个元素。 Foo类中定义的任何方法现在可以在elem上使用。<br>sumOfList方法返回列表中的数字之和：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list)</span><br><span class="line">        s += n.doubleValue();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h1><p>无边界通配符类型是通过通配符（？）来指定。比如List&lt;？&gt;。这个被称为未知类型list。只有在以下两种情况下，无界通配符是才是有用的：</p>
<ul>
<li>如果您正在编写可以使用Object类中提供的功能实现的方法。</li>
<li>当代码使用泛型类中不依赖类型参数的方法时。比如List.size或者List.clear。事实上，Class &lt;？&gt;是经常使用的，因为Class &lt;T&gt;中的大多数方法都不依赖于T.</li>
</ul>
<p>考虑下面的方法printList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Object&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem : list)</span><br><span class="line">        System.out.println(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printList的目标是打印任何类型的list，但是它无法实现该目的 - 它仅打印一个Object实例list;它不能打印List &lt;Integer&gt;，List &lt;String&gt;，List &lt;Double&gt;等，因为它们不是List &lt;Object&gt;的子类型。要编写一个泛型的printList方法，请使用List &lt;？&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem: list)</span><br><span class="line">        System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为对于任何具体类型A，List &lt;A&gt;是List &lt;？&gt;的子类型，您可以使用printList打印任何类型的list：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;String&gt;  ls = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">printList(li);</span><br><span class="line">printList(ls);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本课程中的示例中使用了Arrays.asList方法。这个静态工厂方法转换指定的数组并返回一个固定大小的list。</p>
</blockquote>
<p>请注意，List &lt;Object&gt;和List &lt;？&gt;不一样。您可以将Object或Object的任何子类型插入到List &lt;Object&gt;中。但是您只能将null插入List&lt;？&gt;。</p>
<h1 id="下边界通配符"><a href="#下边界通配符" class="headerlink" title="下边界通配符"></a>下边界通配符</h1><p>下边界通配符将未知类型限制为该类型的指定类型或父类型。下限通配符用通配符（’？’）表示，后跟super关键字，后跟其下界：&lt;？super A&gt;。</p>
<blockquote>
<p>您可以指定通配符的上限，也可以指定下限，但不能同时指定</p>
</blockquote>
<p>假设你想编写一个将Integer对象放入list的方法。为了最大化代码的灵活性，您希望该方法适用于List &lt;Integer&gt;，List &lt;Number&gt;和List &lt;Object&gt; - 任何可以保存Integer值的内容。<br>要想写一个适用于包含Integer的list以及Integer的父类型，比如Integer，Number和Object，您可以指定List &lt;？super Integer&gt;。List&lt;Integer&gt;比List&lt;? Super Integer&gt;限制更大，因为前者只匹配一个Integer类型的list，而后者匹配任何Integer以及其子类型的list。<br>以下代码将数字1到10添加到列表的末尾：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通配符和子类型"><a href="#通配符和子类型" class="headerlink" title="通配符和子类型"></a>通配符和子类型</h1><p>如泛型，继承和子类型所述，泛型类或接口不会仅仅因为它们之间类型存在关系而相关。但是，您可以使用通配符来创建泛型类或接口之间的关系。<br>给定以下两个常规（非泛型）类：<br>class A { &#x2F;* … <em>&#x2F; }<br>class B extends A { &#x2F;</em> … *&#x2F; }  </p>
<p>编写以下代码是合理的：<br>B b &#x3D; new B();<br>A a &#x3D; b; </p>
<p>此示例显示，常规类的继承遵循这个子类型规则：如果B继承A，则类B是类A的子类型。但是此规则不适用于泛型类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;B&gt; lb = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;A&gt; la = lb;   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>鉴于Integer是Number的子类型，List &lt;Integer&gt;和List &lt;Number&gt;之间的关系是什么？<br>![generics-listParent](&#x2F;images&#x2F;java base&#x2F;generics-listParent.gif)<br>虽然Integer是Number的子类型，但List &lt;Integer&gt;不是List &lt;Number&gt;的子类型，实际上这两种类型不相关。 List &lt;Number&gt;和List &lt;Integer&gt;的公共父项是List &lt;？&gt;。<br>为了创建这些类之间的关系，代码可以通过List &lt;Integer&gt;的元素访问Number的方法，使用上限通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;  numList = intList;  <span class="comment">// OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为Integer是Number的子类型，而numList是Number对象的List，所以现在在intList（Integer对象List）和numList之间存在关系。下图显示了使用上边界和下边界通配符声明的几个List类之间的关系。<br>![generics-wildcardSubtyping](&#x2F;images&#x2F;java base&#x2F;generics-wildcardSubtyping.gif)</p>
<h1 id="通配符捕获和帮助方法"><a href="#通配符捕获和帮助方法" class="headerlink" title="通配符捕获和帮助方法"></a>通配符捕获和帮助方法</h1><p>在某些情况下，编译器推断通配符的类型。例如，一个list可以被定义为List &lt;？&gt;，但是当评估表达式时，编译器从代码中推断出特定类型。这种情况称为通配符捕获。</p>
<p>在大多数情况下，您不需要担心通配符捕获，除非您看到包含短语“捕获（capture of）”的错误消息。</p>
<p>WildcardError示例在编译时会产生捕获错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildcardError</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(List&lt;?&gt; i)</span> &#123;</span><br><span class="line">        i.set(<span class="number">0</span>, i.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本示例中，编译器将输入参数i处理为Object类型。当foo方法调用List.set（int，E）时，编译器无法确认正在插入到list中的对象的类型，并产生错误。当发生这种类型的错误时，通常意味着编译器认为您将错误的类型分配给变量。之所以在Java语言中添加泛型是为了在编译时强制保证类型安全。 </p>
<p>WildcardError示例在使用Oracle JDK 7 javac实现编译时产生以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WildcardError.java:6: error: method set in interface List&lt;E&gt; cannot be applied to given types;</span><br><span class="line">    i.set(0, i.get(0));</span><br><span class="line">     ^</span><br><span class="line">  required: int,CAP#1</span><br><span class="line">  found: int,Object</span><br><span class="line">  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion</span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in interface List</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br><span class="line">1 error</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，代码正在尝试执行安全操作，那么你如何解决编译器错误？您可以通过编写私有的捕获通配符帮助方法来修复它。在这种情况下，您可以通过创建私有帮助方法fooHelper来解决问题，如WildcardFixed所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildcardFixed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(List&lt;?&gt; i)</span> &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// Helper method created so that the wildcard can be captured</span></span><br><span class="line">    <span class="comment">// through type inference.</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fooHelper</span><span class="params">(List&lt;T&gt; l)</span> &#123;</span><br><span class="line">        l.set(<span class="number">0</span>, l.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于帮助方法，编译器使用推断来确定T是调用中的CAP＃1（捕获变量）。该示例现在已成功编译。<br>按照惯例，帮助方法通常被命名为originalMethodNameHelper。<br>现在考虑一个更复杂的例子，WildcardErrorBad：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildcardErrorBad</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swapFirst</span><span class="params">(List&lt;? extends Number&gt; l1, List&lt;? extends Number&gt; l2)</span> &#123;</span><br><span class="line">      <span class="type">Number</span> <span class="variable">temp</span> <span class="operator">=</span> l1.get(<span class="number">0</span>);</span><br><span class="line">      l1.set(<span class="number">0</span>, l2.get(<span class="number">0</span>)); <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a CAP#2 extends Number;</span></span><br><span class="line">                            <span class="comment">// same bound, but different types</span></span><br><span class="line">      l2.set(<span class="number">0</span>, temp);	    <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，代码正在尝试不安全的操作。例如，考虑以下调用swapFirst方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Double&gt;  ld = Arrays.asList(<span class="number">10.10</span>, <span class="number">20.20</span>, <span class="number">30.30</span>);</span><br><span class="line">swapFirst(li, ld);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然List &lt;Integer&gt;和List &lt;Double&gt;都符合List&lt;？extends Number&gt;，从Integer的list中获取元素，并尝试将其放入Double值list中显然是不正确的。<br>使用Oracle的JDK javac编译器编译代码会产生以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WildcardErrorBad.java:7: error: method set in interface List&lt;E&gt; cannot be applied to given types;</span><br><span class="line">      l1.set(0, l2.get(0)); // expected a CAP#1 extends Number,</span><br><span class="line">        ^</span><br><span class="line">  required: int,CAP#1</span><br><span class="line">  found: int,Number</span><br><span class="line">  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion</span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in interface List</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Number from capture of ? extends Number</span><br><span class="line">WildcardErrorBad.java:10: error: method set in interface List&lt;E&gt; cannot be applied to given types;</span><br><span class="line">      l2.set(0, temp);      // expected a CAP#1 extends Number,</span><br><span class="line">        ^</span><br><span class="line">  required: int,CAP#1</span><br><span class="line">  found: int,Number</span><br><span class="line">  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion</span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in interface List</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Number from capture of ? extends Number</span><br><span class="line">WildcardErrorBad.java:15: error: method set in interface List&lt;E&gt; cannot be applied to given types;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">         ^</span><br><span class="line">  required: int,CAP#1</span><br><span class="line">  found: int,Object</span><br><span class="line">  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion</span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in interface List</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br><span class="line">3 errors</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于这种问题没有帮助方法可以使用，因为代码设计从根本上就错了。</p>
<h1 id="通配符使用指南"><a href="#通配符使用指南" class="headerlink" title="通配符使用指南"></a>通配符使用指南</h1><p>学习使用泛型进行编程时，更令人困惑的方面之一是确定何时使用上限通配符以及何时使用下限通配符。本页提供了设计代码时遵循的一些指导原则。<br>为了讨论的目的，将变量视为提供两个功能之一是有帮助的：</p>
<ul>
<li><strong>一个”in”变量</strong><br>”in”变量为代码提供数据。想象一下有两个参数的复制方法：copy（src，dest）。 src参数提供要复制的数据，因此它是“in”参数。</li>
<li><strong>一个”out”变量</strong><br>“out”变量保存在其他地方使用的数据。在复制示例中，copy（src，dest），dest参数接受数据，所以它是“out”参数。</li>
</ul>
<p>当然，一些变量同时用于“in”和“out”的目的 - 这种情况也在指南中解决。<br>在决定是否使用通配符以及通配符是什么类型时，可以使用“in”和“out”原则。以下列表提供了以下准则：</p>
<ul>
<li>“in”变量用上限通配符定义，使用“extends”关键字</li>
<li>“out”变量用下限通配符定义，使用“super”关键字</li>
<li>在“in”变量可以访问使用Object类中定义的方法情况下，使用无界通配符。</li>
<li>在代码需要访问变量作为“in”和“out”变量的情况下，请勿使用通配符。</li>
</ul>
<p>这些准则不适用于方法的返回类型。应该避免使用通配符作为返回类型，因为它会强制程序员使用代码来处理通配符。<br>一个被定义为List&lt;? Extends …&gt;的list可以非正式地认为是只读，但这不是一个严格的保证。假设你有以下两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NaturalNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NaturalNumber</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">this</span>.i = i; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumber</span> <span class="keyword">extends</span> <span class="title class_">NaturalNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvenNumber</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">super</span>(i); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请考虑以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;EvenNumber&gt; le = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">NaturalNumber</span>&gt; ln = le;</span><br><span class="line">ln.add(<span class="keyword">new</span> <span class="title class_">NaturalNumber</span>(<span class="number">35</span>));  <span class="comment">// compile-time error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为List &lt;EvenNumber&gt;是List&lt;? extends NaturalNumber&gt;的子类型，可以将le分配给ln。但是您不能使用ln将natural number添加到even numbers的list中。但list中的以下操作是可能的：</p>
<ul>
<li>你可以添加 null.</li>
<li>你可以调用clear方法.</li>
<li>你可以获取iterator并且调用它的remove方法.</li>
<li>您可以捕获通配符并写入从list中读取的元素。</li>
</ul>
<p>你可以看到定义为List&lt;? extends NaturalNumber&gt;的list不是最严格意义上的只读，您可能会想到这样，因为您不能存储新元素或更改list中的现有元素。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（三）泛型方法</title>
    <url>/2017/06/07/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>泛型方法是引入自己的类型参数的方法。这类似于声明泛型类型，但类型参数的范围仅限于声明它的方法。允许静态和非静态泛型方法，以及泛型类构造函数。<br>泛型方法的语法包括一个类型参数，位于尖括号内，并出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。<br>Util类包括一个泛型的方法compare，用来比较两个Pair对象：  </p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span> &#123; <span class="built_in">this</span>.key = key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>   &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用此方法的完整语法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">same</span> <span class="operator">=</span> Util.&lt;Integer, String&gt;compare(p1, p2);</span><br></pre></td></tr></table></figure>
<p>上面泛型方法显示给出了类型参数，但一般来说，这可以省略，编译器会推断需要的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">same</span> <span class="operator">=</span> Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>
<p>此功能称为类型推断（type inference），允许您以常规方法调用泛型方法，而不在尖括号内指定类型。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（九）泛型的限制</title>
    <url>/2017/06/09/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B9%9D%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>要有效地使用Java泛型，您必须考虑以下限制：</p>
<ul>
<li>无法使用原始类型实例化泛型类型</li>
<li>无法创建类型参数实例</li>
<li>无法声明类型参数静态字段</li>
<li>无法在参数化类型上使用类型转换或instranceof</li>
<li>无法创建参数化类型数组</li>
<li>无法创建、捕获、或抛出参数化类型对象</li>
<li>无法重载一个形式参数被擦除后是相同原生类型的方法<span id="more"></span></li>
</ul>
<h1 id="无法使用原始类型实例化泛型类型"><a href="#无法使用原始类型实例化泛型类型" class="headerlink" title="无法使用原始类型实例化泛型类型"></a>无法使用原始类型实例化泛型类型</h1><p>考虑以下参数化类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lass Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个Pair对象时，你不可以用原始类型来替代类型参数K或者V</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<pre><code>你只可以使用非原始类型来替代类型参数K和V
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, Character&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，Java编译器将8自动装箱为Integer.valueOf（8）并且“a”自动装箱为Character（’a’）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, Character&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(Integer.valueOf(<span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>


<h1 id="无法创建类型参数实例"><a href="#无法创建类型参数实例" class="headerlink" title="无法创建类型参数实例"></a>无法创建类型参数实例</h1><p>您不能创建一个类型参数的实例。例如，以下代码会导致编译时错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">elem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();  <span class="comment">// compile-time error</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为解决方法，您可以通过反射创建类型参数的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; cls)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">elem</span> <span class="operator">=</span> cls.newInstance();   <span class="comment">// OK</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以如下调用append方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure>

<h1 id="无法声明类型参数静态字段"><a href="#无法声明类型参数静态字段" class="headerlink" title="无法声明类型参数静态字段"></a>无法声明类型参数静态字段</h1><p>一个类的静态字段是由类的所有非静态对象共享的类级变量。因此，不允许使用类型参数的静态字段。考虑下列类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileDevice</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果允许类型参数的静态字段，那么以下代码将被混淆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = <span class="keyword">new</span> <span class="title class_">MobileDevice</span>&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = <span class="keyword">new</span> <span class="title class_">MobileDevice</span>&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = <span class="keyword">new</span> <span class="title class_">MobileDevice</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>因为静态字段os是由phone，pager和pc共享的，那么os的实际类型是什么？它不能同时是Smartphone，Pager和TabletPC。因此，您不能创建类型参数的静态字段。因此，您不能创建类型参数的静态字段。</p>
<h1 id="无法在参数化类型上使用类型转换或instranceof"><a href="#无法在参数化类型上使用类型转换或instranceof" class="headerlink" title="无法在参数化类型上使用类型转换或instranceof"></a>无法在参数化类型上使用类型转换或instranceof</h1><p>因为Java编译器会擦除通用代码中的所有类型参数，所以无法验证在运行时使用泛型类型的参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">rtti</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递给rtti方法的一系列参数化类型是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S = &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... &#125;</span><br></pre></td></tr></table></figure>
<p>运行时不跟踪类型参数，因此它不能区分ArrayList &lt;Integer&gt;和ArrayList &lt;String&gt;之间的区别。您可以做的最多的是使用无界通配符来验证list是否为ArrayList：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rtti</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123;  <span class="comment">// OK; instanceof requires a reifiable type</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，您不能转换为参数化类型，除非由无界通配符来参数化的。例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>然而，在某些情况下，编译器知道一个类型参数始终是有效的并允许该转换。例如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  <span class="comment">// OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="无法创建参数化类型数组"><a href="#无法创建参数化类型数组" class="headerlink" title="无法创建参数化类型数组"></a>无法创建参数化类型数组</h1><p>您不能创建参数化类型的数组。例如，以下代码无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// compile-time error</span></span><br><span class="line">```java</span><br><span class="line">以下代码说明了将不同类型插入到数组中时会发生什么：</span><br><span class="line">```java</span><br><span class="line">Object[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">strings[<span class="number">0</span>] = <span class="string">&quot;hi&quot;</span>;   <span class="comment">// OK</span></span><br><span class="line">strings[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">// An ArrayStoreException is thrown.</span></span><br></pre></td></tr></table></figure>
<p>如果您使用泛型列表尝试相同的事情，则会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] stringLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[];  <span class="comment">// compiler error, but pretend it&#x27;s allowed</span></span><br><span class="line">stringLists[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();   <span class="comment">// OK</span></span><br><span class="line">stringLists[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  <span class="comment">// An ArrayStoreException should be thrown,</span></span><br><span class="line">                                            <span class="comment">// but the runtime can&#x27;t detect it.</span></span><br></pre></td></tr></table></figure>
<p>如果允许使用参数化列表的数组，以前的代码将无法抛出所需的ArrayStoreException。</p>
<h1 id="无法创建、捕获、或抛出参数化类型对象"><a href="#无法创建、捕获、或抛出参数化类型对象" class="headerlink" title="无法创建、捕获、或抛出参数化类型对象"></a>无法创建、捕获、或抛出参数化类型对象</h1><p>泛型类不能直接或间接继承Throwable类。例如，以下类将不会编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueFullException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Throwable</span> &#123; <span class="comment">/* ... */</span> <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>一个方法不能捕获一个类型参数的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Exception</span>, J&gt; <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(List&lt;J&gt; jobs)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，您可以在throws子句中使用类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parser</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Exception</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(File file)</span> <span class="keyword">throws</span> T &#123;     <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="无法重载一个形式参数被擦除后是相同原生类型的方法"><a href="#无法重载一个形式参数被擦除后是相同原生类型的方法" class="headerlink" title="无法重载一个形式参数被擦除后是相同原生类型的方法"></a>无法重载一个形式参数被擦除后是相同原生类型的方法</h1><p>一个类不能有两个在类型擦除后将具有相同的签名重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;String&gt; strSet)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载将共享相同的类文件表示，并将生成编译时错误。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（二）原生类型</title>
    <url>/2017/06/07/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="原生类型"><a href="#原生类型" class="headerlink" title="原生类型"></a>原生类型</h1><p>原生类型（raw type）是没有任何类型参数的泛型类或接口的名称。例如，给定泛型Box类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>要创建一个参数化类型的Box &lt;T&gt;，您可以为形式类型参数T提供一个实际的类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>如果实际的类型参数被省略，您将创建一个Box &lt;T&gt;的原生类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Box</span> <span class="variable">rawBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br></pre></td></tr></table></figure>
<p>因此，Box是泛型类型Box &lt;T&gt;的原生类型。但是，非泛型类或接口类型不是原生类型。<br>原生类型存在于许多遗留代码中，因为许多API类（如Collections类）在JDK 5.0之前不是泛型的。当使用原生类型时，您实质上是获得了一个预泛型 - 一个提供Object的Box。为了向后兼容，允许将参数化类型分配给其原生类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line"><span class="type">Box</span> <span class="variable">rawBox</span> <span class="operator">=</span> stringBox;               <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>但是，如果将原始类型分配给参数化类型，则会收到警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Box</span> <span class="variable">rawBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();           <span class="comment">// rawBox is a raw type of Box&lt;T&gt;</span></span><br><span class="line">Box&lt;Integer&gt; intBox = rawBox;     <span class="comment">// warning: unchecked conversion</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您使用原生类型来调用在相应的泛型类型中定义的泛型方法，则还会收到警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line"><span class="type">Box</span> <span class="variable">rawBox</span> <span class="operator">=</span> stringBox;</span><br><span class="line">rawBox.set(<span class="number">8</span>);  <span class="comment">// warning: unchecked invocation to set(T)</span></span><br></pre></td></tr></table></figure>

<p>警告显示，原生类型绕过泛型类型检查，将不安全代码的捕获推迟到运行时。因此，您应避免使用原生类型。<br>在类型擦除章节有关于Java编译器如何使用原生类型的更多信息。</p>
<h1 id="未检查错误信息"><a href="#未检查错误信息" class="headerlink" title="未检查错误信息"></a>未检查错误信息</h1><p>如前所述，当将旧代码与泛型代码混用时，您可能会遇到类似于以下内容的警告消息：<br>**Note: Example.java uses unchecked or unsafe operations.<br>Note: Recompile with -Xlint:unchecked for details.   **<br>当使用旧的API对一个原生类型进行操作的时候，可能会发生这种情况，如以下示例所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; bi;</span><br><span class="line">        bi = createBox();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Box <span class="title function_">createBox</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“unchecked”表示编译器没有足够的类型信息来执行所有必要的类型检查以确保类型安全。尽管编译器提供了一个提示，但是默认情况下，“unchecked”警告是被禁用的。要查看所有“unchecked”警告，请使用Xlint:unchecked重新编译。<br>使用-Xlint：unchecked重新编译前面的示例可以显示以下附加信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WarningDemo.java:4: warning: [unchecked] unchecked conversion</span><br><span class="line">found   : Box</span><br><span class="line">required: Box&lt;java.lang.Integer&gt;</span><br><span class="line">        bi = createBox();</span><br><span class="line">                      ^</span><br><span class="line">1 warning</span><br></pre></td></tr></table></figure>
<p>要完全禁用“unchecked”警告，请使用-Xlint：unchecked标志。@SuppressWarnings（“unchecked”）注释也会抑制“unchecked”的警告。如果您不熟悉@SuppressWarnings语法，请参阅注释。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（五）泛型，继承和子类型</title>
    <url>/2017/06/09/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89%E6%B3%9B%E5%9E%8B%EF%BC%8C%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>如您所知，如果类型是兼容的，则可以将一种类型的对象分配给另一种类型的对象。例如，您可以分配一个Integer给一个Object，因为Object是Integer的父类型之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">someInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">someObject = someInteger;   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在面向对象的术语中，这被称为“是一个（is a）”关系。因为Integer是一种Object，所以这种赋值是允许的。但是Integer同时也是一种Number,所以下面的代码也是有效的：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">(Number n)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">someMethod(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));   <span class="comment">// OK</span></span><br><span class="line">someMethod(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">10.1</span>));   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>泛型同样如此。您可以执行一个泛型类型调用，将Number作为其类型参数传递，并且如果参数与Number兼容，则将允许任何后续的add方法调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Number&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Number&gt;();</span><br><span class="line">box.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));   <span class="comment">// OK</span></span><br><span class="line">box.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">10.1</span>));  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>现在考虑以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>它接受什么类型的论据？通过查看其签名，您可以看到它接受一个类型为Box &lt;Number&gt;的单个参数。但是，这是什么意思？它是否允许按照您的预期传递Box &lt;Integer&gt;或Box &lt;Double&gt;？答案是“否”，因为Box &lt;Integer&gt;和Box &lt;Double&gt;不是Box &lt;Number&gt;的子类型。<br>这是在使用泛型编程时一个最常见的误解，但这是一个重要的学习概念<br>![generics-subtypeRelationship](&#x2F;images&#x2F;java base&#x2F;generics-subtypeRelationship.gif)</p>
<blockquote>
<p>注意：给定两个具体类型A和B（例如Number和Integer），MyClass &lt;A&gt;与MyClass &lt;B&gt;无关，无论A和B是否相关。 MyClass &lt;A&gt;和MyClass &lt;B&gt;的父对象是Object。</p>
</blockquote>
<h1 id="泛型类和子类型"><a href="#泛型类和子类型" class="headerlink" title="泛型类和子类型"></a>泛型类和子类型</h1><p>以Collection类作为示例，ArrayList &lt;E&gt;实现List &lt;E&gt;，并且List &lt;E&gt;扩展Collection &lt;E&gt;。所以ArrayList &lt;String&gt;是List &lt;String&gt;的子类型，它是Collection &lt;String&gt;的子类型。只要不改变类型参数，子类型之间的关系将保留在类型之间。<br>![generics-sampleHierarchy](&#x2F;images&#x2F;java base&#x2F;generics-sampleHierarchy.gif)</p>
<p>现在想象我们要定义我们自己的List接口PayloadList，它将泛型类型P的可选值与每个元素相关联。其声明可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PayloadList</span>&lt;E,P&gt; <span class="keyword">extends</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setPayload</span><span class="params">(<span class="type">int</span> index, P val)</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下PayloadList参数都是List &lt;String&gt;的子类型：</p>
<ul>
<li>PayloadList&lt;String,String&gt;</li>
<li>PayloadList&lt;String,Integer&gt;</li>
<li>PayloadList&lt;String,Exception&gt;</li>
</ul>
<p>![generics-payloadListHierarchy](&#x2F;images&#x2F;java base&#x2F;generics-payloadListHierarchy.gif)</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（八）类型擦除</title>
    <url>/2017/06/09/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E5%85%AB%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
    <content><![CDATA[<p>泛型被引入Java语言，以便在编译时提供更严格的类型检查，并支持通用编程。为了实现泛型，Java编译器将类型擦除应用于：</p>
<ul>
<li>在泛型类中用它的边界替换所有类型参数，或者以Object替代如果类型参数是无界的。因此，编译生成的字节码只包含普通的类，接口和方法。</li>
<li>必要时插入类型转换以保护类型安全。</li>
<li>生成桥接方法来保留扩展泛型类型中的多态。</li>
</ul>
<p>类型擦除确保不会为参数化类型而创建新类;因此，泛型不会导致运行时额外的开销。</p>
<span id="more"></span>
<h1 id="泛型类型的擦除"><a href="#泛型类型的擦除" class="headerlink" title="泛型类型的擦除"></a>泛型类型的擦除</h1><p>在类型擦除过程中，如果类型参数是有界的，则Java编译器将擦除所有类型参数，并将其替换为其边界第一个类型，如果类型参数为无边界，则该对象将替换为Object。<br>考虑以下通用类，表示单链表中的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> &#125;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型参数T是无界的，所以Java编译器用Object替换它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以下示例中，泛型Node类使用有界类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器将有界类型参数T替换为第一个边界类，Comparable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Comparable data, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getData</span><span class="params">()</span> &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型方法的擦除"><a href="#泛型方法的擦除" class="headerlink" title="泛型方法的擦除"></a>泛型方法的擦除</h1><p>Java编译器还会擦除泛型方法参数中的类型参数。考虑以下泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Counts the number of occurrences of elem in anArray.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">count</span><span class="params">(T[] anArray, T elem)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为T是无边界的，Java编译器用Object替换它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(Object[] anArray, Object elem)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设定义了以下类：<br>class Shape { &#x2F;* … <em>&#x2F; }<br>class Circle extends Shape { &#x2F;</em> … <em>&#x2F; }<br>class Rectangle extends Shape { &#x2F;</em> … *&#x2F; }<br>您可以编写一个泛型方法来绘制不同的形状：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Shape</span>&gt; <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(T shape)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器将T替换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型擦除和桥接方法的影响"><a href="#类型擦除和桥接方法的影响" class="headerlink" title="类型擦除和桥接方法的影响"></a>类型擦除和桥接方法的影响</h1><p>有时类型擦除会导致您可能没有预料到的情况。以下示例显示了这种情况如何发生的。这个示例（在Bridge方法中描述）显示了编译器有时会创建一种称为桥接方法的合成方法，作为类型擦除过程的一部分。<br>给出以下两个类：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Node.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123; <span class="built_in">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类型擦除后，此代码变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyNode</span> <span class="variable">mn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> (MyNode)mn;         <span class="comment">// A raw type - compiler throws an unchecked warning</span></span><br><span class="line">n.setData(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (String)mn.data; <span class="comment">// Causes a ClassCastException to be thrown.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是执行代码时会发生什么：</p>
<ul>
<li>n.setData(“Hello”);导致在MyNode类的对象上执行setData(Object)方法。（MyNode类从Node继承了setData(Object)。）</li>
<li>在setData（Object）的方法体中，由n引用的字段的对象被分配为String。</li>
<li>可以访问通过mn引用的同一对象的字段数据，并且预期它是一个整数（因为mn是一个MyNode，它是一个Node &lt;Integer&gt;。</li>
<li>尝试将一个String分配给Integer会导致Java编译器在分配时插入的转换的ClassCastException。</li>
</ul>
<h2 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h2><p>当编译一个类或接口，它是继承自参数化的类或接口时，编译器可能需要创建一个被称为桥接方法的合成方法，作为其类型擦除的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，则可能会感到困惑。</p>
<p>类型擦除后，Node和MyNode类变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Node.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123; <span class="built_in">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在经过类型擦除后，方法签名不匹配。 Node的方法变为setData（Object），而MyNode的方法为setData（Integer）。因此，MyNode setData方法不会覆盖Node 的setData方法。<br>为了解决这个问题，并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bridge method generated by the compiler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如你所看到的，与Node类的setData方法有相同签名的桥接方法，在类型擦除之后将委托给原始的setData方法。</p>
<h1 id="不可具体化类型"><a href="#不可具体化类型" class="headerlink" title="不可具体化类型"></a>不可具体化类型</h1><p>类型擦除部分讨论了编译器删除与type parameters 和type arguments相关的信息的过程。类型擦除有与变量参数（也称为可变参数）方法相关，其变量形式参数是不可具体化的类型。</p>
<h2 id="不可具体化类型-1"><a href="#不可具体化类型-1" class="headerlink" title="不可具体化类型"></a>不可具体化类型</h2><p>可具体化类型是一种在整个运行时期它的类型信息都可用的类型。这包括原始类型，非泛型类型，原生类型，以及无边界通配符的调用。<br>不可具体化类型是其信息会在编译时期被类型擦除去除的类型那个。也就是指未定义为无边界通配符的泛型的调用。一个不可具体化类型它的所有信息在允许时期不是都可使用的。比如不可具体化类型List&lt;String&gt;和List&lt;Number&gt;，在运行时期JVM不能得知他们之间的类型差别。如“泛型的限制”章节所示，有种情况下，不能使用不可具体化类型类型：比如在instanceof表达式中，或者作为数组中的元素时。</p>
<h2 id="堆污染"><a href="#堆污染" class="headerlink" title="堆污染"></a>堆污染</h2><p>当参数化类型的变量指向的不是一个参数化类型的对象时，会发生堆污染。如果程序执行一些会在编译时产生“unchecked”警告的操作，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，如果涉及参数化类型（例如，转换或方法调用）的操作的正确性不可得到验证的话，就会产生一个”unchecked”警告。例如，当混合原生类型和参数化类型时，或者执行未检查的转换时，会发生堆污染。<br>在正常情况下，当同时编译所有代码时，编译器会发出一个”unchecked”警告，以引起您对潜在的堆污染的注意。如果您单独编译部分代码，则很难发现堆污染的潜在风险。如果确保您的代码编译没有警告，则不会有堆污染的发生。</p>
<h2 id="使用不可具体化形式可变参数方法的潜在漏洞"><a href="#使用不可具体化形式可变参数方法的潜在漏洞" class="headerlink" title="使用不可具体化形式可变参数方法的潜在漏洞"></a>使用不可具体化形式可变参数方法的潜在漏洞</h2><p>包含可变输入参数的泛型方法可能导致堆污染。<br>考虑下面的ArrayBuilder类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addToList</span> <span class="params">(List&lt;T&gt; listArg, T... elements)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">faultyMethod</span><span class="params">(List&lt;String&gt;... l)</span> &#123;</span><br><span class="line">    Object[] objectArray = l;     <span class="comment">// Valid</span></span><br><span class="line">    objectArray[<span class="number">0</span>] = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> l[<span class="number">0</span>].get(<span class="number">0</span>);       <span class="comment">// ClassCastException thrown here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面示例中，HeapPollutionExample 使用了 ArrayBuiler 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapPollutionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(<span class="string">&quot;Hello!&quot;</span>), Arrays.asList(<span class="string">&quot;World!&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时，ArrayBuilder.addToList方法的定义会产生以下警告：</p>
<blockquote>
<p>warning: [varargs] Possible heap pollution from parameterized vararg type T</p>
</blockquote>
<p>当编译器遇到一个可变参数方法，它将可变形式参数转换到一个数组中。然而Java编程语言不允许创建参数化类型的数组。在方法arrayBuilder.addToList中，编译器将可变形式参数T…elements转换成一个形式参数T[] elements数组。然而由于类型擦除，编译器将可变形式参数转换为Object[] elements。因此，这里有堆污的可能性。  </p>
<p>以下语句将可变形式参数l分配给Object数组objectArgs：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure>
<p>这个声明可能会引起堆污。一个与可变形式参数l的参数化类型不相匹配的值可以被分配给变量objectArray，因此可以分配给l。但是，编译器在此语句中不会生成”unchecked“警告。当编译器将形式参数List &lt;String&gt; … l转换为形式参数List [] l时，编译器已经生成了一个警告。因此这个声明是有效的;这里变量l是List []类型，而List []是Object []的子类型。<br>因此，如果将任何类型的List对象分配给objectArray数组的任何部分，编译器不会发出警告或错误，就如下面语句所展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectArray[<span class="number">0</span>] = Arrays.asList(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>这个语句将一个包含一个Integer对象的List对象分配给了objectArray数组的第一个索引<br>假如你使用以下语句调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBuilder.faultyMethod</span><br><span class="line">ArrayBuilder.faultyMethod(Arrays.asList(<span class="string">&quot;Hello!&quot;</span>), Arrays.asList(<span class="string">&quot;World!&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在运行时期，以下语句JVM抛出一个ClassCastException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassCastException thrown here</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> l[<span class="number">0</span>].get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>存储在变量l的第一个索引处的对象是List &lt;Integer&gt;类型，但此语句却期待返回一个List &lt;String&gt;类型的对象。</p>
<h2 id="阻止来自使用不可具体化形式参数的可变参数方法的警告"><a href="#阻止来自使用不可具体化形式参数的可变参数方法的警告" class="headerlink" title="阻止来自使用不可具体化形式参数的可变参数方法的警告"></a>阻止来自使用不可具体化形式参数的可变参数方法的警告</h2><p>如果你声明一个可变参数方法有一个参数化类型的参数，并且你确保方法体内不会因不正确处理可变形式参数而抛出一个ClassCastException或者其他类似的异常，你可以通过向静态和非构造函数方法声明中添加以下注释，来防止编译器为这些类型的可变参数方法生成的警告：<br>@SafeVarargs<br>@SafeVarargs注释是方法合同的一个文档部分; 此注释声明该方法的实现将不会不正确地处理可变形式参数。<br>尽管不太可取，但也可以通过在方法声明中加入以下内容来抑制这种警告：<br>@SuppressWarnings({“unchecked”, “varargs”})<br>但是，这种方法不会抑制从该方法调用处产生的警告。如果您不熟悉@SuppressWarnings语法，请参阅”注释“。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（六）类型推断</title>
    <url>/2017/06/09/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</url>
    <content><![CDATA[<p>类型推断是Java编译器查看每个方法调用和相应声明的能力，以确定调用适用的类型参数（或参数）。推断算法确定参数的类型，如果可用的话，这个类型将被分配或返回。最后，推断算法尝试找到适用于所有参数的最适应类型。<br>为了说明这个最后一点，在下面的例子中，推断确定传递给pick方法的第二个参数的类型是Serializable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T <span class="title function_">pick</span><span class="params">(T a1, T a2)</span> &#123; <span class="keyword">return</span> a2; &#125;</span><br><span class="line"><span class="type">Serializable</span> <span class="variable">s</span> <span class="operator">=</span> pick(<span class="string">&quot;d&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这种情况下，我们使用两种不同类型的T：String和ArryaList。编译器然后使用最普适的类型参数，使得方法调用类型正确。在这种情况下，它推断T是两种类型共同实现接口类型Serializable。</p>
<h1 id="类型推断和泛型方法"><a href="#类型推断和泛型方法" class="headerlink" title="类型推断和泛型方法"></a>类型推断和泛型方法</h1><p>在泛型方法中引入了类型推断，这使您能够像普通的方法一样调用泛型方法，而不在尖括号之间指定类型，考虑下面的例子BoxDemo，它需要Box类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> <span class="title function_">addBox</span><span class="params">(U u, </span></span><br><span class="line"><span class="params">      java.util.List&lt;Box&lt;U&gt;&gt; boxes)</span> &#123;</span><br><span class="line">    Box&lt;U&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">    box.set(u);</span><br><span class="line">    boxes.add(box);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> <span class="title function_">outputBoxes</span><span class="params">(java.util.List&lt;Box&lt;U&gt;&gt; boxes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Box&lt;U&gt; box: boxes) &#123;</span><br><span class="line">      <span class="type">U</span> <span class="variable">boxContents</span> <span class="operator">=</span> box.get();</span><br><span class="line">      System.out.println(<span class="string">&quot;Box #&quot;</span> + counter + <span class="string">&quot; contains [&quot;</span> +</span><br><span class="line">             boxContents.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br><span class="line">    BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(<span class="number">10</span>), listOfIntegerBoxes);</span><br><span class="line">    BoxDemo.addBox(Integer.valueOf(<span class="number">20</span>), listOfIntegerBoxes);</span><br><span class="line">    BoxDemo.addBox(Integer.valueOf(<span class="number">30</span>), listOfIntegerBoxes);</span><br><span class="line">    BoxDemo.outputBoxes(listOfIntegerBoxes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是此示例的输出：<br>Box #0 contains [10]<br>Box #1 contains [20]<br>Box #2 contains [30]<br>泛型方法addBox定义了一个名为U的类型参数。通常，Java编译器可以推断泛型方法调用的类型参数。因此，在大多数情况下，您不必指定它们。例如，要调用泛型方法addBox，可以使用类型见证指定类型参数，如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(<span class="number">10</span>), listOfIntegerBoxes);</span><br></pre></td></tr></table></figure>
<p>或者，如果省略类型见证，Java编译器会自动推断（从方法的参数），类型参数是Integer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BoxDemo.addBox(Integer.valueOf(<span class="number">20</span>), listOfIntegerBoxes);</span><br></pre></td></tr></table></figure>

<h1 id="类型推断和泛型类"><a href="#类型推断和泛型类" class="headerlink" title="类型推断和泛型类"></a>类型推断和泛型类</h1><p>只要编译器可以从上下文中推断出类型参数，就可以使用空的一组类型参数（&lt;&gt;）替换调用泛型构造函数所需的类型参数。这对尖括号是非正式地称为菱形。</p>
<p>例如，考虑以下变量声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>您可以使用空的一组类型参数（&lt;&gt;）替换构造函数的参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>请注意，要在泛型类实例化过程中使用类型推断，您必须使用菱形符号。在以下示例中，编译器生成未经检查的转换警告，因为HashMap（）构造函数引用了HashMap原生类型，而不是Map &lt;String，List &lt;String &gt;&gt;类型： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// unchecked conversion warning</span></span><br></pre></td></tr></table></figure>

<h1 id="类型推断和泛型类以及非泛型类的泛型构造方法"><a href="#类型推断和泛型类以及非泛型类的泛型构造方法" class="headerlink" title="类型推断和泛型类以及非泛型类的泛型构造方法"></a>类型推断和泛型类以及非泛型类的泛型构造方法</h1><p>请注意，在泛型类以及非泛型类中，构造方法都可以是泛型（换而言之，声明自己的形式类型参数）。考虑以下示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;X&gt; &#123;</span><br><span class="line">  &lt;T&gt; MyClass(T t) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑下面的类MyClass的实例化：<br>new MyClass&lt;Integer&gt;(“”)<br>此语句创建一个参数化类型MyClass &lt;Integer&gt;的实例; 该语句显式指定了泛型类MyClass &lt;X&gt;的形式类型参数X的类型为Integer。请注意，此泛型类的构造函数包含一个形式类型参数T. 编译器推断出此泛型类的构造函数的形式类型参数T的类型为String（因为此构造函数的实际参数是String对象）。<br>在Java SE 7之前的版本的编译器能够推断泛型构造函数的实际类型参数，类似于泛型方法。但是，J在ava SE 7及更高版本中如果您使用菱形符号（&lt;&gt;），编译器可以推断要实例化的泛型类的实际类型参数。请考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass&lt;Integer&gt; myObject = <span class="keyword">new</span> <span class="title class_">MyClass</span>&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，编译器推断泛型类Myclass&lt;x&gt;中形式参数X的类型为Integer。它也推断出泛型类的构造方法的形式参数T额类型为String。</p>
<blockquote>
<p>需要注意的是，推断算法只使用调用参数，目标类型以及可能的明显的预期返回类型来推断类型。推断算法不使用程序后期的结果。</p>
</blockquote>
<h1 id="目标类型"><a href="#目标类型" class="headerlink" title="目标类型"></a>目标类型</h1><p>Java编译器利用目标类型来推断泛型方法调用的类型参数。表达式的目标类型是Java编译器期望的数据类型，具体取决于表达式的出现位置。考虑方法Collections.emptyList，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">emptyList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>考虑以下赋值语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; listOne = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p>此语句期待List &lt;String&gt;的实例;这个数据类型就是是目标类型。因为方法emptyList返回一个类型为List &lt;T&gt;的值，编译器会推断类型参数T一定是值String。这可以在Java SE 7和8中使用。或者，您可以使用类型见证并指定T的值如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; listOne = Collections.&lt;String&gt;emptyList();</span><br></pre></td></tr></table></figure>
<p>但是，在这种情况下这不是必需的。但在其他情况下是有必要的。请考虑以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processStringList</span><span class="params">(List&lt;String&gt; stringList)</span> &#123;</span><br><span class="line">    <span class="comment">// process stringList</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设你想使用一个空List调用processStringList方法。在Java SE 7中，以下语句不能编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processStringList(Collections.emptyList());</span><br></pre></td></tr></table></figure>
<p>Java SE 7编译器会生成类似于以下内容的错误消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; cannot be converted to List&lt;String&gt;</span><br></pre></td></tr></table></figure>

<p>编译器需要一个类型参数T的值，所以它从值Object开始。因此，对Collections.emptyList的调用返回一个类型为List &lt;Object&gt;的值，它与processStringList方法不兼容。因此，在Java SE 7中，必须指定type参数的值的值如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processStringList(Collections.&lt;String&gt;emptyList());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 泛型（四）有界类型参数</title>
    <url>/2017/06/07/java-%E6%B3%9B%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E6%9C%89%E7%95%8C%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>可能有时候要限制在参数化类型中可以用作类型参数的类型。例如，一个对数字进行操作的方法可能只希望接受Number或其子类的实例。这就是有界类型参数。<br>要声明一个有界类型的参数，需要列出类型参数的名称，后跟extends关键字，再后跟其上边界，在此示例中为Number。请注意，在这种情况下，extends在一般意义上用于表示“extends”（如在类中）或“implements”（如在接口中）。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;          </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">inspect</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T: &quot;</span> + t.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;U: &quot;</span> + u.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();</span><br><span class="line">        integerBox.set(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">        integerBox.inspect(<span class="string">&quot;some text&quot;</span>); <span class="comment">// error: this is still String!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改我们的泛型方法，添加了这个有界类型的参数后，编译现在将失败，因为我们在调用inspect时传入了一个String：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Box.java:21: &lt;U&gt;inspect(U) <span class="keyword">in</span> Box&lt;java.lang.Integer&gt; cannot</span><br><span class="line">  be applied to (java.lang.String)</span><br><span class="line">                        integerBox.inspect(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">                                  ^</span><br><span class="line">1 error</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了限制可用于实例化通用类型的类型之外，有界类型参数还允许您调用边界对象中定义的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NaturalNumber</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NaturalNumber</span><span class="params">(T n)</span>  &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isEven方法通过n调用Integer类中定义的intValue方法。</p>
<h1 id="多重边界"><a href="#多重边界" class="headerlink" title="多重边界"></a>多重边界</h1><p>前面示例中说明了在单边界类型参数的使用，但类型参数可以有多个边界：</p>
<blockquote>
<p>&lt;T extends B1 &amp; B2 &amp; B3&gt;</p>
</blockquote>
<p>一个有多个边界的类型变量是在边界中所有类型的子类型。如果其中一个边界是一个类，则必须首先指定。例如：<br>Class A { &#x2F;* … <em>&#x2F; }<br>interface B { &#x2F;</em> … <em>&#x2F; }<br>interface C { &#x2F;</em> … *&#x2F; }  </p>
<p>class D &lt;T extends A &amp; B &amp; C&gt; { &#x2F;* … *&#x2F; }<br>如果指定边界A为第一个，那么就会产生一个编译时期错误:</p>
<p>class D &lt;T extends B &amp; A &amp; C&gt; { &#x2F;* … *&#x2F; }  &#x2F;&#x2F; compile-time error</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 泛型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java 编码与Charset.defaultCharset()问题</title>
    <url>/2017/05/04/java-%E7%BC%96%E7%A0%81%E4%B8%8ECharset-defaultCharset-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>　　在学习I&#x2F;O字符流的时候，使用FileReader读取一份txt文档时，中文字符显示出现了乱码问题。Java中字符流实际底层实际还是使用字节流，再由转换流来实现编码解码工作的。当我们没有设置字符编码时，转换流会自动获取默认的系统编码字符集。<br>具体我们可以查看相关源码，从FileReader的初始化开始，下面是它的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>可以发现FileReader初始化时使用super(new FileInputStream(fileName))调用父类构造方法，而FileReader父类正是字节字符输入转换流InputStreamReader，我们进入InputStreamReader查看其被调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>); <span class="comment">// 编码是在这里进行设置，最后一个参数指定字符集，但这里传入了一个null</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进StreamDecoder.forInputStreamReader方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title function_">forInputStreamReader</span><span class="params">(InputStream var0, Object var1, String var2)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">var3</span> <span class="operator">=</span> var2;     <span class="comment">// var2参数为字符集的名称</span></span><br><span class="line">       <span class="keyword">if</span>(var2 == <span class="literal">null</span>) &#123;     <span class="comment">//从传入参数知道var2为(String)null</span></span><br><span class="line">           var3 = Charset.defaultCharset().name(); <span class="comment">//这里获取默认字符集名称</span></span><br><span class="line">       &#125;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面在Charset.defaultCharset()获取使用的字符集名称，我们进入该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (defaultCharset == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Charset.class) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">csn</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GetPropertyAction</span>(<span class="string">&quot;file.encoding&quot;</span>));<span class="comment">//file.encoding正是系统文件字符集的配置名称啦</span></span><br><span class="line">        <span class="type">Charset</span> <span class="variable">cs</span> <span class="operator">=</span> lookup(csn);</span><br><span class="line">        <span class="keyword">if</span> (cs != <span class="literal">null</span>)</span><br><span class="line">            defaultCharset = cs;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            defaultCharset = forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultCharset;</span><br></pre></td></tr></table></figure>
<p>可以看出当没有设置字符集名称时，在AccessController.doPrivileged(new GetPropertyAction(“file.encoding”));中会去获取我们操作系统使用的字符集，来作为转换流的编码解码格式。</p>
<p>而系统字符集的编码是根据我们设置的系统语言决定的，windows系统语言是中文时，默认字符集应该是GBK,创建的txt文档字符默认也是GBK格式的，按理来说我这里不应该出现乱码问题。<br>于是将txt文档另存为UTF-8格式，再运行一次程序，乱码问题消失，这说明FileReader读取文件时使用的是UTF-8格式，用代码获取字符流使用编码格式，以及Charset使用的字符集，和当前系统使用字符集，它们是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;fileReader encoding is :&quot;</span>+fileReader.getEncoding());</span><br><span class="line"></span><br><span class="line">String defaultCharsetName= Charset.defaultCharset().displayName();</span><br><span class="line">String systemEncoding= System.getProperties().get(<span class="string">&quot;file.encoding&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;systemEncoding is :&quot;</span>+systemEncoding);</span><br><span class="line">System.out.println(<span class="string">&quot;defaultCharsetName is :&quot;</span>+defaultCharsetName);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<blockquote>
<p>fileReader encoding is :UTF8<br>systemEncoding is :UTF-8<br>defaultCharsetName is :UTF-8  </p>
</blockquote>
<p>显示字符集使用的都是UTF-8，并不是我当前操作系统字的GBK符集，而很可能是IDE设置的字符编码，我是使用的intelliJ idea,在File→Settings→File Encodings→Project Encoding里将文件编码改为GBK,再次执行代码</p>
<blockquote>
<p>fileReader encoding is :GBK<br>systemEncoding is :GBK<br>defaultCharsetName is :GBK  </p>
</blockquote>
<p>此时乱码问题消失，并且可见IDE会影响JVM获取系统的字符集，在idea的run窗口运行程序时会显示其编译运行命令的一些参数如图<br>![run window](\images\other\idea run.png)<br>注意标红区域，这里idea在使用jdk时会事先设置了字符编码格式，当我们使用java获取系统编码时，获取的只是idea设置的编码格式。如果想看不在idea运行结果，我们可以命令行编译运行一下代码，命令行输出</p>
<blockquote>
<p>fileReader encoding is :GBK<br>systemEncoding is :GBK<br>defaultCharsetName is :GBK</p>
</blockquote>
<p>显示的是系统使用的字符集。</p>
]]></content>
      <categories>
        <category>java遇到的问题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（一）概述</title>
    <url>/2017/05/16/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>java.net提供了以下地址相关类</p>
<ul>
<li><strong>InetAddress</strong></li>
<li><strong>Inet4Address</strong></li>
<li><strong>Inet6Address</strong></li>
<li><strong>SocketAddress</strong></li>
<li><strong>InetSocketAddress</strong></li>
</ul>
<p>对于IP地址，有InetAddress,Inet4Address和Inet6Address三个类可用。InetAddress表示IP地址，它是IP使用的32位或128位无符号数，用来构建TCP和UDP协议的下级协议。Inet4Address提供IPv4地址，Inet6Address提供IPv6地址，他们都是InetAddress的子类。    </p>
<span id="more"></span>

<p>对于套接字地址，提供了SocketAddress和InetSocketAddress两个类。SockeAddress是一个抽象的独立于特定协议的套接字地址，是一个抽象类。InetSocketAddress 是SocketAddress的子类，它表示一个IP套接字地址，它有三种表示形式</p>
<ul>
<li>一个IP地址和一个端口号（192.168.0.01：8888）</li>
<li>一个主机名和一个端口号（localhost：8888）</li>
<li>只有端口号（8888）</li>
</ul>
<p>后一种是假设有一个通配符的IP地址。</p>
<h1 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h1><p>以下类用来建立一个正常的TCP连接</p>
<ul>
<li>ServerSocket</li>
<li>Socket</li>
</ul>
<p>对于客户端和服务端之间的简单连接，ServerSocket和Socket是经常会使用到的。</p>
<p>ServerSocket表示服务器上等待并监听客户端服务请求的套接字。一个socket表示一个服务器和客户端之间通信的端点。当服务器获得服务请求时，它创建一个socket与客户端进行通信，并且在ServerSocket上继续收听其他请求 。客户端同样创建一个 socket与服务器进行通信。序列如下所示：<br><img src="/images/other/sockets.png" alt="TCP Connect"><br>一旦建立连接，getInputStream()和getOutputStream()可以用来套接字之间的通信。</p>
<h1 id="通过UDP接收-x2F-发送数据包"><a href="#通过UDP接收-x2F-发送数据包" class="headerlink" title="通过UDP接收&#x2F;发送数据包"></a>通过UDP接收&#x2F;发送数据包</h1><p>以下类用来通过UDP接收和发送数据包</p>
<ul>
<li>DatagramPacket</li>
<li>DatagramSocket</li>
</ul>
<p>DatagramPacket表示一个数据包。数据报包用于无连接传送，通常包括目的地址和端口信息。 DatagramSocket是用于通过UDP经由网络发送和接收数据包的套接字。DatagramSocket通过调用send(DatagramPacket dp)方法来发送一个DatagramPacket，同样通过调用recevie(DatagramPacket dp)来接收一个DatagramPacket（MulticastSocket可能接收&#x2F;发送一个DatagramPacket到一个群组，它是DatagramSocket的子类，额外添加了多点广播功能）</p>
<h1 id="查找-x2F-识别网络资源"><a href="#查找-x2F-识别网络资源" class="headerlink" title="查找&#x2F;识别网络资源"></a>查找&#x2F;识别网络资源</h1><p>以下类用于查找和识别网络资源.</p>
<ul>
<li>URI</li>
<li>URL </li>
<li>URLClassLoader</li>
<li>URLConnection</li>
<li>URLStreamHandler</li>
<li>HttpURLConnection</li>
<li>JarURLConnection</li>
</ul>
<p>这里最常使用的类是URI,URL,URLConnection和HttpURLConnection.</p>
<p>URI代表一个统一资源标识符，它是资源的标识符，但不一定是该资源的定位符。URL代表资源的统一资源定位符。URL是URI的一个子集，尽管类URL不是 URI的子类。简而言之，URL描述了如何访问资源，而URI可能是也可能不是。统一资源名（URN）是URI的另一个子集，但是没有它的java类存在。</p>
<p>URLConnection是表示所有应用程序和以URL标识的网络资源之间连接的抽象父类。给定一个URL和一个协议，URL.openConnection()返回一个URLConnection的适当实现的实例（协议在URL是已知的）。这个实例提供了URLConnection.connect()实际打开连接，访问URL的方法。</p>
<p>HttpURLConnection是最常使用的URLConnection实现类。它使用http协议，该协议用来访问Web服务器上的内容。</p>
<h1 id="安全性（Security）"><a href="#安全性（Security）" class="headerlink" title="安全性（Security）"></a>安全性（Security）</h1><p>安全性包括认证和权限相关的类。认证涉及到用户认证，包括用户名和密码的检查。用户的身份验证可能需要在一定的场景下，比如当一个用户尝试访问一个URL。权限涉及到可能执行的操作，例如，除非存在NetPermission对的的setDefaultAuthenticator存在，否则调用Autherticator.setDefault(Authenticator a)会导致一个安全异常；</p>
<h2 id="验证（Authentication）"><a href="#验证（Authentication）" class="headerlink" title="验证（Authentication）"></a>验证（Authentication）</h2><p>一些代理和源服务器需要使用验证方案比如基本验证（BASIC）和摘要验证（DIGEST）来验证信息。例如，当使用http通过一个代理来连接时，这个代理需要验证，我们调用Authenticator类来获取用户名，密码，以及其他需要验证的条目。下面这些类和验证有关</p>
<ul>
<li>Authenticator</li>
<li>PasswordAuthentication</li>
</ul>
<p>除了用户验证方法外，抽象类Authenticator还有用于查询正在请求验证的方法（getRequestingXXX()）。这些通常是子类，一个子类的实例通过调用serDefault(Authenticator a)来向系统注册。(注意如果这里有一个安全管理器，则会检查安全策略是否允许NetPermission”setDefaultAuthenticator”)然后，当系统需要验证的时候，它会调用一个方法比如requestPasswordAuthentication().</p>
<p>PasswordAuthentication只是一个用户名和密码数据的容器。</p>
<h2 id="权限（Permissions）"><a href="#权限（Permissions）" class="headerlink" title="权限（Permissions）"></a>权限（Permissions）</h2><ul>
<li>SocketPermission</li>
<li>NetPermisson</li>
</ul>
<p>一个SocketPermisson由一个主机，可选的端口号范围，和一组在主机上可能执行的操作：connect，accept,listen和&#x2F;或resolve组成。它包括确定是否一个SocketPermission和另一个相等或意味着另一个Permission的方法。为了更容易检查一个权限是否存在，Socketpermission可能会被包含在一个PermissinCollection中。</p>
<p>NetPermission是一个各种网络权限命名的类。一个这儿有三个：setDefaultAuthenticator，requestPasswordAuthenticator,以及specifyStreamHandler。为了更容易检查一个权限是否存在，NetPermission可能会被包含在一个PermissinCollection中。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（三）Socket</title>
    <url>/2017/05/19/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89Socket/</url>
    <content><![CDATA[<p>URL和URLConnection为因特网提供了一个高水平的资源访问机制，但是有时我们需要一些低水平的网络通信，比如我们需要一个客户端-服务端程序。<br>这种客户端-服务端程序可能依据不同的需求，使用不同的协议，比如有的程序需要建立一种可靠的连接，以确保数据不会丢失，而有的则不需要。在网络模型中的传输层，提供给我们两种协议。</p>
<span id="more"></span>

<ul>
<li><strong>TCP</strong> 传输控制协议（Transmission Control Protocol ）</li>
<li><strong>UDP</strong> 用户数据包协议（User Datagram Protocol）</li>
</ul>
<p>TCP是一种可靠，面向连接的，且数据传输基于流的连接协议。使用TCP协议可以最大确保数据不会丢失，所以它使用于对可靠性要求较高的通信系统。<strong>应用层的Ftp,Http,Telnet,和Smtp都是基于TCP协议</strong>。</p>
<p>UDP则是一种不可靠，非连接，数据传输基于数据报的连接协议，它的特定是速度快，但不保证对方能够接收到数据，适用于那些对可靠性和连接要求不高的通信系统。<strong>应用层的Dns,Tftp,Dhcp,Nfs都是基于UDP协议</strong>.</p>
<p>无论是TCP还是UDP协议，都是点对点的通信连接，而要想在网络中寻找到指定的通信对象，就需要用IP地址和端口号作为其在网络中的唯一标记，而通过IP和端口号标记的每一个通信端，我们都称为一个Socket。两种协议都是通过socket进行相互的通信。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>java.net包中适用TCP协议的主要有两个类<strong>ServerSocket</strong>和<strong>Socket</strong>,分别代表服务端和客户端，在_java 网络编程（一）概述_中已经介绍过。<br>下面是一个创建TCP连接，客户端向服务端上传文件的示例代码。首先是创建一个客户端Client,它读取本地一个文件upload.txt,然后发送给服务端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">             <span class="type">BufferedInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\upload.txt&quot;</span>));</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> client.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">while</span> ((a = input.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            client.shutdownOutput();<span class="comment">//告诉服务端文件已经传输完毕</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面就是创建服务端类Server,接收Client传来的文件数据流，并将其保存到本地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\download.txt&quot;</span>));</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(clientSocket.getInputStream()))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">while</span> ((a = input.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中都使用了try-with-resource来处理Socket和I&#x2F;O流，所以不必我们自己来关闭。需要注意的是Server在使用getInputStream()获取网络中传输的文件I&#x2F;O流时，无法获知是否到文件尾，所以要在Cilent中调用client.shutdownOutput()来告知已经到文件尾。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>java.net包中适用UDP协议的主要有两个类<strong>DatagramPacket</strong>和<strong>DatagramSocket</strong>,分别代表数据包和一个Socket，在_java 网络编程（一）概述_中已经介绍过，此外java.net还有一个MulticastSocket类，提供了组播功能，可以将数据包群发给多个接收端。 </p>
<p>下面是一个创建UDP连接,来模拟两个客户端发送消息的场景,首先是发送端接收来自控制台的标准输入信息，以数据包的形式发送给接收端,当输入over时，则停止接收输入，关闭发送端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">sendClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in))) &#123;</span><br><span class="line"></span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> ((s = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(s.getBytes(), s.getBytes().length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8888</span>);</span><br><span class="line">                sendClient.send(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;over&quot;</span>.equals(s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着是一个接收端，接收发送端的数据包，并打印在控制台上，当接收发送端的over信息时，则停止监听接收数据包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecevieClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">recevieClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">            recevieClient.receive(packet);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()).trim();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(message))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们要使用组播功能，需要将RecevieClient中的DatagramSocket换成MulticastSocket，在SendClient中我们指定DatagramPacket中指定了发送的地址“localhost”,这里是本机IP,但是在使用组播功能的时候，必须使用组播IP地址否则MulticastSocket将抛出“java.net.SocketException: Not a multicast address”。我们要想多个接收端接收此数据包，通过MulticastSocket.joinGroup(InetAddress)加入该组播IP群组即可。下面是组播的接收端实例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecevieClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">multiClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//这里使用239.0.0.1组播地址，发送端同样需要修改发送的IP地址</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">group</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;239.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">//将该Socket加入此组播地址群组</span></span><br><span class="line">        multiClient.joinGroup(group);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">            multiClient.receive(packet);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()).trim();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(message))&#123;</span><br><span class="line">                <span class="comment">//结束时退出群组。</span></span><br><span class="line">                multiClient.leaveGroup(group);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（三）URL</title>
    <url>/2017/05/18/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89URL/</url>
    <content><![CDATA[<p>URL是统一资源定位符的缩写，用来在网络中定位获取资源。java.net包中提供一个URL类来代表一个URL地址。<br>尽管不确切，但是通常我们认为一个URL就是一个在万维网上的文件名，因为大多数的URL就是指一个在计算机或网络上的文件。但是需要注意的是URL同样可以指向网络上的其他资源，比如数据库查询和命令输出。</p>
<span id="more"></span>

<p>一个URL有两个主要组成部分</p>
<ul>
<li><strong>协议标识符</strong>：对于URL http :&#x2F;&#x2F;example.com来说，http就是协议标识符</li>
<li><strong>资源名</strong>：对于URL http: &#x2F;&#x2F;example.com来说，example.com就是资源名</li>
</ul>
<p>需要注意的是协议标识符与资源名之间通过“:&#x2F;&#x2F;”来分割，协议标识符表示用来获取资源的协议名称，例子中使用的是超文本传输协议（HTTP）,通常用于提供超文本文档。资源名是资源的完整地址。资源名的格式完全依赖它所使用的协议，但是对于大多数协议来说，包括HTTP,资源命名通常包括一下一个或多个组成。</p>
<ul>
<li><strong>主机名</strong>（Host Name）<br>资源所存在的机器名称</li>
<li><strong>文件名</strong>（File Name）<br>机器中文件路径地址</li>
<li><strong>端口号</strong>（Port Number）<br>需要连接的端口号（通常可选）</li>
<li><strong>引用</strong>（Reference）<br>资源中通常标识文件中特定位置（通常为可选）的命名锚点的引用。</li>
</ul>
<p>对于大多数协议来说，主机名和文件名都是必须的，而端口号和引用则是可选的。例如HTTP URL的资源名称必须指定网络上服务器（主机名）和该机器上的文档路径（文件名）</p>
<hr>
<h1 id="创建URL"><a href="#创建URL" class="headerlink" title="创建URL"></a>创建URL</h1><hr>
<h2 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h2><p>通常我们使用一个绝对路径创建一个URL,比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但也可是使用相对路径的方式创建一个URL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URL</span> <span class="variable">url1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(baseUrl,<span class="string">&quot;page1.html&quot;</span>);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(baseUrl,<span class="string">&quot;page2.html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式需要另一个URL对象来作为基础URL,后面一个String参数指定在这个URL基础上的资源名，这很适合一些用锚点命名的URL,比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">page1BottomURL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(page1URL,<span class="string">&quot;#BOTTOM&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>除了这些外，URL还提供了额外的两个构造方法，可以让分别传入URL的组成部分，协议名、主机名、端口号、和文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL(String protocol, String host, <span class="type">int</span> port, String file)</span><br><span class="line"></span><br><span class="line">URL(String protocol, String host, String file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们创建一个URL后，如果想要获得该URL的完整地址字符串，可以使用URL.toString()或URL.toExternalForm()方法，这两个是等效的。</p>
<blockquote>
<ul>
<li>当URL构造方法给定的参数为null，或者协议名是一个未知的协议，就会抛出MalformedURLException 异常。</li>
</ul>
</blockquote>
<ul>
<li>URL还是一个一次性写入的对象，一旦我们创建该对象后，它的任何属性都无法再修改（协议，主机名，文件名，或端口号）</li>
</ul>
<h2 id="URL内特殊字符"><a href="#URL内特殊字符" class="headerlink" title="URL内特殊字符"></a>URL内特殊字符</h2><p>有些URL地址里含有一些特殊的字符，我们需要对其进行编码，比如</p>
<p>　　<strong>http :&#x2F;&#x2F;example.com&#x2F;hello world&#x2F;</strong></p>
<p>因为hello world中包含一个空格，在创建URL时就需要特殊处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/hello%20world&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是当特殊字符比较多，或者我们不确定要访问的URL地址时，可以使用java.net.URI的多参构造创建一个URI对象，然后再调用它的方法转换为URL，这是java会帮我们自动进行编码工作，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;/hello world/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> uri.toURL();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以使用专门的工具类URLEncode来对URL路径进行编码，URLEncode有两个静态方法encode(String s)和encode(String s,String enc)前一个方法已经不推荐使用，后一个需要我们指定编码的字符集，该方法会将url中的特殊字符按照给定字符集编码成“%XX”形式的十六进制表示，示例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http&quot;</span>,<span class="string">&quot;example.com/&quot;</span>,URLEncoder.encode(<span class="string">&quot;hello world&quot;</span>,<span class="string">&quot;utf-8&quot;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是URLEncode.encode会把“&#x2F;”当作特殊字符进行编码，所以只能用来处理url中后缀部分。</p>
</blockquote>
<hr>
<h1 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h1><hr>
<p>URL类提供了一系列的方法用来查询URL对象的属性，如下表</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>getProtocol()</strong></td>
<td>返回URL的协议标识符</td>
</tr>
<tr>
<td><strong>getAuthority()</strong></td>
<td>返回URL的权限组件</td>
</tr>
<tr>
<td><strong>getHost()</strong></td>
<td>返回URL的主机名组件</td>
</tr>
<tr>
<td><strong>getPort()</strong></td>
<td>返回URL的端口号组件</td>
</tr>
<tr>
<td><strong>getPath()</strong></td>
<td>返回URL的路径组件</td>
</tr>
<tr>
<td><strong>getQuery()</strong></td>
<td>返回URL的查询组件</td>
</tr>
<tr>
<td><strong>getFile()</strong></td>
<td>返回URL的文件名，它相当于getPath()加上getQuery()</td>
</tr>
<tr>
<td><strong>getRef()</strong></td>
<td>返回URL的引用组件</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是不是每个URL都包含以上的组件，URL提供这些方法，只是因为HTTP URL包含这些组件。虽然URL支持各种协议，但是有点是以HTTP协议为中心设计的。</p>
</blockquote>
<p>下面是示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParseURL</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">aURL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com:80/docs/books/tutorial&quot;</span></span><br><span class="line">                           + <span class="string">&quot;/index.html?name=networking#DOWNLOADING&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;protocol = &quot;</span> + aURL.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">&quot;authority = &quot;</span> + aURL.getAuthority());</span><br><span class="line">        System.out.println(<span class="string">&quot;host = &quot;</span> + aURL.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;port = &quot;</span> + aURL.getPort());</span><br><span class="line">        System.out.println(<span class="string">&quot;path = &quot;</span> + aURL.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;query = &quot;</span> + aURL.getQuery());</span><br><span class="line">        System.out.println(<span class="string">&quot;filename = &quot;</span> + aURL.getFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;ref = &quot;</span> + aURL.getRef());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p><strong>protocol</strong> &#x3D; http<br><strong>authority</strong> &#x3D; example.com:80<br><strong>host</strong> &#x3D; example.com<br><strong>port</strong> &#x3D; 80<br><strong>path</strong> &#x3D; &#x2F;docs&#x2F;books&#x2F;tutorial&#x2F;index.html<br><strong>query</strong> &#x3D; name&#x3D;networking<br><strong>filename</strong> &#x3D;&#x2F;docs&#x2F;books&#x2F;tutorial&#x2F;index.html?  name&#x3D;networking<br><strong>ref</strong> &#x3D; DOWNLOADING  </p>
</blockquote>
<hr>
<h1 id="连接URL"><a href="#连接URL" class="headerlink" title="连接URL"></a>连接URL</h1><hr>
<h2 id="直接读取URL"><a href="#直接读取URL" class="headerlink" title="直接读取URL"></a>直接读取URL</h2><p>使用URL对象，通过调用URL.openStream()方法，我们可以直接获取其在网络上的资源。openStream()方法返回一个java.io.InputStream()对象，这样我们就可以像使用一般I&#x2F;O流一样，进行读操作。下面是示例代码，其中我们使用了一个输入缓冲字符流BufferedReader来提高读取性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.ifeng.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(url.openStream()))) &#123;</span><br><span class="line">           String line;</span><br><span class="line">           <span class="keyword">while</span>((line = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.println(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>控制台中将输出Html文档内容，这里I&#x2F;O流使用了try-with-resource方式处理异常，程序会自动关闭I&#x2F;O流。</p>
<h2 id="使用URLConnection连接"><a href="#使用URLConnection连接" class="headerlink" title="使用URLConnection连接"></a>使用URLConnection连接</h2><p>前面我们使用openStream()方法可以直接获取网络资源的输入流，我们看下该方法的源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title function_">openStream</span><span class="params">()</span> <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> openConnection().getInputStream();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　其实这里是先调用了openConnection()方法，而openConnection()方法返回的是之前说过的URLConnection对象，它是代表应用程序和网络资源之间连接的抽象类。openConnection()方法会根据URL的协议名称返回相应的URLConnection子类，比如当使用http协议的时候，返回的就是HttpURLConnection对象,此时并不会有联网操作，只有当调用URLConnection.connect()方法时，才会实际建立与远程网络资源之间的通信连接。<br>　　实际不必每次都使用connect方法初始化连接，一些依赖连接的方法比如getInputStream()和getOutputStream()会自动调用该方法进行连接。<br>　　getInputStream()和getOutputStream()方法分别是从URLConnection连接中读取和写入流，获取流就是直接读取网络资源。写入流则是用于向服务器发送一些数据。很多网页上有一些表单，需要我们填写一些数据后发送到服务器端，然后服务端给我们一个响应。如果采用http的get请求，发送的查询数据直接在挂在url连接后，但是有些表单采用的post请求发送数据，这时就要使用一个OutputStream来写入需要的数据。<br>　　下面是一段示例代码，这里虚拟一个网址，需要我们向其发送一个查询关键字，然后服务器返回给我们一个查询后的静态html文档,我们再将其打印到控制台中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/search&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">con</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">con.setDoOutput(<span class="literal">true</span>);<span class="comment">//设置连接允许写入数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> con.getOutputStream()) &#123;</span><br><span class="line">    out.write(<span class="string">&quot;keyword=cat&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(con.getInputStream());</span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(in)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>需要注意的是，要想写入流，需要先调用setDoOutput(true)设置方法</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（二）HTTP </title>
    <url>/2017/05/16/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89HTTP/</url>
    <content><![CDATA[<p>HttpURLConnection是一个支持HTTP特定功能的URLConnection。每个HttpURLConnection实例用于创建单个请求，但是到HTTP服务器的底层网络连接可以被其他实例共享。在请求之后，需要调用HttpURLConnection上InputStream和OutputStream的close()方法，来释放相关的网络资源，但是该方法对共享的持久化连接没有影响。可以调用disconnect()方法来关闭底层套接字，如果一个持久化连接闲置的话。</p>
<span id="more"></span>

<h1 id="URLConnection缓存API"><a href="#URLConnection缓存API" class="headerlink" title="URLConnection缓存API"></a>URLConnection缓存API</h1><p>HTTP通常用于分布式信息系统，通过使用响应缓存可以提高性能。虽然HTTP代理服务器通常自己缓冲最近访问的网络资源，但是有时它也希望有一个本地缓存，比如浏览器缓冲。</p>
<p>![ResponseCache](&#x2F;images&#x2F;java base&#x2F;ResponseCache.gif)</p>
<p>在java.net包中有三个缓存相关的抽象类</p>
<ul>
<li><strong>ResponseCache</strong></li>
<li><strong>CacheRequest</strong></li>
<li><strong>CacheResponse</strong></li>
</ul>
<h2 id="ResponseCache"><a href="#ResponseCache" class="headerlink" title="ResponseCache"></a>ResponseCache</h2><p>一个ResponseCache的具体子类代表一个URLConnection缓存。这种子类实例可以通过调用ResponseCache.setDefault()方法来注册进系统内。并且系统会按照一下顺序来调用这些对象。</p>
<ul>
<li>存储那些已经被从外部资源检索的资源数据到缓存中</li>
<li>尝试调取可能存储在缓存中的可被请求资源</li>
</ul>
<p>ResponseCache有两个方法：get()返回一个基于URI和请求头的CacheResponse。put()允许缓存决定是否资源应该被存储，并且返回CacheRequest。</p>
<h2 id="CacheRequest"><a href="#CacheRequest" class="headerlink" title="CacheRequest"></a>CacheRequest</h2><p>一个CacheRequest的具体子类用于在ResponseCache中写入一个条目。这种类的实例提供了一个由协议处理程序调用，用来存储资源数据到缓冲中的OutputStream对象。同时还有一个abort()方法，可以允许缓存打断或放弃一个存储操作。</p>
<p>CacheRequest类有两个方法:getBody()返回一个用于将请求体写入缓存的流；abort()方法放弃缓存写入。</p>
<h2 id="CacheResponse"><a href="#CacheResponse" class="headerlink" title="CacheResponse"></a>CacheResponse</h2><p>一个CacheResponse的具体子类从ResponseCache中返回一个条目。这种类的实例提供一个返回实体主体的InputStream，还有一个getHeaders()方法，返回相应的响应头。</p>
<p>CacheResponse类有两种方法：getBody()返回从缓存读取请求体的流；而getHeaders()返回存储的响应头。</p>
<h1 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h1><p>HTTP状态管理机制指定了一种使用HTTP请求和响应创建有状态会话的方法。</p>
<h2 id="JDK-5-0之前"><a href="#JDK-5-0之前" class="headerlink" title="JDK 5.0之前"></a>JDK 5.0之前</h2><p>在JDK 5.0之前可以向应用程序添加Cookie管理，但是提供的API有些基础。没有一点和cookie管理有关联。每个应用程序必须通过使用java.net.URLConnection类中的以下两种方法单独处理每个HTTP请求。响应的cookie.</p>
<ul>
<li>setRequestProperty()</li>
<li>getHeaderFileds()</li>
</ul>
<p>在发送HTTP请求前应该调用第一种方法，以便为HTTP头中的的当前URL设置适当的cookie。而第二种方法应当在从由HTTP服务器发送的响应头中检索cookies时调用。</p>
<p>这种方法容易分散代码，且容易出错不易维护。</p>
<h2 id="JDK-5-0后"><a href="#JDK-5-0后" class="headerlink" title="JDK 5.0后"></a>JDK 5.0后</h2><p>在JDK 5.0中通过一个抽象类引入了一个新的回调机制，将HTTP状态管理策略的实现连接到HTTP协议处理程序中。应用程序和Web容器可以通过提供新API的具体子类来引入Cookie管理。</p>
<p>新的抽象类是java.net.CookieHandler。它提供了一种注册和检索JVM中当前CookieHandler的机制，以及检索和记录特定URI的相关Cookie的方法。</p>
<p>在CookieHandler中有两个静态方法：getDefault()和setDefault()用来在虚拟机中检索和注册默认的CookieHandler。还有两个实例方法：get()和put()分别用来返回基于URL的cookie列表，存储来自响应头中cookies的列表。</p>
<p>cookies是使用一个Map&lt;String,List&lt;String&gt;&gt;来表示，一个由cookie头字段名称映射到由字符串表示的cookie的List的键值对。目前为止定义了两个状态管理头“Set-Cookie2”和“Cookie”.前一个用来返回相应头中的cookeis，后一个是在HTTP请求头中设置cookies。</p>
<p>目前在JavaSE中没有cookie管理的实现类，但在Java Plugin 和 Java WebStart 中提供了默认的CookieHandler。</p>
<h1 id="HTTP验证"><a href="#HTTP验证" class="headerlink" title="HTTP验证"></a>HTTP验证</h1><p>Authenticator是一个抽象类，但是它没有抽象方法，可以由应用程序来实现继承使用。调用该类可以获取用户名和密码来用于认证交互。</p>
<h2 id="继承Authenticator"><a href="#继承Authenticator" class="headerlink" title="继承Authenticator"></a>继承Authenticator</h2><p>继承Authenticator的应用程序代码必须重写getPasswordAuthenticator()，需要注意的只这个方法并不是抽象方法，但是Authenticator中只是简单返回了一个null。下面是一个小的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAuthenticator</span> <span class="keyword">extends</span> <span class="title class_">Authenticator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PasswordAuthentication <span class="title function_">getPasswordAuthentication</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PasswordAuthentication</span> (<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，只是为HTTP的认证交互返回了一个用户的用户名和密码。实际应用过程会使用到Authenticator的其他来获取关于HTTP请求更多的需要验证的信息。下面这些方法都可以由getPasswordAuthenticator()方法的实现调用，用来决定如获取处理每个请求。</p>
<ul>
<li>getRequestingHost()</li>
<li>getRequestingPort()</li>
<li>getRequestingPrompt()</li>
<li>getRequestingProtocol()</li>
<li>getRequestingScheme()</li>
<li>getRequestingURL()</li>
<li>getRequestingSite()</li>
<li>getRequesttorType() 返回请求者是一台服务器还是代理</li>
</ul>
<h2 id="开启验证"><a href="#开启验证" class="headerlink" title="开启验证"></a>开启验证</h2><p>定义好一个合适的验证实现类后，可以通过以下调用来开启验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Authenticator.setDefault (authinstance);</span><br></pre></td></tr></table></figure>
<p>其中authinstance是一个声明的实现类实例。如果不调用该方法的话，其禁用身份验证，并通过IOException异常将服务器身份验证错误返回给用户代码。一旦注册验证，http实现将尝试自动获取用户凭据来进行身份验证（通过缓存中的凭据或从系统获取的凭据）。如果正确的凭据不可用，则会调用该用户验证器来提供。</p>
<h2 id="控制使用的验证方案"><a href="#控制使用的验证方案" class="headerlink" title="控制使用的验证方案"></a>控制使用的验证方案</h2><p>当服务器有一个客户端请求需要验证的时候，可能会给客户端提供一些验证方案（比如摘要验证和NTLM身份验证），然后客户端可以从中选择一个，通常应用程序不关系哪个方案被使用，并且自动实现选择一个安全性最高的协议。</p>
<p>如果用户需要确保使用特定方案，则可以设置以下系统属性来修改默认行为。</p>
<blockquote>
<p>-Dhttp.auth.preference&#x3D;”scheme”</p>
</blockquote>
<p> -D 用来指定要在命令行上要设置的属性。 “http.auth.preference” 是属性名，”scheme”则是要使用的验证方案名。如果服务器的方案列表中不包含此方案，则会选择默认方案来验证。</p>
<h2 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h2><h3 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h3><p>基本验证是一种简单，但是非常不安全的验证方案。用户名和密码都是通过BASE64编码，因此它可以被任何一个能够访问该数据包的人获取这些信息。基本验证的安全性可以通过使用HTTPS协议来提高，从而加密请求和响应。getRequestingPrompt()方法返回由服务器提供的基本认证领域(Basic authentication realm)。</p>
<h3 id="摘要验证"><a href="#摘要验证" class="headerlink" title="摘要验证"></a>摘要验证</h3><p>Digest是使用MD5哈希算法的基于用户名和密码的密码散列的相对安全的方案。Digest还提供服务器向客户端证明它也知道共享密钥（密码）的能力。这种行为通常被禁用，因为并不是所有的服务器都支持它。可以使用以下系统属性启用此功能：    </p>
<blockquote>
<p>-Dhttp.auth.digest.validateServer &#x3D;“true”<br>-Dhttp.auth.digest.validateProxy &#x3D;“true” </p>
</blockquote>
<p>getRequestingPrompt（）方法返回由服务器提供的摘要认证领域(Digest  authentication realm)。</p>
<h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NTLM是微软定义的一种验证方案，它的安全性介于基本验证和摘要验证之间。NTLM可以与代理或服务器一起使用，但是不能两者同时使用。如果正在使用代理，则不能用于服务器身份验证。这是因为协议实际是验证TCP里拦截，而不是单独的HTTP交互。</p>
<p>在Microsoft Windows平台上，NTLM身份验证尝试从系统中获取用户凭据，而不会提示用户的身份验证对象。如果这些凭据不被服务器接受，则用户的验证器将被调用。</p>
<p>由于Authenticator类在支持NTLM出现就定义了，因此无法在API中添加对NTLM域字段的支持，下面有三种对该域的选择</p>
<ul>
<li>在某些环境中不要指定它，域实际上并不是必需的，应用程序不需要指定。</li>
<li>域名可以使用在用户名前加域名前缀，然后在用户名前添加一个反斜线“\”的方式进行编码。使用此方法，只要使用者知道必须使用此符号，则不需要修改使用Authenticator类的现有应用程序。</li>
<li>如果未在方法2中指定域名，并且定义了系统属性“http.auth.ntlm.domain”，则该属性的值将被用作域名。</li>
</ul>
<h3 id="Http-Negotiate（SPNEGO）"><a href="#Http-Negotiate（SPNEGO）" class="headerlink" title="Http Negotiate（SPNEGO）"></a>Http Negotiate（SPNEGO）</h3><h1 id="持久连接-Persistent-Connections"><a href="#持久连接-Persistent-Connections" class="headerlink" title="持久连接(Persistent Connections)"></a>持久连接(Persistent Connections)</h1><p>HTTP持久连接也被称为HTTP活动保持（keep-alive）或者HTTP连接重用（connection reuse）,它是使用相同TCP连接发送和接收多个HTTP请求&#x2F;响应的思想，而不是为每个单个请求&#x2F;响应对打开一个新的TCP连接。使用持久连接对于提高HTTP性能非常重要。</p>
<p>使用持久连接有以下几个优点</p>
<ul>
<li>对网络友好。由于更少的创建和关闭TCP连接，这减少了网络通信。</li>
<li>由于避免了初始化TCP握手，减少了后续请求的延迟。</li>
<li>持续更久连接允许TCP足够的时间来确定网络的拥塞状态，从而进行适当的反应。</li>
</ul>
<p>当在HTTPS或者使用SSL&#x2F;TLS的HTTP中时，这些优点可能显得更加明显。这里，除了初始TCP连接建立之外，持续连接可能减少昂贵的SSL &#x2F; TLS握手数以建立安全关联。</p>
<p>在HTTP &#x2F; 1.1中，持久连接是任何连接的默认行为。也就是说，除非另有说明，否则客户端应该假定服务器将维护持久连接，即使在服务器发生错误响应之后。但是，该协议提供了一种客户端和服务器发出关闭TCP连接信号的手段。</p>
<h2 id="当前的JDK如何处理Keep-Alive？"><a href="#当前的JDK如何处理Keep-Alive？" class="headerlink" title="当前的JDK如何处理Keep-Alive？"></a>当前的JDK如何处理Keep-Alive？</h2><p>JDK同时支持HTTP&#x2F;1.1 和 HTTP&#x2F;1.0。<br>当应用程序读取完响应体内容后或者调用 close() 关闭了URLConnection.getInputStream()返回的流，JDK中的HTTP协议句柄将关闭连接，并将连接放到连接缓存中，以便后面的HTTP请求使用。<br>对HTTP keep-Alive 的支持是显然的。但是，你也可以通过系统属性http.keepAlive和http.maxConnections以及HTTP&#x2F;1.1协议中的特定的请求响应头来控制。</p>
<p>控制Keep-Alive表现的系统属性有：</p>
<blockquote>
<p>http.keepAlive&#x3D;&lt;boolean&gt;<br>默认: true<br>指定长连接是否支持</p>
</blockquote>
<blockquote>
<p>http.maxConnections&#x3D;&lt;int&gt;<br>默认: 5<br>指定对同一个服务器保持的长连接的最大个数。</p>
</blockquote>
<p>影响长连接的HTTP header是：Connection: close如果请求或响应中的Connection header被指定为close，表示在当前请求或响应完成后将关闭TCP连接。</p>
<p>JDK中的当前实现不支持缓存响应体，所以应用程序必须读取完响应体内容或者调用close()关闭流并丢弃未读内容来重用连接。此外，当前实现在清理连接时并未使用阻塞读，这就意味这如果响应体不可用，连接将不能被重用。</p>
<h2 id="JDK1-5中的新特性"><a href="#JDK1-5中的新特性" class="headerlink" title="JDK1.5中的新特性"></a>JDK1.5中的新特性</h2><p>当应用接收到400或500的HTTP响应时，它将忽略IOException 而另发一个HTTP 请求。这种情况下，底层的TCP连接将不会再保持，因为响应内容还在等待被读取，socket 连接未清理，不能被重用。应用可以在捕获IOException 以后调用HttpURLConnection.getErrorStream() ，读取响应内容然后关闭流。但是现存的应用没有这么做，不能体现出长连接的优势。为了解决这个问题，我们引入了一个解决方法。</p>
<p>解决方法是缓冲响应体，如果响应码大于等于400的话，如果在一定的时间限制内达到一定的数量，则释放底层的socket连接来重用。基本原理是当响应状态码大于或等于400时，服务器端会发送一个简短的响应体来指明连接谁以及如何恢复连接。</p>
<p>下面介绍一些SUN实现中的特定属性来帮助接收到错误响应体后清理连接：<br>主要的一个是：<br>sun.net.http.errorstream.enableBuffering&#x3D;&lt;boolean&gt;<br>默认: false</p>
<p>当上面属性设置为true后，在接收到响应码大于或等于400是，HTTP 句柄将尝试缓存响应内容。释放底层的socket连接来重用。所以，即便应用不调用getErrorStream()来读取响应内容，或者调用 close()关闭流，底层的socket连接也将保持连接状态。</p>
<p>下面的两个系统属性是为了更进一步控制错误流的缓存行为：<br>sun.net.http.errorstream.timeout&#x3D;&lt;int&gt; in 毫秒<br>默认: 300 毫秒<br>sun.net.http.errorstream.bufferSize&#x3D;&lt;int&gt; in bytes<br>默认: 4096 bytes</p>
<h2 id="你如何做可以保持连接为连接状态呢？"><a href="#你如何做可以保持连接为连接状态呢？" class="headerlink" title="你如何做可以保持连接为连接状态呢？"></a>你如何做可以保持连接为连接状态呢？</h2><p>不要忽略响应体而丢弃连接。这样会是TCP连接闲置，当不再被引用后将会被垃圾回收器回收。<br>如果getInputStream()返回成功，读取全部响应内容。如果抛出IOException ，捕获异常并调用getErrorStream() 读取响应内容（如果存在响应内容）。  </p>
<p>即便你对响应内容不感兴趣，也要读取它，以便清理连接。但是，如果响应内容很长，你读取到开始部分后就不感兴趣了，可以调用close()来关闭流。值得注意的是，其他部分的数据已在读取中，所以连接将不能被清理进而被重用。<br>下面是一些示例代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">urlc</span> <span class="operator">=</span> a.openConnection();</span><br><span class="line">        is = conn.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ret = is.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          processBuf(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭输入流</span></span><br><span class="line">        is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                respCode = ((HttpURLConnection)conn).getResponseCode();</span><br><span class="line">                es = ((HttpURLConnection)conn).getErrorStream();</span><br><span class="line">                <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 读取响应体</span></span><br><span class="line">                <span class="keyword">while</span> ((ret = es.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processBuf(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 关闭错误流</span></span><br><span class="line">                es.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你预先就对响应内容不感兴趣，你可以使用HEAD 请求来代替GET 请求。例如，获取web资源的meta信息或者测试它的有效性，可访问性以及最近的修改。下面是代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(args[<span class="number">0</span>]);</span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">urlc</span> <span class="operator">=</span> a.openConnection();</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">httpc</span> <span class="operator">=</span> (HttpURLConnection)urlc;</span><br><span class="line"><span class="comment">// only interested in the length of the resource</span></span><br><span class="line">httpc.setRequestMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> httpc.getContentLength();</span><br></pre></td></tr></table></figure>

<h2 id="JDK-6中的更改"><a href="#JDK-6中的更改" class="headerlink" title="JDK 6中的更改"></a>JDK 6中的更改</h2><p>在JDK 6 之前，如果应用程序在少量数据仍然被读取时关闭HTTP InputStream，则连接必须被关闭，而不是被缓存。现在在JDK 6中，则是从后台线程中的连接中一直读取到高达512 KB，从而允许连接被重用。可以通过http.KeepAlive.remainingData系统属性配置可以读取的确切数据量。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（五）Cookie管理</title>
    <url>/2017/05/24/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89Cookie%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Java SE为cookie管理提供一个主要的类——java.net.CookieHandler,以及一些相关的支持类和接口：java.net.CookieManager,java.net.CookiePolicy,java.net.CookieStore和java.net.HttpCookie。</p>
<hr>
<h1 id="使用Cookie的HTTP状态管理"><a href="#使用Cookie的HTTP状态管理" class="headerlink" title="使用Cookie的HTTP状态管理"></a>使用Cookie的HTTP状态管理</h1><hr>
<p>HTTP状态管理机制指定了一种使用HTTP请求和响应创建有状态会话的方法。</p>
<p>通常，HTTP请求&#x2F;响应是彼此独立的。然而状态管理机制使客户端和服务器能够交换状态信息，来将一个请求&#x2F;相应对放在一个大的被称为会话（session）上下文中。这种用来创建和维持会话的状态信息就被称为cookie。</p>
<span id="more"></span>

<p>Cookie是可以存储在浏览器缓存中的一段数据。如果您访问网站，然后重新访问，则可以使用Cookie数据将您标识为再次访问者。Cookie可以记录状态信息，例如在线购物车。Cookie可以是短期保存单个Web会话的数据，直到您关闭浏览器它都会有效。同时Cookie也可以长期有效，在一周或一年的期限内保存数据。</p>
<hr>
<h1 id="CookieHandler回调机制"><a href="#CookieHandler回调机制" class="headerlink" title="CookieHandler回调机制"></a>CookieHandler回调机制</h1><hr>
<p>HTTP状态管理在Java SE中是通过java.net.CookieHandler来实现的。一个CookieHandler对象提供了一个回调机制，来在HTTP协议的处理程序中提供了HTTP状态管理策略实现。也即是说，URL使用HTTP作为协议的话，比如（URL(“http :&#x2F;&#x2F;example.com”)），它会使用HTTP协议处理程序。这个协议处理程序会调用CookeiHandler对象（如果我们设置了的话）来处理状态管理。</p>
<p>CookieHandler是一个抽象类，它提供了两对相关的方法。第一对是getDefalut()和setDefault(coookieHandler),它们是静态方法使我们能获取和设置当前要使用的cookieHandler。<br>默认情况下是没有设置cookieHandler的，并且如果我们安装一个cookieHandler的话是基于全系统安装。对于一个在安全环境下运行的应用程序，他们都有安装一个安全管理器，因此你必须有指定的权限来获取或设置这个cookieHandler.<br>第二对相关方法是put(uri,responseHeaders)和get(uri,requestHeaders),这两个方法使我们能分别在在cookie缓存中为请求&#x2F;响应头中的指定的URI，设置和获取所有的合适的cookies。这些方法都是抽象方法，需要我们在CookieHandler实现类中来实现。</p>
<p>Java Web Start 和 Java Plug-in 中都有默认安装了一个CookieHandler。但是，如果您运行一个独立应用程序并要启用HTTP状态管理，则必须设置一个全系统范围的处cookieHandler。</p>
<hr>
<h1 id="默认CookieManager"><a href="#默认CookieManager" class="headerlink" title="默认CookieManager"></a>默认CookieManager</h1><hr>
<p>java.net.CookieManager提供了一个CookieHandler的具体实现类，它对大多数用户来说已经足够来处理HTTP状态管理。CookieManager将Cookie的存储与周边，接受和拒绝的策略分开。CookieManager通过使用一个java.net.CookieStore和java.net.CookiePolicy来初始化。CookieStore管理cookies的储存。CookiePolicy对cookie接受和拒绝做出决策。</p>
<p>下面代码展示了如果创建和设置一个全系统的CookieManager.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CookieManager</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span> Manager();</span><br><span class="line">CookieHander.setDefault(cm)</span><br></pre></td></tr></table></figure>

<p>默认的CookieManager构造器通过一个默认的cookie储存和接收策略来创建一个新的cookieManager实例。CookieStore是存储任何被接受的HTTP cookie的地方。如果我们创建CookieManager的时候没有指定的话，CookieManager的实例就会使用一个内部内存实现。该实现不是长久的，只能在JVM运行的生命周期内存在。用户需要一持久存储的话必须有自己的存储实现。</p>
<p>CookieManeger使用的默认cookie政策是CookiePolicy.ACCEPT_ORIGINAL_SERVER，它只接受来之原始服务器的cookie。因此，来自服务器的Set-Cookie响应必须有一个“domain”属性集，并且它必须和URL中的主机域名匹配。用户需要一个不同的策略的话，必须实现CookiePolicy接口，并且将它作为CookieManager构造器的参数传递，或者使用一个已经初始化的CookieManager实例的setCookiePolicy(cookiePolicy)方法。</p>
<p>从Cookie存储区检索Cookie时，CookieManager也会强制执行路径匹配规则 。因此，cookie也必须设置其“path”属性，以便可以在从存储的cookie中检索到指定的cookie之前，能够执行路径匹配规则。</p>
<p>总之，CookieManager提供了处理Cookie的框架，并提供了一个很好的默认实现CookieStore。我们还可以通过设置CookieStore和CookiePolicy来高度可自定义一个CookieManager.</p>
<hr>
<h1 id="自定义CookieManger"><a href="#自定义CookieManger" class="headerlink" title="自定义CookieManger"></a>自定义CookieManger</h1><hr>
<p>CookieManger类有两个方面可以自定义：CookiePolicy和CookieStore。</p>
<h2 id="CookiePolicy"><a href="#CookiePolicy" class="headerlink" title="CookiePolicy"></a>CookiePolicy</h2><p>为方便起见，CookiePolicy定义以下预设的Cookie接受策略：</p>
<ul>
<li><strong>CookiePolicy.ACCEPT_ORIGINAL_SERVER</strong>  只接受来自原始服务器的cookie</li>
<li><strong>CookiePolicy.ACCEPT_ALL</strong>   接收所有的cookie</li>
<li><strong>CookiePolicy.ACCEPT_NONE</strong>   不接受任何cookie.</li>
<li>也可以通过实现CookiePolicy的shouldAccept方法来第一自己的cookie接受策略。</li>
</ul>
<p>以下是在应用CookiePolicy.ACCEPT_ORIGINAL_SERVER策略之前拒绝来自黑名单上的域的Cookie的Cookie策略的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistCookiePolicy</span> <span class="keyword">implements</span> <span class="title class_">CookiePolicy</span> &#123;</span><br><span class="line">    String[] blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlacklistCookiePolicy</span><span class="params">(String[] list)</span> &#123;</span><br><span class="line">        blacklist = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldAccept</span><span class="params">(URI uri, HttpCookie cookie)</span>  &#123;</span><br><span class="line">        String host;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            host =  InetAddress.getByName(uri.getHost()).getCanonicalHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            host = uri.getHost();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;blacklist.length; i++) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (HttpCookie.domainMatches(blacklist[i], host)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CookiePolicy.ACCEPT_ORIGINAL_SERVER.shouldAccept(uri, cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当创建一个BlacklistCookiePolicy实例的时候，需要传入一个黑名单列表。然后将BlcacklistCookiePolicy实例作为cookie管理策略设置在CookieManager中。如例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CookieManager</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieManager</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">BlacklistCookiePolicy</span>(list));</span><br><span class="line">CookieHandler.setDefault(cm);</span><br></pre></td></tr></table></figure>

<p>示例代码将不接受来自以下主机的Cookie，例如：  </p>
<blockquote>
<p>host.example.com<br>domain.example.com </p>
</blockquote>
<p>但是，此示例代码将接受来以下自主机的Cookie，如下所示：  </p>
<blockquote>
<p>example.com<br>example.org<br>myhost.example.org</p>
</blockquote>
<h2 id="CookieStore"><a href="#CookieStore" class="headerlink" title="CookieStore"></a>CookieStore</h2><p>CookieStore是一个表示cookie存储区的接口。CookieManager为每个HTTP响应把cookie添加到CookieStore，并且在每个HTTP请求时，从CookieStore中取回cookie.</p>
<p>我们可以实现这个接口来提供我们自己的CookieStore,并且在创建CookieManager传递它作为构造器参数。我们无法在创建CookieManager实例后再来设置CookieStore。<br>然而我们可以通过调用CookieManager.getCookieStore()方法来获取cookie store的引用。这样做很有用，因为它可以利用CookieStoreJava SE提供的默认内存实现，并补充其功能。</p>
<p>例如，您可能需要创建一个保存Cookie的持久性Cookie存储，以便即使Java虚拟机重新启动也可以使用它们。您的实现将会以下类似。</p>
<ol>
<li>读入之前我们存储的所有cookie</li>
<li>运行期间，cookie将会从内存中存储和检索cookie</li>
<li>在退出之前将Cookie写入永久存储。</li>
</ol>
<p>以下是此Cookie存储的不完整示例。此示例显示如何利用Java SE默认内存Cookie存储，以及如何扩展其功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentCookieStore</span> <span class="keyword">implements</span> <span class="title class_">CookieStore</span>, Runnable &#123;</span><br><span class="line">    CookieStore store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersistentCookieStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// get the default in memory cookie store</span></span><br><span class="line">        store = <span class="keyword">new</span> <span class="title class_">CookieManager</span>().getCookieStore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo: read in cookies from persistant storage</span></span><br><span class="line">        <span class="comment">// and add them store</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a shutdown hook to write out the in memory cookies</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// todo: write cookies in store to persistent storage</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>	<span class="title function_">add</span><span class="params">(URI uri, HttpCookie cookie)</span> &#123;</span><br><span class="line">        store.add(uri, cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;HttpCookie&gt; <span class="title function_">get</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.get(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;HttpCookie&gt; <span class="title function_">getCookies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.getCookies();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;URI&gt; <span class="title function_">getURIs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.getURIs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(URI uri, HttpCookie cookie)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.remove(uri, cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> store.removeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 网络编程（四）网络接口</title>
    <url>/2017/05/22/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>系统通常运行多个活动网络连接，比如有线网，无线网和蓝牙。某些应用程序可能需要访问此信息才能在特定连接上执行特定的网络活动。 java.net.NetworkInterface课程提供对这些信息的访问。<br>一个网络接口是一台计算机与私有或公有网络之间的互联点，通常是一个网卡，但是不一定是物理上的网卡。比如本地回环 IP“127.0.0.1”就不是一个物理设备而是一个软件模拟的网络接口，它通常用于测试本地网络环境。NetworkInterface可以代表这两种类型的接口。</p>
<span id="more"></span>
<p>NetworkInterface没有提供公共构造器，因此我们不能创建它的对象，但是它提供了一系列的静态方法，供我们来检索系统中的网络接口。</p>
<ul>
<li><strong>getByInetAddress()</strong></li>
<li><strong>getByName()</strong></li>
<li><strong>getNetwordInterfaces()</strong></li>
</ul>
<p>前两种方法是需要我们已经知道了接口的IP地址或接口名，后一种则以Enumeration返回系统内所有的网络接口。</p>
<p>在前面Socket通信中，我们要给一个Socket绑定要发送到的IP地址，这里我们可以使用NetworkInterface来获得本地网卡的IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NetworkInterface</span> <span class="variable">networkInterface</span> <span class="operator">=</span> NetworkInterface.getByName(<span class="string">&quot;eth0&quot;</span>);</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> networkInterface.getInetAddresses().nextElement();</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress.getHostName(),<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<p>同样在使用MulticastSocket时，也可以指定一个MultcastSocekt加入的群组接收数据包时使用的网络接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NetworkInterface</span> <span class="variable">nif</span> <span class="operator">=</span> NetworkInterface.getByName(<span class="string">&quot;bge0&quot;</span>);</span><br><span class="line"><span class="type">MulticastSocket</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>();</span><br><span class="line">ms.joinGroup(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostname, port), nif);</span><br></pre></td></tr></table></figure>

<p>网络是可以分层组织的，NetworkInterface类还提供了两个方法</p>
<ul>
<li><strong>getParent()</strong></li>
<li><strong>getSubInterfaces()</strong></li>
</ul>
<p>如果一个网络接口是一个子接口的话调用getParent()返回其父接口，而getSubInterface()则返回一个接口的所有子接口。</p>
<p>我们还可以获取网络接口的IP地址或子网掩码等其他信息，这里有两个方法</p>
<ul>
<li><strong>getInetAddresses()</strong></li>
<li><strong>getInterfaceAddress()</strong><br>getInetAddress()会返回一个Enumeration类型的InetAddress.而getInterfaceAddresses()则返回一个List类型包含InterfaceAddress元素。通过InterfaceAddress我们可以获取网络接口的IPv4地址子网掩码和广播地址，以及IPv6地址的网络前缀长度。</li>
</ul>
<p>还有一些方法用来获取相关网络接口的参数</p>
<ul>
<li><strong>isUp()</strong> 网络接口是否运行</li>
<li><strong>isLoopback()</strong> 网络接口是否是本地回环接口</li>
<li><strong>isPointToPoint()</strong> 是否是点对点接口</li>
<li><strong>isVirtual()</strong> 是否是虚拟接口</li>
<li><strong>supporsMultiCast</strong> 接口是否支持多播</li>
<li><strong>getHardwareAddress()</strong> 获取MAC地址</li>
<li><strong>getMTU()</strong> 返回最大传输单元（MTU）</li>
</ul>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 网络编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（十六）Map</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E5%8D%81%E5%85%AD-Map/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="http://www.processon.com/chart_image/58eca417e4b0c9097c3897b2.png" alt="Map"></p>
<p>　　Map是一个包含键值对的集合,一个map不能有重复的键(key),而且每个键至多只能对应一个值.Map同Collection一样,它的所有通用实现都会提供一个转换器构造函数,接收一个Map类型集合,并以此初始化自己,这样只要是Map的实现都可以相互之间转换.<br>　　和List与Set一样,Map强化了equal和hashCode以能对两个Map对象实现逻辑上的比较.如果两个Map实例有相同的键值对,那么它们是相等的.  </p>
<blockquote>
<p>Map的集合视角方法使Map可以像Collection一样进行操作元素</p>
</blockquote>
<ul>
<li>KeySet–返回Map集合中键的Set集合</li>
<li>Values–返回Map集合中值的Collection集合</li>
<li>entrySet–返回Map集合中键值对对象的Set集合.在Map中提供了一个小的嵌套接口Map.Entry,它就是Map的键值对对象.</li>
</ul>
<span id="more"></span>

<p>Map没有实现Iterable接口,所以集合视角是Map集合遍历的唯一手段,并且每次获取Map集合视角的时候,返回的是相同的对象.集合视角支持removal类型操作,但是任何情况下都不支持addition,对集合视角的removal操作会影响到Map集合本身,比如map.keySet().clear()将会清空map,反之亦然,这和Set,List的视图一样.</p>
<p>使用集合视角有一些有意思的用法,比如判断一个Map是否是另一个Map的子集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m1.entrySet().containsAll(m2.entrySet())) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类似,也可以判断两个Map的是否拥有相同的键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m1.keySet().equals(m2.keySet())) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SortedMap与NavigableMap"><a href="#SortedMap与NavigableMap" class="headerlink" title="SortedMap与NavigableMap"></a>SortedMap与NavigableMap</h1><p>　Map和Set接口从形式上有些类似,类比与SortedSet和NavigableSet,Map也有SortedMap和NavigableMap两个接口,实际上Set的实现底层就是使用的Map存储数据.</p>
<p>　　SortedMap将元素的键以自然排序,或者依照给定的排序器来进行排序,同SortedSet,SortedMap提供了以下几种操作.</p>
<ul>
<li><strong>视图</strong>–允许从SortedMap截取并返回任意范围的元素视图</li>
<li><strong>端点操作</strong>—可以直接获取集合头或尾的元素</li>
<li><strong>排序器</strong>—返回用于排列元素的排序器<br>　　Map集合并无法直接实现遍历,而是通过它的集合视角遍历元素,所以SortedMap在返回的集合视角中,集合视角的迭代器也将会按SortedMap的顺序进行排序,同理的SortedMap中toArray方法返回的数组也是如此,toString方法会返回一个包含所有元素,并排序好的字符串.</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>　　Map的实现可以分成<strong>通用实现</strong>,<strong>专用实现</strong>,<strong>并发实现</strong></p>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>　　通用实现有三个,<strong>HashMap</strong>,<strong>TreeMap</strong>和<strong>LinkedHashMap</strong>.如果我们想要对元素进行一些排序操作,那么应当使用TreeMap,如果我们想要最好的性能而不在乎是否排序,应当使用HashMap,如果需要和HashMap接近的性能,并且可以以插入顺序遍历,那么应当使用LinkedHashMap.这和Set的通用实现很类似.</p>
<p>　　此外LinkedHashMap不仅提供了插入排序(insert order),同时还提供访问排序(access order),这样LinkedHashMap非常适用做本地缓存类(LRU)</p>
<h2 id="专用实现"><a href="#专用实现" class="headerlink" title="专用实现"></a>专用实现</h2><p>　　专用实现也有三个,分别是<strong>Enummap</strong>,<strong>WeakHashMap</strong>和<strong>IdentityHashMap</strong>。</p>
<ul>
<li><p>EnumMap是一个高性能的以枚举为键的Map集合,它内部是以数组实现.EnumMap将Map集合的丰富功能和安全性与数组的快速访问结合起来,如果想要实现一个用枚举映射值得结构,应当使用EnumMap.</p>
</li>
<li><p>WeakHashMap只存储弱引用类型的key,当它内部的元素的键不再被外界引用时,其键值对就可以被垃圾回收期(GC)回收,被从WeakHashMap中移除.WeakHashMap提供最简单利用弱引用的方法,这对实现”registry-like”数据结构非常有用.</p>
</li>
<li><p>IdentityHashMap存储元素时,不使用equal方法比较键对象,而是使用&#x3D;&#x3D;来对比,适用于实现对象拓扑结构转换,比如对象序列化或深度拷贝时,作为一个”节点表”来跟踪处理那些已经处理过的对象引用.</p>
</li>
</ul>
<p>Java.util.concurrent包含ConcurrentMap接口,它继承自Map,其putIfAbsent,remove,和replace方法是原子性的.ConcurrentHashMap是它的实现.</p>
<p>ConcurrentHashMap是一个高并发高性能的基于哈希表的实现,当检索元素时永不会阻塞,并且当执行update允许客户端选定执行并发级别更新.它是HashMap的替代,ConcurrentHashMap除了实现ConcurrentMap还支持HashTable所有遗留的独有的操作.</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（十四）Queue</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E5%8D%81%E5%9B%9B-Queue/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　Queue一种队列结构集合,用来存储将要进行处理的元素.通常以FIFO的方式排序元素,但这并不是必须的.比如优先度队列就是一个例外,它是以元素的值来排序.但无论怎样,每个Queue的实现都必须指定它的排序属性.Queue通常不定义元素的equal和hashCode方法.</p>
<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><p>　　每个Queue方法都存在两种形式<br>   (1)<strong>操作失败则抛出异常</strong><br>   (2)<strong>操作失败返回一个特定值,通常是null或者是false</strong>  </p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常</th>
<th>返回特定值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Insert</strong></td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>　　Queue的实现可能会限制集合存储的元素数,这种队列被称为有界队列,对于有界队列当调用add方法时,如果元素数超出其容量限制,就会抛出IllegalStateException异常.offer方法就是专门为有界队列设计的,和add不同的是当插入元素失败的的时候,它返回false而不是抛出异常.</p>
<p>　　Remove和poll方法都是从队列头部弹出元素.具体是那个元素被弹出,这要看队列的排序策略.remove和poll仅当是空集合的时候才有区别,remove会抛出NoSuchElementException,而poll返回null值.</p>
<p>　　Element和peek方法都是返回队列的头部元素,但并不会从队列中将其删除.同remove和poll一样仅当是空集合时两者才有差别,element抛出NoSuchElementException而peek返回null值.</p>
<p>　　Queue的实现通常不允许插入null值,除了LinkedList这个例外,出于历史原因它允许插入null值,但是必须十分注意的是null也是poll和peek方法返回的特别值.</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>　　Queue的实现可以划分为<strong>通用实现</strong>和<strong>并发实现</strong></p>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>　　通用实现主要有两个,一个是<strong>LinkedList</strong>,一个是<strong>PriorityQueue</strong>.LinkedList在List总我们已经说过,它继承自Queue接口,提供FIFO的队列操作形式.<br>　　PriorityQueue是一个基于栈结构的优先度队列,它可以根据元素的自然排序或者给定的排序器进行排序.  </p>
<h2 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h2><p>　　在java.util.concurrent包中包含了一系列的同步Queue接口和实类.BlockingQueue继承自Queue,它会在检索元素时等待队列是非空队列处于可用状态,并在存入一个元素后将状态更改为可用状态,下面是它的实现类.</p>
<ul>
<li><strong>LinkedeBlockingQueue</strong>—基于链接节点的可选有界FIFO方式阻塞式队列</li>
<li><strong>ArrayBlockingQueue</strong>—基于数组的有界FIFO方式的阻塞式队列</li>
<li><strong>PriorityBlockingQueue</strong>—基于栈结构无界阻塞式队列</li>
<li><strong>DelayQueue</strong>—基于栈结构的时间调度队列</li>
<li><strong>SychronousQueue</strong>—通过使用BlockingQueue接口的简单对接机制的队列 </li>
<li><strong>TransferQueue</strong>—在JDK7中 ,TransferQueue是一个特殊额BlockingQueue,它向队列添加一个元素后,可以选择处于等待(阻塞)状态,以让另一个线程检索元素,TransferQueue只有一个实现类</li>
<li><strong>LinkedTransferQueue</strong>—基于链接节点的无界TransferQueue</li>
</ul>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架（一）概述</title>
    <url>/2017/04/24/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p>　　Java Collection Framework (JCF) 提供给我们一系列的类和接口,方便开发者处理集合对象.<br>　　在Java2之前，Java是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如<strong>Vector，Stack，Hashtable</strong>等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在Java 2中，Java设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。<br>　　Java集合框架大部分在java.util包中,此外还有一系列的并发集合在java.util.concurrent包中.在Java 7之后添加了泛型机制,使集合框架中在运行时期可能出现的类型转换问题,提前到编译时期来检查.</p>
<span id="more"></span>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><hr>
<p><img src="http://www.processon.com/chart_image/58dcc48be4b0a49a5fae4955.png" alt="JCF结构图"><br>　  从上图可以看出,java集合框架主要分两大类型,一种是<strong>集合(Collection)</strong>,另一种是<strong>图(Map)</strong>,Collection我们可以理解为一个大小可变,提供各种操作数据方法的数组,而Map是一种key-value数据结构的集合.</p>
<p>Java集合框架的通用实现类的都提供两个”标准”的构造方法,一个无参构造,一个用来初始化集合大小的有参构造,但这并不是java的强制规范,但是集合框架中所有的通用类都遵循这个规则.</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><em>Collection</em></h3><p>　　Collection是存储一组对象的集合容器,它主要有以下三个接口子类:</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>重复有序集合</td>
</tr>
<tr>
<td>Set</td>
<td>无序元素不重复集合</td>
</tr>
<tr>
<td>Queue</td>
<td>JDK 1.5后新添加的队列数据结构集合,主要是为了存储数据而设计的,而不是处理数据</td>
</tr>
</tbody></table>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><em>Map</em></h3><p>Map是一种键值对结构的集合，它保存的键是唯一的，并且一个键只能对应一个值</p>
<blockquote>
<p>Map并不是一个真正意义上的集合（are not true collections），但是这个接口提供了三种“集合视角”（collection views ），使得可以像操作集合一样操作它们</p>
</blockquote>
<ul>
<li>把map的内容看作key的集合(Set<K> keySet())</li>
<li>把map的内容看作value的集合(Collection&lt;V&gt; values())</li>
<li>把map的内容看作key-value映射的集合(Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet())</li>
</ul>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><hr>
<p>集合框架具体实现子类,可由不同接口类型集合与不同数据结构组合而成</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>哈希表</th>
<th>可变数组</th>
<th>平衡二叉树</th>
<th>链表</th>
<th>链表+哈希表</th>
</tr>
</thead>
<tbody><tr>
<td><strong>List</strong></td>
<td></td>
<td><em>ArrayList</em></td>
<td></td>
<td><em>LinkedList</em></td>
<td></td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td><em>HashSet</em></td>
<td></td>
<td><em>TreeSet</em></td>
<td></td>
<td><em>LinkedHashSet</em></td>
</tr>
<tr>
<td><strong>Deque</strong></td>
<td></td>
<td><em>ArrayDeuque</em></td>
<td></td>
<td><em>LinkedList</em></td>
<td></td>
</tr>
<tr>
<td><strong>Map</strong></td>
<td><em>HashMap</em></td>
<td></td>
<td><em>TreeMap</em></td>
<td><em>LinkedHashMap</em></td>
<td><em>LinkedHashMap</em></td>
</tr>
</tbody></table>
<p>　　通用接口实现类支持接口中所有可选的数据操作,并且没有任何的限制.这些通用类都是非同步的,如果要在多线程环境下使用线程安全的同步集合,可以调用Collections中的静态同步封装器,它可以将非同步的集合封装成同步集合.此外这些实现都有fail-fast机制的迭代器,可以用来探测无效的并发修改,快速而简洁的抛出错误.详细的可见<a href="http://www.2cto.com/kf/201403/286536.html">Java ConcurrentModificationException</a><br>　　此外,为了保证集合框架的核心接口易于管理,一些修改集合的操作方法在接口中是被设计为可选的,一些通用实现可以选择不支持此类操作方法,如果这些方法被调用的话,则会抛出UnsupportedOperationException,例如在AbstractList类中,调用有些方法,比如add(int,E)就会直接抛出UnsupportedOperationException异常,子类必须重写这个方法才能支持添加元素操作,否则就意味着这个子类是被设计为不可变集合.但是在java集合框架中所有的通用实现类都支持所有的元素操作方法.</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><ul>
<li><a href="">一. Iterable接口</a></li>
<li><a href="">二. Collection集合</a><ul>
<li><a href="">1.Set接口</a><ul>
<li><a href="">1.1 HashSet</a></li>
<li><a href="">1.2 TreeSet</a></li>
<li><a href="">1.3 LinkedHashSet</a></li>
</ul>
</li>
<li><a href="">2.List接口</a></li>
<li><a href="">3.Queue接口</a></li>
<li><a href="">4.Deque接口</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><a href="">三. Map集合</a></li>
<li><a href="">四. Collections</a></li>
<li><a href="">五. 聚合操作</a></li>
<li><a href="">六. 并发集合</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<blockquote>
<p><a href="http://liujiacai.net/blog/2015/09/01/java-collection-overview/">Java集合框架综述</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html">Java Collection Framework Tutorials</a><br><a href="http://www.myexception.cn/java-other/2033553.html">JAVA基础拾掇-集合篇（一）</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-5things2.html">关于 Java Collections API 您不知道的 5 件事</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（三）Collection</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89Collection/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<p><img src="http://www.processon.com/chart_image/58e8a70ae4b01f83d25e1b79.png" alt="Collection"><br>　Collection是集合框架的根接口.不同的集合具有不同的特性,比如有的集合可以有重复元素,有的不可以,有的可以排序,有的不可排序,如此等等,而Collection作为集合的根接口,它规范定义了集合的通用方法,一个集合我们可以看作一个在内存中的小型数据库,而数据库的常用操作无外乎”增删改查”,Collection中的方法也大体是这些类型操作.</p>
<p>　　此外Colletion的所有通用实现类都会有一个<strong>转换器构造方法</strong>,它接收一个Collection类型参数,这样可以以另一个Collection类型集合中元素来初始化自己,也相当于实现了集合类型的相互转换.</p>
<span id="more"></span>
<hr>
<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><hr>
<table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>添加功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><strong>add</strong>(E)</td>
<td>向集合添加一个元素,集合元素数没有变化的话返回false</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>addAll</strong>(Collection&lt;? extends E&gt;)</td>
<td>向集合添加另一个集合全部元素,集合元素数没有变化的话返回false</td>
</tr>
<tr>
<td><strong>删除功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><strong>remove</strong>(Object)</td>
<td>从集合移除一个元素,集合元素数没有变化的话返回false</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>removeAll</strong>(Colletion&lt;?&gt;)</td>
<td>从集合移除另一个集合中所有元素,集合元素数没有变化的话返回false</td>
</tr>
<tr>
<td>defalut boolean</td>
<td><strong>removeIf</strong>(Predicate&lt;? super E&gt;)</td>
<td>按条件从集合中移除相应元素,集合元素没变化的话返回false</td>
</tr>
<tr>
<td>void</td>
<td><strong>clear</strong>()</td>
<td>清空集合内元素</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>retainAll</strong>(Collection&lt;?&gt; )</td>
<td>保留交集元素,移除不在交集中的元素,集合元素数没有变化的话返回false</td>
</tr>
<tr>
<td><strong>判读功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><strong>contains</strong>(Object)</td>
<td>判读对象是否在集合内</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>containsAll</strong>(Collection&lt;?&gt;)</td>
<td>判断参数集合内元素是否都在集合内</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>equals</strong>(Object)</td>
<td>判断集合是否与传入对象”相等”</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>isEmpty</strong>()</td>
<td>判断集元素是否为空</td>
</tr>
<tr>
<td><strong>获取功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td><strong>size</strong>()</td>
<td>获取集合内实际元素数</td>
</tr>
<tr>
<td>Object[]</td>
<td><strong>toArray</strong>()</td>
<td>返回包含集合所有元素的数组</td>
</tr>
<tr>
<td>T[]</td>
<td><strong>toArray</strong>(T[])</td>
<td>返回包含集合所有元素的数组,如果集合元素数大于传入数组长度,返回为新建数组,否则返回为传入数组,传入数组若果有剩余,多余填充为null值,如果数组类型与集合元素类型不符,抛出ArrayStoreException</td>
</tr>
<tr>
<td>int</td>
<td><strong>hashCode</strong>()</td>
<td>返回对象哈希值</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Iterator</td>
<td><strong>iterator</strong>()</td>
<td>返回集合迭代器</td>
</tr>
<tr>
<td>defalut SplIteraror</td>
<td><strong>splIterator</strong>()</td>
<td>返回集合可分割迭代器</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>defalut Stream&lt;E&gt;</td>
<td><strong>stream</strong>()</td>
<td>返回流对象</td>
</tr>
<tr>
<td>defalut Stream&lt;E&gt;</td>
<td><strong>parallelStream</strong>()</td>
<td>返回并行流对象</td>
</tr>
</tbody></table>
<p>Colletion接口中定义的方法是集合操作中最通用的操作方法,按照对元素不同的操作类型大致可以分为<strong>添加,删除,判断,获取</strong>这四种,集合为了实现元素的遍历还要提供一个获取迭代器的方法,此外在java 8之后为了应对现在分布式并行操作需求,提供了一个可分割迭代器spliterator(),为了方便开发者对集合元素快速遍历和处理,java 8新提出的聚合操作概念,可以通过stream()和parallelStream()方法来实现聚合操作.</p>
<h1 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h1><p>　　对于集合的遍历,我们知道Collection继承了Iterable接口.所以可以使用迭代器和for-loop以及forEach()形式进行遍历. 在Java 8之后,我们可以获取集合的流(stream),然后进行聚合操作(Aggregate Operations)遍历,聚合操作在后面文章有详细介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    c.add(<span class="string">&quot;aad&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;bde&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;cdf&quot;</span>);</span><br><span class="line">    c.add(<span class="string">&quot;dad&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用聚合操作</span></span><br><span class="line">    c.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//与lambda表达式结合</span></span><br><span class="line">    c.stream().filter(s -&gt; s.contains(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">              .forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出为</p>
<blockquote>
<p>aad<br>dad<br>bde  </p>
</blockquote>
<h1 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h1><ul>
<li><p><strong>Set</strong>是一种无序而元素唯一的集合类型,它是比如扑克中的卡牌,学生课程表安排的课程,计算机中运行的进程这些事物的数学概念的抽象表示.Set接口相比Colletion并没有更多的操作方法,而他的子接口SortedSet和NavigableSet进行了更多的拓展,可以看出子接口中方法侧重对元素的比较和排序</p>
</li>
<li><p><strong>List</strong>是一种有序且元素可重复的集合类型,它像数组一样可以通过索引来快速查找操作元素.</p>
</li>
<li><p><strong>Queue</strong>是一种队列结构,它更适合用来存储数据而不是处理数据.Queue常用来做先见先出的(FIFO)的存储结构,新加入的元素会被存储在集合尾部,取出元素则会从头部取出.Deque是一种双向队列,既可以做先进先出(FIFO)也可以做先进后出（LIFO）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（二十一）聚合操作</title>
    <url>/2017/04/29/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="聚合操作（Aggregate-Operations）"><a href="#聚合操作（Aggregate-Operations）" class="headerlink" title="聚合操作（Aggregate Operations）"></a>聚合操作（Aggregate Operations）</h1><hr>
<p>通常我们使用集合，不仅仅是存取数据，更多的情况是对集合内的数据进行一定的检索操作。在java 8之前，如果我们要对集合内元素进行复杂的操作，比如我们有一个存储个人信息的集合roster，里面存储着许多Person</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Sex gender;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>我们要计算这个花名册内所有男性的平均年龄，可能会这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">sumAge</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (Person person : roster) &#123;</span><br><span class="line">	<span class="keyword">if</span>(person.getGender() == Person.Sex.MALE)&#123;</span><br><span class="line">		sumAge = sumAge + person.getAge();</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="type">double</span> <span class="variable">averageAge</span> <span class="operator">=</span> (<span class="type">double</span>)sumAge/count;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>如果我们使用聚合操作的话，代码将会变得简洁明了，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> roster</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.getGender() == Person.Sex.FEMALE)</span><br><span class="line">        .mapToInt(Person::getAge)</span><br><span class="line">        .average()</span><br><span class="line">        .getAsDouble();                           </span><br></pre></td></tr></table></figure>
<p>上面例子可以展示聚合操作对于集合数据处理的高效与便捷性，在现实应用中，以往传统的J2EE应用，Java代码常常需要依赖（RDBMS）关系型数据库的操作来完成一系列的业务处理，而当脱离RDBMS时，我们需要使用iterator来遍历集合，并进行一系列的比较筛查，现在依靠集合操作，则相当便利。</p>
<p>对于聚合操作，我们需要明白两个概念：<strong>流</strong>（Stream）和<strong>管道</strong>（Pipelines）。</p>
<h2 id="流（Stream）"><a href="#流（Stream）" class="headerlink" title="流（Stream）"></a>流（Stream）</h2><p>一个流是一序列的元素，但是和集合不同，流不是存储元素的数据结构,而是用来在管道中运载来自数据源的元素。流是绝对不会修改自己底层所封装的数据的，对流的操作只会产生一个新的流。<br>对于Collection集合有两个获取流对象的方法</p>
<ul>
<li>stream() 获取普通流对象</li>
<li>parallelStream() 获取并行流用，在并行运算中使用</li>
</ul>
<blockquote>
<p>Map集合中并没有stream()方法的存在，但是我们可以通过Map的集合视角获得的Collection间接的对Map进行聚合操作</p>
</blockquote>
<h2 id="管道（Pipelines）"><a href="#管道（Pipelines）" class="headerlink" title="管道（Pipelines）"></a>管道（Pipelines）</h2><p>一个管道是指一序列的聚合操作，对于一个管道，它包含以下几个部分</p>
<ul>
<li><strong>一个数据源（source）</strong>：数据源可能是集合（collection）或数组（array）或者是一个I&#x2F;O通道，对于聚合操作，数据源是可以无限大的。</li>
<li><strong>零个或多个中间操作（intermediate operations）</strong>：一个中间操作会产出一个新的流，交给下个中间操作或者终端操作处理。</li>
<li><strong>一个终端操作（terminal operation）</strong>：终端操作最后必定产生一个非流形式的结果，返回要给结果或者副作用（side-effect），需要注意的是终端操作将会消耗掉流，所以一个管道只可能有一个终端操作。</li>
</ul>
<p>管道里中间操作是可以有多个的，但是需要注意的是这么多中间操作是懒（lazy）执行的，意思是调用中间操作的时候，并不会真正执行，而是等到调用终端操作时，才会真正执行。中间操作我们可以理解成管道的操作配置，程序运行时不是每调用一个中间操作就遍历一遍集合并进行相应的过滤或映射，而是在终端操作执行一次遍历，对每个元素依次按照配置的中间操作，执行相关方法。</p>
<p>对于例子中代码来说，roster是数据源，通过stream()获取了流对象，通过一系列的fileter，mapToint中间操作来过滤检索元素，最后通过average是终端操作返回了一个double类型的原始类型数据。</p>
<h2 id="与迭代的差异"><a href="#与迭代的差异" class="headerlink" title="与迭代的差异"></a>与迭代的差异</h2><p>对于聚合操作，像forEach方法，和迭代看起来很类似，但是聚合操作与迭代有一些根本上的差异。</p>
<ul>
<li><strong>使用内部迭代</strong>：聚合操作对元素的遍历迭代是通过内部委托的方式，由你来指定需要迭代的集合，而迭代方式由JDK来决定。而外部迭代这两者都需要你的代码来决定。这样的话，外部迭代只能按序顺迭代集合元素，而内部迭代则不受这个限制，这样可以更好的利用并行计算，JDK会在内部帮我们分割问题，分线程处理，并自动合并最终的结果。</li>
<li><strong>像流一样处理元素</strong>：聚合操作不直接处理集合本身，而是从流中处理元素，因此它有时也被称为流操作</li>
<li><strong>支持参数行为</strong>：你可以指定lambda表达式作为参数，这样可以自己定制一些特殊聚合操作行为</li>
</ul>
<hr>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><hr>
<p>从理解意义上来说，聚合操作可以看成包含数据的流在管道内的流动的过程，但是就代码形式来言，聚合操作是集合获取的Stream对象调用自身的一系列方法，处理元素的过程。而这一系列的操作我们在上文中称为管道.<br>管道中有 <em><strong>中间操作</strong></em> 和 <em><strong>终端操作</strong></em> 两种类型，除此之外，还有一种操作被称为short-circuiting,它用来处理一个无限大的Stream,一个中间操作或者终端操作，可以同时是一个short-circuiting.</p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite&#x2F;unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>依照这些操作，我们可以将Stream一些常用方法分类。</p>
<ul>
<li><strong>中间操作</strong>（intermediate operations）<br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li>
<li><strong>终端操作</strong>（terminal operation）<br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li>
<li><strong>短路</strong>（short-circuting）<br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</li>
</ul>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的作用遍历每个元素，执行给定操作后，映射到一个新的流中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roster.stream().map(Person::getName)</span><br></pre></td></tr></table></figure>
<p>获取roster内所有Person的姓名并映射到一个新的流中。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roster.stream().filter(p -&gt; p.getGender() ==Person.Sex.MALE);</span><br></pre></td></tr></table></figure>
<p>只保留为男性的Person到一个新的流中</p>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>peek 对每个元素执行操作并返回一个新的 Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roster.stream()</span><br><span class="line">          .filter(p -&gt; p.getGender() ==Person.Sex.MALE)</span><br><span class="line">          .peek(p -&gt; System.out.println(p.getName()))</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里peek是用来查看我们筛选后peson的姓名，可以用来debug.</p>
<h3 id="limit-x2F-skip"><a href="#limit-x2F-skip" class="headerlink" title="limit&#x2F;skip"></a>limit&#x2F;skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLimitAndSkip</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> <span class="title class_">Person</span>(i,<span class="string">&quot;name&quot;</span>+i);</span><br><span class="line">        persons.add(person);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; personList2=persons.stream().</span><br><span class="line">        map(Person::getName).limit(<span class="number">10</span>).skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(personList2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<blockquote>
<p>name1<br>name2<br>name3<br>name4<br>name5<br>name6<br>name7<br>name8<br>name9<br>name10<br>[name4, name5, name6, name7, name8, name9, name10]</p>
</blockquote>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>distinct是去除流内重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arrays = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(arrays));</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; distinctList = list.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(distinctList);</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<blockquote>
<p>[1, 2, 3, 4]</p>
</blockquote>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted返回一个经过排序后的流，它有两种形式。sorted()或sorted(Comparator),这和集合类似，sorted()需要元素实现Comparable接口，而sorted(Comparator)是我们自己提供排序器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = roster.stream()</span><br><span class="line">               .sorted((p1,p2) -&gt; p1.getAge()-p2.getAge())</span><br><span class="line">               .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>例子为将roster中Person按年龄排序后返回一个新的List集合</p>
<h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式,它与前面的peek功能类似，只是forEach是一个终端操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roster.stream().forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<p>打印roster中所有person的姓名<br>forEach和常规的for循环没有性能上差异，仅仅是函数式风格与传统java风格的差别，所以如果遍历过程中对集合元素进行增删，同样会抛出ConcurrentModificationException异常.</p>
<blockquote>
<p>forEach 不能修改自己包含的本地变量值，也不能用 break&#x2F;return 之类的关键字提前结束循环。</p>
</blockquote>
<h3 id="forEachOrder"><a href="#forEachOrder" class="headerlink" title="forEachOrder"></a>forEachOrder</h3><p>和forEach同样的功能，不过在并行计算的时候forEachOrder可以保证处理元素有序</p>
<h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。需要注意的是findFirst返回的是一个Optional类型值，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">first</span> <span class="operator">=</span> roster.stream().findFirst().get();</span><br></pre></td></tr></table></figure>
<p>例子中为获取roster第一个元素</p>
<h3 id="min-x2F-max"><a href="#min-x2F-max" class="headerlink" title="min&#x2F;max"></a>min&#x2F;max</h3><p>min&#x2F;max是返回流内元素的Optional类型的最小&#x2F;最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">minAge</span> <span class="operator">=</span> roster.stream()</span><br><span class="line">	.map(Person::getAge)</span><br><span class="line">	.min(Integer::max)</span><br><span class="line">	.get()</span><br></pre></td></tr></table></figure>
<p>例子为获取roster中最大的年龄</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count返回流内元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line"><span class="type">long</span> count=list.stream()</span><br><span class="line">	.filter(i -&gt; i&gt;<span class="number">4</span>)</span><br><span class="line">	.count()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>3</p>
</blockquote>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。如果没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roster.stream() </span><br><span class="line">	.map(Person::getAge)</span><br><span class="line">	.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>上面例子中返回了roster所有人的年龄之和</p>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>collect是一个收集器功能方法，它将流内元素收集到一个容器内，collect也有两种形式，但是通常使用的是与Collectors相结合，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = roster.stream().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender = </span><br><span class="line">roster.stream().collect(Collectors.groupingBy(Person::getGender));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h1><p>并行计算将一个大的问题分解成一个个子问题，同时在多个线程解决这些子问题，并且最后将结果合并起来。在java 7后JavaSE提供了fork&#x2F;join 框架，但是我们需要自己来决定如果分割问题，合并结果，但在聚合操作中，使用stream可以帮我们完成这一切.<br>完成并行计算的另一个难点是集合框架中大多数集合是线程不安全的，尽管可以使用同步包装器来获得线程安全的集合，但是还会带来线程竞争问题。而在聚合操作中stream可以让我们使用线程不安全的集合，同时不必关心线程问题。<br>虽然聚合操作更为便易的让我们实现并行计算，但并行计算并不一定是更有效率的，需要我们实际验证。</p>
<h2 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h2><p>如果我们想要执行流并行计算，可以使用两种方式，要么Collection.parallelStream，或者调用BaseStream.parrallel.聚合操作的并行计算相当于多个管道同时处理流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection.parallelStream</span></span><br><span class="line"> roster.parallelStream()</span><br><span class="line">	.forEach(p -&gt; System.out.println(p.getName()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//BaseStream.parrallel</span></span><br><span class="line"> roster.stream()</span><br><span class="line">	.parallel()</span><br><span class="line">	.forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>

<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>管道处理流的顺序取决于我们使用的是并行流还是串行流,当使用并行流的时候，管道执行的顺序是由JVM来决定的,在并行流中如果想要包装元素处理的顺序的话，可以使用forEachOrder方法，但需要注意的是使用这个方法可能无法发挥出并行计算的好处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">  List&lt;Integer&gt; listOfIntegers =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intArray));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;Parallel stream&quot;</span>);</span><br><span class="line">  listOfIntegers</span><br><span class="line">          .parallelStream()</span><br><span class="line">          .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;Another parallel stream:&quot;</span>);</span><br><span class="line">  listOfIntegers</span><br><span class="line">          .stream()</span><br><span class="line">          .parallel()</span><br><span class="line">          .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;With forEachOrdered:&quot;</span>);</span><br><span class="line">  listOfIntegers</span><br><span class="line">          .parallelStream()</span><br><span class="line">          .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>Parallel stream<br>6 5 8 7 2 3 1 4<br>Another parallel stream:<br>3 4 2 1 8 7 5 6<br>With forEachOrdered:<br>1 2 3 4 5 6 7 8   </p>
</blockquote>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">Java 8 中的 Streams API 详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（二十）Collections</title>
    <url>/2017/04/29/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89Collections/</url>
    <content><![CDATA[<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><hr>
<p>Collections是一个只包含一系列用来操作或返回集合的静态方法的工具类。<br>Collections提供了很多的包装器，用来包装一些通用集合，为它们提供额外的功能，包装器通常使用是传入集合的通用实现作为参数，然后返回一个该实现类型的新的集合，如果传入的参数引用为null的话，则会抛出NullPointerException 异常。<br>此外Collectios中提供一系列的算法来操作集合，比如进行集合的排序，反转，混排等等，一般这些方法都接受一个集合参数，并且主要是针对List类型的集合，一小部分是Collection类型。<br>Collections提供的功能可以大体分为以下几种   </p>
<span id="more"></span>
<ol>
<li><strong>包装实现（Wrapper Implementations）</strong><ul>
<li>同步包装器（Synchronization Wrappers）</li>
<li>不可变包装器（Unmodifiable Wrappers）</li>
<li>类型检查包装器（Checked Interface Wrappers）</li>
</ul>
<pre><code>  			  
</code></pre>
</li>
<li><strong>便利实现（Convenience Implementations）</strong>  <ul>
<li>不可变多重元素复制List（Immutable Multiple-Copy List）</li>
<li>不可变单元素集合(Immutable Singleton Collections)</li>
<li>不可变空集（Immutable Empty Set, List, and Map）</li>
</ul>
</li>
<li><strong>集合操作（Collections Operation）</strong><ul>
<li>排序（Sorting）</li>
<li>混排（Shuffling）</li>
<li>查找（Searching）</li>
<li>常规数据操作（Routine Data Manipulation）</li>
<li>组成（Composition）</li>
<li>极值查找（Finding Extreme Values）</li>
</ul>
</li>
</ol>
<hr>
<h1 id="包装实现"><a href="#包装实现" class="headerlink" title="包装实现"></a>包装实现</h1><hr>
<blockquote>
<p>Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the decorator pattern.   </p>
</blockquote>
<p>Collections提供的包装器会将实际工作交给传入的指定集合，但是在它上面附加一些额的功能，对于设计模式粉丝来说，这是典型的装饰者模式.</p>
<h2 id="同步包装器"><a href="#同步包装器" class="headerlink" title="同步包装器"></a>同步包装器</h2><p>集合框架中大部分通用实现集合都是线程不安全的，而同步包装器可以将这些集合包装成线程安全集合。Collections为集合框架六个核心接口Collections,List,Set,Map,SortedSet以及SortedMap都提供了一个静态方法</p>
<ul>
<li>public static &lt;T&gt; Collection&lt;T&gt; <em><strong>synchronizedCollection</strong></em>(Collection&lt;T&gt; c);</li>
<li>public static &lt;T&gt; Set&lt;T&gt; <em><strong>synchronizedSet</strong></em>(Set&lt;T&gt; s);</li>
<li>public static &lt;T&gt; List&lt;T&gt; <em><strong>synchronizedList</strong></em>(List&lt;T&gt; list);</li>
<li>public static &lt;K,V&gt; Map&lt;K,V&gt; <em><strong>synchronizedMap</strong></em>(Map&lt;K,V&gt; m);</li>
<li>public static &lt;T&gt; SortedSet&lt;T&gt; <em><strong>synchronizedSortedSet</strong></em>(SortedSet&lt;T&gt; s);</li>
<li>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; <em><strong>synchronizedSortedMap</strong></em>(SortedMap&lt;K,V&gt; m);</li>
</ul>
<p>这些方法都返回了一个线程安全的集合，为了保证串行存取，所有对传入的指定集合的访问都必须通过方法返回的集合来完成。因此最好的做法是不保持对传入集合的引用，如下文写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Type&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Type&gt;());</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在并发访问的时候，如果对同步包装器返回的集合进行迭代，需要在迭代临界区加上同步代码块，因为迭代是通过多次调用集合来完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);</span><br><span class="line"><span class="keyword">synchronized</span>(c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Type e : c)</span><br><span class="line">        foo(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用同步包装器一个小的缺点是，你没有办法调用非接口实现的方法，例如在前面例子中list虽然是包装的ArrayList集合，但是它无法调用ArrayList的ensureCapacity方法。</p>
<h2 id="不可变包装器"><a href="#不可变包装器" class="headerlink" title="不可变包装器"></a>不可变包装器</h2><p>和同步包装器不同的是，不可变包装器是限制了集合的一些操作，比如增删元素，调用被限制的操作，则会抛出UnsupportedOperationException异常。不可变包装器主要有两个用途</p>
<ul>
<li>确使集合在创建时就不可变。在这种用途下，最好不要保持对传入集合的引用，这样可以绝对保证集合的不可变性。</li>
<li>使客户端可以以只读方式访问你的数据结构。你可以保持对传入集合的引用，同时分发返回集合给客户端，这样客户端只看数据而不能修改，但是你亦然保留对数据的所有操作权限。</li>
</ul>
<p>同同步包装器一样，不可变包装器对集合框架的六个核心接口都提供了一个静态工厂方法</p>
<ul>
<li>public static &lt;T&gt; Collection&lt;T&gt; <em><strong>unmodifiableCollection</strong></em>(Collection&lt;T&gt; c);</li>
<li>public static &lt;T&gt; Set&lt;T&gt; <em><strong>unmodifiableSet</strong></em>(Set&lt;T&gt; s);</li>
<li>public static &lt;T&gt; List&lt;T&gt; <em><strong>unmodifiableList</strong></em>(List&lt;T&gt; list);</li>
<li>public static &lt;K,V&gt; Map&lt;K,V&gt; <em><strong>unmodifiableMap</strong></em>(Map&lt;K,V&gt; m);</li>
<li>public static &lt;T&gt; SortedSet&lt;T&gt; <em><strong>unmodifiableSortedSet</strong></em>(SortedSet&lt;T&gt; s);</li>
<li>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; <em><strong>unmodifiableSortedMap</strong></em>(SortedMap&lt;K,V&gt; m);</li>
</ul>
<h2 id="类型检查包装器"><a href="#类型检查包装器" class="headerlink" title="类型检查包装器"></a>类型检查包装器</h2><p>类型检查包装器是提供给泛型集合的。它会返回一个给定集合的动态类型安全视图，如果我们向返回的视图里添加一个错误类型的元素，就会抛出ClassCastException异常。</p>
<p>类型检查包装器提供了对之前文章中介绍的所有接口提供了一个静态工厂方法，其方法形式为</p>
<ul>
<li>public static &lt;E&gt; Collection&lt;E&gt; ***checkedCollection *** (Collection&lt;E&gt; c,Class&lt;E&gt; type)</li>
</ul>
<p>之所以提供这个功能，我们知道泛型机制是在编译时期，对集合元素类型进行静态检查检查，但是这样的话，如果在运行时期添加元素，或者将泛型集合引用传递给另一个集合，则泛型机制就会失效，比如下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; commonList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List&lt;String&gt; checkedList = Collections.checkedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),String.class);</span><br><span class="line">         </span><br><span class="line">commonList.add(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">checkedList.add(<span class="string">&quot;string&quot;</span>);</span><br><span class="line"></span><br><span class="line">List newCommonList1= commonList;</span><br><span class="line">List newCheckedList2= checkedList;</span><br><span class="line"></span><br><span class="line">newCommonList1.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(commonList); <span class="comment">//控制台输出[string, 1]</span></span><br><span class="line">newCheckedList2.add(<span class="number">1</span>);         <span class="comment">//抛出ClassCastException异常</span></span><br><span class="line">System.out.println(checkedList);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="便利实现"><a href="#便利实现" class="headerlink" title="便利实现"></a>便利实现</h1><hr>
<h2 id="不可变多重复制元素List"><a href="#不可变多重复制元素List" class="headerlink" title="不可变多重复制元素List"></a>不可变多重复制元素List</h2><p>有时我们可能需要一个包含重复单一元素不可变的List集合，Collections.nCopies方法就返回一个这样的List.这种实现主要有两种用法</p>
<ul>
<li>初始化一个新创建的List</li>
<li>扩展一个已经存在的List</li>
</ul>
<p>比如，我们需要要给包含10个“null”类型的List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Type&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Type&gt;(Collections.nCopies(<span class="number">100</span>, (Type)<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>或者向一个已经存在的集合添加重复元素,下面例子演示，向一个字母表List中添加10个“a”元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alphabetList.addAll(Collections.nCopies(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="不可变单元素集合"><a href="#不可变单元素集合" class="headerlink" title="不可变单元素集合"></a>不可变单元素集合</h2><p>有时我们可能需要一个不可变的单元素集合，它只包含一个给定的元素。Collections中分别为为Set,List,Map三种集合提供了此类实现的静态方法</p>
<ul>
<li>public static &lt;T&gt; Set&lt;T&gt; <em><strong>singleton</strong></em>(T o)  </li>
<li>public static &lt;T&gt; List&lt;T&gt; <em><strong>singletonList</strong></em>(T o)  </li>
<li>public static &lt;K,V&gt; Map&lt;K,V&gt; <em><strong>singletonMap</strong></em>(K key,V value)</li>
</ul>
<p>这种实现主要用来作为一个方法的参数出传递，比如一个方法只接受集合类型参数，而这个集合参数只有一个元素，那我们就可以使用这个这些方法，而不必自己初始化一个集合，一个典型的例子是我们要要从一个集合中删除全部的给定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c.removeAll(Collections.singleton(e));</span><br></pre></td></tr></table></figure>

<h2 id="不可变空集"><a href="#不可变空集" class="headerlink" title="不可变空集"></a>不可变空集</h2><p>Collections还提供了返回空集的静态方法和字段常量</p>
<p>字段</p>
<ul>
<li>public static final List <strong>EMPTY_LIST</strong></li>
<li>public static final Set <strong>EMPTY_SET</strong>  </li>
<li>public static final Map <strong>EMPTY_MAP</strong></li>
</ul>
<p>方法</p>
<ul>
<li>public static final &lt;T&gt; List&lt;T&gt; <em><strong>emptyList</strong></em>();</li>
<li>public static fibal &lt;T&gt; Set&lt;T&gt; <em><strong>emptySet</strong></em>();</li>
<li>public static final &lt;T&gt; List&lt;T&gt; <em><strong>emptyMap</strong></em>();</li>
</ul>
<blockquote>
<ul>
<li>可以看出方法相比提供的常量，只是添加了泛型机制   </li>
<li>这些空集都是不可变的，执行元素的添加操作会抛出UnsupportedOperationException异常</li>
</ul>
</blockquote>
<hr>
<h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Collections提供了两个排序方法</p>
<ul>
<li>sort(List&lt;T&gt; list)</li>
<li>sort(List&lt;T&gt; list,  Comparator&lt;? super T&gt; c)</li>
</ul>
<p>Collections的排序方法可以将List集合内元素按自然排序方式，或者给定的排序器进行排序，这在<a href="">java 集合框架(十七) 对象排序</a>已经介绍过</p>
<h2 id="混排"><a href="#混排" class="headerlink" title="混排"></a>混排</h2><p>Collections提供了两个混排方法</p>
<ul>
<li><strong>shuffle</strong>(List&lt;?&gt; list)</li>
<li><strong>shuffle</strong>(List&lt;?&gt; list,Random rnd)</li>
</ul>
<p>shuffle(List)将传入的List集合内元素随机打乱排序。而shuffle(List,Random)则还需要一个Random作为随机源，其实shuffle(List)也是调用shuffle(List,Random)方法，只是使用了默认的Random对象，以系统时间作为Random的随机种子。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Collections提供了二分查找算法查找元素二分查找法会从集合中间元素开始，按照自然排序的规则开始对比，如果集合中间元素大于给定元素，则向集合前移动继续对比，如果小于给定元素，则向后移动继续对比，直到找到相同元素为止。所以按照这种查找方法，集合必须事先按升序排序好，否则查找结果是无法预知的，而且如果查找的元素在集合内有多个结果，也无法保证哪一个会被先找到。<br>Collections依此提供了两个静态方法</p>
<ul>
<li><strong>binarySearch</strong>((List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key))</li>
<li><strong>binarySearch</strong>(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</li>
</ul>
<p>第一个方法，假定了提供的List已经按照升序排序好，而第二种则需提供一个排序器，来先按升序排序集合，然后进行查找。如果找到元素，则返回其索引值，如果给定元素不在集合中的话，则返回(-(insertion point) - 1)，insertion point指的是如果要向集合中以升序排序方式插入该给定的元素，它的插入位置。</p>
<p>如下面例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;specify value&quot;</span>+i+<span class="string">&quot;return value:   &quot;</span>+Collections.binarySearch(list,i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>specify value  0  return value:   -1<br>specify value  1  return value:   -1<br>specify value  2  return value:   0<br>specify value  3  return value:   1<br>specify value  4  return value:   2<br>specify value  5  return value:   -4<br>specify value  6  return value:   -4  </p>
</blockquote>
<h2 id="常规数据操作"><a href="#常规数据操作" class="headerlink" title="常规数据操作"></a>常规数据操作</h2><p>Collections提供了五种对List集合常规数据操作的算法。</p>
<ul>
<li><strong>reverse</strong>—-反转List元素的顺序</li>
<li><strong>fill</strong>—-用给定的值重写List中的每个元素</li>
<li><strong>copy</strong>—-将源List集合中元素复制并重写到目标List集合中，必须要保证目标集合<strong>实际元素个数</strong>大于源集合，如果有剩余空间，那么目标集合剩余元素不受影响</li>
<li><strong>swap</strong>—-交换List集合中指定两个位置元素的值</li>
<li><strong>addAll</strong>—-将指定的所有元素都添加到一个Collection类型集合中。</li>
</ul>
<p>下面用实际代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(list,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转集合</span></span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝集合</span></span><br><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">    list1.add(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Collections.copy(list1,list);</span><br><span class="line">System.out.println(list1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对换元素</span></span><br><span class="line">Collections.swap(list,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充元素</span></span><br><span class="line">Collections.fill(list,<span class="literal">null</span>);</span><br><span class="line">System.out.println(list);     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出为</p>
<blockquote>
<p>[1, 2, 3, 4, 5]<br>[5, 4, 3, 2, 1]<br>[5, 4, 3, 2, 1, 0, 0]<br>[1, 4, 3, 2, 5]<br>[null, null, null, null, null]</p>
</blockquote>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>Collections提供了频率（frequency ）和不相交（disjoint ）两种算法，来测试一个或多个集合的组成</p>
<ul>
<li><strong>frequency</strong>(Collection&lt;?&gt; c,Object o)</li>
<li><strong>disjoint</strong>(Collection<?> c1,Collection<?> c2)</li>
</ul>
<p>frequency可以统计给定对象在集合中出现的次数,如果元素不在集合中的话则返回0；<br>disjiont是判断给定的两个集合是否有交集，没有的话则返回true。</p>
<h2 id="极值查找"><a href="#极值查找" class="headerlink" title="极值查找"></a>极值查找</h2><p>Collections可以查找集合中的最大值最小值，提供了一下四个方法</p>
<ul>
<li><strong>min</strong>(Collection&lt;? extends T&gt; coll)</li>
<li><strong>min</strong>(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)</li>
<li><strong>max</strong>(Collection&lt;? extends T&gt; coll)</li>
<li><strong>max</strong>(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)</li>
</ul>
<p>极值查找的方法需要集合的元素实现Comparable接口，按照自然排序的方式对比元素，如果元素没有继承Comparable接口，还可以使用第二种方式，在方法中我们自己提供一个排序器，对元素进行比较。</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（二）Iterable接口</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89Iterable%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>　　Iterable接口是java 集合框架的顶级接口,实现此接口使集合对象可以通过迭代器遍历自身元素,我们可以看下它的成员方法</p>
<table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator&lt;T&gt;</td>
<td><em><strong>iterator</strong></em>()</td>
<td>返回一个内部元素为T类型的迭代器</td>
</tr>
<tr>
<td>default void</td>
<td><em><strong>forEach</strong></em>(Consumer&lt;? super T&gt; action)</td>
<td>对内部元素进行遍历,并对元素进行指定的操作</td>
</tr>
<tr>
<td>default Spliterator&lt;T&gt;</td>
<td><em><strong>spliterator</strong></em>()</td>
<td>创建并返回一个可分割迭代器</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>　　Iterable最早出现在JDK 1.5,开始只有iterator()一个抽象方法,需要子类来实现一个内部迭代器Iterator遍历元素.后两个方法是Java 8后新添加的,forEach(Consumer action)是为了方便遍历操作集合内的元素,spliterator()则提供了一个可以并行遍历元素的迭代器,以适应现在cpu多核时代并行遍历的需求.</p>
<p>　　其中我们可以看下default修饰符,这也是Java 8后新出现的,我们知道,如果我们给一个接口新添加一个方法,那么所有他的具体子类都必须实现此方法,为了能给接口拓展新功能,而又不必每个子类都要实现此方法,Java 8新加了default关键字,被其修饰的方法可以不必由子类实现,并且由dafault修饰的方法在接口中有方法体,这打破了Java之前对接口方法的规范.</p>
<p>　　下面是使用迭代器通常写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        iteratorCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">iteratorCase</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator=list.iterator(); <span class="comment">//获取ArrayList内部迭代器</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;            <span class="comment">//hasNext()方法判断是否还有元素</span></span><br><span class="line">            System.out.println(iterator.next()); <span class="comment">//next()返回当前元素,并且将指针移向下个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外我们还可以使用”for-each loop”形式进行遍历,增强for形式在Java中只是一个语法糖,实际编译的时候,还是会转换为迭代器形式,上面方法体可以改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">         System.out.println(integer);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>进行迭代遍历的时候我们需要注意这种情况,就是在遍历的过程中,如果我们对元素进行添加删除,那么会造成并行修改异常(ConcurrentModificationException),如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                list.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>对于这种情况,,我们应当使用迭代器Iterator内部的remove()方法,而不是使用集合list直接删除元素,正确写法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                iterator.remove();  <span class="comment">//使用迭代器进行删除元素,注意这里remove()没有参数,它是直接删除当前迭代的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们自己想自己写一个集合,实现Iterable接口,并可以使用”for-each loop”形式遍历,那么我们需要自己来重写一个迭代器(Iterator)并返回它,看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　这样就可以使用”for-each loop”的形式进行遍历</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架（十七） 对象排序</title>
    <url>/2017/04/29/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h1><hr>
<p>看下面例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<p>控制台将打印</p>
<blockquote>
<p>[a, b, d, e, f, g]</p>
</blockquote>
<p>　这种排序方式被称为自然排序,而之所以Collections.sort(list)能对list中的元素进行自然排序,是因为String实现了Comparable接口，换而言之，list中的元素只有实现了Comparable接口才能使用Collections.sort进行排序.下面这些java中重要的类都实现了Comparable接口.<br> <span id="more"></span></p>
<table>
<thead>
<tr>
<th>类</th>
<th>自然排序</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Character</td>
<td>Unsigned numerical</td>
</tr>
<tr>
<td>Long</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Integer</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Short</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Double</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Float</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>BigInteger</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>Signed numerical</td>
</tr>
<tr>
<td>Boolean</td>
<td>Boolean.FALSE &lt; Boolean.TRUE</td>
</tr>
<tr>
<td>File</td>
<td>System-dependent lexicographic on path name</td>
</tr>
<tr>
<td>String</td>
<td>Lexicographic</td>
</tr>
<tr>
<td>Date</td>
<td>Chronological</td>
</tr>
<tr>
<td>CollationKey</td>
<td>Locale-specific lexicographic</td>
</tr>
</tbody></table>
<hr>
<h1 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h1><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparable只有一个方法compareTo(T)用来与其他对象比较,它的返回值有三种可能  </p>
<ul>
<li>相等时返回0  </li>
<li>大于目标对象返回正数  </li>
<li>小于目标对象返回负数</li>
</ul>
<p>如果目标对象无法与接收的对象比较的话,则会抛出ClassCastException.</p>
<p>我们可以自己写一个实现Comparable的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; p.getName() == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">					</span><br><span class="line">            <span class="comment">//按照姓名，年龄的顺序进行比较排序        </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nameCmp</span> <span class="operator">=</span> <span class="built_in">this</span>.name.compareTo(p.getName());</span><br><span class="line">            <span class="type">return</span> <span class="variable">nameCmp</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="built_in">this</span>.age - p.getAge() : nameCmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h1><hr>
<p>在List接口定义的方法中，也有一个排序方法sort(Comparator),这个方法并不需要元素对象本身实现Comparable接口，而是由我们来提供一个排序器Comparator，对元素进行比较排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>
<p>Comparator是一个函数式接口，compare方法的两个参数就是需要进行比较的两个元素，通常我们使用以下写法对元素进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">14</span>);</span><br><span class="line">     <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">15</span>);</span><br><span class="line">     <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">     List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">     list.add(p1);</span><br><span class="line">     list.add(p2);</span><br><span class="line">     list.add(p3);</span><br><span class="line"><span class="comment">//使用匿名内部类方式</span></span><br><span class="line">     list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">nameCmp</span> <span class="operator">=</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">             <span class="type">return</span> <span class="variable">nameCmp</span> <span class="operator">=</span>= <span class="number">0</span> ? o1.getAge() - o2.getAge() : nameCmp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">     list.sort((o1, o2) -&gt; &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nameCmp</span> <span class="operator">=</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">         <span class="type">return</span> <span class="variable">nameCmp</span> <span class="operator">=</span>= <span class="number">0</span> ? o1.getAge() - o2.getAge() : nameCmp;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     System.out.println(list);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<blockquote>
<p>[Person{name&#x3D;’lisi’, age&#x3D;16}, Person{name&#x3D;’zhangsan’, age&#x3D;14}, Person{name&#x3D;’zhangsan’, age&#x3D;15}]</p>
</blockquote>
<p>我们对于元素的多个因素进行比较的时候，比如上面例子中的Person,我们首先比较第一个字段name，如果相同的话再进行比较第二个字段age。</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（十五）Deque</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89Deque/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　Deque是Queue的子接口,我们知道Queue是一种队列形式,而Deque则是双向队列,它支持从两个端点方向检索和插入元素,因此Deque既可以支持LIFO形式也可以支持LIFO形式.Deque接口是一种比Stack和Vector更为丰富的抽象数据形式,因为它同时实现了以上两者.</p>
<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>添加功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>void</td>
<td><strong>push</strong>(E)</td>
<td>向队列头部插入一个元素,失败时抛出异常</td>
</tr>
<tr>
<td>void</td>
<td><strong>addFirst</strong>(E)</td>
<td>向队列头部插入一个元素,失败时抛出异常</td>
</tr>
<tr>
<td>void</td>
<td><strong>addLast</strong>(E)</td>
<td>向队列尾部插入一个元素,失败时抛出异常</td>
</tr>
<tr>
<td>void</td>
<td><strong>offerFirst</strong>(E)</td>
<td>向队列头部加入一个元素,失败时返回false</td>
</tr>
<tr>
<td>void</td>
<td><strong>offerLast</strong>(E)</td>
<td>向队列尾部加入一个元素,失败时返回false</td>
</tr>
<tr>
<td><strong>获取功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>getFirst</strong>()</td>
<td>获取队列头部元素,队列为空时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>getLast</strong>()</td>
<td>获取队列尾部元素,队列为空时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>peekFirst</strong>()</td>
<td>获取队列头部元素,队列为空时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>peekLast</strong>()</td>
<td>获取队列尾部元素,队列为空时返回null</td>
</tr>
<tr>
<td><strong>删除功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><strong>removeFirstOccurrence</strong>(Object)</td>
<td>删除第一次出现的指定元素,不存在时返回false</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>removeLastOccurrence</strong>(Object)</td>
<td>删除最后一次出现的指定元素,不存在时返回false</td>
</tr>
<tr>
<td><strong>弹出功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>pop</strong>()</td>
<td>弹出队列头部元素,队列为空时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>removeFirst</strong>()</td>
<td>弹出队列头部元素,队列为空时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>removeLast</strong>()</td>
<td>弹出队列尾部元素,队列为空时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>pollFirst</strong>()</td>
<td>弹出队列头部元素,队列为空时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>pollLast</strong>()</td>
<td>弹出队列尾部元素,队列为空时返回null</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Iterator&lt;E&gt;</td>
<td><strong>descendingIterator</strong>()</td>
<td>返回队列反向迭代器</td>
</tr>
</tbody></table>
<p>可以看出Deque在Queue的方法上新添了对队列头尾元素的操作,add,remove,get形式的方法会在有界队列满员和空队列时抛出异常,offer,poll,peek形式的方法则会返回false或null.</p>
<p>此外方法表中需要注意push &#x3D; addFirst,pop &#x3D; removeFirst,只是使用了不同的方法名体现队列表示栈结构时的特点.</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>　　同Queue一样Deque的实现也可以划分成<strong>通用实现</strong>和<strong>并发实现</strong>.</p>
<p>　　通用实现主要有两个实现类ArrayDeque和LinkedList.</p>
<p>　　ArrayDeque是个可变数组,它是在Java 6之后新添加的,而LinkedList是一种链表结构的list.LinkedList要比ArrayDeque更加灵活,因为它也实现了List接口的所有操作,并且可以插入null元素,这在ArrayDeque中是不允许的.</p>
<p>　　从效率来看,ArrayDeque要比LinkedList在两端增删元素上更为高效,因为没有在节点创建删除上的开销.最适合使用LinkedList的情况是迭代队列时删除当前迭代的元素.此外LinkedList可能是在遍历元素时最差的数据结构,并且也LinkedList占用更多的内存,因为LinkedList是通过链表连接其整个队列,它的元素在内存中是随机分布的,需要通过每个节点包含的前后节点的内存地址去访问前后元素.</p>
<p>　　总体ArrayDeque要比LinkedList更优越,在大队列的测试上有3倍与LinkedList的性能,最好的是给ArrayDeque一个较大的初始化大小,以避免底层数组扩容时数据拷贝的开销.</p>
<p>　　LinkedBlockingDeque是Deque的并发实现,在队列为空的时候,它的takeFirst,takeLast会阻塞等待队列处于可用状态</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（十）List</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%8D%81%EF%BC%89List/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<p>　　List是一种有序集合,有时也被称为序列,可以有重复的元素.List集合相比Collection,除了直接继承的方法外,有以下拓展的操作方法</p>
<ul>
<li><strong>位置访问</strong>—可以基于元素索引来操作元素,比如get,set,add,addAll和remove方法都支持这一点</li>
<li><strong>搜索</strong>—在集合中搜索一个特定对象,并返回它的索引,如indexOf和lastIndexOf方法<br>迭代—除了继承自Collection中的迭代器,List还提供一个基于Iterator拓展的ListIterator迭代器</li>
<li><strong>视图</strong>—subList方法提供任意的范围操作方法<br>　　同Set一样,List也要求强化equal和hashCode以使两个集合元素可以进行逻辑上的比较,而不考虑他们具体实现类的类型.当两个List有相同的元素时,他们被认为是相等的.</li>
</ul>
<span id="more"></span>
<hr>
<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><hr>
<table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>添加功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><strong>add</strong>(int,E)</td>
<td>向集合指定索引处插入一个对象,该索引必须与集合连贯</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>addAll</strong>(int,Colletion&lt;? extend E&gt;)</td>
<td>向集合指定索引处插入一个集合的所有元素,该索引必须与集合连贯</td>
</tr>
<tr>
<td><strong>修改功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>set</strong>(int,E)</td>
<td>将集合指定索引出元素修改为为指定对象,并返回旧元素</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>remove</strong>(int)</td>
<td>移除指定索引处元素,集合元素数没有改变时返回false</td>
</tr>
<tr>
<td>void</td>
<td><strong>replaceAll</strong>(UnaryOperator&lt;E&gt;)</td>
<td>按照指定一元运算对集合内所有元素进行修改</td>
</tr>
<tr>
<td><strong>获取功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td><strong>get</strong>(int)</td>
<td>获取指定索引处元素</td>
</tr>
<tr>
<td>int</td>
<td><strong>indexOf</strong>(Object)</td>
<td>从集合中查找给定对象第一次出现的索引,没有时返回-1</td>
</tr>
<tr>
<td>int</td>
<td><strong>lastIndexOf</strong>(Object)</td>
<td>从集合中查找给定对象最后一次出现的索引,没有时返回-1</td>
</tr>
<tr>
<td>List&lt;E&gt;</td>
<td><strong>subList</strong>(int,int)</td>
<td>返回指定索引之间元素组成的视图,包含起始索引元素,不包括结束索引元素</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ListIterator&lt;E&gt;</td>
<td><strong>listIterator</strong>()</td>
<td>获取集合序列迭代器</td>
</tr>
<tr>
<td>ListIterator&lt;E&gt;</td>
<td><strong>listIterator</strong>(int)</td>
<td>获取集合序列迭代器,并将指针指向给定索引元素前</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>void</td>
<td><strong>sort</strong>(Comparator&lt;s super E&gt;)</td>
<td>通过给定的排序器进行排序</td>
</tr>
</tbody></table>
<p>　List大多操作元素的方法都与索引有关,所以需要注意可能引起索引越界的问题,add,remove,set,get,subList这些方法,当给定索引大于集合最大索引或者为负数时,都会抛出IndexOutOfBoundsException异常.</p>
<blockquote>
<p>List进行视图操作时,同Set集合类似,任何对视图的修改都会影响到原集合,反之亦然.</p>
</blockquote>
<hr>
<h1 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List遍历</h1><hr>
<p>　　List从自Collection继承的Iterator迭代器基础上,还根据List特点拓展提供了一个ListIterator迭代器,ListIterator继承自Iterator,所以它也有hasNext(),next(),remove()这些方法.List在获取ListIterator时,提供了两个方法,分别是listIterator()和listIterator(int),区别是有参数的方法在获取迭代器时,会把迭代器指针预先指向给定的索引元素前.ListIterator不仅可以正向遍历,也可以反向遍历,通过hasPrevious(),previous()两个方法,从方法名可以看出,这两个方法和hasNext(),next()类似,只是操作方向反.ListIterator还提供几个方法nextIndex(),previousIndex(),add(E),set(E).<br>　　nextIndex()和previousIndex()分别是获取迭代当前元素的前一个和后一个元素的索引,有这样两种情况需要注意</p>
<ol>
<li><p>指针指向集合头部元素前时,previousIndex()返回-1;</p>
</li>
<li><p>指针指向集合尾部元素后时,nextIndex()返回list.size();</p>
</li>
</ol>
<p>add(E)方法会在迭代的时候,向指针移动的方向后面添加一个元素,而set(E)方法将当前迭代的元素修改为给定对象.</p>
<hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><hr>
<p>　　List的实现也分两种,<strong>通用实现</strong>和<strong>专用实现</strong></p>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>　　通用实现类主要有两个ArrayList和LinkedList.通常我们拿最多使用的是ArrayList,它对元素访问花费常量时间.但是如果频繁的对一个List头部插入元素,或者遍历集合删除元素的时候应该考虑使用LinkedList.这些操作上,LinkedList花费常量时间,ArrarList花费线性时间,在元素的访问上LinkedList花费线性时间,而ArrayList花费常量时间,这是因为ArrayList底层通过数组结构来实现,当对元素的增删时,需要重新开辟一份内存空间,并拷贝原来的数据,而LinkedList底层是链表结构,每个元素都是一个节点,节点在内存中的存储是无序随机的,但每个节点都包含前一个节点和后一个节点的内存地址,从而实现查找,在增删元素的时候,只需要修改特定节点和其对其他节点的联系.</p>
<p>　　综合考虑,当要使用LinkedList的时候最好测试一下LinkedList和ArrayList的性能,通常ArrayList表现更好些.</p>
<p>　　List还有两个遗留实现Vector,Stack.Vector相比ArrayList是线程安全的,Stack是一种后进先出的数据结构(LIFO),继承自Vector.这两个实现都不推荐使用,他们是java早期版本的遗留,仅为向上兼容,可用Collections提供的静态同步封装器封装ArrayList代替Vector,虽然Vector性能要稍好些,使用Deque的通用实现代替Stack.</p>
<h2 id="专用实现"><a href="#专用实现" class="headerlink" title="专用实现"></a>专用实现</h2><p>　　List专用实现类主要有CopyOnWriteList,它和CopyOnWriteSet类似,实现读写分离,不需要手动进行同步,适合用来维持一个频繁读取而很少修改的事件处理列表.</p>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合框架（四）Set</title>
    <url>/2017/04/28/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89Set/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="http://www.processon.com/chart_image/58e85dc4e4b0c32f7cf0e28f.png" alt="Set"><br>　　Set是一种没有重复元素的集合,它所有的方法都是直接继承自Collection接口,但是添加了一个对重复元素的限制.Set要求元素强化equals和hashCode两个方法,以使Set集合可以对元素进行排序和对比.<br>　　Set中没有新添方法,而是在子接口SortedSet和NavigableSet中拓展了一些功能</p>
<span id="more"></span>
<h1 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h1><table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>端点操作</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>first</strong>()</td>
<td>返回当前集合第一个元素(低位),没有时抛出异常</td>
</tr>
<tr>
<td>E</td>
<td><strong>last</strong>()</td>
<td>返回当前集合最后一个元素(高位),没有时抛出异常</td>
</tr>
<tr>
<td><strong>视图功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SortedSet&lt;E&gt;</td>
<td><strong>subSet</strong>(E，E)</td>
<td>返回指定两元素间元素组成的集合</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt;</td>
<td><strong>headSet</strong>(E)</td>
<td>返回指定元素之前元素组成的集合,不包含指定元素</td>
</tr>
<tr>
<td>SortedSet&lt;E&gt;</td>
<td><strong>tailSet</strong>(E)</td>
<td>返回指定元素之后元素组成的集合,包含指定元素</td>
</tr>
<tr>
<td><strong>判读功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Comparator&lt;? extend E&gt;</td>
<td><strong>comparator</strong>()</td>
<td>返回排序器</td>
</tr>
</tbody></table>
<p>SortedSet内的元素以自然排序方式维持升序排序,或者依照指定的排序器排序,SortedSet集合相比Set添加了以下对元素操作的方式</p>
<ul>
<li><strong>视图</strong>–允许从SortedSet截取并返回任意范围的元素视图</li>
<li><strong>端点操作</strong>—可以直接获取集合头或尾的元素</li>
<li><strong>排序器</strong>—返回用于排列元素的排序器</li>
</ul>
<p>需要格外注意的是,SortedSet视图的端点指向的是存储元素的内存空间,而不是给定的端点元素,视图仅仅是一个查看原集合的窗口,因此任何对视图的操作都会影响原集合,反之亦然.SortedSet在选取视图的时候,需要给定视图的截取的端点,并且含头不含尾,如果想要一个闭区间,同时包含两端点,可以在尾端点后加”&#x2F;0”(空白字符),这样按照自然排序,前面一个字符自然就是我们给定的尾端点元素.</p>
<h1 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h1><table>
<thead>
<tr>
<th>修饰符和返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>导航功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>lower</strong>(E)</td>
<td>返回指定对象之前的元素,没有时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>floor</strong>(E)</td>
<td>返回小于或等于指定对象的元素,没有时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>higher</strong>(E)</td>
<td>返回指定对象之后的元素,没有时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>ceiling</strong>(E)</td>
<td>返回大于或等于指定对象的元素,没有时返回null</td>
</tr>
<tr>
<td><strong>视图功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt;</td>
<td><strong>subSet</strong>(E,boolean,E,boolean)</td>
<td>返回指定端点间元素组成的集合,布尔值决定是否包含指定元素</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt;</td>
<td><strong>headSet</strong>(E,boolean)</td>
<td>返回指定端点前元素组成的集合,布尔值决定是否包含指定元素</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt;</td>
<td><strong>tailSet</strong>(E,boolean)</td>
<td>返回指定端点后元素组成的集合,布尔值决定是否包含指定元素</td>
</tr>
<tr>
<td>NavigableSet&lt;E&gt;</td>
<td><strong>decendingSet</strong>()</td>
<td>返回与原集合相反排序的集合</td>
</tr>
<tr>
<td><strong>弹出功能</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td><strong>pollFirst</strong>()</td>
<td>移除并返回集合第一个元素,集合为空时返回null</td>
</tr>
<tr>
<td>E</td>
<td><strong>pollLast</strong>()</td>
<td>移除并返回集合最后一个元素,集合为空时返回null</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Iterator&lt;E&gt;</td>
<td><strong>decendingIterator</strong>()</td>
<td>获取集合的降序迭代器</td>
</tr>
</tbody></table>
<p>　　NavigableSet接口继承自SortedSet,视图操作上相比SortedSet,NavigableSet不仅多了一个decendingSet()获取反相排序的集合,而且subSet,headSet,tailSet还多了一个boolean类型参数,这个参数决定返回集合视图中是否包含给定的元素.NavigableSet还有一系列的导航方法,可以更具给定对象在集合内向前或向后寻找满足条件的元素</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>Set接口的实现分为<strong>通用实现</strong>和<strong>专用实现</strong></p>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>通用实现类主要有三个<strong>HashSet</strong>,<strong>LinkedHashSet</strong>和<strong>TreeSet</strong>.</p>
<ul>
<li>HashSet通过哈希表存储元素,它是Set通用类中性能最好的一个,但不保证元素的排序.</li>
<li>TreeSet以红黑树结构存储数据,它的元素按一定规则排序,所以他的性能要比HashSet差许多.</li>
<li>LinkedHashSet在HashSet的基础上,增添了一个链表结构,来保证数据的按插入先后存储有序,因为需要维持一个链表,所以它的性能比HashSet稍微差一点,介于HashSet和TreeSet之间.</li>
</ul>
<p>HashSet的性能开销在集合内元素数和集合容量上都是线性的,因此HashSet初始化太大会浪费空间和时间,太小的话,在扩容的时候数据结构的拷贝浪费很多时间,如果不指定初始化大小,集合容量默认是16.过去指定一个初始化大小有一定好处,但现在不再是这样了.HashSet还有一个被称为负载系数的调优参数,但一般都是使用默认值,如果不设定负载系数的话,我们最好将初始化大小定义为两倍我们需要的值,即使用不到这么多,一般也不是什么大问题</p>
<h2 id="专用实现"><a href="#专用实现" class="headerlink" title="专用实现"></a>专用实现</h2><p>专用实现类主要有两个,<strong>EnumSet</strong>和<strong>CopyOnWriteArraySet</strong>.</p>
<ul>
<li>EnumSet是一个高性能的枚举类型的Set实现类,其内部元素必须都是相同的枚举类型.</li>
<li>CopyOnWriteArraySet是一个支持COW(copy-on-write)机制的集合.CopyOnWriteArraySet对集合的任何修改操作如,add,remove,set时,都会先复制一份,所以在CopyOnWriteArraySet可以安全的并发进行迭代和元素插入删除操作,不需要同步锁,实现了读写分离,但是读操作不具备实时性.CopyOnWriteArraySet只适用集合频繁迭代但很少修改的情景.</li>
</ul>
]]></content>
      <categories>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>《Maven官方文档》（二）构建生命周期介绍</title>
    <url>/2017/07/04/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="构建生命周期基础"><a href="#构建生命周期基础" class="headerlink" title="构建生命周期基础"></a>构建生命周期基础</h1><p>Maven是基于构建生命周期核心概念。这意味着构建和分发一个特定artifact（项目）的过程是被明确定义的。<br>对于构建项目的人员，这意味着只需要学习一小堆命令就能构建任何Maven项目，并且POM将确保他们获得所需的结果。<br>这有三个内置的生命周期：<strong>default</strong>，<strong>clean</strong>和<strong>site</strong>。<strong>default</strong>生命周期处理你的项目部署，<strong>clean</strong>生命周期处理你的项目清除，而<strong>site</strong>生命周期处理你的项目站点文档的创建。 </p>
<span id="more"></span>

<h2 id="构建生命周期由阶段组成"><a href="#构建生命周期由阶段组成" class="headerlink" title="构建生命周期由阶段组成"></a>构建生命周期由阶段组成</h2><p>每一个这些生命周期都由不同的构建阶段列表定义，其中构建阶段表示生命周期中的时期。<br>比如，default生命周期包含下几个阶段（有关生命周期阶段的完整列表，请参阅<a href="">生命周期参考</a>）</p>
<ul>
<li>**validate - **验证项目是否正确，所有必要的信息是否可用</li>
<li>**compile - **编译项目的源代码</li>
<li>**test - **使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署</li>
<li>**package - **编译代码并将其打包成可分发格式，如JAR。</li>
<li>**verify - **对整合测试结果进行任何检查，以确保满足质量标准</li>
<li>**install - **将软件包安装到本地仓库中，以作为本地其他项目的依赖使用</li>
<li>**deploy - **在构建环境中完成，将最终软件包复制到远程仓库，以与其他开发人员和项目共享。</li>
</ul>
<p>这些生命周期阶段（加上这里未显示的其他生命周期阶段）按顺序执行，以完成default周期。给定上述生命周期阶段，这意味着当使用default生命周期时，Maven将首先对项目进行验证，然后尝试编译源代码，针对这些源代码进行测试，打包二进制文件（例如jar），针对这些包进行集成测试，验证集成测试，将验证的软件包安装到本地仓库，然后将安装的软件包部署到远程仓库。</p>
<h2 id="通常的命令行调用"><a href="#通常的命令行调用" class="headerlink" title="通常的命令行调用"></a>通常的命令行调用</h2><p>在开发环境中，使用以下调用来构建并将artifact安装到本地仓库中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>
<p>该命令在执行install之前，按顺序(validate, compile, package,等),执行每个默认生命周期阶段。你只需要调用最后的构建阶段来执行，在这个例子中是install：<br>在构建环境中，使用以下调用来清空构建，并将artifact发布到共享仓库中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure>
<p>相同的命令可以在多模块场景（即具有一个或多个子项目的项目）中使用。Maven遍历每个子项目并执行clean，然后执行deploy（包括所有之前的构建阶段步骤）。</p>
<h2 id="构建阶段由插件目标组成"><a href="#构建阶段由插件目标组成" class="headerlink" title="构建阶段由插件目标组成"></a>构建阶段由插件目标组成</h2><p>然而，即使构建阶段负责构建生命周期中的特定步骤，其执行这些职责的方式可能会有所不同。这是通过声明绑定到这些构建阶段的插件目标来完成的。<br>一个插件目标表示一个指定有助于构建和管理项目的任务（比构建阶段更精细）。目标可能会被绑定到零个或多个构建阶段上。一个目标没有被绑定到任何构建阶段上的话，可以通过直接调用在构建生命周期之外来执行。执行顺序取决于调用目标和构建阶段的顺序。例如，考虑下面的命令。clean和package参数是构建阶段，而dependency:copy-dependencies是一个（插件的）目标。    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean dependency:copy-dependencies package</span><br></pre></td></tr></table></figure>
<p>如果这个命令执行的话，clean阶段会首先被执行（这意味着它将运行clean 生命周期的所有前期阶段，以及clean 阶段本身），然后执行dependency:copy-dependencies 目标,最后执行package阶段（以及default 生命周期中的所有之前的构建阶段）。<br>而且，如果一个目标被绑定到一个或多个构建阶段，那么在所有这些阶段都将调用这个目标。    </p>
<p>此外，构建阶段也可以有零个或多个目标。如果构建阶段没有绑定目标，则该构建阶段将不会执行。但是，如果它有一个或多个目标，它将执行所有这些目标。  </p>
<p>（注意：在Maven 2.0.5及更高版本中，绑定到阶段的多个目标的执行顺序与POM中声明的顺序相同，但是不支持同一插件的多个实例。同一个插件的多个实例被分组以一起执行，并在Maven 2.0.11及更高版本中进行排序）</p>
<h2 id="某些阶段通常不会从命令行调用"><a href="#某些阶段通常不会从命令行调用" class="headerlink" title="某些阶段通常不会从命令行调用"></a>某些阶段通常不会从命令行调用</h2><p>用连字符（pre *，post- *或process- *）命名的阶段通常不会从命令行直接调用。这些阶段对构建进行排序，生成在构建之外无用的中间结果。在调用integration-test的情况下，环境可能处于挂起状态。<br>代码覆盖工具比如Jacoco，以及执行容器插件比如Tomcat，Cargo和Docker绑定目标到pre-integration-test阶段以准备集成测试容器环境。这些插件也绑定目标到post-integration-test阶段以收集覆盖统计数据或停止集成测试容器。<br>故障安全和代码覆盖插件将目标绑定到integration-test和verify 阶段。最终结果是在verify 阶段后可以使用测试和覆盖率报告。如果从命令行调用integration-test，则不会生成任何报告。更为糟糕的是集成测试容器环境处于挂起状态；Tomcat网络服务器或Docker实例仍在运行，Maven甚至可能不会自行终止。</p>
<h1 id="建立项目以使用构建生命周期"><a href="#建立项目以使用构建生命周期" class="headerlink" title="建立项目以使用构建生命周期"></a>建立项目以使用构建生命周期</h1><p>构建生命周期足够简单，但是当您为项目构建一个Maven构建时，您如何将任务分配到每个构建阶段？</p>
<h2 id="Packaging"><a href="#Packaging" class="headerlink" title="Packaging"></a>Packaging</h2><p>第一种也是最常见的方法是通过相同命名的POM元素&lt;packaging&gt;为您的项目设置packaging。packaging元素一些有效的值由：jar，war，ear，和pom。如果没有指定packaging的值，默认是jar。<br>每个packaging包含绑定到特定阶段的一系列目标。比如，jar将绑定以下目标到default生命周期的构建阶段。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>process-resources</td>
<td>resources:resources</td>
</tr>
<tr>
<td>compile</td>
<td>compiler:compile</td>
</tr>
<tr>
<td>process-test-resources</td>
<td>resources:testResources</td>
</tr>
<tr>
<td>test-compile</td>
<td>compiler:testCompile</td>
</tr>
<tr>
<td>test</td>
<td>surefire:test</td>
</tr>
<tr>
<td>package</td>
<td>jar:jar</td>
</tr>
<tr>
<td>install</td>
<td>install:install</td>
</tr>
<tr>
<td>deploy</td>
<td>deploy:deploy</td>
</tr>
</tbody></table>
<p>这是一个几乎是标准的绑定;然而，一些packagings以不同的方式处理它们。比如一些项目纯粹是元数据（packaging值是pom）只会绑定目标到install和deploy阶段（对于绑定到一些packaging类型的完整goal-to-build-phase 列表，参阅<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference">“生命周期参考”</a>）.</p>
<p>请注意，对于某些可用的打包类型，您可能还需要在POM的&lt;build&gt;部分中包含一个特定的插件，并为该插件指定&lt;extensions&gt; true &lt;&#x2F; extensions&gt;。<br>需要这样的插件的一个例子是Plexus插件，它提供plexus-application和plexus-service的packaging.</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>将目标添加到阶段的第二种方法是在项目中配置插件。插件是提供目标给Maven的artifact。此外，一个插件可能有一个或多个目标，其中每个目标都表示这个插件的一个能力。比如，编译插件有两个目标：compile和testCompile。前一个编译你的主代码的源代码，而后一个编译你的测试代码的源代码。<br>正如你将在后面的部分将会看到的，插件可以包含将目标绑定到哪个生命周期阶段的信息。注意，只添加插件自身是不够的-你还必须指定你想运行的目标作为构建的哪一部分。<br>配置的目标将被添加到已经从选定的包装绑定到生命周期的目标。如果超过一个目标被绑定到一个特定的阶段，则使用的顺序是首先执行来自packaging 的顺序，然后执行在POM中配置的那些。请注意，您可以使用&lt;executions&gt;元素来获得对特定目标的顺序的更多控制。 </p>
<p>例如，Modello插件默认将目标modello：java绑定到generate-sources阶段（注：modello：java目标生成Java源代码）。所以要使用Modello插件，并从模型中生成源代码并将其并入到构建中，您将在&lt;build&gt;的&lt;plugins&gt;部分中将以下内容添加到POM中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.modello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modello-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">model</span>&gt;</span>src/main/mdo/maven.mdo<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>你可能会想知道为什么&amp;ltexecutions&gt;元素在这。这样，如果需要，您可以使用不同的配置多次运行相同的目标。可以使用给定ID区分execution，以便在继承或应用配置文件期间，您可以控制是否将目标配置合并或转换为额外的execution。<br>当给定多个与特定阶段匹配的execution时，它们按照POM中指定的顺序执行，继承的execution首先运行。<br>现在，在modello：java的情况下，它只在generate-sources阶段有意义。但是一些目标可以用在超过一个阶段，也许这可能没有合理的默认。对于那些，您可以自己指定阶段。例如，假设你有一个目标display:time，它辉县目前的时间到命令行，并且你想要它运行在process-test-resources阶段指出测试何时开始。这将被配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>display-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>time<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="生命周期参考"><a href="#生命周期参考" class="headerlink" title="生命周期参考"></a>生命周期参考</h1><p>以下列出了default,clean和site生命周期的所有构建阶段，它们按照指定的顺序执行。<br><strong>Clean生命周期</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>pre-clean</td>
<td>执行实际项目清理之前所需的流程</td>
</tr>
<tr>
<td>clean</td>
<td>删除以前构建生成的所有文件</td>
</tr>
<tr>
<td>post-clean</td>
<td>执行完成项目清理所需的过程</td>
</tr>
</tbody></table>
<p><strong>Default生命周期</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>validate</td>
<td>验证项目是否正确，所有必要的信息是否可用。</td>
</tr>
<tr>
<td>initialize</td>
<td>初始化构建状态，例如设置属性或创建目录。</td>
</tr>
<tr>
<td>generate-sources</td>
<td>生成包含在编译中的任何源代码。</td>
</tr>
<tr>
<td>process-sources</td>
<td>处理源代码，例如过滤任何值。</td>
</tr>
<tr>
<td>generate-resources</td>
<td>生成包含在包中的资源。</td>
</tr>
<tr>
<td>process-resources</td>
<td>将资源复制并处理到目标目录中，准备打包。</td>
</tr>
<tr>
<td>compile</td>
<td>编译项目的源代码。</td>
</tr>
<tr>
<td>process-classes</td>
<td>后期处理编译生成的文件，例如对Java类进行字节码增强。</td>
</tr>
<tr>
<td>generate-test-sources</td>
<td>生成包含在编译中的任何测试源代码。</td>
</tr>
<tr>
<td>process-test-sources</td>
<td>处理测试源代码，例如过滤任何值。</td>
</tr>
<tr>
<td>generate-test-resources</td>
<td>创建测试资源。</td>
</tr>
<tr>
<td>process-test-resources</td>
<td>将资源复制并处理到测试目标目录中。</td>
</tr>
<tr>
<td>test-compile</td>
<td>将测试源代码编译到测试目标目录中</td>
</tr>
<tr>
<td>process-test-classes</td>
<td>后期处理测试编译生成的文件，例如对Java类进行字节码增强。对于Maven 2.0.5及以上版本。</td>
</tr>
<tr>
<td>prepare-package</td>
<td>在实际打包前，执行任何必要的准备打包操作。这会产生一个解压，处理版本的包（Maven 2.1及以上）</td>
</tr>
<tr>
<td>package</td>
<td>使用编译后的代码，并以其可分发的格式（如JAR）进行打包。</td>
</tr>
<tr>
<td>pre-integration-test</td>
<td>在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境等事情。</td>
</tr>
<tr>
<td>integration-test</td>
<td>如果必要时将包处理并部署到集成测试运行的环境</td>
</tr>
<tr>
<td>post-integration-test</td>
<td>执行集成测试后执行所需的操作。这可能包括清理环境。</td>
</tr>
<tr>
<td>verify</td>
<td>运行任何检查以验证包是否有效符合质量标准。</td>
</tr>
<tr>
<td>install</td>
<td>将软件包安装到本地仓库中，以作为本地其他项目的依赖。</td>
</tr>
<tr>
<td>deploy</td>
<td>在集成或发布环境中完成，将最终软件包复制到远程存储库，以便与其他开发人员和项目共享。</td>
</tr>
</tbody></table>
<p><strong>Site生命周期</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>pre-site</td>
<td>在实际的项目站点生成之前执行所需的执行的流程</td>
</tr>
<tr>
<td>site</td>
<td>生成项目的站点文档</td>
</tr>
<tr>
<td>post-site</td>
<td>执行完成站点生成所需的进程，并准备站点部署</td>
</tr>
<tr>
<td>site-deploy</td>
<td>将生成的站点文档部署到指定的Web服务器</td>
</tr>
</tbody></table>
<h1 id="内置生命周期绑定"><a href="#内置生命周期绑定" class="headerlink" title="内置生命周期绑定"></a>内置生命周期绑定</h1><p>一些阶段默认情况下已经绑定了一些目标。对于default生命周期，这些绑定依赖packagin的值。这有一些goal-to-build-phase 绑定。</p>
<p><strong>Clean生命周期绑定</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>clean</td>
<td>clean:clean</td>
</tr>
</tbody></table>
<p><strong>Default生命周期绑定- Packaging ejb &#x2F; ejb3 &#x2F; jar &#x2F; par &#x2F; rar &#x2F; war</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>process-resources</td>
<td>resources:resources</td>
</tr>
<tr>
<td>compile</td>
<td>compiler:compile</td>
</tr>
<tr>
<td>process-test-resources</td>
<td>resources:testResources</td>
</tr>
<tr>
<td>test-compile</td>
<td>compiler:testCompile</td>
</tr>
<tr>
<td>test</td>
<td>surefire:test</td>
</tr>
<tr>
<td>package</td>
<td>ejb:ejb or ejb3:ejb3 or jar:jar or par:par or rar:rar or war:war</td>
</tr>
<tr>
<td>install</td>
<td>install:install</td>
</tr>
<tr>
<td>deploy</td>
<td>deploy:deploy</td>
</tr>
</tbody></table>
<p><strong>Default生命周期绑定- Packaging ear</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>generate-resources</td>
<td>ear:generate-application-xml</td>
</tr>
<tr>
<td>process-resources</td>
<td>resources:resources</td>
</tr>
<tr>
<td>package</td>
<td>ear:ear</td>
</tr>
<tr>
<td>install</td>
<td>install:install</td>
</tr>
<tr>
<td>deploy</td>
<td>deploy:deploy</td>
</tr>
</tbody></table>
<p><strong>Default生命周期绑定- Packaging maven-plugin</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>generate-resources</td>
<td>plugin:descriptor</td>
</tr>
<tr>
<td>process-resources</td>
<td>resources:resources</td>
</tr>
<tr>
<td>compile</td>
<td>compiler:compile</td>
</tr>
<tr>
<td>process-test-resources</td>
<td>resources:testResources</td>
</tr>
<tr>
<td>test-compile</td>
<td>compiler:testCompile</td>
</tr>
<tr>
<td>test</td>
<td>surefire:test</td>
</tr>
<tr>
<td>package</td>
<td>jar:jar and plugin:addPluginArtifactMetadata</td>
</tr>
<tr>
<td>install</td>
<td>install:install</td>
</tr>
<tr>
<td>deploy</td>
<td>deploy:deploy</td>
</tr>
</tbody></table>
<p><strong>Default生命周期绑定- Packaging pom</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>package</td>
<td>site:attach-descriptor</td>
</tr>
<tr>
<td>install</td>
<td>install:install</td>
</tr>
<tr>
<td>deploy</td>
<td>deploy:deploy</td>
</tr>
</tbody></table>
<p><strong>Site 生命周期绑定</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>site</td>
<td>site:site</td>
</tr>
<tr>
<td>site-deploy</td>
<td>site:deploy</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>完整的Maven生命周期由maven-core模块中的components.xml文件定义，并附有相关文档供参考。<br>在Maven 2.x中，components.xml中包含默认的生命周期绑定，但在Maven 3.x中，它们在单独的default-bindings.xml描述符中定义。</p>
]]></content>
      <categories>
        <category>Maven</category>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>一些代码写法</title>
    <url>/2017/06/30/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><hr>
<p>实现字符串的反转有很多种方法，例如使用StringBuilder或StringBuffer的reverse方法，也可以自己实现逻辑来实现反转。这些方法列举如下：</p>
<span id="more"></span>
<h2 id="使用StringBuilder-x2F-StringBuffer"><a href="#使用StringBuilder-x2F-StringBuffer" class="headerlink" title="使用StringBuilder&#x2F;StringBuffer"></a>使用StringBuilder&#x2F;StringBuffer</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String origin)</span>&#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">origin</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(origin).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer与StringBuilder一致，用在多线程环境。</p>
<h2 id="使用charAt方法"><a href="#使用charAt方法" class="headerlink" title="使用charAt方法"></a>使用charAt方法</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String origin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> origin.length();       </span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; length; a++) &#123;<span class="comment">//将字符串中的字符从反向挨个放入一个char数组中</span></span><br><span class="line">        chars[a] = origin.charAt(length - <span class="number">1</span> - a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用递归反转"><a href="#使用递归反转" class="headerlink" title="使用递归反转"></a>使用递归反转</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String origin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="literal">null</span> || origin.length() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    <span class="keyword">return</span> reverse(origin.substring(<span class="number">1</span>)) + origin.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h1><hr>
<p><strong>使用“%”取模运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">(<span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (d % <span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不要使用(d % 2) &#x3D;&#x3D; 1来判断为奇数，因为当d为负数的时候，取模运算会保留d的符号。</p>
<p><strong>使用“&amp;”位运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">(<span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (d &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偶数二进制表示的时候，最后一位一定是“0”，奇数一定是“1”，使用位运算符更加高效。</p>
<hr>
<h1 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h1><hr>
<p>如果要对a使用b取模<br><strong>使用“%”取模运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> a % b;</span><br></pre></td></tr></table></figure>
<p><strong>使用“&amp;”位运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> a &amp; (b - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面奇偶判断实际意义就是对2取模。</p>
<hr>
<h1 id="变量对调"><a href="#变量对调" class="headerlink" title="变量对调"></a>变量对调</h1><hr>
<p><strong>使用临时变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>
<p><strong>使用算数运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b; <span class="comment">// 此时b =a</span></span><br><span class="line">a = a - b; <span class="comment">// 右边a为a+b的和，再减去已经等于a的b，结果为最初的b，实现交互</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以简写为 a = (a + b) - ( b = a);</span></span><br></pre></td></tr></table></figure>

<p><strong>使用异或运算符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b; <span class="comment">// b = (a ^ b) ^ b,根据异或运算，a与b异或再异或还是a</span></span><br><span class="line">a = a ^ b; <span class="comment">// 此时b=a，a= a^b则b与a异或再异或等于b，实现交换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以简写为 a = (b = a) ^ (a ^ b)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java其他</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>从Object.clone()方法,看protected权限问题</title>
    <url>/2017/04/29/%E4%BB%8EObject-clone-%E6%96%B9%E6%B3%95-%E7%9C%8Bprotected%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>学习java权限修饰符时,权限那张表里可以看到,被protected修饰的类成员,是可以在同包类,或者不同包的子类中访问的,然而当使用类的clone()方法时,却出现了方法不可见的编译错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Person <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Test&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> ClontNotSupportedException&#123;</span><br><span class="line">          <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">          person.clone();          <span class="comment">//Compile error (The method clone() from the type Object is not visible)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码中Test与Person在同一个包中,为何调用person.clone()会报错呢?再看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Person <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Class Test&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> ClontNotSupportedException&#123;</span><br><span class="line">           <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">           person.clone();          <span class="comment">//Compile succes</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们知道,clone()方法是继承自父类Object,其方法体是   protected native Object clone() throws CloneNotSupportedException;</p>
<p>通过多次测试,我发现</p>
<blockquote>
<p>“当父类与子类不在同一个包时(Object与Person)，创建子类对象实例(person)的类(Test)如果与父类(Object)不在同一个包,受保护的成员(clone方法)是无法访问的,如果我们在父类(Object)的包中创建测试类,同样创建子类实例(Person),这时受保护成员则可以访问”</p>
</blockquote>
<blockquote>
<p>“在上面第二个代码中,我们在子类Person中重写了受保护成员clone(),在测试类Test中编译通过,可以访问”</p>
</blockquote>
<p>通过上面的对比,我觉得可以这样理解,</p>
<ol>
<li><p>子类没有重写受保护方法,就看作是使用的父类的方法,这样测试类Test与父类Object是不同包的关系,所以无法调用</p>
</li>
<li><p>如果我们把测试类Test挪到Object所在的包,可以调用</p>
</li>
<li><p>如果子类Person重写了clone方法,调用的就是子类中clone方法,子类Person与测试类Test在同一个包中,所以可以调用</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java遇到的问题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程需要注意的地方</title>
    <url>/2017/04/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>任何一个时刻，对象的控制权（monitor）只能被一个线程拥有。无论是执行对象的wait、notify还是notifyAll方法，必须保证当前运行的线程取得了该对象的控制权（monitor），如果在没有控制权的线程里执行对象的以上三种方法，则会抛出java.lang.IllegalMonitorStateException异常。JVM基于多线程，默认情况下不能保证运行时线程的时序性</p>
<span id="more"></span>

<p><a href="http://longdick.iteye.com/blog/453615">参考链接</a></p>
<p>java线程唤醒休眠机制,具有同一个同步锁对象的线程,任何时刻只能执行一个线程,这个对象相当于一个令牌,只有控制该令牌,才能运行</p>
<p>需要注意的问题</p>
<ol>
<li><p>没有具有该线程控制权对象调用wait,notify,或notifyall,导致java.lang.IllegalMonitorStateException异常问题</p>
</li>
<li><p>具有该线程控制权对象,修改引用后,导致java.lang.IllegalMonitorStateException异常问题</p>
</li>
<li><p>wait()会释放对象控制权,这样其他线程才有可能获得对象控制权</p>
</li>
<li><p>notify()调用后,必须执行完后面的同步代码块,释放对象控制权后,其他线程才有可能重新获得对象控制权,得以执行</p>
</li>
<li><p>notify()与notifyAll()区别—-<a href="http://www.importnew.com/10173.html">notify()可能造成的死锁问题</a></p>
</li>
<li><p>唤醒丢失问题</p>
</li>
<li><p>虚假唤醒问题</p>
</li>
</ol>
<p>当有多个线程,其中一个获得对象控制权,得以运行,然后执行wait()方法,此时它释放对象控制权,其他线程随机一个获得控制权,如果该线程也执行wait(),则同样释放对象控制权,这样连续几个线程都进入休眠后,又一个线程获得对象控制权,得以运行,并执行notify()方法,此时它随即唤醒一个wait()方法,然而此wait()线程并不能执行,因为它没有获得对象控制权,必须等待notify()方法执行完后面的同步代码块,释放对象控制权后,才有可能去争夺对象控制权,如果调用notifyAll()则会唤醒所有wait线程,通知它们可以在notifyAll()线程释放对象控制权后争夺线程控制权.</p>
<p>四个线程A,B,C,D</p>
<ol>
<li>A,B,C,D争夺对象控制权</li>
<li>A获取控制权运行,并执行wait()进入休眠,释放控制权</li>
<li>B,C,D争夺对象控制权</li>
<li>B获取控制权运行,并执行wait()进入休眠,释放控制权</li>
<li>C,D争夺对象控制权</li>
</ol>
<p>此时如果调用notify()</p>
<ol>
<li>C获取控制权运行,并执行notify()随机唤醒A             </li>
<li>C执行完同步代码块,释放控制权                              </li>
<li>A,C,D争夺对象控制权</li>
</ol>
<p>　　　　　　　　　　　　　　　</p>
<p>此时如果调用notifyAll()</p>
<ol>
<li>C获取控制权运行,并执行notifyAll()唤醒A,B</li>
<li>C执行完同步代码块,释放控制权</li>
<li>A,B,C,D争夺对象控制权</li>
</ol>
]]></content>
      <categories>
        <category>java其他</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>查找（Search）</title>
    <url>/2017/09/13/%E6%9F%A5%E6%89%BE%EF%BC%88Search%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h1><hr>
<p>二分查找,也称折半查找、二分搜索，是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。</p>
<p>二分查找在搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。</p>
<span id="more"></span>
<p>对于一个有N个项的数组a，在a[i…j] (j&#x3D;N-1)中查找元素d，其步骤如下：</p>
<ol>
<li>计算数组中点mid &#x3D; i + (j - i)&#x2F;2</li>
<li>比较a[mid]与d，如果a[mid]等于d则返回mid，大于查找mid左边元素，小于查找mid右边元素</li>
</ol>
<p>java循环实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; d) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; d) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java递归实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> d,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low ) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(a[mid] == d)</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; d)</span><br><span class="line">            <span class="keyword">return</span> binarySearch1(a,d,low,mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; d)</span><br><span class="line">            <span class="keyword">return</span> binarySearch1(a,d,mid + <span class="number">1</span>,high);</span><br><span class="line">    <span class="comment">//可以使用三元运算符简写为</span></span><br><span class="line">    <span class="comment">//return a[mid] &gt; d ? binarySearch1(a,d,low,mid - 1) : (a[mid] == d ? mid : binarySearch1(a,d,mid + 1,high));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表（LinkedList）</title>
    <url>/2017/09/07/%E9%93%BE%E8%A1%A8%EF%BC%88LinkedList%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr>
<p>链表是由一组顶点（节点）组成的数据结构，它们一起表示一个序列。在最简单的形式，每个顶点由数据和序列中下一个顶点的引用（链接）组成。链表及其变体用作底层数据结构来实现<strong>List</strong>，<strong>Stack</strong>，<strong>Queue</strong>和<strong>Deque</strong>等ADT。</p>
<p>链表数据结构是计算机科学（CS）本科最常教授的课程，原因如下： </p>
<ol>
<li>它是一个简单的线性数据结构</li>
<li>作为list ADT它有一系列潜在的应用，例如学生列表，事件列表，约会列表等（尽管还有其他更高级的数据结构可以更好地执行相同的应用程序），或作为以及stack&#x2F;queue&#x2F; deque ADT</li>
<li>它有一些有趣的极端&#x2F;特殊情况来说明一个好的数据结构实现的需要</li>
<li>它具有各种自定义选项，因此通常使用面向对象编程（OOP）方式教导链表数据结构使用。</li>
</ol>
<span id="more"></span>
<h2 id="List-ADT"><a href="#List-ADT" class="headerlink" title="List ADT"></a>List ADT</h2><hr>
<p> List是系列的items&#x2F;date ，它们位置有序{a0，a1，…，aN-2，aN-1}。 通常的List ADT操作有：</p>
<ol>
<li><strong>get(i)</strong> — 可能是一个微不足道的操作，返回ai（基于0的索引），</li>
<li>**search(v) **— 决定item&#x2F;data在list中是否存在，存在的话报告它的位置&#x2F;索引，不存在通常返回索引-1</li>
<li><strong>insert(i,v)</strong> — 在list中向指定的位置&#x2F;索引插入item&#x2F;data v，可能需要将item从之前的位置：[i..N-1]，移动到它们右边的一个位置，</li>
<li><strong>remove(i)</strong> — 删除list中特定于位置&#x2F;索引为i的item，可能会将之前位置的item[i + 1..N-1]向左移动一个位置，以关闭空格。</li>
</ol>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><hr>
<p>（紧凑）数组是实现List ADT的一个好的选择，因为它是处理集合的一个简单的构造。</p>
<p>当我们说<strong>紧凑数组</strong>（Compact Array），这意味着一个没有空隔的数组，也就是如果有N个item在数组（它的大小为M，并且M≥N）中，那么只有索引[0..N-1]处被占据，而其他的索引[N..M-1] 依旧为空<br><img src="/%5Cimages%5Cdatastructure%5Ccompactarray_illustration.png" alt="紧凑数组"></p>
<h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><p>一个紧凑数组名称为A，索引[0..N-1]处为list中的item。 </p>
<ul>
<li>get(i)，只是返回A [i]。 如果不是紧凑数组，这个简单的操作将不必要地复杂化。</li>
<li>search(v)，我们逐一检查每个索引i∈[0..N-1]以查看是否A [i] &#x3D;&#x3D; v。v，如果存在，可以在索引[0..N-1]中的任何位置。</li>
<li>insert(i，v)，我们将item∈[i..N-1]移位到[i + 1..N]（从后向），并设置A [i] &#x3D; v。这是为了使v在索引i处正确插入并保持紧凑性。 </li>
<li>remove(i)，我们将项∈[i + 1..N-1]移动到[i..N-2]，覆盖旧的A [i]。 这是为了保持紧凑性。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>get(i)非常快：只有一个访问，O（1）。 </li>
<li>search(v)<br>在最好的情况下，v在第一个位置找到,O（1）。<br>在最坏的情况下，列表中找不到v，我们需要扫描来确定,O（N）。</li>
<li>insert(i，v)<br>在最好的情况下，在i &#x3D; N处插入，不需要移动元素，O（1）。<br>在最坏的情况下，在i &#x3D; 0处插入，我们将所有N个元素移位，O（N）。 </li>
<li>remove(i)<br>在最好的情况下，在i &#x3D; N-1处删除，不需要移动元素，O（1）。<br>在最坏的情况下，在i &#x3D; 0处删除，我们将所有N个元素移位，O（N）。</li>
</ul>
<h3 id="固定大小问题"><a href="#固定大小问题" class="headerlink" title="固定大小问题"></a>固定大小问题</h3><p>紧凑数组的大戏M不是无限的，而是一个有限的数组。这暴露出一个问题，在许多应用程序中最大大小可能是未知的。<br>如果M太大的话，会有很多空间被浪费，如果M太小的话，很容易耗尽空间。<br>解决方法是让M是一个变量。这样当数据满的时候，我们创建一个更大的数组，并且将元素从旧数组移动到新数组中。因此，除了（通常较大的）物理计算机存储器大小限制之外的没有其他的尺寸限制，此类实现如， C ++ STL vector，Java Vector或Java ArrayList。然而，空间浪费和复制&#x2F;转移item开支的问题仍然存在问题。</p>
<p>对于固定大小的集合，具有已知最大限制的item数量，即M的最大值，则数组已经是List ADT实现的相当好的数据结构。<br>对于尺寸变化的集合，它的大小M未知，并且一些动态操作如insert&#x2F;remove相当平常，一个简单的数据实际上是一个数据结构的糟糕选择。对于这样的应用程序，有更好的数据结构。</p>
<hr>
<h1 id="Linked-List-LL"><a href="#Linked-List-LL" class="headerlink" title="Linked List(LL)"></a>Linked List(LL)</h1><hr>
<p>现在我们引入链表数据结构。它使用指针来允许item&#x2F;data在内存中不连续（这与简单数组的主要区别）。它将item从索引0到索引N-1排序，通过指针将item i与其相邻item i + 1相关联。<br><img src="/%5Cimages%5Cdatastructure%5Cll_illustration.png" alt="链表"><br>在最基本的形式中，链接列表中的单个顶点（节点）具有以下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct or <span class="keyword">class</span> <span class="title class_">Vertex</span> &#123; <span class="comment">//我们同时使用 C++ struct/(Java) class</span></span><br><span class="line">  <span class="type">int</span> item<span class="comment">// 数据存储在这里，本例中是整数</span></span><br><span class="line">  Vertex *next <span class="comment">// 这个指针告诉我们下一个顶点的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在链表数据结构中还有一些我们需要记住的额外数据。</p>
<ul>
<li><strong>head</strong>指针指向a<sub>0</sub></li>
<li><strong>tail</strong>指针指向a<sub>N-1</sub></li>
</ul>
<p>就是这样,我们只添加两个额外的变量的数据结构。</p>
<h2 id="Get-i-——比数组慢很多"><a href="#Get-i-——比数组慢很多" class="headerlink" title="Get(i)——比数组慢很多"></a>Get(i)——比数组慢很多</h2><hr>
<p>由于我们只保留头尾指针，所以需要列表遍历的方法来达到head（索引0）和tail（索引N-1）以外的位置。由于这个遍历需要频繁使用，我们将它抽象为一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vertex <span class="title function_">Get</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">// 返回该顶点</span></span><br><span class="line">  <span class="type">Vertex</span> <span class="variable">ptr</span> <span class="operator">=</span> head <span class="comment">//从head部开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) <span class="comment">// 向后移动i 次</span></span><br><span class="line">    ptr = ptr.next <span class="comment">//指针指向后一个的索引</span></span><br><span class="line">  <span class="keyword">return</span> ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它运行在O（N），因为i可能等于索引N-2。<br>与数组相比，数组可以在O（1）时间访问索引i。</p>
<h2 id="Search-i-——不比数组快"><a href="#Search-i-——不比数组快" class="headerlink" title="Search(i)——不比数组快"></a>Search(i)——不比数组快</h2><hr>
<p>由于我们只直接引用第一个head和最后一个tail，加上指针指向右侧（较高位置&#x2F;索引），我们只能通过从头项目开始并通过下一个指针来访问其余部分。例子：</p>
<h2 id="Insert-i，v"><a href="#Insert-i，v" class="headerlink" title="Insert(i，v)"></a>Insert(i，v)</h2><hr>
<p>由于链表的性质，它有比数组更多的情况，对于insert(i, v)，有四种（合法）的可能性，也就是v插入到：</p>
<ol>
<li>链表的头部（在当前第一个item之前），i&#x3D;0</li>
<li>一个空的链表（幸运的是类似于前面的情况）</li>
<li>链表最后一个item（当前的tail）之后的位置，i&#x3D;N</li>
<li>链表的其他位置，i &#x3D; [1..N-1].</li>
</ol>
<h3 id="插入到头部"><a href="#插入到头部" class="headerlink" title="插入到头部"></a>插入到头部</h3><p>插入头部的伪代码简单而高效，时间复杂度为O（1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">vtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(v) <span class="comment">//从item v创建一个新的Vertex vtx</span></span><br><span class="line">vtx.next = head <span class="comment">// 将这个新的顶点链接到 (旧的) head顶点上</span></span><br><span class="line">head = vtx <span class="comment">//该新的顶点变为新的head</span></span><br></pre></td></tr></table></figure>
<h3 id="插入到空的链表"><a href="#插入到空的链表" class="headerlink" title="插入到空的链表"></a>插入到空的链表</h3><p>空数据结构是一个常见的极端&#x2F;特殊情况，如果未正确测试，可能会导致意外的崩溃。将新item插入到当前空的列表中，即索引i &#x3D; 0处是合法的。幸运的是，用于插入到head的伪代码同样适用于一个空的list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">vtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(v) <span class="comment">//从item v创建一个新的Vertex vtx</span></span><br><span class="line">vtx.next = head <span class="comment">// 之前head为null，所以vtx.next保持为null</span></span><br><span class="line">head = vtx <span class="comment">//该新的顶点变为新的head</span></span><br></pre></td></tr></table></figure>
<h3 id="插入到链表之间"><a href="#插入到链表之间" class="headerlink" title="插入到链表之间"></a>插入到链表之间</h3><p>借助链表遍历Get(i)子程序，我们现在可以如下实现向链表中间插入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">pre</span> <span class="operator">=</span> Get(i-<span class="number">1</span>) <span class="comment">// 遍历到第(i-1)个顶点， O(N)</span></span><br><span class="line">aft = pre.next <span class="comment">// aft 不能为null, 思考下</span></span><br><span class="line"><span class="type">Vertex</span> <span class="variable">vtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(v) <span class="comment">// 创建一个新的顶点</span></span><br><span class="line">vtx.next = aft <span class="comment">// 链接这个</span></span><br><span class="line">pre.next = vtx <span class="comment">// 以及这个</span></span><br></pre></td></tr></table></figure>
<p>由于需要遍历列表（例如，如果i靠近N-1），则该操作很慢，时间复杂度为O（N）。</p>
<h3 id="插入到tail后"><a href="#插入到tail后" class="headerlink" title="插入到tail后"></a>插入到tail后</h3><p>如果我们还记得这个前面tail指针（这是可取的，因为它只是一个额外的指针变量），我们可以有效地执行在tail项后位置（i &#x3D; N）插入，以O（1 ）实践复杂度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">vtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(v) <span class="comment">// 从v项创建一个新的顶点vtx</span></span><br><span class="line">tail.next = vtx <span class="comment">// tail是 i = (N-1)项，只需要链接到新的顶点</span></span><br><span class="line">tail = vtx <span class="comment">// 现在更新tail指针</span></span><br></pre></td></tr></table></figure>

<h2 id="Remove-i"><a href="#Remove-i" class="headerlink" title="Remove(i)"></a>Remove(i)</h2><hr>
<p>对于remove(i),这有三种（合法）可能，也就是索引i为:</p>
<ol>
<li>链表的头部（当前第一个项），i&#x3D;0，它影响head指针</li>
<li>链表的尾部，i&#x3D;N-1，它影响链表的tail指针</li>
<li>链表其他位置， i &#x3D; [1..N-2]</li>
</ol>
<h3 id="移除头部项"><a href="#移除头部项" class="headerlink" title="移除头部项"></a>移除头部项</h3><p>这种情况相当直观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">temp</span> <span class="operator">=</span> head <span class="comment">// 我们可以稍后删除它</span></span><br><span class="line">head = head.next <span class="comment">// 更新头部指针</span></span><br><span class="line">delete temp <span class="comment">// 删除原来的head</span></span><br></pre></td></tr></table></figure>
<h3 id="移除尾部项"><a href="#移除尾部项" class="headerlink" title="移除尾部项"></a>移除尾部项</h3><p>假设链接列表有多个项，我们可以执行如下删除链表的尾部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="type">head</span></span><br><span class="line"><span class="variable">temp</span> <span class="operator">=</span> head.next</span><br><span class="line"><span class="title function_">while</span> <span class="params">(temp.next != <span class="literal">null</span>)</span> <span class="comment">// 当临近项不为tail时</span></span><br><span class="line">  pre = pre.next, temp = temp.next <span class="comment">// pre = Get(N-2), temp = Get(N-1)</span></span><br><span class="line">pre.next = <span class="literal">null</span></span><br><span class="line">delete temp, tail = pre <span class="comment">// temp = (old) tail,更新tail指针</span></span><br></pre></td></tr></table></figure>
<p>实际上，如果我们还维护链表的尺寸N（与此幻灯片相比），我们可以使用链表遍历子程序Get(i)来实现链表尾部的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">pre</span> <span class="operator">=</span> Get(N-<span class="number">2</span>) <span class="comment">// 到tail前的索引处, 时间复杂度为O(N)</span></span><br><span class="line">pre.next = <span class="literal">null</span></span><br><span class="line">delete tail, tail = pre <span class="comment">// 可以访问旧的tail</span></span><br></pre></td></tr></table></figure>
<p>请注意，这个操作很慢，为O（N），只是因为需要从N-1项向后一个单位更新tail指针到N-2项，以便之后在tail后插入依旧保持正确…这个缺陷将在后面的双向链表中得到解决。</p>
<h3 id="移除中间项"><a href="#移除中间项" class="headerlink" title="移除中间项"></a>移除中间项</h3><p>借助链表遍历Get(i)子程序，我们现在可以实现移除链表中间项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Vertex</span> <span class="variable">pre</span> <span class="operator">=</span> Get(i-<span class="number">1</span>) <span class="comment">//遍历到第(i-1) 个顶点, 时间复杂度为O(N)</span></span><br><span class="line"><span class="type">Vertex</span> <span class="variable">del</span> <span class="operator">=</span> pre.next, aft = del.next</span><br><span class="line">pre.next = aft <span class="comment">//绕过del</span></span><br><span class="line">delete del</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><hr>
<ul>
<li>get(i)是比较慢：O（N）。 </li>
<li>search(v)<br>在最好的情况下，v在第一个位置找到,O（1）。<br>在最坏的情况下，列表中找不到v，我们需要扫描来确定，O（N）。</li>
<li>insert(i，v)<br>在最好的情况下，在i &#x3D; 0或i &#x3D; N插入，通过头尾指针帮助，需要O（1）。<br>在最坏的情况下，在i &#x3D; N-1处插入，我们需要在尾部之前找到N-2项,O（N）。 </li>
<li>remove(i)<br>在最好情况下，删除i &#x3D; 0，在头指针帮助下，需要O（1）。<br>在最坏的情况下，在i &#x3D; N-1处删除，由于需要更新尾部指针，O（N）。</li>
</ul>
<p>纯粹（单向）的链表应用程序是罕见的，因为更简单的可调整大小的紧凑型数组（vector）可以更好地完成工作，将链表版本与紧凑数组版本进行比较。<br>然而，链表的基本概念允许顶点在内存中不连续，这使其成为另外两个抽象数据类型的尺寸可调整的数据结构：<strong>Stack</strong>和<strong>Queue</strong>。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven入门</title>
    <url>/2017/07/06/Maven%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Maven概览-核心概念"><a href="#Maven概览-核心概念" class="headerlink" title="Maven概览-核心概念"></a>Maven概览-核心概念</h1><p>Maven是一个围绕POM文件（项目对象模型）的概念。 POM文件是源代码，测试代码，依赖（使用的外部JAR）等项目资源的XML表示.POM包含对所有这些资源的引用。POM文件应位于其所属项目的根目录下。<br>这是一个说明Maven如何使用POM文件以及POM文件主要包含的内容的图：<br><img src="/images/other/maven-overview-1.png" alt="Maven核心概念"><br>这些概念将在下面简要介绍以给你一个概览，然后在本教程后面的各自章节中有更详细的介绍。</p>
<span id="more"></span>
<h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><p>当您执行Maven命令时，您可以给Maven一个POM文件来执行命令。然后，Maven将对POM中描述的资源执行命令。</p>
<h2 id="构建生命周期，阶段和目标"><a href="#构建生命周期，阶段和目标" class="headerlink" title="构建生命周期，阶段和目标"></a>构建生命周期，阶段和目标</h2><p>Maven的构建过程分为构建生命周期，阶段和目标。一个构建生命周期包含一系列的构建阶段，每个构建阶段由一系列目标组成。当你运行Maven时，你传递一个命令到Maven。这个命令就是构建生命周期，阶段或目标的名称。如果执行一个生命周期，则这个生命周期中的所有构建阶段都会被执行。如果请求执行构建阶段，则在预定义的构建阶段序列之前的所有构建阶段都将被执行。</p>
<h2 id="依赖和仓库"><a href="#依赖和仓库" class="headerlink" title="依赖和仓库"></a>依赖和仓库</h2><p>Maven首先执行的目标之一就是检查项目所需的依赖项。依赖是项目使用的外部JAR文件（Java库）。如果在Maven本地仓库库中找不到依赖项，Maven会从Maven中央仓库中下载它们，并将它们放在本地仓库中。本地仓库只是计算机硬盘上的一个目录。如果你想的话，您自己可以指定本地仓库的位置。您还可以指定要用于下载依赖远程仓库。所有这些将在本教程的后面更详细地解释。</p>
<h2 id="构建插件"><a href="#构建插件" class="headerlink" title="构建插件"></a>构建插件</h2><p>构建插件用于在构建阶段插入额外的目标。如果您需要为您的项目执行一系列不涵盖在标准Maven构建阶段和目标的操作，则可以向POM文件添加一个插件。Maven有一些可以使用的标准插件，如果需要，还可以使用Java实现自己的插件。</p>
<h2 id="构建配置文件"><a href="#构建配置文件" class="headerlink" title="构建配置文件"></a>构建配置文件</h2><p>如果您需要以不同的方式构建项目，则使用构建配置文件。例如，您可能需要为您的本地计算机构建项目，以进行开发和测试。并且您也可能需要构建它来部署在您的生产环境中。这两个版本可能会有所不同。要启用不同的构建，您可以向POM文件添加不同的构建配置文件。执行Maven时，您可以判断要使用的构建配置文件。</p>
<h1 id="Maven-vs-Ant"><a href="#Maven-vs-Ant" class="headerlink" title="Maven vs. Ant"></a>Maven vs. Ant</h1><p>Ant是Apache的另一个流行的构建工具。如果你习惯Ant，而你正在尝试学习Maven，你会注意到两个项目的方法有所不同。<br>Ant使用命令式方法，这意味着您在Ant构建文件中指定Ant应该采取什么动作。您可以指定一个低级操作，如复制文件，编译代码等。您可以指定操作，还可以指定执行操作的顺序。 Ant没有默认目录布局。<br>Maven使用更具声明性的方法，这意味着您在Maven POM文件中指定要构建什么，而不是如何去构建它。 POM文件描述您的项目资源 - 而不是如何构建它。相反，Ant文件描述如何构建项目。在Maven中，如何构建项目是在<a href="#Maven%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E9%98%B6%E6%AE%B5%E5%92%8C%E7%9B%AE%E6%A0%87">Maven构建生命周期，阶段和目标</a>中预先定义的。</p>
<h1 id="Maven-POM文件"><a href="#Maven-POM文件" class="headerlink" title="Maven POM文件"></a>Maven POM文件</h1><p>Maven POM文件（项目对象模型）是描述项目资源的XML文件。这包括源代码，测试源等所在的目录，你的项目有什么外部依赖（JAR文件）等等。 </p>
<p>POM文件描述了要构建的内容，但最常见的不是如何构建它。如何构建它是由Maven构建阶段和目标。如果需要，您可以将自定义操作（目标）插入到Maven构建阶段。</p>
<p>每个项目都有一个POM文件。POM文件名为pom.xml，应位于项目的根目录中。一个项目分为几个子项目的，它通常将有一个父项目的POM文件，并且每个子项目都有一个POM文件。这种结构允许整个项目一个步构建，或者任何一个子项目要单独构建。</p>
<p>在本节的其余部分中，我将描述POM文件中最重要的部分。有关POM文件的完整参考，<a href="#">Post not found: 《Maven官方文档》（三）POM参考</a>_</p>
<p>这是一个最小的POM文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jenkov<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-web-crawler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>modelVersion元素设置您正在使用的POM模型的版本。使用与你正在使用的Maven版本相匹配的值。版本4.0.0匹配Maven 2和3版本。</p>
<p>groupId元素是组织或项目（例如开源项目）的唯一ID。通常，您将使用类似于项目的根Java包名称的groupId。例如，对于我的Java Web Crawler项目，我可以选择groupId为com.jenkov。如果该项目是一个具有许多独立贡献者的开源项目，或许使用与该项目相关的groupId更有意义，而不是与我公司相关的groupId。因此，可以使用com.javawebcrawler。</p>
<p>groupId不必一定是Java包名称，并且不必在ID中使用.符号（点符号）来分割单词。但是，如果这样做的话，项目将位于与组ID匹配的目录结构下的Maven仓库中。每个.被替换为目录分隔符，因此每个单词都表示一个目录。这样groupId com.jenkov将位于名为MAVEN_REPO &#x2F; com &#x2F; jenkov的目录中。目录名称的MAVEN_REPO部分将替换为Maven仓库的目录路径。</p>
<p>artifactId元素包含您正在构建的项目的名称。在我的Java Web Crawler项目的情况下，artifactId将是java-web-crawler。artifactId用作Maven仓库中groupId目录下的子目录的名称。artifactId也用作构建项目时生成的JAR文件的名称的一部分。构建过程的输出（即构建结果）在Maven中称为artifact。大多数情况下，它是一个JAR，WAR或EAR文件，但它也可以是别的东西。 </p>
<p>versionId元素包含项目的版本号。如果您的项目已经以不同的版本发布，例如开放源代码API，那么版本生成是有用的。这样您的项目的用户可以参考您的项目的特定版本。版本号用作artifactId目录下的子目录的名称。版本号也用作构建的artifact名称的一部分。</p>
<p>上述groupId，artifactId和version元素将导致一个JAR文件被构建并放在的Maven本地仓库中，位于以下路径（目录和文件名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAVEN_REPO/com/jenkov/java-web-crawler/1.0.0/java-web-crawler-1.0.0.jar</span><br></pre></td></tr></table></figure>

<p>如果您的项目使用Maven目录结构，并且您的项目没有外部依赖关系，那么上述最小的POM文件就是你构建项目所需要的全部。</p>
<p>如果您的项目不遵循标准目录结构，具有外部依赖关系，或者在构建期间需要特殊操作，则需要向POM文件添加更多元素。这些元素列在Maven POM参考中（参见上面的链接）。</p>
<p>一般来说，您可以在POM中指定很多东西，为Maven提供有关如何构建项目的更多详细信息。有关可以指定的内容的更多信息，请参阅Maven POM参考。</p>
<h2 id="超级POM"><a href="#超级POM" class="headerlink" title="超级POM"></a>超级POM</h2><p>所有Maven POM文件都继承自超级POM。如果没有指定超级POM，则POM文件将从基本POM继承。以下是图示：<br><img src="/images/other/maven-super-pom.png" alt="超级POM和POM继承。"></p>
<p>您可以使POM文件明确地继承另一个POM文件。这样，您可以通过其通用的超级POM更改所有继承的POM的设置。您可以在POM文件的顶部指定超级POM，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">        &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">        &lt;/parent&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;my-project&lt;/artifactId&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>继承的POM文件可以覆盖超级POM的设置。只需在继承的POM文件中指定新设置即可。</p>
<p>POM继承也在Maven POM引用中有更详细的介绍。</p>
<h2 id="有效POM"><a href="#有效POM" class="headerlink" title="有效POM"></a>有效POM</h2><p>使用所有这些POM继承，可能很难知道当Maven执行时，总体POM文件的样子。总POM文件（所有继承的结果）称为有效POM。您可以使用以下命令让Maven向您显示有效的POM：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:effective-pom</span><br></pre></td></tr></table></figure>
<p>该命令将使Maven将有效的POM写入命令行提示符。</p>
<h1 id="Maven设置文件"><a href="#Maven设置文件" class="headerlink" title="Maven设置文件"></a>Maven设置文件</h1><p>Maven有两个设置文件。在设置文件中，您可以在所有Maven POM文件为Maven进行配置设置。例如，您可以配置：</p>
<ul>
<li>本地仓库位置</li>
<li>活动构建配置文件</li>
<li>等等</li>
</ul>
<p>设置文件名为settings.xml。两个设置文件位于：</p>
<ul>
<li>Maven安装目录：$M2_HOME&#x2F;conf&#x2F;settings.xml </li>
<li>用户的主目录：${user.home}&#x2F;.m2&#x2F;settings.xml</li>
</ul>
<p>这两个文件都是可选的。如果两个文件都存在，则用户主文件设置文件中的值将覆盖Maven安装设置文件中的值。</p>
<p>您可以在<a href="#">Post not found: 《Maven官方文档》（二）设置参考</a> _中了解有关Maven设置文件的更多信息。</p>
<h1 id="Maven目录结构"><a href="#Maven目录结构" class="headerlink" title="Maven目录结构"></a>Maven目录结构</h1><p>Maven有一个标准的目录结构。如果您按照该项目的目录结构，您不需要在POM文件中指定源代码，测试代码等的目录。</p>
<p>您可以在<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">Maven标准目录布局简介</a>中看到完整的目录布局。</p>
<p>以下是最重要的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - main</span><br><span class="line">    - java</span><br><span class="line">    - resources</span><br><span class="line">    - webapp</span><br><span class="line">  - test</span><br><span class="line">    - java</span><br><span class="line">    - resources</span><br><span class="line"></span><br><span class="line">- target</span><br></pre></td></tr></table></figure>
<p>src目录是源代码和测试代码的根目录。main 目录是与应用程序本身相关的源代码的根目录（不是测试代码）。test 目录包含测试源代码。 main和test下的java目录包含应用程序本身的Java代码（主要内容）和测试的Java代码（被测试）。<br>资源目录包含项目所需的其他资源。这可以是用于应用程序国际化的属性文件，或其他内容。</p>
<p>如果您的项目是Web应用程序，则webapp目录包含您的Java Web应用程序。webapp目录将是Web应用程序的根目录。因此，webapp目录包含WEB-INF目录等</p>
<p>target目录由Maven创建。它包含由Maven生成的所有编译的类，JAR文件等。执行cleang构建阶段时，将清除目标目录。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>Maven中的外部依赖是一个不在Maven仓库（既不在本地仓库，也不在中央仓库，远程仓库）中的依赖（JAR文件）。它可能位于本地硬盘上的某个位置，例如位于webapp的lib目录或其他位置。因此，“外部”一词意味着在Maven仓库系统的外部 - 而不仅仅是项目外部。大多数依赖都在在项目外部，但在仓库系统外部（不在仓库中）的很少。</p>
<p>你可以在像这样配置外部依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\war\WEB-INF\lib\mydependency.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>groupId和artifactId都设置为依赖的名称。也就是使用的API的名称。scope 元素值设置为system。 systemPath元素设置为指向包含依赖关系的JAR文件的位置。$ {basedir}指向POM所在的目录。该路径的其余部分是是相对目录的位置。</p>
<h2 id="快照依赖"><a href="#快照依赖" class="headerlink" title="快照依赖"></a>快照依赖</h2><p>快照依赖关系是正处在开发阶段的依赖（JAR文件）。相比经常更新版本号来获取最新的版本，你可以依赖于项目的快照版本。快照版本会为每次构建下载到你的本地仓库中，即使在你的本地仓库中一个匹配的快照版本已经存在。始终下载快照依赖确保您在本地仓库中始终拥有最新版本，以用于每次构建。<br>你可以通过将-SNAPSHOT附加到POM下的version元素（您也可以设置groupId和artifactId的地方），告诉Maven您的项目是一个快照版本。这是一个version元素示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意版本号后附加的-SNAPSHOT。</p>
<p>你也可以通过在配置依赖关系后在版本号之后附加-SNAPSHOT来完成设置依赖一个快照版本。下面是示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jenkov<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-web-crawler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>版本号附加的-SNAPSHOT告诉Maven这是一个快照版本。</p>
<p>您可以配置Maven在Maven设置文件中下载快照依赖关系的频率。</p>
<h1 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h1><p>Maven仓库是具有额外元数据的打包JAR文件的目录。元数据是描述JAR文件所属项目的POM文件，包括每个打包JAR的外部依赖关系。正是这个元数据使Maven能够递归地下载依赖的依赖，直到整个依赖关系树下载并放入本地存储库中。</p>
<p>Maven仓库在Maven<a href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html">“仓库简介”</a>中有更详细的介绍，但这里是一个简要的概述。</p>
<p>Maven有三种类型的仓库：</p>
<ul>
<li>本地仓库</li>
<li>中央仓库</li>
<li>远程仓库</li>
</ul>
<p>Maven在上述顺序中搜索这些仓库中的依赖关系。首先在本地仓库中搜索，然后在中央仓库中，如果在POM中有指定，最后在远程仓库中。</p>
<p><img src="/images/other/maven-repositories.png" alt="Maven仓库类型和位置"></p>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>本地仓库是开发人员计算机上的目录。该仓库将包含Maven下载的所有依赖项。相同的Maven存储库通常用于多个不同的项目。因此，Maven只需要下载依赖关系，即使多个项目依赖于它们（例如Junit）。</p>
<p>您也可以使用mvn install命令，在本地仓库中构建并安装自己的项目。这样，您的其他项目可以将您自己的项目的打包JAR文件作为外部依赖，将它们指定为Maven POM文件中的外部依赖项。</p>
<p>默认情况下，Maven将本地存储库放在本地计算机上的用户主目录中。但是，您可以通过设置Maven设置文件中的目录来更改本地仓库的位置。您的Maven设置文件也位于user-home&#x2F;.m2目录中，文件名为settings.xml。以下是为本地仓库指定其他位置的方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span></span><br><span class="line">        d:\data\java\products\maven\repository</span><br><span class="line">    <span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h2><p>Maven中央仓库是由Maven社区提供的一个存储库。默认情况下，如果本地仓库中找不到，Maven在此中央仓库中查找所需的任何依赖。 Maven然后将这些依赖下载到您的本地仓库。您无需特殊的配置来访问中央仓库。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库是Web服务器上的仓库，Maven可以从其中下载依赖，就像中央仓库一样。远程仓库可以位于互联网上的任何地方，也可以位于本地网络内。</p>
<p>远程仓库通常用于托管您组织内部的项目，这些项目由多个项目共享。例如，可以在多个内部项目中使用通用的安全项目。这个安全项目不应该被外部世界访问，因此不应该被托管在公共的Maven中央仓库中。相反，它可以托管在内部远程仓库。  </p>
<p>在远程仓库中找到的依赖也由Maven下载并放入本地仓库。</p>
<p>您可以在POM文件中配置远程仓库。将以下XML元素放在&lt;dependencies&gt;元素之后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>jenkov.code<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.jenkov.com/maven2/lib<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Maven构建生命周期，阶段和目标"><a href="#Maven构建生命周期，阶段和目标" class="headerlink" title="Maven构建生命周期，阶段和目标"></a>Maven构建生命周期，阶段和目标</h1><p>当Maven构建一个软件项目时，它遵循构建生命周期。构建生命周期分为构建阶段，构建阶段分为构建目标。Maven构建生命周期，构建阶段和目标在<a href="#">Post not found: 《《Maven官方文档》（二）构建生命周期介绍</a> _中有更详细的描述，但在这里我将给您一个快速的概述。</p>
<h2 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h2><p>Maven有三个内置生命周期，它们是</p>
<ol>
<li><strong>default</strong></li>
<li><strong>clean</strong></li>
<li><strong>site</strong></li>
</ol>
<p>这些构建生命周期中的每一个都处理构建软件项目的不同方面。因此，这些构建生命周期中的每一个彼此独立地执行。您可以让Maven执行多个构建生命周期，但它们将按顺序执行，彼此分开，就好像已经执行了两个单独的Maven命令一样。<br>default生命周期处理与编译和打包项目相关的所有内容。clean的生命周期处理与从输出目录中删除临时文件相关的所有内容，包括生成的源文件，编译的类，以前的JAR文件等。site生命周期处理与为您的项目生成文档相关的所有内容。事实上，site可以生成一个完整的网站，其中包含您项目的文档。</p>
<h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>每个构建生命周期分为一系列构建阶段，构建阶段再次细分为目标。因此，总体构建过程是一系列的构建生命周期，构建阶段和目标。</p>
<p>您可以执行整个构建生命周期如clean或site，或者一个构建阶段如install，这是default构建生命周期的一部分，或一个构建目标，如 dependency:copy-dependencies。注意：您不能直接执行default生命周期。您必须在default生命周期内指定构建阶段或目标。</p>
<p>当你执行一个构建阶段，在这个标准构建阶段序列中所有之前的构建阶段都会被执行。因此，执行install构建阶段实际意味着执行在install阶段之前所有构建阶段，然后再执行install阶段。</p>
<p>default的生命周期是最有意思的，因为它建立代码。由于您无法直接执行default生命周期，因此您需要执行deafault生命周期中的构建阶段或目标。</p>
<p>deafault生命周期有一个广泛的构建阶段和目标序列，但这里不描述。最常用的构建阶段是：</p>
<table>
<thead>
<tr>
<th>构建阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>validate</td>
<td>验证项目是否正确，是否提供了所有必要的信息。这也确保了依赖被下载。</td>
</tr>
<tr>
<td>compile</td>
<td>编译项目源代码</td>
</tr>
<tr>
<td>test</td>
<td>使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署</td>
</tr>
<tr>
<td>package</td>
<td>编译代码并将其打包成可分发格式，如JAR。</td>
</tr>
<tr>
<td>install</td>
<td>将软件包安装到本地仓库中，以作为本地其他项目的依赖使用</td>
</tr>
<tr>
<td>deploy</td>
<td>将最终软件包复制到远程仓库，以与其他开发人员和项目共享。</td>
</tr>
</tbody></table>
<p>通过将其名称传递给mvn命令来执行其中一个构建阶段。这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>此示例执行package构建阶段，也执行在此阶段在Maven预定义构建阶段序列之前所有的阶段。</p>
<p>如果标准的Maven构建阶段和目标不足以构建项目，则可以创建Maven插件以添加所需的额外构建功能。</p>
<h2 id="构建目标"><a href="#构建目标" class="headerlink" title="构建目标"></a>构建目标</h2><p>构建目标是Maven构建过程中最精细的步骤。一个目标可以绑定到一个或多个构建阶段，或者根本没有。如果目标没有绑定到任何构建阶段，则只能通过将目标名称传递给mvn命令来执行。如果一个目标被绑定到多个构建阶段，那么该目标将在每个构建阶段被执行。</p>
<h1 id="Maven构建配置"><a href="#Maven构建配置" class="headerlink" title="Maven构建配置"></a>Maven构建配置</h1><p>Maven构建配置使您能够使用不同的配置构建项目。相比创建两个单独的POM文件，您可以只需指定一个带有不同构建配置的profile，并在需要时使用此构建配置文件构建项目。</p>
<p>您可以在<a href="http://maven.apache.org/pom.html#Profiles">“Profile”</a>下的Maven POM参考资料中阅读有关构建配置文件的完整故事。这里我会给你一个快速的概述。</p>
<p>Maven配置文件指定在POM文件中，在profiles元素内。每个构建配置文件嵌套在profile元素中。这有一个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jenkov.crawler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-web-crawler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">activation</span>&gt;</span>...<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>构建配置文件描述在该构建配置文件下执行时应对POM文件进行哪些更改。这可能会更改要使用的应用程序配置文件等。配置文件元素中的元素将覆盖POM中具有相同名称的元素的值。</p>
<p>在profile元素内可以看到activation元素。该元素描述触发此构建配置文件被使用的条件。选择执行那个profile的一个方式在setting.xml文件中。这里你可以设置激活的profile。另一种方法是将-P profile-name添加到Maven命令行。有关详细信息，请参阅配置文件文档。</p>
<h1 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a>Maven插件</h1><p>Maven插件使您能够将自己的操作添加到构建过程中。您可以通过创建一个简单的Java类来继承一个特殊的Maven类，然后为该项目创建一个POM。该插件应该位于其自己的项目中。</p>
<h1 id="Maven命令"><a href="#Maven命令" class="headerlink" title="Maven命令"></a>Maven命令</h1><p>Maven包含一系列你可以执行的命令。Maven命令是构建生命周期，构建阶段和构建目标的混合，因此可能会有点混乱。因此，我将在本教程中描述常见的Maven命令，并解释其正在执行的构建生命周期，构建阶段和构建目标。</p>
<h2 id="Maven命令结构"><a href="#Maven命令结构" class="headerlink" title="Maven命令结构"></a>Maven命令结构</h2><p>一个Maven命令包含这两个元素</p>
<ul>
<li>mvn</li>
<li>一个或多个构建周期，构建阶段或构建目标</li>
</ul>
<p>这是一个Maven命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>
<p>该命令由执行Maven的mvn命令和名为clean的构建生命周期组成。<br>这是另一个Maven命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>
<p>这个maven命令执行clean构建生命周期和default生命周期中的install构建阶段。</p>
<p>您可能会想知道如何看待构建生命周期，构建阶段和构建目标之间的区别。稍后会说明。</p>
<h2 id="构建生命周期，阶段和目标-1"><a href="#构建生命周期，阶段和目标-1" class="headerlink" title="构建生命周期，阶段和目标"></a>构建生命周期，阶段和目标</h2><p>如关于构建生命周期，构建阶段和构建目标的部分中的介绍中提到的，Maven包含三个主要的构建生命周期：</p>
<ul>
<li>clean</li>
<li>default</li>
<li>site</li>
</ul>
<p>在每个构建生命周期内都有构建阶段，每个构建阶段都有构建目标。      </p>
<p>您可以执行构建生命周期，构建阶段或构建目标。当执行构建生命周期时，执行了构建生命周期内执行所有构建阶段（以及构建目标）。</p>
<p>执行构建阶段时，会执行构建阶段内执行所有的构建目标。 Maven还执行了构建生命周期中的希望的构建阶段之前所有的构建阶段。</p>
<p>Buid目标被分配到一个或多个buid阶段。执行构建阶段时，构建阶段的所有目标也是如此。您也可以直接执行构建目标。</p>
<h2 id="执行生命周期，阶段和目标"><a href="#执行生命周期，阶段和目标" class="headerlink" title="执行生命周期，阶段和目标"></a>执行生命周期，阶段和目标</h2><p>运行mvn命令时，可以传递一个或多个参数。这些参数指定构建生命周期，构建阶段或构建目标。例如，要执行clean构建生命周期，请执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>
<p>要执行站点构建生命周期，请执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure>
<h1 id="执行Default生命周期"><a href="#执行Default生命周期" class="headerlink" title="执行Default生命周期"></a>执行Default生命周期</h1><p>default的生命周期是生成，编译，打包等你的源代码的构建生命周期。</p>
<p>您无法像clean或site一样直接执行default构建生命周期。相反，您必须在default构建生命周期内执行特定的构建阶段。</p>
<h1 id="执行构建阶段"><a href="#执行构建阶段" class="headerlink" title="执行构建阶段"></a>执行构建阶段</h1><p>通过将构建阶段的名称传递给Maven命令，可以在构建生命周期内执行构建阶段。这里有几个构建阶段命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn pre-clean</span><br><span class="line"></span><br><span class="line">mvn compile</span><br><span class="line">    </span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>Maven会查找指定的构建阶段所属的构建生命周期，因此您不需要明确指定构建阶段所属的构建生命周期。</p>
<h1 id="Maven原型"><a href="#Maven原型" class="headerlink" title="Maven原型"></a>Maven原型</h1><p>Maven原型是可以为您的Maven生成的项目模板。换句话说，当您开始一个新项目时，您可以使用Maven为该项目生成一个模板。在Maven中，一个模板被称为原型（archetype）。因此，每个Maven原型对应于Maven可以生成的项目模板。</p>
<h2 id="可用的Maven原型"><a href="#可用的Maven原型" class="headerlink" title="可用的Maven原型"></a>可用的Maven原型</h2><p>Maven包含很多原型，所以这个Maven原型教程将只显示一些最常用的原型。要查看Maven原型的完整列表，只需运行以下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>该命令实际上是为您生成一个Maven原型，但是由于您没有在命令中指定要构建的原型，Maven将会将其所有可用的原型输出到命令提示符。最后，Maven会询问你生成哪一个Maven原型。如果您知道要生成的原型的编号，则可以在命令提示符中键入数字，然后按Enter键。</p>
<p>该列表包含超过1.300个Maven原型，因此找到所需的原型并不是那么容易。看看可用的Maven原型列表，您可以将输出管道输入到一个文件中，然后打开该文件。Notepad++ 等等。您可以使用此Maven命令将可用的Maven原型管理到文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate &gt; archetypes.txt</span><br></pre></td></tr></table></figure>

<p>您可能需要在要求您输入原型号码的地方取消该命令。您可以使用CTRL-C在Windows上执行此操作。原型仍将写入文件。</p>
<h2 id="命名原型"><a href="#命名原型" class="headerlink" title="命名原型"></a>命名原型</h2><p>Maven包含一组您可以创建的命名原型。我将在以下部分中列出其中的几个原型。</p>
<h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><p>有一个Maven原型可以生成一个新的Java项目，包括Eclipse IDE的文件。您可以使用此Maven命令生成该原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn eclipse:eclipse</span><br></pre></td></tr></table></figure>
<p>在生成此Maven原型之前，您需要在要生成原型的项目根目录中有一个POM文件。</p>
<h3 id="IDEA原型"><a href="#IDEA原型" class="headerlink" title="IDEA原型"></a>IDEA原型</h3><p>与Eclipse原型类似，Maven包含一个IntelliJ IDEA原型。您可以使用此Maven命令生成IDEA原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn idea:idea</span><br></pre></td></tr></table></figure>
<h1 id="Maven单元测试报告"><a href="#Maven单元测试报告" class="headerlink" title="Maven单元测试报告"></a>Maven单元测试报告</h1><p>Maven可以以HTML形式生成单元测试报告。 Maven通过运行单元测试并记录单元测试的结果来做到这一点。然后Maven从单元测试结果生成一个HTML报告。</p>
<p>使用Maven生成单元测试报告可以在构建过程中看到哪些单元测试失败。特别是如果构建很大并且需要很长时间，那么因为在开发过程中您可能不会在IDE内部运行所有的单元测试。您只能运行与您所做更改相关的单元测试。然后，要检查项目中的所有内容是否仍然有效，您可以告诉Maven运行单元测试并生成单元测试报告。然后，您可以阅读报告，查看在构建期间是否有任何单元测试失败。</p>
<p>Maven单元测试报告是一个HTML文件。这意味着如果您需要与其他开发人员共享，则可将其复制到服务器。</p>
<h2 id="Maven-Surefire插件"><a href="#Maven-Surefire插件" class="headerlink" title="Maven Surefire插件"></a>Maven Surefire插件</h2><p>Maven单元测试报告由Maven Surefire插件生成。因此，单位测试报告也有时被称为Surefire 报告。</p>
<h2 id="生成一个单元测试报告"><a href="#生成一个单元测试报告" class="headerlink" title="生成一个单元测试报告"></a>生成一个单元测试报告</h2><p>您使用以下Maven命令生成一个Maven的单元测试报告（Surefire单元测试报告）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn surefire-report:report</span><br></pre></td></tr></table></figure>
<p>生成的单元测试报告可以在target&#x2F;site目录中找到。单元测试报告名为surefire-report.html。因此，单元测试报告的路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your-project/target/site/surefire-report.html</span><br></pre></td></tr></table></figure>

<h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>有时您可能希望Maven生成单元测试报告，而不再重新运行所有单元测试。<br>您可能只想使用上次运行的结果。你可以使用以下命令让Maven生成单元测试报告，而无需重新运行单元测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn surefire-report:report-only</span><br></pre></td></tr></table></figure>
<p>此命令仅生成单元测试报告。</p>
]]></content>
      <categories>
        <category>Maven</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2018/02/05/Python/</url>
    <content><![CDATA[<hr>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><hr>
<p>Python是一种易于学习，功能强大的编程语言。它具有高效的高级数据结构以及实现面向对象编程简单而有效的途径。 Python的优雅语法和动态类型以及其解释的特性使其成为大多数平台上许多领域脚本编写和快速应用程序开发的理想语言。<br>Python通过使用C或C++（或其他C语言可用的语言）实现很容易拓展新的函数和数据结构，Python也适合作为可定制应用程序的扩展语言。</p>
<span id="more"></span>

<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><hr>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<hr>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><hr>
<hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><hr>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><hr>
<p>List是使用方括号（[]）括起来，并使用逗号分隔的元素集，List可以包含不同数据类型的元素，但通常元素都是相同类型的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>同string一样（包括所有的内置sequence类型），list也可以被索引（index）和切片（slice），所有的切片操作都会返回一个包含所请求项的新的list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">0</span>]  <span class="comment"># 索引返回项</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[-<span class="number">1</span>]</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[-<span class="number">3</span>:]  <span class="comment"># 切片返回一个新的list</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>list还支持拼接等操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p><strong>不像string是一个不可变类型，list是一个可变类型</strong>，也就是list的内容可以更改。此时对切​​片的重新赋值也是可能的，这甚至可以改变list的大小或完全清除它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 替换一些值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 现在移除他们</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 通过使用一个空list替换掉所有元素来清空list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h3 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>append(x)</strong></td>
<td>再list尾部添加一个元素，等同 a[len(a):] &#x3D; [x]</td>
</tr>
<tr>
<td><strong>extend(iterable)</strong></td>
<td>通过附加iterable中的所有项来扩展list。等同于[len(a):] &#x3D;iterable。</td>
</tr>
<tr>
<td><strong>insert(i,x)</strong></td>
<td>在给定位置插入一个元素</td>
</tr>
<tr>
<td><strong>remove(x)</strong></td>
<td>从list中删除值为x的第一个元素。如果没有这样的元素，会抛出错误。</td>
</tr>
<tr>
<td><strong>pop([i])</strong></td>
<td>删除list中给定位置的元素，并返回它。如果没有指定索引，则a.pop()将弹出list中的最后一个元素。</td>
</tr>
<tr>
<td><strong>clear()</strong></td>
<td>从list中删除所有元素。相当于del a [:]。</td>
</tr>
<tr>
<td><strong>index(x[,start[,end]])</strong></td>
<td>返回list中第一个值为x的元素的基于0的索引。如果没有这样的元素会抛出一个ValueError</td>
</tr>
<tr>
<td><strong>count(x)</strong></td>
<td>返回x出现在list中的次数。</td>
</tr>
<tr>
<td><strong>sort(key&#x3D;None,reverse&#x3D;False)</strong></td>
<td>对list中的元素进行排序（参数可用于自定义排序，请参阅sorted（）以获取其解释）。</td>
</tr>
<tr>
<td><strong>reverse(x)</strong></td>
<td>反转list中的元素。</td>
</tr>
<tr>
<td><strong>copy(x)</strong></td>
<td>返回list的浅拷贝。等同于a[:]</td>
</tr>
</tbody></table>
<h3 id="list推导"><a href="#list推导" class="headerlink" title="list推导"></a>list推导</h3><p>list推导提供了一种简明的创建list的方式。通常应用创建一个新的list，该list中每个元素都是应用于另一个序列的每个成员或迭代的某些操作的结果，或者创建满足特定条件的那些元素的子序列。<br>例如，假设我们创建一个list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>注意，这样创建（或覆盖）一个名为x的变量在循环结束后依然存在，我们可以使用以下方法计算无任何副作用的list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>或者等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>这样更加简明易读。<br>list推导由一个方括号组成，括号中包含一个表达式，后跟一个for子句，然后零或更多的for或if子句。结果将成为一个新的list，通过评估后面的for和if子句的内容中产生。例如下面的list推导组合了两个list不相同的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>它等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>请注意在这两个代码片段中for和if语句的顺序是相同的。<br>如果表达式是一个元组（例如前面例子中的（x，y）），它必须加上括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [-<span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用值*2创建新的list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[-<span class="number">8</span>, -<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 过滤list排除掉负数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> vec <span class="keyword">if</span> x &gt;= <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 对每个元素应用函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 在每个元素上调用方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>freshfruit = [<span class="string">&#x27;  banana&#x27;</span>, <span class="string">&#x27;  loganberry &#x27;</span>, <span class="string">&#x27;passion fruit  &#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[weapon.strip() <span class="keyword">for</span> weapon <span class="keyword">in</span> freshfruit]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 创建一个双元组的列表，如（数字，平方）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, x**<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 元组必须加括号，否则会引发错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    [x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用两个&#x27;for&#x27;使用listcomp展开list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h3 id="嵌套list推导"><a href="#嵌套list推导" class="headerlink" title="嵌套list推导"></a>嵌套list推导</h3><p>list推导中的初始表达式可以是任意的表达式，包括另一个list推导。<br>考虑以下3个4长度为4的list的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>
<p>以下list推导将转置行和列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>正如我们在前面的章节中看到的那样，嵌套的listcomp是在它后面的for的上下文中计算的，所以这个例子相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>这反过来又是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 下面三行实现了嵌套的listcomp</span></span><br><span class="line"><span class="meta">... </span>    transposed_row = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line"><span class="meta">... </span>        transposed_row.append(row[i])</span><br><span class="line"><span class="meta">... </span>    transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>在实际工作中，你应该更喜欢内置函数来处理复杂的流程语句。对于这个用例，**zip()**函数可以做很好的工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h2><hr>
<h2 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h2><hr>
<p>我们看到列表和字符串有许多共同的属性，如索引和切片操作。它们是<strong>序列（sequence）</strong>数据类型的两个示例（请参见序列类型 - 列表，元组，范围）。由于Python是一种不断发展的语言，因此可能会添加其他序列数据类型。还有另一种标准的序列数据类型：<strong>元组（tuple）</strong>。<br>元组由多个用逗号分隔的值组成，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 元组可能是嵌套的:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 元组是不可变的:</span></span><br><span class="line"><span class="meta">... </span>t[<span class="number">0</span>] = <span class="number">88888</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 但是它可以包含可变对象:</span></span><br><span class="line"><span class="meta">... </span>v = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，在输出中，元组总是被包含在圆括号中，以便嵌套元组被正确解释;它们可能输入时带有或不带括号，尽管通常括号是必要的（如果元组是更大表达式的一部分）。无法给元组的单个项赋值，但可以创建一个包含可变对象（如list）的元组。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><hr>
<hr>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><hr>
<p>python可以将一些函数定义在一个文件中，以便在脚本或解释器中调用，这样的文件python称为<strong>模块</strong>(module)。模块中的定义可以被导入到其他模块或者主模块中。</p>
<p>模块(module)是一个包含Python定义和语句的文件。文件名为模块名加上 <strong>.py</strong> 后缀。在模块中，模块名（一个字符串）可以通过全局变量__name__获取。我们可以创建一个模块文件<em>fibo.py</em>，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fibonacci numbers module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(b, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>):   <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>要想在解释器或其他模块中使用fibo模块中的定义，需要先使用如下语句导入该模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>
<p>之后就可以通过模块名fibo引用该模块中的定义。</p>
<h2 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h2><hr>
<p>模块中也可以包含像在函数中一样的可执行语句，不过这些语句一般用来做初始化模块的功能。模块中定义的语句，只会在模块被import时执行一次。<br>每个模块都有自己私有的符号表（symbol table），它被该模块定义的所有函数用作全局符号表。因此在一个模块中可以使用该模块全局变量，而不用担心与其他模块全局变量冲突。</p>
<p>模块可以导入其他模块，习惯但不强制要求需要把<strong>import</strong>语句放在模块的开始位置。被导入的模块名称会被存在进行导入的模块的全局变量中。</p>
<p><strong>import</strong>语句还有一种变体</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种写法不会将模块名称引入执行import模块的局部符号表中（如这个例子中，fibo是未定义的）</p>
<p>还可以使用通配符将模块中所有定义名称导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种导入会将模块中除了以下划线（ _ ）开头的之外所有的名称导入。多数情况下开发人员不会使用这种方式，因为它容易隐藏自己已定义的名称，导致糟糕的代码易读性。</p>
<blockquote>
<p><strong>Note</strong>:基于效率考虑，每个模块在每次解释器会话中只会导入一次。因此，如果你更改了模块，则必须重启解释器，或者只有一个测试交互的模块的话，可以使用  importlib.reload(), 也就是<br>import importlib;<br>importlib.reload(modulename).</p>
</blockquote>
<h3 id="将模块作为脚本执行"><a href="#将模块作为脚本执行" class="headerlink" title="将模块作为脚本执行"></a>将模块作为脚本执行</h3><p>当如下运行Python模块时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python fibo.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
<p>就如同导入该模块一样，模块中的代码都会执行，除了模块的”__name__“会被设置为”__main__“,这意味着你可以在模块中加入如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    fib(<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>这样你可以使该文件就如一个可导入模块一样作为脚本使用，因为这些代码只会在该模块作为”main”文件执行时解析命令行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python fibo.py <span class="number">50</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>如果导入该模块，这些代码则不会执行。这种写法通常用来提供一个便捷的用户接口，或者用于测试目的（将模块作为脚本运行以执行单元测试）。</p>
<h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当一个名为<strong>spam</strong>的模块被导入，解释器首先搜索该名称的内置模块。如果没有找到，则在变量<strong>sys.path</strong>给定的目录列表中搜索名为<strong>spam.py</strong>的文件。<strong>sys.path</strong>从以下位置初始化：</p>
<ul>
<li>包含输入脚本的目录（或者当没有文件制定时为当前目录）</li>
<li>PYTHONPATH(一个目录名称列表，它与shell变量PATH有着相同的语义)</li>
<li>默认安装目录</li>
</ul>
<p>初始化之后，Python程序可以修改sys.path。运行脚本所在的目录在搜索路径开头，位于标准库路径之前。这意味着如果标准库目录下有与该目录下的相同名字的脚本，实际执行的是该目录下脚本。</p>
<h3 id="“编译”Python文件"><a href="#“编译”Python文件" class="headerlink" title="“编译”Python文件"></a>“编译”Python文件</h3><p>为了加速模块加载，Python在<strong>__pycache__<strong>目录下缓存每个模块的编译版本，并存储在名为</strong>module.version.pyc</strong>文件中。其中version对文件编码，他通常包含Python的版本号。这个命名约定允许来自不同版本和不同版本的Python的编译模块共存。<br>Python根据编译后的版本检查源代码的修改日期，看它是否过期并需要重新编译。这是一个完全自动的过程。另外，编译后的模块是独立于平台的，因此可以在不同架构的系统之间共享相同的库。<br>在两种情况下，Python不会检查缓存。第一种，从命令行直接加载的模块总是重新编译，并且不存储模块的结果。第二种，如果没有源模块，则不会检查缓存。要支持非源代码（仅编译）分发，编译的模块必须位于源代码目录中，并且不得有源模块。</p>
<h2 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h2><hr>
<p>Python带有一个标准模块库，在一个单独的文档中描述，即Python库参考 Python Library Reference （以下简称“库参考”）。一些模块是内置在解释器中的；它们提供了一些访问不属于该语言核心部分的操作，比如无论是为了提高效率还是对操作系统原函数的访问操作。这些模块的集是一个配置选项，它也取决于底层平台。例如，<strong>winreg</strong> 模块仅在Windows系统上提供。一个特定的模块<strong>sys</strong>值得注意：它被内置进了每个Python解释器。变量<strong>sys.ps1</strong> 和<strong>sys.ps2</strong> 定义用作主要和次要提示的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">&#x27;&gt;&gt;&gt; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">&#x27;... &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&#x27;C&gt; &#x27;</span></span><br><span class="line">C&gt; <span class="built_in">print</span>(<span class="string">&#x27;Yuck!&#x27;</span>)</span><br><span class="line">Yuck!</span><br><span class="line">C&gt;</span><br></pre></td></tr></table></figure>
<p>这两个变量只在解释器处于交互模式时才被定义。<br>变量<strong>sys.path</strong>是一个字符串列表，它决定了解释器的模块搜索路径。它被初始化为从环境变量<strong>PYTHONPATH</strong>获取的默认路径，或者如果未设置<strong>PYTHONPATH</strong>则从内置默认路径初始化。你可以使用标准的list操作修改它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">&#x27;/ufs/guido/lib/python&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><hr>
<p><strong>包（Package）</strong>是通过使用“点分割模块名称”来构造Python模块命名空间的一种方式。例如，模块名称A.B在名为A的包中指定名为B的子模块。假设你想设计一个模块集（一个“包”）来统一处理声音文件和声音数据。一下是可能的包结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sound/                          顶层的包</span><br><span class="line">      __init__.py              初始化sound包</span><br><span class="line">      formats/                  用于文件格式转换的子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  用作声音效果的子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  用作过滤器的子包装</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>当导入包时，Python将搜索<strong>sys.path</strong>上的目录，查找包子目录。<br>如果想要Python将一个目标视为包，则该目录下必须有**<strong>init</strong>.py<strong>文件。这是为了防止具有通用名称（例如String）的目录无意中隐藏稍后在模块搜索路径中查找到的有效模块。在最简单的情况下，</strong>__init__.py<strong>可以只是一个空文件，但它也可以执行包的初始化代码或设置</strong>__all__**变量。<br>包的使用者可以从包中导入单个模块，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>
<p>这会加载子模块<strong>sound.effects.echo</strong>。它必须以全名引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>导入子模块的另一种方法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<p>这也加载了子模块echo，并让它可以在不包含它的包前缀的情况下可用，因此可以如下使用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>另一种变体是直接导入所需的函数或变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>
<p>再次，这加载了子模块echo，但它的函数echofilter()可以直接使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>请注意，当使用<strong>from package import item</strong>，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。<strong>import</strong>语句首先测试item是否定义在包中;如果不是，它假定它是一个模块并尝试加载它。如果找不到它，则会引发<strong>ImportError</strong>异常。</p>
<h3 id="import-from-package"><a href="#import-from-package" class="headerlink" title="import * from package"></a>import * from package</h3><p>import语句使用以下约定：如果一个包的<strong>__init__.py</strong>代码定义了一个名为<strong>__all__<strong>的list，它被认为是执行from package import *  时应该导入的模块名称的列表。如果未定义</strong>__all__<strong>，则该语句不会导入该包下的任何模块到当前命名空间，它只确保包本身（可能在</strong>__init__.py</strong>文件中的初始化代码）被导入，然后导入包中定义的任何名称。这包括<strong>__init__.py</strong>定义的任何名称（以及明确加载的子模块）。它还包括由前面的<strong>import</strong>语句显式加载的包的任何子模块。考虑如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>echo和surround模块等同于使用from…import导入形式。</p>
<h3 id="多目录中的包"><a href="#多目录中的包" class="headerlink" title="多目录中的包"></a>多目录中的包</h3><p>包还支持一个更特殊的属性<strong>__path__<strong>。在执行该文件中的代码之前，它被初始化为一个包含了所有包含</strong>__init__.py</strong>文件的目录名称的列表。这个变量可以修改;但这样做会影响将来对包中包含的模块和子包的搜索。</p>
<p>虽然通常不需要此功能，但它可用于扩展程序包中找到的一组模块。</p>
<hr>
<h1 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h1><hr>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><hr>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><hr>
<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 概述</title>
    <url>/2017/07/24/Spring%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}
</style>

<p><a href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#spring-introduction">原文链接:</a> Spring Framework是一个轻量级解决方案，也是构建企业级应用程序的潜在一站式服务。但是，Spring是模块化的，允许你只使用你所需的部分，而无需引用其他的部分。你可以在任何web框架的顶层使用IOC容器，但也可以仅使用 Hibernate integration code或 JDBC abstraction layer。Spring框架支持声明式事务管理，通过RMI或web service远程访问你的业务逻辑，以及用于数据持久化的各种选项。它提供了一个全功能的MVC框架，使你能够将AOP透明地集成到你的软件中。</p>
<p>Spring被设计为非侵入式的，这意味着你的域逻辑代码通常不需要依赖框架本身。在你的集成层（比如数据访问层）中，将存在对数据访问技术和Spring库的一些依赖。但是，应该很容易将这些依赖关系与你的代码库的其余部分隔离开来。</p>
<span id="more"></span>
<hr>
<h1 id="Spring入门"><a href="#Spring入门" class="headerlink" title="Spring入门"></a>Spring入门</h1><hr>
<p>本参考指南提供有关Spring框架的详细信息。它为所有功能提供了全面的文档，以及Spring的一些基本概念（如“依赖注入”）的一些背景知识。</p>
<p>如果你刚开始使用Spring，则可能需要通过创建基于Spring Boot的应用程序来开始使用Spring Framework。Spring Boot提供一种创建一个基于Spring生成就绪应用程序的快捷（主观上）方式。它基于Spring框架，有利于配置的约定，并且旨在尽可能快地开始运行。</p>
<p>你可以使用<a href="http://start.spring.io/">start.spring.io</a>生成一个基本项目，或按照“<a href="https://spring.io/guides">入门指南</a>”中的一个指导，如“<a href="https://spring.io/guides/gs/rest-service/">开始构建RESTful Web服务</a>”。除了易于学习以外，这些指南非常重视任务，它们大部分都是基于Spring Boot。它们还包含了当解决特定问题时你可能想要考虑的Spring解决方案中的其他项目。</p>
<hr>
<h1 id="Spring框架简介"><a href="#Spring框架简介" class="headerlink" title="Spring框架简介"></a>Spring框架简介</h1><hr>
<p>Spring Framework是一个Java平台，为开发Java应用程序提供全面的基础框架支持。Spring处理这些基础框架，以便你可以专注于你的应用程序。</p>
<p>Spring使你能够从“plain old Java objects”（POJO）构建应用程序，并将企业服务非侵入式应用于POJO。此功能适用于全部的Java SE编程模型以及部分Java EE。</p>
<p>作为应用程序开发人员，你可以从Spring平台中获益：</p>
<ul>
<li>使Java方法在数据库事务中执行，而不必处理事务API。</li>
<li>使本地Java方法成为HTTP端点，而无需处理Servlet API。</li>
<li>使本地Java方法成为消息处理器，而无需处理JMS API。</li>
<li>使本地Java方法成为管理操作，而无需处理JMX API。</li>
</ul>
<h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><hr>
<p>一个Java应用程序—这是一个宽泛的术语，它的范围从受限的嵌入式应用程序到n层的服务端企业应用程序—通常由相互协作来形成应用程序的对象组成。因此，应用程序中的对象彼此有依赖关系。</p>
<p>虽然Java平台提供了丰富的应用程序开发功能，但是它缺乏将基本构建块组织一个连贯整体的方法，它将将该任务留给架构师和开发人员。虽然你可以使用设计模式，如 Factory, Abstract Factory, Builder, Decorator和Service Locator来组成构成应用程序的各种类和对象实例，这些模式简单地：最佳实践给了一个名字，描述了模式的作用，应用于哪里，它解决的问题等等。设计模式是形式化的最佳实践，你必须在应用程序中自己实现。</p>
<p>Spring框架控制反转-Inversion of Control（IoC）组件通过提供一种形式化的方式，将不同的组件组合成一个可以随用完全工作的应用程序，来解决这个问题。Spring框架将形式化的设计模式作为头等对象进行编写，这样你可以集成到你自己的应用程序中。许多组织和机构以这种方式使用Spring框架来设计强大的，可维护的应用程序。</p>
<blockquote>
<p><strong>背景知识</strong><br>“问题是，哪一方面的控制（他们）反转了？”Martin Fowler在2004年在他的网站上提出了关于控制反转（IoC）的问题.Fowler建议重新命名这个原理，使其更加自明，并提出了<em>依赖注入</em>这个名称。</p>
</blockquote>
<h2 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h2><hr>
<p>Spring框架由被组织成约20个模块的功能组成。这些模块被分组为核心容器（Core Container），数据访问&#x2F;集成（Data Access&#x2F;Integration），Web，AOP（面向切面编程），Instrumentation，消息和测试，如下表所示。<br><img src="/images/spring/spring-overview.png.pagespeed.ce.XVe1noRCMt.png" alt="Spring框架概览"><br>以下部分列出了每个功能的可用模块和它的artifact名称及其涵盖的主题。Artifact名称与依赖关系管理工具中使用的<em>artifact ID</em>相关。</p>
<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>核心容器由<em><strong>spring-core</strong></em>，<em><strong>spring-beans</strong></em>，<em><strong>spring-context</strong></em>，<em><strong>spring-context-support</strong></em> 和<em><strong>spring-expression</strong></em>（Spring表达式语言）模块组成。</p>
<p><em><strong>spring-core</strong></em> 和<em><strong>spring-beans</strong></em> 模块提供框架的基本部分，包括IoC和依赖注入功能。<em><strong>BeanFactory</strong></em> 是工厂模式的一个复杂实现。它消除了对单例编程的需要，并允许你将依赖关系的配置和说明与实际程序逻辑分离。</p>
<p>Context(<em><strong>spring-context</strong></em> )模块在Core and Beans模块提供的实体基础上构建：它是以框架式方式访问对象的一种手段，这类似于JNDI注册。Context模块从Beans模块继承其功能，并且添加了对国际化的支持（例如使用资源束），事件传播，资源加载以及通过例如Servlet的容器透明地创建上下文。Context模块还支持Java EE功能，如EJB，JMX和基本远程处理。<em><strong>ApplicationContext</strong></em> 接口是Context模块的焦点。<em><strong>spring-context-support</strong></em> 提供了将常见的第三方库集成到Spring应用程序上下文中的支持，用于缓存（EhCache, Guava, JCache），邮件（JavaMail），作业调度（CommonJ, Quartz）以及模板引擎（FreeMarker, JasperReports, Velocity）。</p>
<p><em><strong>spring-expression</strong></em> 模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP 2.1规范中规定的统一表达语言（统一EL）的扩展。该语言支持设置和获取属性值，属性分配，方法调用，访问数组，集合和索引器的内容，逻辑和算术运算符，命名变量以及从Spring的IoC容器中以名称检索对象。它还支持列表投影与选择以及常见列表聚合。</p>
<h3 id="AOP和Instrumentation"><a href="#AOP和Instrumentation" class="headerlink" title="AOP和Instrumentation"></a>AOP和Instrumentation</h3><p><em><strong>spring-aop</strong></em> 模块提供了符合AOP联盟的面向切面的编程实现，允许你定义方法拦截器和切入点，来将应分离的功能代码完全解耦。使用源代码级元数据功能，你还可以以类似于.NET属性的方式将行为信息合并到代码中。</p>
<p>单独的<em><strong>spring-aspects</strong></em> 模块提供与AspectJ的集成。</p>
<p><em><strong>spring-instrument</strong></em> 模块提供了在某些应用服务器中使用的类仪表支持和类加载器实现。<em><strong>spring-instrument-tomcat</strong></em> 模块包含Spring的Tomcat Instrumentation代理。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>Spring Framework 4包括一个<em><strong>spring-messaging</strong></em> 模块，其中包含来自Spring Integration项目（如Message，MessageChannel，MessageHandler等）的关键摘要，以及一些其他的作为基于消息的应用程序的基础。这个模块还包含一系列用于映射消息到方法的注解，类似于Spring MVC基于注解的编程模型。</p>
<h3 id="数据访问-x2F-集成"><a href="#数据访问-x2F-集成" class="headerlink" title="数据访问&#x2F;集成"></a>数据访问&#x2F;集成</h3><p>数据访问&#x2F;集成层由JDBC,ORM,OXM,JMS和Transaction模块组成。</p>
<p><em><strong>spring-jdbc</strong></em> 模块提供了一个JDBC抽象层，它不需要进行繁琐的JDBC编程和解析数据库供应商特定的错误代码。</p>
<p><em><strong>spring-tx</strong></em> 模块对于实现特殊接口和所有POJO（简单Java对象）的类，支持支持编程和声明式事务管理。</p>
<p><em><strong>spring-orm</strong></em> 模块对流行的对象关系映射API，包括 JPA, JDO和Hibernate等提供了整合层. 使用这个模块你可以将所有的这些O&#x2F;R映射框架与Spring提供的所有其他功能结合使用，比如前面提到的简单的声明式事务管理功能。</p>
<p><em><strong>spring-oxm</strong></em> 模块提供了一个支持Object&#x2F;XML映射实现的抽象层，如JAXB，Castor，XMLBeans，JiBX和XStream。</p>
<p><em><strong>spring-jms</strong></em>（Java Messaging Service）包含用于生成和消费消息的功能。自Spring Framework 4.1以来，它提供了与<em><strong>spring-messaging</strong></em>模块的集成。</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web层由spring-web，spring-webmvc,spring-websocket和spring-webmvc-portlet模块组成。</p>
<p><em><strong>spring-web</strong></em> 模块提供了基本的面向Web的集成功能，例如多部分文件上传功能，使用Servlet监听器和面向Web应用程序上下文来初始化IoC容器。它还包含一个HTTP客户端和Spring的远程支持的Web相关部分。</p>
<p><em><strong>spring-webmvc</strong></em> 模块（也称为Web-Servlet模块）包含Web应用程序的Spring的模型-视图-控制器（MVC）和REST Web Service实现。Spring的MVC框架在域模型代码和Web表单之间提供了清晰的分隔，并与Spring Framework的所有其他功能整合在一起。</p>
<p><em><strong>spring-webmvc-portlet</strong></em> 模块（也称为Web-Portlet模块）提供了在Portlet环境中使用的MVC实现，并镜像了基于Servlet的spring-webmvc模块的功能。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><em><strong>spring-test</strong></em> 模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。它提供了Spring ApplicationContexts的一致加载和这些上下文的缓存。它还提供可用于隔离测试代码的模拟对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><hr>
<p>前面描述的构建块使Spring在许多场景中可以合理选择，从在资源有限的设备上运行的嵌入式应用程序到使用Spring的事务管理功能和web框架集成的全面企业应用程序。</p>
<p><em><strong>典型的完整Spring Web应用程序</strong></em><br><img src="/images/spring/overview-full.png.pagespeed.ce.sC26wirtWB.png" alt="典型的完整Spring Web应用程序">Spring的声明式事务管理功能使Web应用程序完全事务性，就像使用EJB容器管理的事务一样。所有你的自定义业务逻辑都可以使用简单的POJO实现，并由Spring的IoC容器进行管理。其他的服务包括对发送邮件的支持和独立于web层验证，可让你选择执行验证规则的位置。Spring的ORM支持是与JPA，Hibernate和JDO集成;比如，当你使用Hibernate，你可以继续使用已有的映射文件和标准的Hibernate SessionFactory配置。表单控制器将Web层与域模型无缝集成，从而无需ActionForms或将HTTP参数转换为你的域模型值的其他类。</p>
<p><em><strong>使用第三方web框架的Spring中间层</strong></em><br><img src="/images/spring/overview-thirdparty-web.png.pagespeed.ce.1lJso2G8WP.png" alt="使用第三方web框架的Spring中间层"><br>有时一些情况不允许你完全切换到不同的框架。Spring框架并不强制你使用它的一切;它不是一个要么全部采用要么全不采用的解决方案。使用Struts，Tapestry，JSF或其他UI框架构建的现有前端可以与基于Spring的中间层集成，这允许你使用Spring事务功能。你只需要使用ApplicationContext连接你的业务逻辑，并使用WebApplicationContext来集成你的Web层。</p>
<p><em><strong>远程使用场景</strong></em><br><img src="/images/spring/overview-remoting.png.pagespeed.ce.HIMsJb_Xya.png" alt="远程使用场景"><br>当你需要通过Web服务访问现有代码时，可以使用Spring的Hessian-，Burlap-，Rmi-或JaxRpcProxyFactory类。启用对现有应用程序的远程访问并不困难。</p>
<p><em><strong>EJBs - 包装现有的POJO</strong></em><br><img src="/images/spring/overview-ejb.png.pagespeed.ce.VN88UiKUhA.png" alt="EJBs - 包装现有的POJO"><br>Spring Framework还为Enterprise JavaBeans提供了一个访问和抽象层，使你能够重用现有的POJO，并将其包装在无状态会话bean中，以便在可能需要声明式安全性的可扩展的，故障安全的Web应用程序中使用。</p>
<h3 id="依赖管理和命名惯例"><a href="#依赖管理和命名惯例" class="headerlink" title="依赖管理和命名惯例"></a>依赖管理和命名惯例</h3><p>依赖管理和依赖注入是不同的事情。为了将Spring的这些不错的功能（如依赖注入）引入到应用程序中，你需要组合所有必须的库（jar文件），并且在运行时期或编译时期将它们导入你的类路径中。这些依赖不是注入的虚拟组件，而是文件系统中的物理资源（通常为）。依赖管理的过程包括定位这些资源，存储并添加它们到类路径。依赖可以是直接依赖（如我的程序在运行时期依赖Spring），或间接依赖（如我的程序依赖commons-dbcp，而它又依赖commons-pool）。间接依赖关系也被称为“传递性”，它们是最难识别和管理的依赖关系。</p>
<p>如果你要使用Spring，你需要获得一个包含你所需要的Spring部分的jar库的副本。为了使这更容易，Spring被打包成一系列的模块，这样可以尽可能地分离依赖关系，因此，例如如果你不想编写Web应用程序，则不需要spring-web模块。要在本指南中引用Spring库模块，我们使用一个简写命名约定spring-*或spring-*.jar，这里*代表模块的简称（如spring-core, spring-webmvc, spring-jms，等等）。而实际你使用的jar文件名称通常是模块名后面连接着版本号（比如spring-core-4.3.10.RELEASE.jar）。</p>
<p>Spring Framework的每个版本都会将artifacts发布到以下位置：</p>
<ul>
<li>Maven Central，这是Maven查询的默认仓库，并且不需要任何特殊配置来使用。Spring的许多常见的库也可以从Maven Central获得，Spring社区的大部分使用Maven进行依赖关系管理，所以这对他们来说很方便。这里jar的名称是 spring - * - &lt;version&gt;.jar的形式，Maven groupId是<em>org.springframework</em>.</li>
<li>在专门用于Spring的公共Maven仓库。除了最终的GA版本，这个仓库还托管这开发快照版和里程碑版。jar文件名称与Maven Central中使用同样的形式，所以这是一个对开发者有用的地方，可以让开发版本的Spring与在Maven Central中部署的其他库一起使用。该存储库还包含捆绑分发zip文件，其中包含所有Spring jar，捆绑在一起以便于下载。</li>
</ul>
<p>所以你需要决定的第一件事是如何管理你的依赖：我们通常建议使用像Maven，Gradle或Ivy这样的自动化系统，但你也可以通过自己下载所有的jar来手动进行操作。</p>
<p>下面你将会看到Spring工件的列表。有关每个模块的更完整的描述，请参见第2.2节“<a href="#%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97">框架模块</a>”。</p>
<table>
<thead>
<tr>
<th>GroupId</th>
<th>ArtifactId</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>org.springframework</td>
<td>spring-aop</td>
<td>基于代理的AOP支持</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-aspects</td>
<td>基于AspectJ的切面</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-beans</td>
<td>Beans支持, 包括Groovy</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-context</td>
<td>运行时期应用程序上下文，包括调度和远程抽象</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-context-support</td>
<td>支持类将常见的第三方库集成到Spring应用程序上下文中</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-core</td>
<td>核心实用程序，被许多其他Spring模块使用</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-expression</td>
<td>Spring表达式语言 (SpEL)</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-instrument</td>
<td>用于JVM引导的Instrumentation代理</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-instrument-tomcat</td>
<td>Tomcat的Instrumentation代理</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-jdbc</td>
<td>JDBC支持包，包括DataSource设置和JDBC访问支持</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-jms</td>
<td>JMS支持包，包括发送&#x2F;接收JMS消息的帮助类</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-messaging</td>
<td>支持消息架构和协议</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-orm</td>
<td>对象&#x2F;关系映射，包括JPA和Hibernate支持</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-oxm</td>
<td>对象&#x2F; XML映射</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-test</td>
<td>支持单元测试和集成测试Spring组件</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-tx</td>
<td>事务基础框架，包括DAO支持和JCA整合</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-web</td>
<td>基础网络支持，包括Web客户端和基于Web的远程处理</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-webmvc</td>
<td>基于HTTP的Model-View-Controller和REST端点，用于Servlet堆栈</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-webmvc-portlet</td>
<td>在Portlet环境中使用MVC实现</td>
</tr>
<tr>
<td>org.springframework</td>
<td>spring-websocket</td>
<td>的WebSocket和SockJS基础框架，包括STOMP消息支持</td>
</tr>
</tbody></table>
<h4 id="Spring依赖和依赖Spring"><a href="#Spring依赖和依赖Spring" class="headerlink" title="Spring依赖和依赖Spring"></a>Spring依赖和依赖Spring</h4><p>虽然Spring为大型企业和其他外部工具提供集成和支持，它有意将它的强制依赖保持在最小：你不必为了简单的案例使用Spring而去定位和下载（甚至自动）大量的jar库。对于基本依赖注入，只有一个强制性的外部依赖关系，也就是用于日志记录（有关日志记录选项的更详细描述，请参阅下文）。</p>
<p>接下来我们概述需要配置一个依赖Spring的应用程序，首先是使用Maven，然后是Gradle，最后是Ivy。在这些所有情况下，如果哪些不清楚，请参阅你的依赖管理系统的文档，或者看些简单代码-Spring它自己在构建的时候使用Gradle来管理依赖，并且我们的示例大多使用Gradle或Maven。</p>
<h4 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h4><p>如果你使用Maven作为依赖管理，那么你甚至不必明确的提供日志依赖。比如，要创建应用程序上下文并使用依赖注入来配置应用程序，你的Maven依赖项将如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是这样。注意，如果你不需要针对Spring APIs进行编译，那么scope可以被声明为runtime，通常情况下这是基本依赖注入用例的情况。</p>
<p>上面的例子适用于Maven中央仓库。要想使用Spring的Maven仓库（如为了使用里程碑和开发快照版），你需要在你的Maven配置中指定仓库的位置。对于全部版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>io.spring.repo.maven.release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于里程碑版：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>io.spring.repo.maven.milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于快照版：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>io.spring.repo.maven.snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/snapshot/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Maven“物料清单”依赖"><a href="#Maven“物料清单”依赖" class="headerlink" title="Maven“物料清单”依赖**"></a>Maven“物料清单”依赖**</h4><p>使用Maven时，可能会意外混合不同版本的Spring JAR。比如，你可能发现一个第三方库或者另一个Spring项目，将传递依赖传递给了旧的版本。如果你忘记自己明确声明一个直接依赖，可能会出现各种意外问题。</p>
<p>为了克服这些问题，Maven支持“物料单”（BOM）依赖的概念。你可以在dependencyManagement部分中导入spring-framework-bom，以确保所有的spring 依赖（直接和传递）都是相同的版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-framework-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用BOM的另外一个好处是，你不再需要在依赖于Spring框架的artifact时指定&lt;version&gt;属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Gradle依赖管理"><a href="#Gradle依赖管理" class="headerlink" title="Gradle依赖管理"></a>Gradle依赖管理</h4><p>要使用具有Gradle构建系统的Spring存储库，请在存储库部分中包含适当的URL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    // and optionally...</span><br><span class="line">    maven &#123; url &quot;http://repo.spring.io/release&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以根据需要将存储库URL从&#x2F; release更改为&#x2F; milestone或&#x2F; snapshot。一旦存储库被配置，你可以通常使用Gradle方式来声明依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(&quot;org.springframework:spring-context:4.3.10.RELEASE&quot;)</span><br><span class="line">    testCompile(&quot;org.springframework:spring-test:4.3.10.RELEASE&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ivy依赖管理"><a href="#Ivy依赖管理" class="headerlink" title="Ivy依赖管理"></a>Ivy依赖管理</h4><p>如果你喜欢使用Ivy来管理依赖关系，那么还有类似的配置选项。</p>
<p>要配置Ivy指向Spring存储库，请将以下解析器添加到你的ivysettings.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resolvers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ibiblio</span> <span class="attr">name</span>=<span class="string">&quot;io.spring.repo.maven.release&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">m2compatible</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">root</span>=<span class="string">&quot;http://repo.spring.io/release/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resolvers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以根据需要将根URL从&#x2F; release &#x2F;更改为&#x2F; milestone &#x2F;或&#x2F; snapshot &#x2F;。 配置完成后，你可以按通常的方式添加依赖项。例如（在ivy.xml中）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span> <span class="attr">org</span>=<span class="string">&quot;org.springframework&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;spring-core&quot;</span> <span class="attr">rev</span>=<span class="string">&quot;4.3.10.RELEASE&quot;</span> <span class="attr">conf</span>=<span class="string">&quot;compile-&gt;runtime&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="分发Zip文件"><a href="#分发Zip文件" class="headerlink" title="分发Zip文件"></a>分发Zip文件</h4><p>虽然使用支持依赖关系管理的构建系统是推荐的获取Spring框架的方法，但仍然可以下载分发zip文件。</p>
<p>分发zip被发布到Spring Maven仓库中（这只是为了我们的方便，你不需要Maven或任何其他构建系统来下载它们）。</p>
<p>要下载分发zip打开Web浏览器到<a href="http://repo.spring.io/release/org/springframework/spring">http://repo.spring.io/release/org/springframework/spring</a> ，并为所需的版本选择适当的子文件夹。分发文件以-dist.zip结尾，例如spring-framework- {spring-version} -RELEASE-dist.zip。发行版还会发布里程碑和快照。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>对于Spring来说，日志记录是非常重要的依赖因为：</p>
<ul>
<li>它是唯一的强制依赖</li>
<li>每个人都喜欢从他们使用的工具中看到一些输出</li>
<li>Spring与许多其他工具集成，这些工具都可以选择日志记录依赖关系。</li>
</ul>
<p>应用程序开发人员的目标之一通常是将统一的日志记录配置在整个应用程序的中央位置，包括所有外部组件。自从有了这么多的日志框架可以选择，这项工作比以前困难很多。</p>
<p>Spring中的强制性日志依赖是Jakarta Commons Logging API（JCL）。我们针对JCL进行编译，并且我们还使JCL的Log对象对所有继承自Spring框架的类可见。对用户来说，所有版本的Spring都使用相同的日志库很重要：这样迁移很容易，因为即使拓展自Spring的应用程序仍然保留向后兼容性。我们这样做的方式是使Spring中的一个模块明确地依赖于commons-logging（JCL的规范实现），然后在编译时使所有其他模块依赖于它。例如，如果你使用Maven，并且想知道在哪里可以获取对commons-logging的依赖，那么它来自Spring，明确来说是来自名为spring-core的中央模块。</p>
<p>commons-logging的好处在于，你不需要任何其他操作来使你的应用程序正常工作。它有一个运行时期发现算法，可以在classpath中的众所周知的地方查找其他的日志框架，并且使用一个它认为合适的使用（或者你可以可以告诉它你需要哪一个）。如果没有其他可用的，你可以从JDK（java.util.logging或者简称JUL）中看到非常漂亮的日志。你应该发现，在大多数情况下，你的Spring应用程序可以快乐地登录到控制台，这很重要。</p>
<h4 id="使用Log4j-1-2或2-X"><a href="#使用Log4j-1-2或2-X" class="headerlink" title="使用Log4j 1.2或2.X"></a>使用Log4j 1.2或2.X</h4><blockquote>
<p>Log4j 1.2在此期间已经终止。此外，Log4j 2.3是最新的Java 6兼容版本，较新的Log4j 2.x版本需要Java 7+版本。</p>
</blockquote>
<p>为了配置和管理的目的，许多人使用Log4j作为日志框架。它是高效和成熟的，实际上它是我们在构建Spring时在运行时使用的。Spring还提供了一些用于配置和初始化Log4j的工具，所以它在一些模块中它有一个对Log4j的可选的编译时期依赖。</p>
<p>要使Log4j 1.2与默认的JCL依赖（commons-logging）一起使用，所有你需要做的是将Log4j放入到classpath下，并且提供给它一个配置文件（log4j.properties或log4j.xml在classpath根下）。所以对于Maven用户来说，这是你的依赖声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这还有一个简单的用于记录日志到控制台的log4j.properties：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory=INFO, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %t %c&#123;2&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">log4j.category.org.springframework.beans.factory=DEBUG</span><br></pre></td></tr></table></figure>
<p>要和JCL一起私用Log4j 2.x，所有你需要做的是将Log4j放入到类路径，并且提供给它一个配置文件（log4j2.xml, log4j2.properties,或者其他支持的配置格式）。对于Maven用户，需要的最小依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你还希望启用SLF4J委托给Log4j，例如对于默认使用SLF4J的其他库，还需要以下依赖关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这有一个记录日志到控制台的log4j2.xml示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.beans.factory&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="避免使用Commons-Logging"><a href="#避免使用Commons-Logging" class="headerlink" title="避免使用Commons Logging"></a>避免使用Commons Logging</h4><p>不幸的是，在标准commons-logging API中的运行时期发现算法，方便终端用户的同时，也会带来问题。如果你想避免JCL的标准查找，基本上有两种方法来关闭它：</p>
<ol>
<li>从spring-core模块中排除依赖（因为它是明确依赖于commons-logging的唯一模块）</li>
<li>依赖一个特殊的commons-logging依赖，用一个空的jar取代这个库（更多细节可以在<a href="http://slf4j.org/faq.html#excludingJCL">SLF4J FAQ</a>中找到）</li>
</ol>
<p>要想排除commos-logging，在你的<strong>dependencyManagement</strong>部分添加一下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在这个应用程序目前被打破了，因为在类路径上没有JCL API实现，所以要解决它，必须提供一个新的。在下一节，我们向你展示如何使用SLF4J提供一个JCL的替代实现。</p>
<h4 id="使用SLF4J与Log4j或Logback"><a href="#使用SLF4J与Log4j或Logback" class="headerlink" title="使用SLF4J与Log4j或Logback"></a>使用SLF4J与Log4j或Logback</h4><p>Simple Logging Facade for Java (SLF4J) 是Spring常用的其他库使用的流行API。它通常和Logback一起使用，Logback是SLF4J API的本地实现。</p>
<p>SLF4J提供绑定到许多常见的日志记录框架，包括Log4j，反过来也是在其他日志框架和它自身之间桥接。所以要在Spring使用SLF4J，你需要使用SLF4J-JCL桥接来替换commos-logging依赖。一旦你这么做，那么来自Spring内的日志记录调用将会被转换为SLF4J API的日志调用，所以如果在你的应用程序中的其他库使用这个API，那么你有一个地方来配置和管理日志记录。</p>
<p>一个常见的选择可能是将Spring桥接到SLF4J，然后提供一个从SLF4J到Log4j的显示绑定。你需要提供几个依赖（并排除现有的commons-logging）：JCL桥，绑定到Log4j的SLF4j，和Log4j本身。在Maven你会这样做。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在SLF4J用户中一个更为常见的选择是，直接绑定到Logback，这使用了更少的步骤，生成更少的依赖。这样消除了额外的绑定步骤，因为Logback直接实现了SLF4J，所以你只需要依赖两个库，名字为jcl-over-slf4j和logback。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用JUL（java-util-logging）"><a href="#使用JUL（java-util-logging）" class="headerlink" title="使用JUL（java.util.logging）"></a>使用JUL（java.util.logging）</h4><p>默认情况下Commons Logging会被委托给java.util.logging,前提是在类路径中没有检测到Log4j。所以这里没有特别的依赖需要设置：只需在独立应用程序（具有JDK级别的自定义或默认JUL设置）或应用程序服务器的日志系统（以及其全系统的JUL设置）中使用不带有外部依赖关系的日志输出到java.util.logging ）。</p>
<h4 id="Commons-Logging在WebSphere上"><a href="#Commons-Logging在WebSphere上" class="headerlink" title="Commons Logging在WebSphere上"></a>Commons Logging在WebSphere上</h4><p>Spring应用程序可以在本身提供JCL实现的容器上运行，例如IBM的WebSphere Application Server（WAS）。这本身并不引起问题，但是它导致有两个不同的场景需要理解：</p>
<p>在“parent first”ClassLoader委托模型（WAS中的默认值）中，应用程序将始终拾取服务器提供的Commons Logging版本，委托给WAS记录子系统（实际上基于JUL）。JCL的应用程序提供的变体，无论是标准的Commons Logging还是JCL-over-SLF4J桥，实际都将被忽略，以及任何本地包含的日志提供程序。</p>
<p>在你的应用程序中，使用“parent last”委托模式（这是常规Servlet容器中的默认值，但在WAS上是一个需要明确配置的选项），应用程序提供的Commons Logging变体会被采用，使你能够设置本地包含的日志提供程序，例如Log4j或Logback。在没有本地日志提供程序的情况下，常规Commons Logging将默认委托给JUL，有效地记录到WebSphere的日志记录子系统，像在“parent first”场景中。</p>
<p>总而言之，我们建议将“Spring”应用程序部署在“parent last”模型中，因为它实际地允许本地提供程序以及服务器的日志子系统。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2018/05/05/Spring-Boot/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/">原文链接</a></p>
<style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}
</style>

<hr>
<h1 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h1><hr>
<p>如果你想大体入门Spring Boot或Spring，请从阅读本章节开始。它回答了一些基本的“这是什么”，“如何来用”以及为什么的问题。它包括Spring Boot的介绍以及安装说明。然后，我们将引导您构建您的第一个Spring Boot应用程序，并讨论一些核心原理。</p>
<h2 id="Spring-Boot介绍"><a href="#Spring-Boot介绍" class="headerlink" title="Spring Boot介绍"></a>Spring Boot介绍</h2><hr>
<p>Spring Boot可以轻松创建你可以运行的独立的，生产级的基于Spring的应用程序。我们有对Spring平台和第三方库有自己的看法，以便你花费尽可能少的麻烦来学习。大多数SpringBoot应用程序只需要极少的Spring配置。</p>
<span id="more"></span>
<p>您可以使用Spring Boot来创建可以使用<strong>java -jar</strong>或更传统的wai部署启动的Java应用程序。我们还提供了一个命令行工具可以运行“spring脚本”。<br>我们的主要目标是：</p>
<ul>
<li>为所有Spring开发提供一个更快，更广泛的入门体验。</li>
<li>自认为可以开箱即用，但是尽可能快的随着需求脱离默认设置开始自定义配置</li>
<li>提供一系列大型项目常见的非功能性功能（如嵌入式服务器，安全性，指标，运行状况检查和外部配置）。</li>
<li>绝对不会生成代码，并且不需要XML配置。</li>
</ul>
<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><hr>
<p>Spring Boot 2.0.1.RELEASE需要Java 8或9以及Spring Framework 5.0.5.RELEASE或更高版本。为Maven 3.2+和Gradle 4提供了明确的构建支持。</p>
<h3 id="servlet容器"><a href="#servlet容器" class="headerlink" title="servlet容器"></a>servlet容器</h3><p>Spring Boot支持以下嵌入式servlet容器：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>servlet版本</th>
</tr>
</thead>
<tbody><tr>
<td>Tomcat 8.5</td>
<td>3.1</td>
</tr>
<tr>
<td>Jetty 9.4</td>
<td>3.1</td>
</tr>
<tr>
<td>Undertow 1.4</td>
<td>3.1</td>
</tr>
<tr>
<td>您也可以将Spring Boot应用程序部署到任何与Servlet 3.1+兼容的容器。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="安装Spring-Boot"><a href="#安装Spring-Boot" class="headerlink" title="安装Spring Boot"></a>安装Spring Boot</h2><hr>
<p>Spring Boot可以与“经典”Java开发工具一起使用，也可以作为命令行工具安装。无论哪种方式，您都需要Java SDK v1.8或更高版本。在开始之前，您应该使用以下命令检查当前的Java安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure>
<p>如果您对Java开发不熟悉，或者想要试验Spring Boot，则可能需要先尝试Spring Boot CLI（命令行界面）。否则，请阅读“经典”安装说明。</p>
<h3 id="Java开发人员的安装说明"><a href="#Java开发人员的安装说明" class="headerlink" title="Java开发人员的安装说明"></a>Java开发人员的安装说明</h3><p>您可以像使用任何标准Java库一样使用Spring Boot。为此，请在类路径中包含相应的<strong>spring-boot - *.jar</strong>文件。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。此外，Spring Boot应用程序没有什么特别之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。</p>
<p>虽然您可以复制Spring Boot jar，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。</p>
<h4 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h4><p>Spring Boot与Apache Maven 3.2或更高版本兼容。如果您尚未安装Maven，则可以按照<a href="https://maven.apache.org/">maven.apache.org</a>上的说明进行操作。</p>
<blockquote>
<p>在大多操作系统上，Maven可以使用包管理器安装。如果您使用OSX Homebrew，请尝试<strong>brew install maven</strong>。 Ubuntu用户可以运行<strong>sudo apt-get install maven</strong>。具有Chocolatey的Windows用户可以从提升（管理员）提示符下运行<strong>choco install maven</strong>。</p>
</blockquote>
<p>Spring Boot依赖使用<strong>org.springframework.boot</strong>这个<strong>groupId</strong>，通常，您的Maven POM文件继承自<strong>spring-boot-starter-parent</strong>项目并将依赖关系声明为一个或多个“Starter”。Spring Boot还提供了一个可选的Maven插件来创建可执行的jar。<br>以下列表显示了一个典型的pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 继承Spring Boot的默认值 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 为Web应用程序添加典型的依赖 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 打包成可执行的jar文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Spring-Boot-starter-parent</strong>是使用Spring Boot的好方法，但它可能并不是所有的时候都合适。有时您可能需要继承另一个不同的父POM，或者您可能不喜欢我们的默认设置。在这些情况下，请参见第13.2.2节“使用没有父POM的Spring Boot”，了解使用导入范围的替代解决方案。</p>
</blockquote>
<h4 id="Gradle安装"><a href="#Gradle安装" class="headerlink" title="Gradle安装"></a>Gradle安装</h4><p>Spring Boot与Gradle 4兼容。如果您还没有安装Gradle，可以按照<a href="https://gradle.org/">gradle.org</a>上的说明进行操作。<br>Spring Boot依赖可以通过使用<strong>org.springframework.boot</strong>group来声明。通常，您的项目将依赖项声明为一个或多个“Starter”。 Spring Boot提供了一个有用的Gradle插件，可以用来简化依赖声明和创建可执行的jar。</p>
<blockquote>
<p>Gradle Wrapper<br>当您需要构建项目时，Gradle Wrapper提供了一种“获取”Gradle的好方法。它是一个小脚本和库，与代码一起提交以引导构建过程。有关详细信息，请参阅docs.gradle.org&#x2F;4.2.1&#x2F;userguide&#x2F;gradle_wrapper.html。</p>
</blockquote>
<p>以下示例显示了一个典型的<strong>build.gradle</strong>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id &#x27;org.springframework.boot&#x27; version &#x27;2.0.1.RELEASE&#x27;</span><br><span class="line">	id &#x27;java&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">	baseName = &#x27;myproject&#x27;</span><br><span class="line">	version =  &#x27;0.0.1-SNAPSHOT&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;)</span><br><span class="line">	testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装Spring-Boot-CLI"><a href="#安装Spring-Boot-CLI" class="headerlink" title="安装Spring Boot CLI"></a>安装Spring Boot CLI</h3><p>省略</p>
<h3 id="从较早版本的Spring-Boot升级"><a href="#从较早版本的Spring-Boot升级" class="headerlink" title="从较早版本的Spring Boot升级"></a>从较早版本的Spring Boot升级</h3><p>如果您是从早期版本的Spring Boot进行升级，请查看项目wiki上的“<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">迁移指南</a>”，其中提供了详细的升级说明。还要检查“<a href="https://github.com/spring-projects/spring-boot/wiki">发行说明</a>”，以获取每个发行版的“新功能”和“值得注意”功能列表。<br>要升级现有的CLI安装，请使用相应的软件包管理器命令（例如，brew升级），或者如果您手动安装了CLI，请遵循标准说明，记住更新PATH环境变量以删除所有旧的引用。</p>
<h2 id="开发你的第一个Spring-Boot应用程序"><a href="#开发你的第一个Spring-Boot应用程序" class="headerlink" title="开发你的第一个Spring Boot应用程序"></a>开发你的第一个Spring Boot应用程序</h2><hr>
<p>本节介绍如何开发一个简单的“Hello World！”Web应用程序，该应用程序重点介绍Spring Boot的一些主要功能。我们使用Maven来构建这个项目，因为大多数IDE都支持它。</p>
<blockquote>
<p><a href="https://spring.io/">spring.io</a>网站包含许多使用Spring Boot的“<a href="https://spring.io/guides">入门指南</a>”。如果您需要解决特定问题，请先在那里查看。<br>您可以通过转到<a href="https://start.spring.io/">start.spring.io</a>并从依赖关系搜索器中选择“Web”starter来缩短以下步骤。这样做会产生一个新的项目结构，以便您可以立即开始编码。查看<a href="https://github.com/spring-io/initializr">Spring Initializr文档</a>以获取更多详细信息。</p>
</blockquote>
<p>在开始之前，请打开终端并运行以下命令以确保您已安装了Java和Maven的有效版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_102&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_102-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn -v</span><br><span class="line">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00)</span><br><span class="line">Maven home: /usr/local/Cellar/maven/3.3.9/libexec</span><br><span class="line">Java version: 1.8.0_102, vendor: Oracle Corporation</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此示例需要在其自己的文件夹中创建。后续说明假定您已经创建了合适的文件夹，并且它是您当前的目录。</p>
</blockquote>
<h3 id="创建POM"><a href="#创建POM" class="headerlink" title="创建POM"></a>创建POM</h3><p>我们需要从创建一个Maven <strong>pom.xml</strong>文件开始。 <strong>pom.xml</strong>是用于构建项目的配方。打开您最喜欢的文本编辑器并添加以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 在这里添加额外的行... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前面的列表应该给你一个可运行的构建。你可以通过运行<strong>mvn package</strong>来测试它（现在，你可以忽略“jar will be empty - no content was marked for inclusion！”警告）。</p>
<blockquote>
<p>此时，您可以将项目导入IDE（大多数现代Java IDE包含对Maven的内置支持）。为了简单起见，我们在本例中继续使用纯文本编辑器。</p>
</blockquote>
<h3 id="添加类路径依赖"><a href="#添加类路径依赖" class="headerlink" title="添加类路径依赖"></a>添加类路径依赖</h3><p>Spring Boot提供了一系列“Starter”，可让您将jar添加到类路径中。我们的示例应用程序已经在POM的父节点中使用了<strong>spring-boot-starter-parent</strong>。 <strong>spring-boot-starter-parent</strong>是一个特别的starter，它提供了有用的Maven默认值。它还提供了一个 <a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#using-boot-dependency-management">dependency-management</a>部分，以便您可以在其他依赖中省略<strong>version</strong>标签。<br>其他“Starter”提供了在开发特定类型的应用程序时可能需要的依赖。<br>由于我们正在开发一个Web应用程序，因此我们添加了<strong>spring-boot-starter-web</strong>依赖项。在此之前，我们可以通过运行以下命令来查看我们目前的功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn dependency:tree</span><br><span class="line"></span><br><span class="line">[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p><strong>mvn dependency:tree</strong>命令打印项目依赖关系的树形表示。你可以看到<strong>spring-boot-starter-parent</strong>本身不提供任何依赖关系。要添加必要的依赖项，请编辑您的<strong>pom.xml</strong>并在<strong>parent <strong>下方添加</strong>spring-boot-starter-web</strong>依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果您再次运行<strong>mvn dependency:tree</strong>，则会发现现在有许多其他依赖项，包括Tomcat Web服务器和Spring Boot本身。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>为了完成我们的应用程序，我们需要创建一个Java文件。默认情况下，Maven会从<strong>src &#x2F; main &#x2F; java</strong>编译源代码，因此您需要创建该文件夹结构，然后添加名为<strong>src &#x2F; main &#x2F; java &#x2F; Example.java</strong>的文件以包含以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">	String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		SpringApplication.run(Example.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这里没有太多的代码，但后面还是有很多。我们将在接下来的几节中介绍一些重要的部分。</p>
<h4 id="RestController和-RequestMapping注解"><a href="#RestController和-RequestMapping注解" class="headerlink" title="@RestController和@RequestMapping注解"></a>@RestController和@RequestMapping注解</h4><p>我们的<strong>Example</strong>类的第一个注解是**@RestController<strong>。这被称为stereotype注解。它为阅读代码的人提供了线索，对于Spring来说，这个类扮演着特定的角色。在这种情况下，我们的类是一个web <strong>@Controller</strong>，所以Spring在处理传入的Web请求时会考虑它。<br><strong>@RequestMapping</strong>注解提供了“路由”信息。它告诉Spring，任何带有</strong>&#x2F;** 路径的HTTP请求都应该映射到<strong>home</strong>方法。 <strong>@RestController</strong>注解告诉Spring将结果字符串直接呈现给调用者。</p>
<blockquote>
<p><strong>@RestController</strong>和**@RequestMapping**注解是Spring MVC注解。 （它们并不特定于Spring Boot。）有关更多详细信息，请参阅Spring参考手册中的<a href="#">Post not found: Spring Web（一）MVC框架</a>部分。</p>
</blockquote>
<h4 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h4><p>第二个类级注解是**@EnableAutoConfiguration<strong>。这个注解告诉Spring Boot根据你添加的jar依赖来“猜测”你想要如何配置Spring。由于</strong>spring-boot-starter-web**添加了Tomcat和Spring MVC，因此自动配置假定您正在开发Web应用程序并相应地设置Spring。</p>
<blockquote>
<p>Starters与Auto-Configuration<br>Auto-Configuration旨在与“Starter”配合使用，但这两个概念并不直接相关。您可以自由选择初学者之外的jar依赖项。 Spring Boot仍然尽力自动配置您的应用程序。</p>
</blockquote>
<h4 id="“main”方法"><a href="#“main”方法" class="headerlink" title="“main”方法"></a>“main”方法</h4><p>我们应用程序的最后一部分是<strong>main</strong>方法。这只是一个遵循Java约定的应用程序入口点的标准方法。我们的<strong>main</strong>方法通过调用<strong>run</strong>来委托Spring Boot的<strong>SpringApplication</strong>类。 <strong>SpringApplication</strong>启动我们的应用程序，从Spring开始，然后启动自动配置的Tomcat Web服务器。我们需要将<strong>Example.class</strong>作为参数传递给<strong>run</strong>方法，以告知<strong>SpringApplication</strong>哪一个是Spring的主要组件。 <strong>args</strong>数组也被传递以暴露任何命令行参数。</p>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p>此时你的应用程序应该可以工作了，由于你使用<strong>spring-boot-starter-parent</strong>，你有一个可用的<strong>run</strong> goal，你可以用它来启动应用程序。从项目根目录键入<strong>mvn spring-boot：run</strong>以启动应用程序。您应该看到类似于以下内容的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn spring-boot:run</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___<span class="string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | &#x27;</span>_ | <span class="string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  <span class="string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="string"> =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="string"> :: Spring Boot ::  (v2.0.1.RELEASE)</span></span><br><span class="line"><span class="string">....... . . .</span></span><br><span class="line"><span class="string">....... . . . (log output here)</span></span><br><span class="line"><span class="string">....... . . .</span></span><br><span class="line"><span class="string">........ Started Example in 2.222 seconds (JVM running for 6.514)</span></span><br></pre></td></tr></table></figure>
<p>如果您打开一个Web浏览器到localhost：8080，您应该看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>要正常退出应用程序，请按ctrl-c。</p>
<h3 id="创建一个可执行的Jar"><a href="#创建一个可执行的Jar" class="headerlink" title="创建一个可执行的Jar"></a>创建一个可执行的Jar</h3><p>我们通过创建一个完全独立的可执行jar文件来完成我们的示例，该文件可以在生产环境中运行。可执行jar（有时称为“fat jars”）是包含您的编译类以及您的代码需要运行的所有jar依赖项的归档文件。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">
**可执行的jar和Java**</br>
Java没有提供加载嵌套jar文件的标准方式（本身包含在jar中的jar文件）。如果您想分发自包含的应用程序，这可能会有问题。</br>
为了解决这个问题，许多开发者使用“uber”jar。一个超级jar将所有应用程序依赖关系中的所有类打包到一个单独的存档中。这种方法的问题是很难看到你的应用程序中有哪些库。如果在多个jar中使用相同的文件名（但是具有不同的内容），则它也可能是有问题的。Spring Boot采用了[不同的方法](https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#executable-jar)，可以让您直接嵌入jar。
</div>

<p>要创建一个可执行的jar，我们需要将<strong>spring-boot-maven-plugin</strong>添加到我们的<strong>pom.xml</strong>中。为此，请在<strong>dependencies</strong>的下面插入以下几行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>spring-boot-starter-parent</strong> POM包含**&lt; executions&gt; **配置来绑定重新打包目标。如果您不使用父POM，则需要自行声明此配置。有关详细信息，请参阅插件文档。</p>
</blockquote>
<p>保存你的<strong>pom.xml</strong>并从命令行运行<strong>mvn package</strong>，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line"></span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building myproject 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] .... ..</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---</span><br><span class="line">[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.0.1.RELEASE:repackage (default) @ myproject ---</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>如果您查看<strong>target</strong>目录，则应该看到<strong>myproject-0.0.1-SNAPSHOT.jar</strong>。该文件的大小应该在10 MB左右。如果你想在里面偷看，你可以使用<strong>jar tvf</strong>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>您还应该在<strong>target</strong>目录中看到名为<strong>myproject-0.0.1-SNAPSHOT.jar.original</strong>的小得多的文件。这是Maven在被Spring Boot重新打包之前创建的原始jar文件。<br>要运行该应用程序，请使用<strong>java -jar</strong>命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -jar target/myproject-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___<span class="string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | &#x27;</span>_ | <span class="string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  <span class="string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="string"> =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="string"> :: Spring Boot ::  (v2.0.1.RELEASE)</span></span><br><span class="line"><span class="string">....... . . .</span></span><br><span class="line"><span class="string">....... . . . (log output here)</span></span><br><span class="line"><span class="string">....... . . .</span></span><br><span class="line"><span class="string">........ Started Example in 2.536 seconds (JVM running for 2.864)</span></span><br></pre></td></tr></table></figure>
<p>和以前一样，要退出应用程序，请按ctrl-c。</p>
<h2 id="接下来要阅读的内容"><a href="#接下来要阅读的内容" class="headerlink" title="接下来要阅读的内容"></a>接下来要阅读的内容</h2><hr>
<p>希望本节提供了一些Spring Boot的基础知识，并帮助您编写自己的应用程序。如果您是面向任务的开发人员，则可能需要跳至spring.io，查看一些入门指南，以解决具体的“我该如何使用Spring？”问题。我们也有Spring Boot专用的“How-to”参考文档。<br>Spring Boot存储库还有一堆你可以运行的样本。样本与代码的其余部分无关（也就是说，您不需要构建其余代码以运行或使用样本）。<br>否则，下一个逻辑步骤是阅读第三部分“使用Spring Boot”。如果你真的不耐烦，你也可以直接跳过去阅读Spring Boot的功能。</p>
<hr>
<h1 id="使用Spring-Boot"><a href="#使用Spring-Boot" class="headerlink" title="使用Spring Boot"></a>使用Spring Boot</h1><hr>
<p>强烈建议您选择一个支持依赖关系管理的构建系统，并且可以使用发布到“Maven Central”存储库的artifacts 。我们建议您选择Maven或Gradle。 Spring Boot可以与其他构建系统（例如Ant）一起工作，但它们并没有得到特别好的支持。</p>
<h2 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h2><hr>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="继承Starter父项"><a href="#继承Starter父项" class="headerlink" title="继承Starter父项"></a>继承Starter父项</h4><h4 id="使用没有父POM的Spring-Boot"><a href="#使用没有父POM的Spring-Boot" class="headerlink" title="使用没有父POM的Spring Boot"></a>使用没有父POM的Spring Boot</h4><h4 id="使用Spring-Boot-Maven插件"><a href="#使用Spring-Boot-Maven插件" class="headerlink" title="使用Spring Boot Maven插件"></a>使用Spring Boot Maven插件</h4><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><h3 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h3><h3 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h3><p>Starters是一套方便的依赖描述符，你可以将其包含在应用程序中。您可以获得所需的所有Spring及相关技术的一站式商店，而无需查看示例代码并复制粘贴依赖描述符。例如，如果您想开始使用Spring和JPA进行数据库访问，请在项目中包含<strong>spring-boot-starter-data-jpa</strong>依赖项。<br>Starters包含很多依赖项，您需要快速启动并快速运行项目，并且需要一组支持的可传递依赖关系。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**名称是怎么的**</br>所有官方的starters都遵循一个相似的明明模式**spring-boot-starter-\***,其中\*是特定类型的应用程序。许多IDE中的Maven集成允许您按名称搜索依赖项。例如，通过安装适当的Eclipse或STS插件，您可以在POM编辑器中按**ctrl-space**并键入“spring-boot-starter”获取完整列表。</br>
正如“[创建自己的启动器](https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#boot-features-custom-starter)”部分所述，第三方启动器不应该从**spring-boot**开始，因为它是为官方Spring Boot工件保留的。相反，第三方starter通常以项目名称开头。例如，名为**thirdpartyproject**的第三方启动器项目通常会被命名为**thirdpartyproject-spring-boot-starter**。
</div>

<p>以下starter应用程序由Spring Boot在org.springframework.boot组下提供：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>Pom</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-boot-starter</strong></td>
<td>核心入门者，包括自动配置支持，日志记录和YAML</td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-activemq</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-amqp</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-aop</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-artemis</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-batch</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-cache</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-cloud-connectors</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-cassandra</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-cassandra-reactive</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-couchbase</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-couchbase-reactive</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-elasticsearch</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-jpa</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-ldap</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-mongodb</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-mongodb-reactive</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-neo4j</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-redis</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-redis-reactive</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-rest</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-data-solr</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-freemarker</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-groovy-templates</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-hateoas</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-integration</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jdbc</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jersey</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jooq</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-json</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jta-atomikos</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jta-bitronix</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-jta-narayana</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-mail</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-mustache</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-quartz</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-security</strong></td>
<td>使用Spring Security的starter</td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-test</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-thymeleaf</strong></td>
<td>使用Thymeleaf视图构建MVC Web应用程序的starter</td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-validation</strong></td>
<td>通过Hibernate Validator使用Java Bean验证的starter</td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-web</strong></td>
<td>使用Spring MVC构建Web的starter，包括RESTful应用程序。使用Tomcat作为默认的嵌入容器</td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-web-services</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-webflux</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spring-boot-starter-websocket</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>除应用程序starter外，还可以使用以下starter来添加生产准备功能：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>Pom</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-boot-starter-actuator</strong></td>
<td>Starter使用Spring Boot的执行器提供生产就绪功能，可帮助您监控和管理您的应用程序</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml">pom</a></td>
</tr>
</tbody></table>
<p>最后，Spring Boot还包含以下启动器，如果您想要排除或交换特定技术方面，可以使用以下starter：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>Pom</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-boot-starter-jetty</strong></td>
<td>将Jetty用作嵌入式servlet容器的starter。spring-boot-starter-tomcat的替代方案</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml">pom</a></td>
</tr>
<tr>
<td><strong>spring-boot-starter-log4j2</strong></td>
<td>使用Log4j2用于日志的starter。spring-boot-starter-logging的替代方案</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml">pom</a></td>
</tr>
<tr>
<td><strong>spring-boot-starter-logging</strong></td>
<td>使用Logback进行日志记录的stareter。默认的日志starter</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml">pom</a></td>
</tr>
<tr>
<td><strong>spring-boot-starter-reactor-netty</strong></td>
<td>使用Reactor Netty作为嵌入式反应式HTTP服务器的starter。</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml">pom</a></td>
</tr>
<tr>
<td><strong>spring-boot-starter-tomcat</strong></td>
<td>使用Tomcat作为嵌入式servlet容器的starter。被spring-boot-starter-web所使用的默认servlet容器</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml">pom</a></td>
</tr>
<tr>
<td><strong>spring-boot-starter-undertow</strong></td>
<td>将Undertow 用作嵌入式servlet容器的starter。spring-boot-starter-tomcat的替代方案</td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.0.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml">pom</a></td>
</tr>
</tbody></table>
<blockquote>
<p>有关其他社区贡献者的列表，请参阅GitHub上的spring-boot-starters模块中的README文件。</p>
</blockquote>
<h2 id="组织你的代码"><a href="#组织你的代码" class="headerlink" title="组织你的代码"></a>组织你的代码</h2><hr>
<p>Spring Boot不需要任何特定的代码布局来工作。但是，有一些最佳实践可以提供帮助。</p>
<h3 id="使用“默认”包"><a href="#使用“默认”包" class="headerlink" title="使用“默认”包"></a>使用“默认”包</h3><p>当一个类不包含一个包声明时，它被认为是在“默认包”中。通常不鼓励使用“默认包”，并且应该避免使用。对于使用**@ComponentScan<strong>，</strong>@EntityScan<strong>或</strong>@SpringBootApplication**注解的Spring Boot应用程序，它可能会导致特定问题，因为每个jar中的每个类都被读取。</p>
<blockquote>
<p>我们建议您遵循Java推荐的软件包命名约定并使用反向域名（例如，com.example.project）。</p>
</blockquote>
<h3 id="定位主程序类"><a href="#定位主程序类" class="headerlink" title="定位主程序类"></a>定位主程序类</h3><p>我们通常建议您将主应用程序类定位在其他类上方的根包中。 <strong>@SpringBootApplication</strong>注解通常放在您的主类上，它隐式地为特定项目定义了一个基本的“搜索包”。例如，如果您正在编写JPA应用程序，则使用**@SpringBootApplication<strong>注解类的所在的包被用来搜索</strong>@Entity**项目。使用根包也允许组件扫描仅适用于您的项目。</p>
<blockquote>
<p>如果您不想使用**@SpringBootApplication<strong>，则它导入的</strong>@EnableAutoConfiguration**和@<strong>ComponentScan</strong>注解将定义该行为，以便您也可以使用该注解。</p>
</blockquote>
<p>下面的清单显示了一个典型的布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- Application.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>
<p><strong>Application.java</strong>文件将声明主方法以及基本的**@SpringBootApplication**，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><hr>
<p>Spring Boot支持基于Java的配置。虽然可以将<strong>SpringApplication</strong>与XML源一起使用，但我们通常建议您的主源是一个**@Configuration<strong>类。通常，定义main方法的类作为主要</strong>@Configuration**是一个很好的候选者。</p>
<blockquote>
<p>许多使用XML配置的Spring配置示例已经被发布在互联网上。如果可能的话，请始终使用相等的基于Java的配置。搜索**Enable***注解可能是一个很好的起点。</p>
</blockquote>
<h3 id="导入其他配置类"><a href="#导入其他配置类" class="headerlink" title="导入其他配置类"></a>导入其他配置类</h3><p>你不需要把你所有的**@Configuration<strong>放到一个类中。 <strong>@Import</strong>注解可用于导入其他配置类。或者，您可以使用</strong>@ComponentScan<strong>自动获取所有Spring组件，包括</strong>@Configuration**类。</p>
<h3 id="导入XML配置"><a href="#导入XML配置" class="headerlink" title="导入XML配置"></a>导入XML配置</h3><p>如果您绝对必须使用基于XML的配置，我们建议您仍以**@Configuration<strong>类开始。然后您可以使用</strong>@ImportResource**注解来加载XML配置文件。</p>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>Spring Boot自动配置会尝试根据您添加的jar依赖自动配置您的Spring应用程序。例如，如果<strong>HSQLDB</strong>在您的类路径中，并且您尚未手动配置任何数据库连接Bean，则Spring Boot会自动配置一个内存数据库。</p>
<blockquote>
<p>您应该只添加一个**@SpringBootApplication<strong>或</strong>@EnableAutoConfiguration<strong>注解。我们通常建议您将一个或另一个添加到您的主要</strong>@Configuration**类中。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>《Maven官方文档》（三）POM介绍</title>
    <url>/2017/07/04/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89POM%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html">原文链接</a>    </p>
<h1 id="POM是什么"><a href="#POM是什么" class="headerlink" title="POM是什么"></a>POM是什么</h1><p>一个项目对象模型或者POM是Maven的基本工作单元。它是一个XML文件，其中包含有关Maven用于构建项目的所有项目和配置详细信息。它包含了大多数项目的默认值。比如target是构建的目录；src&#x2F;main&#x2F;java是源代码目录；src&#x2F;test&#x2F;java是测试源代码目录。等等。<br>POM从Maven 1中的project.xml重命名为Maven 2中的pom.xml。相比于有一个mave.xml文件包含可以执行的目标，现在目标或插件都配置在pom.xml中。当执行一个任务或目标，Maven查找当前目录的POM。它读取POM，获得需要的配置信息，然后执行目标。 </p>
<p>一些可以指定在POM中的配置是项目的依赖，可以执行的插件或目标，构建配置文件，等等。其他信息，比如项目版本，描述，开发者，邮件列表等等同样可以指定。</p>
<span id="more"></span>
<h2 id="超级POM"><a href="#超级POM" class="headerlink" title="超级POM"></a>超级POM</h2><p>超级POM是Maven的默认POM。除非明确设置，所有的POM扩展自超级POM，这意味着指定在超级POM中的配置由你为项目创建的POM继承。下面的代码片段是Maven 2.0.x的超级POM。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Default Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;artifactId&#125;-$&#123;version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>release-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">updateReleaseInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">updateReleaseInfo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面的代码片段是Maven 2.1.x的超级POM。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Default Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> MNG-3731 maven-plugin-tools-api &lt; 2.4.4 expect this to be relative... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>       </span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2-beta-2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>         </span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-ear-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-ejb-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-rar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        </span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                </span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0-beta-8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                </span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0-beta-7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>         </span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1-alpha-2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>release-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">updateReleaseInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">updateReleaseInfo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="最小POM"><a href="#最小POM" class="headerlink" title="最小POM"></a>最小POM</h1><p>POM的最低要求如下：</p>
<ul>
<li>project根元素</li>
<li>modelVersion - 应该被设置为4.0.0</li>
<li>groupId - 项目组织的id</li>
<li>artifactId - 工件（项目）的id</li>
<li>version - 指定组下的工件的版本</li>
</ul>
<p>这有一个示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>POM需要配置其groupId，artifactId和version 。这三个值形成项目的完全合格的artifact名称。该名称是以 &lt;groupId&gt;:&lt;artifactId&gt;:&lt;version&gt;的形式.对于上面的例子，其完全限定的工件名称是“com.mycompany.app:my-app:1”。</p>
<p>另外，如第一节所述，如果未指定配置详细信息，Maven将使用其默认值。这些默认值之一是打包类型。每个Maven项目都有一个packaging 类型。如果在POM中没有指定，那么将使用默认值“jar”。<br>此外，您可以看到，在最小的POM中，没有指定repositories 。如果您使用最小的POM构建项目，它将继承超级POM中的repositories配置。<br>因此，当Maven看到最小POM中的依赖时，它会知道这些依赖将从超级POM中指定的<a href="http://repo.maven.apache.org/maven2%E4%B8%8B%E8%BD%BD%E3%80%82">http://repo.maven.apache.org/maven2下载。</a></p>
<h1 id="项目继承"><a href="#项目继承" class="headerlink" title="项目继承"></a>项目继承</h1><p>POM中的元素按以下合并</p>
<ul>
<li>dependencies</li>
<li>developers and contributors</li>
<li>plugin lists (including reports)</li>
<li>plugin executions with matching ids</li>
<li>plugin configuration</li>
<li>resources</li>
</ul>
<p>超级POM是项目继承的一个例子，但是，您还可以通过指定POM中的父元素来引入您自己的父POM，如以下示例所示。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p><strong>情景</strong><br>例如，让我们重新使用我们以前的工件com.mycompany.app:my-app:1。让我们再来介绍一个另外的工件，com.mycompany.app:my-module:1：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们指定它们的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"> |-- my-module</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- pom.xml</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong>:my-module&#x2F;pom.xml是 com.mycompany.app:my-module:1的POM，而pom.xml是of com.mycompany.app:my-app:1的POM。</p>
<p><strong>解决方案</strong><br>现在，如果我们将com.mycompany.app:my-app:1转换成com.mycompany.app:my-module:1的父工件，我们需要按以下配置来修改com.mycompany.app:my-module:1的POM：</p>
<p><strong>com.mycompany.app:my-module:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 注意现在我们添加的部分-&lt;parent&gt;元素。这部分允许我们指定哪些工件是我们的POM的父级。我们通过指定父POM的完全限定的工件名称来实现。通过此设置，我们的模块现在可以继承我们的父POM的一些属性。<br>另外，如果我们希望你的模块的goupId和&#x2F;或version与它的父级的一样，你可以在其POM中删除该组件的groupId和&#x2F;或version。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这允许模块继承它的父POM的groupId和version。</p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p><strong>情景</strong><br>但是，如果父项目已经安装在本地仓库中，或者是在特定的目录结构（父pom.xml是一个比模块的pom.xml更高的目录）中，示例1会起作用。</p>
<p>但是如果父级没有安装并且目录结构如下会如何呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- my-module</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">`-- parent</span><br><span class="line">    `-- pom.xml</span><br></pre></td></tr></table></figure>
<p><strong>解决方案</strong><br>要解决这个目录结构（或任何其他目录结构），我们必须将&lt;relativePath&gt;元素添加到我们的父部分。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>顾名思义，它是从模块的pom.xml到父的pom.xml的相对路径。</p>
<h1 id="项目聚合"><a href="#项目聚合" class="headerlink" title="项目聚合"></a>项目聚合</h1><p>项目聚合与项目继承类似。但是相比于从模块中指定父POM，它从父POM中指定模块。通过这样做，父项目现在知道其模块，并且如果针对父项目调用Maven命令，那么该Maven命令也将被执行到父项目的模块。要进行项目聚合，您必须执行以下操作：</p>
<ul>
<li>将父POM的packaging更改为值“pom”。</li>
<li>在父POM中指定其模块的目录（子级POM）</li>
</ul>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p><strong>情景</strong><br>给定以前的原始工件POM和目录结构，<br><strong>com.mycompany.app:my-app:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>com.mycompany.app:my-module:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>目录结构</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"> |-- my-module</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- pom.xml</span><br></pre></td></tr></table></figure>
<p><strong>解决方案</strong><br>如果我们将my-module聚合到my-app中，我们只需要修改 my-app。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在修订的com.mycompany.app:my-app:1中，添加了packaging部分和modules部分。对于packaging，其值设置为“pom”，对于modules部分，我们有元素&lt;module&gt;my-module&lt;&#x2F;module&gt;。&lt;module&gt;的值是从com.mycompany.app:my-app:1到com.mycompany.app:my-module:1的POM的相对路径(通过实践，我们使用模块的artifactId作为模块目录的名称)。</p>
<p>现在，每当Maven命令处理com.mycompany.app:my-app:1时，同样的Maven命令也将针对com.mycompany.app:my-module:1运行。此外，一些命令（具体目标）不同地处理项目聚合。</p>
<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><p><strong>情景</strong><br>但是如果将目录结构更改为以下内容呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"> |-- my-module</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- parent</span><br><span class="line">     `-- pom.xml</span><br></pre></td></tr></table></figure>
<p>父pom如何指定其模块？</p>
<p><strong>解决方案</strong><br>答案？ - 与示例3相同的方式，通过指定模块的路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="项目继承vs项目聚合"><a href="#项目继承vs项目聚合" class="headerlink" title="项目继承vs项目聚合"></a>项目继承vs项目聚合</h1><p>如果您有多个Maven项目，并且它们都具有相似的配置，那么可以通过抽取这些类似配置并建立一个父项目来重构项目。因此，您所要做的就是让Maven项目继承父项目，然后将这些配置会应用于所有这些项目。<br>如果您有一组项目一起构建或处理，您可以创建一个父项目，并让该父项目将这些项目声明为其模块。通过这样做，您只需要构建父级，其余的将遵循。<br>但是当然，您可以同时拥有项目继承和项目聚合。意思是，您可以让模块指定一个父项目，同时让该父项目指定这些Maven项目作为其模块。你只需要应用三个规则：</p>
<ul>
<li>指定每一个子POM谁是它们的父POM</li>
<li>修改父POM的packaging为“pom”</li>
<li>在父POM中指定其模块（子级POM）的目录</li>
</ul>
<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><p>再次给定之前的原始工件POM</p>
<p><strong>com.mycompany.app:my-app:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>com.mycompany.app:my-module:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以及目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"> |-- my-module</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- parent</span><br><span class="line">     `-- pom.xml</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong><br>要进行项目继承和聚合，您只需应用所有三个规则。</p>
<p><strong>com.mycompany.app:my-app:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>com.mycompany.app:my-module:1的POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：配置文件继承与POM本身使用的相同的继承策略。</p>
<h1 id="项目插值和变量"><a href="#项目插值和变量" class="headerlink" title="项目插值和变量"></a>项目插值和变量</h1><p>Maven鼓励的做法之一是不要重复。但是，在某些情况下，您需要在几个不同的位置使用相同的值。为了帮助确保该值只被指定一次，Maven允许您在POM中使用自己的和预定义的变量。<br>例如，要访问project.version变量，您可以这样引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，这个变量在继承之后才能如上进行处理。这意味着如果一个父项目使用一个变量，然后它定义在子级中，而不是父级，这完全可以使用。</p>
<h2 id="可用变量"><a href="#可用变量" class="headerlink" title="可用变量"></a>可用变量</h2><p><strong>项目模型变量</strong><br>模型的任何字段都是一个单值元素，可以作为一个变量引用。例如${project.groupId}，${project.version}，${project.build.sourceDirectory}等等。请参阅<a href="#">Post not found: 《Maven官方文档》（三）POM参考</a>_以查看属性的完整列表。<br>这些变量全部由前缀“project”引用。你也可能看到使用”pom.”作为前缀引用，或者前缀全部省略-这些形式现在被弃用，并且也不应该再被使用。</p>
<p><strong>特殊变量</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>project.basedir</td>
<td>当前项目所在的目录。</td>
</tr>
<tr>
<td>project.baseUri</td>
<td>当前项目所在的目录，表示为URI。自从Maven 2.1.0</td>
</tr>
<tr>
<td>maven.build.timestamp</td>
<td>表示构建开始的时间戳。自从Maven 2.1.0-M1</td>
</tr>
</tbody></table>
<p>可以通过声明属性maven.build.timestamp.format来定制构建时间戳的格式，如下面的示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.build.timestamp.format</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&#x27;Z&#x27;<span class="tag">&lt;/<span class="name">maven.build.timestamp.format</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>格式模式必须符合SimpleDateFormat API文档中给出的规则。如果属性不存在，则默认格式为示例中给出的值。</p>
<p><strong>属性</strong><br>您还可以将项目中定义的任何属性引用为变量。请考虑以下示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mavenVersion</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">mavenVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mavenVersion&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mavenVersion&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《Maven官方文档》（三）构建配置介绍</title>
    <url>/2017/07/07/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Apache Maven 2.0非常重视确保构建的可移植性。除了其他事项之外，这意味着允许在POM内构建配置，避免所有文件系统引用（在继承，依赖和其他地方），并且更倾向于本地仓库来存储使其成为可能的元数据。</p>
<p>然而，有时可移植性不是能完全做到。在某些情况下，插件可能需要配置本地文件系统路径。在其他情况下，需要稍微不同的依赖设置，并且项目的artifact名称可能需要稍微调整。而在其他时间，您甚至可能需要根据检测到的构建环境在构建生命周期中包含整个插件。</p>
<p>为了解决这些情况，Maven 2.0引入了构建配置文件的概念。配置文件使用POM本身可用的元素的子集指定（添加一个额外的部分），并以各种方式触发。它们在构建时期修改POM，并且意在在补充的设置中使用，为一系列目标环境提供等效但是不同的参数（提供例如开发，测试和生产环境中的应用程序服务器根目录的路径）。因此，配置文件很容易因为团队不同成员导致不同的构建结果。但是，正确使用，保持项目可移植性的同事配置文件也可以使用。这也将最小化使用maven的-f选项，该选项允许用户创建具有不同参数或配置的POM。这样使项目更易于维护，因为它仅与一个POM一起运行。</p>
<span id="more"></span>
<h1 id="不同类型的配置是什么-每个都定义在哪里？"><a href="#不同类型的配置是什么-每个都定义在哪里？" class="headerlink" title="不同类型的配置是什么?每个都定义在哪里？"></a>不同类型的配置是什么?每个都定义在哪里？</h1><ul>
<li>每个项目<br>  –定义在POM本身（pom.xml）中。</li>
<li>每个用户<br> –定义在Maven设置(%USER_HOME%&#x2F;.m2&#x2F;settings.xml)中</li>
<li>全局<br> –定义在Maven全局设置（${maven.home}&#x2F;conf&#x2F;settings.xml）中。</li>
<li>配置描述<br> –描述位于project basedir（profiles.xml）中（Maven 3.0中不受支持，请参阅Maven 3兼容性注释）</li>
</ul>
<h1 id="配置如何被触发？如何根据使用配置类型而变化？"><a href="#配置如何被触发？如何根据使用配置类型而变化？" class="headerlink" title="配置如何被触发？如何根据使用配置类型而变化？"></a>配置如何被触发？如何根据使用配置类型而变化？</h1><p>可以通过以下几种方式触发&#x2F;激活配置文件：</p>
<ul>
<li>明确指定</li>
<li>通过Maven设置文件</li>
<li>基于环境变量</li>
<li>OS设置</li>
<li>文件的存在或缺失</li>
</ul>
<h2 id="配置激活细节"><a href="#配置激活细节" class="headerlink" title="配置激活细节"></a>配置激活细节</h2><p>可以使用-P 命令行界面选项显式指定配置文件。</p>
<p>此选项采用一个参数，该参数是以逗号分隔的profile-id列表。除了通过激活配置被激活或者砸setting.xml中&lt;activeProfiles&gt;元素下的配置外，在指定这个选项时，选项参数中指定的配置也会被激活。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn groupId:artifactId:goal -P profile-1,profile-2</span><br></pre></td></tr></table></figure>
<p>可以通过&lt;activeProfiles&gt;部分，在Maven设置中激活配置文件。这部分是一个&lt;activeProfile&gt;元素的列表，每个元素都包含一个profile-id。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>profile-1<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，每次一个项目使用它，列出在&lt;activeProfiles&gt;标签中的配置文件将被激活。</p>
<p>配置会根据检测到的配置环境状态被自动触发。这些触发条件通过配置文件本身的&lt;activation&gt;部分指定。目前，此检测限于JDK版本的前缀匹配，系统属性的存在或系统属性的值。这里有些例子。</p>
<p>当JDK的版本以“1.4”开头（例如“1.4.0_08”，“1.4.2_07”，“1.4”）时，以下配置将触发配置文件）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种范围指定也可以用于Maven 2.1（有关详细信息，请参阅<a href="http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html"> Enforcer Version Range Syntax</a>）。以下指定1.3,1.4和1.5版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>[1.3,1.6)<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：1.5]的上限很可能不包括1.5的大多数版本，因为它们将有一个额外的“补丁”版本，如_05，在上述范围内不被考虑。</p>
<p>下一个将根据操作系统设置激活。有关操作系统值的更多详细信息，请参阅<a href="http://maven.apache.org/enforcer/enforcer-rules/requireOS.html">Maven Enforcer Plugin</a>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当系统属性“debug”被指定任何值的时候，下面的配置文件将被激活：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当系统属性“debug”根本没有定义时，将激活以下配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>!debug<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当系统属性“debug”未定义或者使用不为“true”的值定义时，将激活以下配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>!true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要激活这个配置，您可以在命令行中键入其中之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn groupId:artifactId:goal</span><br><span class="line">mvn groupId:artifactId:goal -Ddebug=false</span><br></pre></td></tr></table></figure>
<p>当使用值“test”指定系统属性“environment”时，下一个示例将触发配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>environment<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要激活这个配置，您可以在命令行中键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn groupId:artifactId:goal -Denvironment=test</span><br></pre></td></tr></table></figure>
<p>从Maven 3.0开始，POM中的配置文件也可以根据settings.xml中活动配置文件的属性激活。</p>
<p>注意：像FOO这样的环境变量可用作env.FOO格式的属性。还要注意，环境变量名称在Windows上被归一化为所有大写。</p>
<p>此示例当生成的文件target&#x2F;generated-sources&#x2F;axistools&#x2F;wsdl2java&#x2F;org&#x2F;apache&#x2F;maven缺失时，将触发该配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">missing</span>&gt;</span>target/generated-sources/axistools/wsdl2java/org/apache/maven<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从Maven 2.0.9开始，可以标签&lt;exists&gt;和&lt;missing&gt;可以被插入值。支持的变量是系统属性，如${user.home}和环境变量，如${env.HOME}。请注意，POM本身定义的属性和值不可用于插值，例如，上述示例中激活器不能使用${project.build.directory}，需要对target路径进行硬编码。</p>
<p>使用如下配置，profile也可以默认激活。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个配置对于所有的构建默认激活，除非在相同POM中其他的配置使用了之前描述的方法被激活。当POM中的配置在命令行上或通过其激活配置被激活时，所有被社设置默认激活的配置将自动失效。</p>
<h2 id="停用一个配置"><a href="#停用一个配置" class="headerlink" title="停用一个配置"></a>停用一个配置</h2><p>从Maven 2.0.10开始，一个或多个配置可以使用命令行，通过将它们的识别码加上前缀符号’!’或’-‘来停用，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn groupId:artifactId:goal -P !profile-1,!profile-2</span><br></pre></td></tr></table></figure>
<p>这可以用于停用标记为activeByDefault的配置，或通过其激活配置激活的配置。</p>
<h1 id="每种类型的配置可以自定义POM的哪些区域？为什么？"><a href="#每种类型的配置可以自定义POM的哪些区域？为什么？" class="headerlink" title="每种类型的配置可以自定义POM的哪些区域？为什么？"></a>每种类型的配置可以自定义POM的哪些区域？为什么？</h1><p>现在我们已经讨论了在哪里指定配置文件，以及如何激活它们，谈论您可以在配置文件中指定哪些内容将是有意义的。与配置文件配置的其他方面一样，这个答案并不简单。</p>
<p>根据您选择配置您的配置文件的位置，您将可以访问不同的POM配置选项。</p>
<h2 id="外部文件中的Profiles"><a href="#外部文件中的Profiles" class="headerlink" title="外部文件中的Profiles"></a>外部文件中的Profiles</h2><p>在外部文件中指定的配置（即在settings.xml或profiles.xml中）在最严格的意义上是不可移植的。任何似乎很有可能改变构建结果的东西都限于POM中的内联profile。像仓库列表这样的只能简单指定工件专有仓库，而不能改变构建结果。因此，您只能修改&lt;repositories&gt;和&lt;pluginRepositories&gt;部分，再加上额外的&lt;properties&gt;部分。</p>
<p>&lt;properties&gt;部分允许您指定自由格式键值对,这些属性将被包括在POM的插值过程中。这允许您以${profile.provided.path}的形式指定插件配置。</p>
<h2 id="POM中的Profiles"><a href="#POM中的Profiles" class="headerlink" title="POM中的Profiles"></a>POM中的Profiles</h2><p>另一方面，如果您的配置文件有理由在在POM内部指定，那么你会有更多选项。当然，你只能修改该项目以及它子模块。由于这些配置文件是内联指定的，因此有更好的保留可移植性的机会，所以说可以向他们添加更多信息是合理的，而不会有其他用户无法使用该信息的风险。</p>
<p>POM中指定的配置Profiles 可以修改以下POM元素：</p>
<ul>
<li>&lt;repositories&gt;</li>
<li>&lt;pluginRepositories&gt;</li>
<li>&lt;dependencies&gt;</li>
<li>&lt;plugins&gt;</li>
<li>&lt;properties&gt; (在主POM中实际上不可用，但在幕后使用)</li>
<li>&lt;modules&gt;</li>
<li>&lt;reporting&gt;</li>
<li>&lt;dependencyManagement&gt;</li>
<li>&lt;distributionManagement&gt;</li>
<li>&lt;build&gt;元素的子元集，其中包括：:<ul>
<li>&lt;defaultGoal&gt;</li>
<li>&lt;resources&gt;</li>
<li>&lt;testResources&gt;</li>
<li>&lt;finalName&gt;</li>
</ul>
</li>
</ul>
<h2 id="lt-profiles-gt-之外的POM元素"><a href="#lt-profiles-gt-之外的POM元素" class="headerlink" title="&lt;profiles&gt;之外的POM元素"></a>&lt;profiles&gt;之外的POM元素</h2><p>我们不允许修改POM-profiles之外的一些POM元素，因为当POM部署到仓库系统时，不会分发这些运行时修改，就这导致个人的项目构建与其他人完全不一致。当您可以在某种程度上选择通过外部配置文件的进行此操作，这样危险性被限制了。另一个原因是这个POM信息有时从父POM中重用。</p>
<p>外部文件（如settings.xml和profiles.xml）也不支持POM-profiles之外的元素。让我们来看这个场景来进行阐述。当有效POM部署到远程存储库时，任何人都可以从存储库中获取其信息，并使用它直接构建Maven项目。现在假设，如果我们可以在依赖中设置配置-这对构建来说非常重要，或者在settings.xml中设置的POM-profiles之外的任何其他元素中，那么我们可能不能指望别人从仓库中使用该POM，并且能够构建它。而且我们还要考虑如何与其他人共享settings.xml。注意，太多的文件需要配置是非常混乱而且难以维护的。底线是因为这是构建数据所以它应该在POM中。Maven 2中的一个目标是将运行构建所需的所有信息合并到单个文件或作为POM的文件层次结构中。</p>
<h1 id="配置陷阱"><a href="#配置陷阱" class="headerlink" title="配置陷阱"></a>配置陷阱</h1><p>我们已经提到了为您的构建添加配置有可能破坏您的项目的可移植性。我们甚至已经突出强调了可能会破坏项目可移植性的情况。然而，值得重申的是作为对使用配置文件时避免的一些陷阱进行更相关讨论的一部分。<br>使用配置的时候要注意两个主要问题。第一个是外部属性，通常用在插件配置中。这些可能会破坏您的项目的可移植性。另一个更细微的地方是是profile的实际设置的不完整的规范。</p>
<h2 id="外部属性"><a href="#外部属性" class="headerlink" title="外部属性"></a>外部属性</h2><p>外部属性定义涉及在pom.xml之外定义的任何属性值，但不在其中对应的profile中定义。POM中最明显的属性使用是插件配置。虽然没有属性肯定有可能打破项目可移植性，但这些细节可能会产生微妙的影响，导致构建失败。例如，在settings.xml中指定的profile中指定Appserver路径可能会导致集成测试插件在组中的其他用户尝试在没有相似的settings.xml的情况下构建时失败。请考虑以下web应用程序项目的pom.xml片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.myco.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spiffy-integrationTest-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">appserverHome</span>&gt;</span>$&#123;appserver.home&#125;<span class="tag">&lt;/<span class="name">appserverHome</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，在你本地$ {user.home}&#x2F;.m2&#x2F;settings.xml中，你有：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>appserverConfig<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appserver.home</span>&gt;</span>/path/to/appserver<span class="tag">&lt;/<span class="name">appserver.home</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>appserverConfig<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当您构建integration-test生命周期阶段时，您的集成测试通过，因为您提供的路径允许测试插件安装和测试此Web应用程序。</p>
<p>但是，当您的同事尝试构建到integration-test时，他的构建失败是壮观的，抱怨说它无法解析插件配置参数&lt;appserverHome&gt;,或者更糟糕的是，该参数的值 - 字面上是${appserver.home} - 是无效（如果它完全警告你）。</p>
<p>恭喜，您的项目现在不可移植。在pom.xml中加入此配置文件可以帮助缓和这种情况，因为每个项目层次结构（允许继承的效果）现在都必须指定此信息的明显缺陷。由于Maven提供对项目继承的良好支持，所以可以将这种配置放在团队级POM或类似文件中的&lt;pluginManagement&gt;部分，并且只需简单继承路径。</p>
<p>另一个不那么有吸引力的答案可能是标准化的开发环境的。然而，这将倾向于危及Maven能够提供的生产力提升。</p>
<h2 id="实际配置设置的不完整规范"><a href="#实际配置设置的不完整规范" class="headerlink" title="实际配置设置的不完整规范"></a>实际配置设置的不完整规范</h2><p>除了上述的关于破坏移植性，很难覆盖到你的配置的所有情况。当您这样做时，您通常会将您的目标环境之一置于高处，干燥。我们从上面再来一个例子pom.xml片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.myco.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spiffy-integrationTest-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">appserverHome</span>&gt;</span>$&#123;appserver.home&#125;<span class="tag">&lt;/<span class="name">appserverHome</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，考虑以下profile，它将在pom.xml中内联指定：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>appserverConfig-dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appserver.home</span>&gt;</span>/path/to/dev/appserver<span class="tag">&lt;/<span class="name">appserver.home</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>appserverConfig-dev-2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>dev-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appserver.home</span>&gt;</span>/path/to/another/dev/appserver2<span class="tag">&lt;/<span class="name">appserver.home</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ..</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该配置与上一个示例类似，具有以下几个重要不同点：它明显地面向开发环境，添加了一个名为appserverConfig-dev-2的新配置，它有一个activation部分，当系统属性对于名为appserverConfig-dev的配置包含有”env&#x3D;dev”以及对名为appserverConfig-dev-2的配置包含有 “env&#x3D;dev-2”时，将触发其包含内容。所以，执行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn -Denv=dev-2 integration-test</span><br></pre></td></tr></table></figure>
<p>结果是成功构建，应用由配置名为appserverConfig-dev-2提供的属性。当我们执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -Denv=dev integration-test</span><br></pre></td></tr></table></figure>
<p>它也会成功构建，并且应用由配置名为appserverConfig-dev提供的属性。然而，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -Denv=production integration-test</span><br></pre></td></tr></table></figure>
<p>不会成功构建。为什么？因为，生成的非内插字面值${appserver.home}将不是用于部署和测试Web应用程序的有效路径。在写配置的时候我们没有考虑生产（production）环境的情况。“production”环境（env &#x3D; production）以及“test”，甚至可能是“local”，构成了我们可能希望构建integration-test生命周期阶段的一套实际的目标环境。这个实际设置的不完整规范意味着我们将有效的目标环境限制在开发环境中。你的队友 - 也许你的经理 - 不会想看到这个幽默。当您构建配置文件以处理这些情况时，请务必解决整组目标排列。</p>
<p>简而言之，用户特定的配置文件可能以类似的方式运行。这意味着，当团队添加新的开发人员时，用于处理与用户密切关联的不同环境的配置可以起作用。虽然我认为这可以作为新手的有用的训练，但是以这种方式把他们扔向狼群并不好玩，一定要确保考虑到一整套的配置。</p>
<h1 id="在构建过程中如何知道哪个配置有效？"><a href="#在构建过程中如何知道哪个配置有效？" class="headerlink" title="在构建过程中如何知道哪个配置有效？"></a>在构建过程中如何知道哪个配置有效？</h1><p>确定活动配置将有助于用户知道构建过程中执行的特定配置。我们可以使用Maven Help Plugin来了解在构建期间什么配置有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:active-profiles</span><br></pre></td></tr></table></figure>
<p>让我们看一些小示例，这会帮助我们更多的理解这个插件的active-profiles目标。</p>
<p>从上一个在pom.xml中的配置示例，您会注意到有两个配置名为appserverConfig-dev和appserverConfig-dev-2，它们已被赋予不同的属性值。如果我们继续执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:active-profiles -Denv=dev</span><br></pre></td></tr></table></figure>
<p>结果将是具有“env &#x3D; dev”的激活属性以及声明它的资源的配置的ID的项目符号列表。参见下面的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following profiles are active:</span><br><span class="line"> </span><br><span class="line"> - appserverConfig-dev (source: pom)</span><br></pre></td></tr></table></figure>
<p>现在，如果我们在settings.xml中声明了一个配置（请参阅settings.xml中的配置文件示例），并将其设置为活动配置并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:active-profiles</span><br></pre></td></tr></table></figure>
<p>The result should be something like this<br>中文(简体)<br>结果应该是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following profiles are active:</span><br><span class="line"> </span><br><span class="line"> - appserverConfig (source: settings.xml)</span><br></pre></td></tr></table></figure>
<p>即使我们没有一个激活属性，这个配置也被列为是激活的。为什么？像我们之前提到的一样，在settings.xml中设置为active profile的配置将自动激活。</p>
<p>现在，如果我们有一个配置在setting.xml中被设置为active profile，同时也在POM中触发一个配置。你认为哪个配置会对构建产生影响？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:active-profiles -P appserverConfig-dev</span><br></pre></td></tr></table></figure>
<p> 这回列出激活配置列表<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following profiles are active:</span><br><span class="line"></span><br><span class="line">- appserverConfig-dev (source: pom)</span><br><span class="line">- appserverConfig (source: settings.xml)</span><br></pre></td></tr></table></figure><br>即使列出了两个活动的配置，但我们依然不确定其中哪一个已被应用。通过要看到对构建的影响，来执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:effective-pom -P appserverConfig-dev</span><br></pre></td></tr></table></figure>
<p>这将打印出该构建配置的有效POM到控制台。请注意，settings.xml中的配置比POM中的配置具有更高的优先级。以这里应用的配置是appserverConfig而不是appserverConfig-dev。</p>
<p>如果要将插件的输出重定向到名为effective-pom.xml的文件，请使用命令行选项-Doutput &#x3D; effective-pom.xml。</p>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><p>到目前为止，您已经注意到，配置是解决不同目标环境的不同构建配置要求问题的自然方式。以上，我们讨论了一个“实际设置”的概念来解决这种情况，以及考虑需要的整套配置文件的重要性。</p>
<p>然而，如何组织和管理这些设置的演化的问题也是不平凡的。正如一位好的开发人员努力编写个自记录代码一样，你的配置ID对您的预期用途至关重要。一个很好的方法是使用通用系统属性触发器作为配置的名称的一部分。这可能会导致env-dev，env-test和env-prod等名称被系统属性env触发的配置。这样的系统对如何激活针对特定环境的构建体提供了非常直观的提示。因此，要激活测试环境的构建，您需要通过以下方式激活env-test：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -Denv=test &lt;phase&gt;</span><br></pre></td></tr></table></figure>
<p>在配置id中，只需用“&#x3D;”替换“ - ”即可使用正确的命令行选项。</p>
]]></content>
      <categories>
        <category>Maven</category>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>《Maven官方文档》（十）设置参考</title>
    <url>/2017/07/03/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E5%8D%81%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p><a href="http://maven.apache.org/settings.html">原文链接</a>    </p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="快速概览"><a href="#快速概览" class="headerlink" title="快速概览"></a>快速概览</h2><p>setting.xml文件中的setting元素包含了用于定义以各种方式配置Maven执行的值的元素，比如pom.xml，但是不应该捆绑到任何具体的项目或分发给用户。它包含一些值，比如本地仓库的位置，可选的远程仓库服务器，以及验证信息。<br>setting.xml文件可能存在于两个位置：</p>
<ol>
<li>Maven安装目录下：$ {maven.home} &#x2F;conf&#x2F;settings.xml</li>
<li>用户安装目录： ${user.home}&#x2F;.m2&#x2F;settings.xml<span id="more"></span>
前一个setting.xml同时也被称为全局设置，后一个settin.xml被称为用户设置。如果两个文件都存在，会以用户指定的setting.xml为主，将两者的内容合并。<br>提示：如果你需要从头开始创建用户指定设置，从你的Maven安装中复制全局设置到你的${user.home}&#x2F;.m2目录是最简单的。Maven的默认setting.xml也是一个包含了注释和示例模板，使你可以快速调整以满足你的需求。<br>下面是setting下顶级元素的概览：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                         https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
setting.xml的内容可以使用以下表达式进行插入值：</li>
<li>${user.home}和其他的系统属性（自从Maven 3.0）</li>
<li>${env.HOME}等环境变量</li>
</ol>
<p>注意，setting.xml中定义在profiles中的属性不可以用来当作插值。</p>
<h1 id="设置详细信息"><a href="#设置详细信息" class="headerlink" title="设置详细信息"></a>设置详细信息</h1><h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>一般的顶级setting元素都是一些简单的值，表示一系列用来描述构建系统全时间活跃的元素的值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>$&#123;user.home&#125;/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">interactiveMode</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>&gt;</span>false<span class="tag">&lt;/<span class="name">usePluginRegistry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>&gt;</span>false<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>localRepository</strong>：这个值是构建系统本地仓库的路径。它的默认值是${user.home}&#x2F;.m2&#x2F;repository。该元素对主构建服务器允许所有登录用户从公共本地仓库构建非常有用。</li>
<li><strong>interactiveMode</strong>：如果Maven应尝试与用户输入进行交互，则为true。否则为false。默认是true。</li>
<li><strong>userPluginRegistry</strong>：如果Maven使用${user.home}&#x2F;.m2&#x2F;plugin-registry.xml文件来管理插件版本，则为true。默认为false。注意当前的Maven 2.0版本，不应该依赖于plugin-registry.xml文件。目前认为它无效。</li>
<li><strong>offline</strong>：如果此构建系统应在离线模式下运行，则为true，默认为false。这个元素对于由于网络设置或者安全原因无法连接到远程仓库的构建服务器很有用。</li>
</ul>
<h2 id="插件组"><a href="#插件组" class="headerlink" title="插件组"></a>插件组</h2><p>该元素包含一个pluginGroup元素的列表，其中每一个都包含一个groupId。当一个插件被使用并且groupId没有在命令行上提供时，会在这个列表中搜索。这个列表自动包含org.apache.maven.plugins和org.codehaus.mojo。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>比如，给定的上述设置，Maven命令行可能使用缩短的命令来执行org.mortbay.jetty:jetty-maven-plugin:run</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn jetty：run</span><br></pre></td></tr></table></figure>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>用于下载和部署的仓库由POM的repositories和distributionManagement元素定义。但是，某些设置（如username和password）不应与pom.xml一起分发。这种类型的信息应该存在于的构建服务器的settings.xml中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>server001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_login<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>$&#123;user.home&#125;/.ssh/id_dsa<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>some_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>id</strong> 这是服务器的ID（不是用户用来登录的），它与Maven尝试连接的仓库&#x2F;镜像的id元素相匹配。</li>
<li><strong>username, password</strong>：这些元素成对出现，它表示向该服务器进行验证所需的登录名和密码。</li>
<li><strong>privateKey, passphrase</strong>：像前面的两个元素，这对元素指定一个私钥的路径（默认是${user.home}&#x2F;.ssh&#x2F;id_dsa）和一个密码，如果需要的话。passphrase和password元素在将来可能会外部化，但是现在他们必须在setting.xml中以纯文本设置。</li>
<li><strong>filePermissions, directoryPermissions</strong>：当在部署时创建仓库文件或目录时，这些是使用的权限。每个的合法值是一个三位数的数字对应于* nix文件的权限，即。 664或775。</li>
</ul>
<p>注意：如果使用私钥登录服务器，请确保省略&lt;password&gt;元素。否则，密钥将被忽略。</p>
<h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>一个新功能 - 服务器密码和密码加密已经添加到2.1.0+。详细信息请查看<a href="http://maven.apache.org/guides/mini/guide-encryption.html">“密码加密”</a></p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**id, name: **该镜像的唯一标识符和用户友好名称。该id用于区分mirror元素，并在连接到镜像时从&lt;servers&gt;部分选择相应的凭据。</li>
<li>**url:**镜像的基础URL。构建系统会使用这个URL来连接到一个远程仓库，而不是使用原始的仓库URL。</li>
<li><strong>mirrorOf：</strong>要镜像的仓库的id。比如，要指向Maven central仓库（<a href="https://repo.maven.apache.org/maven2%EF%BC%89">https://repo.maven.apache.org/maven2）</a> 的镜像，设置这个元素值为central。更高级的映射，如repo1，repo2或*，！inhouse也是可能的。但是这个不能匹配一个镜像的id。</li>
</ul>
<p>要更深入地介绍镜像，请阅读<a href="http://maven.apache.org/guides/mini/guide-mirror-settings.html">“镜像设置指南”</a>。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>myproxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.somewhere.com<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>somepassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>id：</strong>此代理的唯一标识符。这用于区分proxy元素。</li>
<li><strong>active：</strong>如果此代理是开启的，则为true。这用于声明一系列的代理，但是一次只有一个代理开启可用。</li>
<li><strong>protocol, host, port：</strong>代理protocol:&#x2F;&#x2F;host:port ，分割开成不同的元素。</li>
<li>**username, password:**这些元素成对出现，表示向该代理服务器进行身份验证所需的登录名和密码。</li>
<li>**nonProxyHosts: **这是不应该被代理的主机列表。列表的分隔符是代理服务器的预期的类型;上面的例子是管道分隔 - 逗号分隔也是常见的。</li>
</ul>
<h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>settings.xml中的profile元素是pom.xml中的profile元素的缩短版本。它由activation, repositories, pluginRepositories和properties元素组成。profile元素只包含这四个元素，因为它们与整个构建系统（这是settings.xml文件的作用）有关，而不是关于单个项目对象模型设置。<br>如果profile在setting中处于开启状态，则其值将覆盖POM或profiles.xml文件中的任何等同ID的配置文件。</p>
<h3 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h3><p>Activations是profile的关键。像POM的profiles一样，profiles的功能来自于在某些情况下修改某些值的能力;这些情况通过activation元素指定。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当满足所有指定的标准时，Activation会开启，尽管不是所有的都是必需的。</p>
<ul>
<li><strong>jdk：</strong>activation有一个内置的，以Java为中心的jdk元素的检查。如果测试在与给定的前缀匹配的jdk版本号下运行，它会激活。在上面的例子中，1.5.0_06将匹配。</li>
<li><strong>os：</strong>os元素可以定义上面显示的一些操作系统特定属性。有关操作系统值的更多详细信息，请参阅<a href="https://maven.apache.org/plugins/maven-enforcer-plugin/rules/requireOS.html">maven-enforcer-plugin</a>。</li>
<li><strong>property：</strong>如果Maven检测到对应的name&#x3D;value对的属性（可以通过${name}在POM中取消引用的值），该profile将激活。</li>
<li><strong>file：</strong>最后，给定的文件名可以通过文件的existence或missing而激活profile。</li>
</ul>
<p>activation元素不是profile可以被激活的唯一方式。setting.xml文件的activeProfile元素可能包含profile的id。它们也可以通过命令行在-P标志后用一个逗号分割的列表（如 -P test）来显示激活。<br>要查看某个构建中将激活哪个配置文件，请使用maven-help-plugin。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn help:active-profiles</span><br></pre></td></tr></table></figure>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Maven属性是值占位符，如Ant中的属性。它们的值可以通过使用符号$ {X}在POM中的任何位置访问，其中X是属性。他们有五种不同的样式，都可以从settings.xml文件访问：</p>
<ol>
<li>env.X：使用“env.”替换变量将返回shell的环境变量。例如，$ {env.PATH}包含\ $ path环境变量（Windows中的％PATH％）。</li>
<li>project.x：POM中的点（.）标记路径将包含相应元素的值。例如：可以通过$ {project.version}访问&lt;project&gt; &lt;version&gt; 1.0 &lt;&#x2F; version&gt; &lt;&#x2F; project&gt;。</li>
<li>setting.x：settings.xml中的点（.）标记路径将包含相应元素的值。例如：可以通过 ${settings.offline}访问&lt;settings&gt;&lt;offline&gt;false&lt;&#x2F;offline&gt;&lt;&#x2F;settings&gt;。</li>
<li>Java系统属性：通过java.lang.System.getProperties()可访问的所有属性都可用作POM属性，例如$ {java.home}。</li>
<li>x：在<properties />元素或外部文件中设置，该值可以用作$ {someVar}。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user.install</span>&gt;</span>$&#123;user.home&#125;/our-project<span class="tag">&lt;/<span class="name">user.install</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果此配置文件处于活动状态，则可以从POM访问属性${user.install}。</p>
<h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>Repositories是Maven用于填充构建系统的本地仓库的远程项目集合。从本地仓库中，Maven称它为插件和依赖。不同的远程仓库可能包含不同的项目，在开启的profile下，它们会搜索相匹配的发布或者快照版的artifact。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**releases, snapshots:**这是对不同类型的artifact的策略，发布版或者快照版。使用这两个设置，POM有权在一个仓库中修改每个类型的策略，而不管其他的类型。比如，出于开发的目的，可能只决定开启快照版本下载。</li>
<li>**enabled:**是否为相应的类型（发布版或快照版）启用了该存储库，为true还是false</li>
<li>**updatePolicy:**此元素指定应尝试更新发生的频率。Maven将将本地POM的时间戳记（存储在仓库中的maven-metadata文件中）与远程文件进行比较。选项是：always，daily（默认），interval：X（其中X是以分钟为单位的整数）或never。</li>
<li>**checksumPolicy:**当Maven将文件部署到仓库时，它还会部署相应的校验和文件。在文件缺失或者校验和不正确时，你的选项是ignore，fail或者warn。</li>
<li>**layout:**在上述仓库的描述中，提到它们都遵循一个共同的布局。这大多数是正确的。 Maven 2为它的仓库有一个默认布局;然而，Maven 1.x有不同的布局。使用此元素来指定它是default还是legacy。</li>
</ul>
<h3 id="插件仓库"><a href="#插件仓库" class="headerlink" title="插件仓库"></a>插件仓库</h3><p>仓库是两种主要类型artifact的家。第一种类型的artifact用来做为其他artifact的依赖。这些是驻留在中央仓库的大多数插件。另一种类型的artifact是插件。Maven插件本身就是一种特殊类型的artifact。因此，插件仓库可能与其他仓库分离开来（尽管我还没有听到有说服力的论据）。无论如何，pluginRepositories元素块的结构类似于repository元素。pluginRepository元素各自指定Maven可以找到新插件的远程位置。</p>
<h2 id="Active-Profiles"><a href="#Active-Profiles" class="headerlink" title="Active Profiles"></a>Active Profiles</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-test<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>settings.xml难题的最后一块是activeProfiles元素。这包含一组activeProfile元素，每个元素都有一个profile id的值。任何profile id被定义为activeProfile都会被激活，而不管任何的环境设置。如果没有找到匹配的profile，则什么也不会发生。比如，如果env-test是一个activeProfile，一个在pom.xml（或profile.xml）中有相应id的profile会被激活。如果没有这样一个profile被找到，则依旧照常执行。</p>
]]></content>
      <categories>
        <category>Maven</category>
        <category>参考</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>哈系表（HashTable）</title>
    <url>/2017/09/07/%E5%93%88%E7%B3%BB%E8%A1%A8%EF%BC%88HashTable%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><hr>
<p>哈系表（Hash Table）是一种个将键映射到值的数据结构（也称为Table或Map抽象数据类型（ Abstract Data Type&#x2F;ADT））。它使用一个hash函数将大型或者甚至非整数的键映射到一个小范围的整数索引（通常是 [0..hash_table_size-1]）上。</p>
<p>两个不同的键碰撞到相同的索引上的概率较高，并且每个这种潜在的碰撞都需要解决以维持数据完整。</p>
<p>这有几种冲突解决策略，将在此学习中突出显示：开放寻址（线性检测，二次探测和双重哈希）和闭合寻址（单独链接）。</p>
<span id="more"></span>
<hr>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><hr>
<p>哈希是一种算法（通过一个hash函数），将可变长度的大的数据集（称为键，不需要是整数）映射到一个固定长度的整数数据集上。</p>
<p>哈希表是使用hash函数有效地将键映射到值（Table或Map ADT）的数据结构，用于高效的搜索&#x2F;检索，插入和&#x2F;或移除。</p>
<p>哈希表广泛应用于多种计算机软件，特别是关联数组，数据库索引，缓存和set。</p>
<p>本教程中我们将讨论Table ADT，哈希的基本思想，并在进入哈希表细节之前讨论哈希函数。</p>
<h2 id="Table-ADT"><a href="#Table-ADT" class="headerlink" title="Table ADT"></a>Table ADT</h2><hr>
<p>一个Table ADT必须至少尽可能高效的支持以下三个操作：</p>
<ol>
<li><strong>Search(v)</strong> — 判断v是否在ADT中</li>
<li><strong>Insert(v)</strong> — 向ADT中插入v</li>
<li>**Remove(v) **— 从ADT中移除v</li>
</ol>
<p>哈希表是该Table ADT的一个可能的实现。</p>
<blockquote>
<p>PS：对于Table ADT的两个较弱的实现，可以单击相应的链接：<a href="">未排序的数组</a>或<a href="">排序的数组</a>来阅读详细的讨论。</p>
</blockquote>
<h2 id="Direct-Addressing-Table（DAT）"><a href="#Direct-Addressing-Table（DAT）" class="headerlink" title="Direct Addressing Table（DAT）"></a>Direct Addressing Table（DAT）</h2><hr>
<p>当Integer键的范围很小时，例如[0..M-1]，我们可以使用大小为M的初始空（boolean）数组A，并直接实现以下Table ADT操作:</p>
<ol>
<li>Search(v): 检查A[v]是否为true (已填充) 或为false (空的),</li>
<li>Insert(v): 设置A[v] 为true (填充),</li>
<li>Remove(v): 设置A[v] 为false (空的).</li>
</ol>
<p>就是这样，我们使用小的整数键来确定数组A中的地址，因此命名为<strong>直接寻址</strong>（Direct Addressing）。很明显，所有三个主要的Table ADT操作时间复杂度都是O（1）。</p>
<h2 id="DAT限制"><a href="#DAT限制" class="headerlink" title="DAT限制"></a>DAT限制</h2><hr>
<p>键必须是<strong>非负整数值</strong>。<br>键的范围必须比较小。如果比较大的话，内存的占用将疯狂增长。<br>键必须密集，也就是在键的值之间没有太多空隔。否则DAT将会包含很多空的单元格。<br>我们会通过使用哈希来克服这些限制。</p>
<hr>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><hr>
<p>使用哈希，我们可以：</p>
<ol>
<li>映射<strong>非整数</strong>键到整数值上</li>
<li>映射大范围整数到更小的整数上</li>
<li>哈系表的影响密度或负载因子<strong>α &#x3D; N&#x2F;M</strong>，这里N是键的数量，M是哈系表的大小</li>
</ol>
<p>使用哈希，我们可以是使用整数数组来实现Table ADT的操作：</p>
<ol>
<li><strong>Search(v)</strong>: 检查是否A[h(v)] !&#x3D; -1 (假设v ≥ 0，我们使用-1表示一个空单元格),</li>
<li><strong>Insert(v)</strong>: 设置A[h(v)] &#x3D; v (我们哈希v 到h(v) 这样我们需要以某种方式记录键v)</li>
<li><strong>Remove(v)</strong>: 设置A[h(v)] &#x3D; -1 — 之后进一步阐释</li>
</ol>
<p>如果我们要让键映射到卫星数据上，并且我们也要记录原始的键，那么我们可以使用（Integer，satellite-data-type）数组来实现哈希表，如下所示：</p>
<ol>
<li><strong>Search(v)</strong>: 返回A[h(v)]，它是一个pair (v, satellite-data)，也可能是空的</li>
<li><strong>Insert(v, satellite-data)</strong>: 设置A[h(v)] &#x3D;pair (v, satellite-data)</li>
<li><strong>Remove(v)</strong>: 设置A[h(v)] &#x3D; (empty pair) — 之后进一步阐释</li>
</ol>
<p>但是你应该注意到有些是不完整的。哈希函数可能并且很可能将不同的键（整数或不整数）映射到相同的整数槽中，也就是，多对一映射而不是一对一映射。</p>
<p>这种情况称为冲突（collision），即两个（或更多个）键具有相同的哈希值。</p>
<blockquote>
<p>生日（冯米塞斯）悖论问：“不管年份和闰天（也就是所有的年份都有365天），一个房间（Hash Table）必须有多少人（key），才能让他们有相同生日（collision）的概率达到50%“？答案是：23人</p>
</blockquote>
<p>这时产生了两个重要的问题：</p>
<ol>
<li>我们可以使用一个哈希函数将大范围的整数键映射到较小范围的整数键上，但非整数键如何呢？如何有效的进行这样的哈希？</li>
<li>我们已经看到大范围键可以通过哈希或映射到小范围中，这时很有可能发生碰撞，该如何处理它们？</li>
</ol>
<hr>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><hr>
<p>一个好的哈希函数应该满足以下要求</p>
<ol>
<li>快速计算，也就是在O（1）的时间复杂度内</li>
<li>使用尽可能小的slot&#x2F;Hash Table大小M</li>
<li>尽可能均匀的将键分散到不同的地址∈ [0..M-1]</li>
<li>实现尽可能小的冲突</li>
</ol>
<p>常用的哈希函数设计有三种</p>
<h2 id="除法哈希法（The-Division-Method）"><a href="#除法哈希法（The-Division-Method）" class="headerlink" title="除法哈希法（The Division Method）"></a>除法哈希法（The Division Method）</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(key) = key mod m</span><br></pre></td></tr></table></figure>
<p>其中key表示被哈希的关键字，m表示哈希表的大小，mod为取余操作。假定所选择的质数与关键字分布中的任何模式都是无关的，这种方法常常可以给出很好的结果。</p>
<h2 id="乘法哈希法（The-Multiplication-Method）"><a href="#乘法哈希法（The-Multiplication-Method）" class="headerlink" title="乘法哈希法（The Multiplication Method）"></a>乘法哈希法（The Multiplication Method）</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(key) = floor( m * ( A * key mod <span class="number">1</span>) )</span><br></pre></td></tr></table></figure>
<p>其中 floor 表示对表达式进行下取整，常数 A 取值范围为（0&lt;A&lt;1），m 表示哈希表的大小，mod 为取余操作。[A * key mod 1] 表示将 key 乘上某个在 0~1 之间的数并取乘积的小数部分，该表达式等价于 [A*key - floor(A * key)]。<br>乘法哈希法的一个优点是对 m 的选择没有什么特别的要求，一般选择它为 2 的某个幂次，这是因为我们可以在大多数计算机上更方便的实现该哈希函数。</p>
<p>虽然这个方法对任何的 A 值都适用，但对某些值效果更好，最佳的选择与待哈希的数据的特征有关。Don Knuth 认为 A ≈ (√5-1)&#x2F;2 &#x3D; 0.618 033 988… 比较好，可称为黄金分割点。</p>
<p>假设我们有一个大小为M的哈希表，其中使用键来识别卫星数据，并且使用特定的哈希函数来计算哈希值。使用哈希函数从键v计算它的哈希值&#x2F;哈希码，得到范围为0到M-1的整数。该哈希值用作卫星数据的哈希表的基本&#x2F;父 索引&#x2F;地址入口。</p>
<p>在讨论现实之前,让我们先讨论理想情况:完美哈希函数。一个完美的哈希函数是键和哈希值之间的一对一映射，即完全没有冲突。如果所有的键都是事先知道的话。例如，编译器&#x2F;解释器搜索保留的关键字。但是，这种情况很少见。<br>当表的大小与提供的关键字数量相同时，可以实现最小的完美哈希函数。这种情况更是罕见。如果你有兴趣，您可以浏览<a href="https://www.gnu.org/software/gperf/">GNU gperf</a>，这是一个免费提供的完美的哈希函数生成器，用C ++编写，可以从用户提供的关键字列表中自动构建完整的函数（一个C ++程序）。</p>
<hr>
<h1 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h1><hr>
<p>通常采用的冲突解决策略为<strong>开放寻址法</strong>（Open Addressing），将所有的元素都存放在哈希表内的数组中，不使用额外的数据结构。开放寻址有三种方式：</p>
<ul>
<li>线性探查（Linear Probing）—— <strong>i&#x3D;(base+step*1) % M</strong></li>
<li>二次探查（Quadratic Probing）—— <strong>i&#x3D;(base+step*step) % M</strong></li>
<li>双重哈希（Double Hashing）——  <strong>i&#x3D;(base+step*secondary) % M</strong></li>
</ul>
<p>其中<br>M &#x3D; HT.length &#x3D; 当前哈系表大小<br>base &#x3D; (key%HT.length)  &#x3D;  键的基本地址<br>step &#x3D; 当前探查步长<br>secondary &#x3D; smaller_prime - key%smaller_prime &#x3D; 次级哈希函数，smaller_prime是一个比M小的素数，这样写可以避免次级哈希函数为0</p>
<h2 id="线性探查（Linear-Probing）"><a href="#线性探查（Linear-Probing）" class="headerlink" title="线性探查（Linear Probing）"></a>线性探查（Linear Probing）</h2><hr>
<h3 id="Insert-v"><a href="#Insert-v" class="headerlink" title="Insert(v)"></a>Insert(v)</h3><p>开放寻址法的最简单的一种实现就是线性探查（Linear Probing），插入操作步骤如下：</p>
<ol>
<li>当插入新的元素时，使用哈希函数在哈希表中定位元素位置；</li>
<li>检查哈希表中该位置是否已经存在元素。如果该位置内容为空，则插入并返回，否则转向步骤 3。</li>
<li>如果该位置为i，则检查i+1是否为空，如果已被占用，则检查i+2，依此类推，直到找到一个内容为空的位置。</li>
</ol>
<p>我们假设一个哈希表，<strong>单元格区分空，占有和删除状态</strong>，线性探查实现逻辑伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> N+<span class="number">1</span> == M, prevent insertion  <span class="comment">//如果要插入元素数量N大于哈希表尺寸M，阻止插入</span></span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span>;   <span class="comment">//当前探测的步数</span></span><br><span class="line">i = base = key%HT.length;  <span class="comment">// 基本地址，也就是通过哈希值获得的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (HT[i] != EMPTY || HT[i] != DELETED)  <span class="comment">//如果该地址不为空或不为删除状态，继续执行</span></span><br><span class="line">  step++;    <span class="comment">//要探测步长加1</span></span><br><span class="line">  i = (base+step*<span class="number">1</span>)%HT.length  <span class="comment">//下一个地址</span></span><br><span class="line">  </span><br><span class="line">found insertion point, insert key at HT[i]</span><br></pre></td></tr></table></figure>
<p>Java实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key  % hashTable.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hashTable[i] != Status.Empty &amp;&amp; hashTable[i] != Status.Delete)&#123;</span><br><span class="line">        <span class="keyword">if</span>(step &gt; hashTable.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        step ++;</span><br><span class="line">        i = (key + step * <span class="number">1</span>) % hashTable.length;</span><br><span class="line">    &#125;</span><br><span class="line">    hashTable[i] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Search-v"><a href="#Search-v" class="headerlink" title="Search(v)"></a>Search(v)</h3><p>线性探查搜索操作类似于插入操作，步骤如下：</p>
<ol>
<li>当搜索指定元素时，使用哈希函数在哈希表中定位元素位置；</li>
<li>检查哈希表中该位置是否已经存在元素。如果该位置内容为空，则返回-1表示元素不存在，否则转向步骤 3。</li>
<li>如果该位置为i，则检查i+1是否为空，如果是返回-1，否则检查i+2，依此类推，直到找到该元素。</li>
</ol>
<p>注意上面步骤中从基本地址开始搜索，如果遇到内容为空的单元格就停止搜索，因为根据插入原则，该元素存在的话不会为-1；伪代码实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">step = <span class="number">0</span>;   <span class="comment">//当前探测的步数</span></span><br><span class="line">i = base = key%HT.length;  <span class="comment">// 基本地址，也就是通过哈希值获得的地址</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> (HT[i] == EMPTY)  <span class="comment">// 如果当前单元格为空，返回未找到</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line">	</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (HT[i] == key) <span class="comment">// 如果当前单元格为查找数据，返回索引</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;found at index i&quot;</span></span><br><span class="line">	</span><br><span class="line">  <span class="keyword">else</span> step++; <span class="comment">// 单元格不为空，也不为查找数据，探测步长加1</span></span><br><span class="line">  i = (base+step*<span class="number">1</span>)%HT.length <span class="comment">//下一个地址</span></span><br></pre></td></tr></table></figure>
<p>主要逻辑Java实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchByIndex(hashing(key), key);  <span class="comment">// 传入基本地址，也就是该数据哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchByIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashTable[index] == key) &#123;   <span class="comment">// 是搜索项的话，直接返回索引</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hashTable[index] == Status.Empty)&#123; <span class="comment">//判断当前索引处单元格是否为空，是的话返回为找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;		</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> (index + <span class="number">1</span>) % hashTable.length; <span class="comment">//下一个地址</span></span><br><span class="line">    <span class="keyword">if</span>(nextIndex != hashing(key))&#123; <span class="comment">// 判断是否已经查找了一圈</span></span><br><span class="line">        <span class="keyword">return</span> searchByIndex(nextIndex, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 返回未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Remove-v"><a href="#Remove-v" class="headerlink" title="Remove(v)"></a>Remove(v)</h3><p>之前设置哈系表单元格状态分为空，占有，和删除，其中如果不设置删除状态，未插入数据的单元格和插入数据但已删除的单元格状态都为空，这时根据插入时原则，在判断时会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">step = <span class="number">0</span>;   <span class="comment">//当前探测的步数</span></span><br><span class="line">i = base = key%HT.length;  <span class="comment">// 基本地址，也就是通过哈希值获得的地址</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> (HT[i] == EMPTY)  <span class="comment">//如果为空，返回未找到，否则为占有或已删除则继续查找</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (HT[i] == key)  <span class="comment">//如果为要删除项，返回索引删除</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;found at index i&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> step++; <span class="comment">// 单元格不为空，也不为查找数据，探测步长加1</span></span><br><span class="line">  i = (base+step*<span class="number">1</span>)%HT.length <span class="comment">//新的地址</span></span><br></pre></td></tr></table></figure>
<p>主要逻辑Java实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeByIndex(hashing(key),key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeByIndex</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashTable[index] == key) &#123;</span><br><span class="line">        hashTable[index] = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hashTable[index] == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> (index + <span class="number">1</span>) % hashTable.length;</span><br><span class="line">    <span class="keyword">if</span>(nextIndex != hashing(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> removeByIndex(nextIndex, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线性探查的探查序列可以形式上如下描述：</p>
<blockquote>
<p>h（v） &#x2F;&#x2F; 基本地址<br>（h（v） + 1*<span style="color: red;">1</span>） % M &#x2F;&#x2F; 如果有冲突，第1个探查步骤<br>（h（v） + 2*<span style="color: red;">1</span>） % M &#x2F;&#x2F; 如果还有冲突，第2个探查步骤<br>（h（v） + 3*<span style="color: red;">1</span>） % M &#x2F;&#x2F; 如果还有冲突，第3个探查步骤<br>…<br>（h（v） + k*<span style="color: red;">1</span>） % M &#x2F;&#x2F; 第K个探查步骤，等等…</p>
</blockquote>
<p>虽然我们可以使用线性探查解决冲突，但这并不是最有效的方法。 我们将一个连续占用槽的集合定义为<strong>群集</strong>（cluster）。一个群集它覆盖了键的基本地址，这称为键的<strong>一级群集</strong>（Primary Clustering）。在insert(v)期间，如果存在冲突，但是在哈希表中存在空（或DEL）插槽，则我们确定在最多M个线性探测步长之后找到它。而当我们这样做的时候，冲突就会被解决，但键v的<strong>一级群集</strong>就会被扩展，未来的哈希表操作也会变慢。并且由于临近群集的合并，一级群集的尺寸将越来越大。这将增加Search(v)&#x2F;Insert(v)&#x2F;Remove(v)操作的运行时间，超出O（1）。对此一种改进的方式为二次探查（Quadratic Probing）</p>
<h2 id="二次探查（Quadratic-Probing）"><a href="#二次探查（Quadratic-Probing）" class="headerlink" title="二次探查（Quadratic Probing）"></a>二次探查（Quadratic Probing）</h2><hr>
<p>为了减少一级群集，我可以可以这样修改探查序列</p>
<blockquote>
<p>h（v） &#x2F;&#x2F; 基本地址<br>（h（v） + 1*<span style="color: red;">1</span>） % M &#x2F;&#x2F; 如果有冲突，第1个探查步骤<br>（h（v） + 2*<span style="color: red;">2</span>） % M &#x2F;&#x2F; 如果还有冲突，第2个探查步骤<br>（h（v） + 3*<span style="color: red;">3</span>） % M &#x2F;&#x2F; 如果还有冲突，第3个探查步骤<br>…<br>（h（v） + k*<span style="color: red;">k</span>） % M &#x2F;&#x2F; 第K个探查步骤，等等…</p>
</blockquote>
<p>这样，二次探查跳过+1，+4，+9，+16，…的似乎能够解决我们早期使用线性探测的一级群集问题，但它依然会有些问题，如果二次探查的插槽恰好已经都有元素，这样即使哈系表依旧有空槽，但二次探查无法插入数据。</p>
<blockquote>
<p><strong>如果α&lt;0.5和M是素数，那么我们总是可以使用二次探查找到一个空槽。回想一下：α是负载因子，M是哈希表大小（HT.length）</strong>。</p>
</blockquote>
<p>在二次探查中，沿着探查的路径形成群集，而不是像线性群集那样在基本地址周围形成群集，这样的被称为<strong>二级群集</strong>（Secondary Clusters）。所有的键使用相同的探查模式会形成二级群集，如果两个键拥有相同的基本地址，二次探查序列将会相同。二次探查中的二级群集并不像线性探查中的一级群集那样糟糕，因为一个好的哈希函数理论上应该将键分散到不同的基本地址∈[0..M-1]中。</p>
<h2 id="双重哈希（Double-Hashing）"><a href="#双重哈希（Double-Hashing）" class="headerlink" title="双重哈希（Double Hashing）"></a>双重哈希（Double Hashing）</h2><hr>
<p>为了减少一级和二级群集，我可以可以这样修改探查序列：</p>
<blockquote>
<p>h（v） &#x2F;&#x2F; 基本地址<br>（h（v） + 1*<span style="color: red;">h2(v)</span>） % M &#x2F;&#x2F; 如果有冲突，第1个探查步骤<br>（h（v） + 2*<span style="color: red;">h2(v)</span>） % M &#x2F;&#x2F; 如果还有冲突，第2个探查步骤<br>（h（v） + 3*<span style="color: red;">h2(v)</span>） % M &#x2F;&#x2F; 如果还有冲突，第3个探查步骤<br>…<br>（h（v） + k*<span style="color: red;">h2(v)</span>） % M &#x2F;&#x2F; 第K个探查步骤，等等…</p>
</blockquote>
<p>h2(v)被称为次级哈希函数，如果h2（v）&#x3D; 1，则Double Hashing与Linear Probing完全相同。 所以我们通常希望h2（v）&gt; 1来避免一级群集。如果h2（v）&#x3D; 0，则由于任何探测步长乘以0，双重哈希不起作用，因为任何探测步长乘以0，即我们在冲突期间永远停留在基本地址 我们需要避免这种情况。通常（对于整数键），h2（v）&#x3D; M’ - v％M’，其中M’是比M小的素数。 这使得h2（v）∈[1..M’]，其足够多样化以避免二级聚集。</p>
<blockquote>
<p>次级哈希函数的使用从理论上避免了一级和二级群集的发生。</p>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><hr>
<p>总之，一个好的开放寻址冲突解决技术需要有：</p>
<ol>
<li>如果有空槽的话需要总能找到它</li>
<li>最小化群集</li>
<li>当两个不同的键冲突的时候，给出不同的探查序列</li>
<li>足够快，O（1）</li>
</ol>
<hr>
<h1 id="分离链接（Separate-Chaining）"><a href="#分离链接（Separate-Chaining）" class="headerlink" title="分离链接（Separate Chaining）"></a>分离链接（Separate Chaining）</h1><hr>
<p>分离链接技术（Separate Chaining）是另一种冲突解决策略。它把哈希到同一个槽中的所有元素都放到一个链表中。分离链接技术将采用额外的数据结构来处理冲突，其将哈希表中每个位置（slot）都映射到了一个链表。当冲突发生时，冲突的元素将被添加到桶（bucket）列表中，而每个桶都包含了一个链表以存储相同哈希的元素。<br><img src="/%5Cimages%5Cdatastructure%5Cseperatechain.gif" alt="分离链接"></p>
<p>如果我们使用分离链接技术，那么负载因子α&#x3D; N &#x2F; M描述列表的平均长度M，并且它确定Search（v）的性能，因为我们可能必须平均探索α元素。作为Remove（v） - 也需要Search（v），其性能将与Search（v）类似。insert(v)的时间复杂度显然是O（1）。如果我们可以将α绑定为小常数，则使用分离链接的所有Search（v），Insert（v）和Remove（v）操作将为O（1）。</p>
<hr>
<h1 id="哈希表扩增"><a href="#哈希表扩增" class="headerlink" title="哈希表扩增"></a>哈希表扩增</h1><hr>
<p>当负载因子α越高时，哈希表的性能下降。对于（标准）二次探查冲突解决技术，当哈希表α&gt; 0.5时，插入可能会失败。如果发生这种情况，我们可以重新哈希转换。我们使用新的哈希函数构建另一个哈希表，大小约是原来的两倍。我们重新计算原始哈希表中的所有键的新哈希值，并将卫星数据插入到新的更大的哈希表中，最后我们删除较旧的较小的哈希表。</p>
<blockquote>
<p>根据经验，如果使用开放寻址，当α&gt; 0.5时，重新哈希转换，如果使用分离链接，当α&gt; 1.0时，重新进行哈希转换。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈系表</tag>
      </tags>
  </entry>
  <entry>
    <title>排序（Sort）</title>
    <url>/2017/09/11/%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li>基于比较的排序算法（Comparison-based Sorting Algorithms）:<ul>
<li>BUB - <strong>冒泡排序</strong></li>
<li>SEL - <strong>选择排序</strong></li>
<li>INS - <strong>插入排序</strong></li>
<li>MER - <strong>合并排序</strong>(递归实现)</li>
<li>QUI - <strong>快速排序</strong>(递归实现)</li>
<li>R-Q - <strong>随机快速排序</strong>(递归实现)</li>
</ul>
</li>
<li>不基于比较的排序算法（Not Comparison-based Sorting Algorithms）:<ul>
<li>COU - <strong>统计排序</strong></li>
<li>RAD - <strong>基数排序</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>
<hr>
<h1 id="基于比较的算法"><a href="#基于比较的算法" class="headerlink" title="基于比较的算法"></a>基于比较的算法</h1><hr>
<ul>
<li><strong>冒泡排序</strong></li>
<li><strong>选择排序</strong></li>
<li><strong>插入排序</strong></li>
<li><strong>合并排序</strong>(递归实现)</li>
<li><strong>快速排序</strong>(递归实现)</li>
<li><strong>随机快速排序</strong>(递归实现)</li>
</ul>
<p>这些排序被称为基于比较的算法，因为它们比较一对数组元素，并决定是否交换它们。 前三个排序算法是最容易实现的，但也不是最有效的，因为它们在O（N2）时间复杂度中运行。</p>
<h2 id="冒泡排序（BublleSort）"><a href="#冒泡排序（BublleSort）" class="headerlink" title="冒泡排序（BublleSort）"></a>冒泡排序（BublleSort）</h2><hr>
<p><img src="/%5Cimages%5Cdatastructure%5CBubbleSort.gif" alt="冒泡排序"><br>给定一个N个元素的数组，冒泡排序将： </p>
<ol>
<li>比较一对相邻元素（a，b）， </li>
<li>元素大小与不与顺序一致，交换元素， </li>
<li>重复步骤1和2，直到我们到达数组的结尾 （因为我们使用基于0的索引，最后一对是第（N-2）和（N-1）项） </li>
<li>到目前为止，最大的项目将在最后的位置。<br>然后我们将N减少1，并重复步骤1，直到N &#x3D; 1。</li>
</ol>
<p>如上每次循环将最大值放到了最后，最坏情况下N个元素就将进行N-1次这样的循环，如下示例</p>
<ol>
<li>第1次迭代，到第N-2位置结束，总共需要N-1次比较交换，将最大值放到N-1位置</li>
<li>第2次迭代，到第N-3位置结束，总共需要N-2次比较交换，将第二大值放到N-2位置</li>
<li>第3次迭代，到第N-4位置结束，总共需要N-3次比较交换，将第三大值放到N-3位置<br>…</li>
<li>第N-1次迭代，到第0位置结束，总共需要1次比较交换，将倒数第二大值放到1位置</li>
</ol>
<p>这样总共需要的迭代次数为iterations &#x3D; (N−1)+(N−2)+…+1 &#x3D; N*(N−1)&#x2F;2，比较交换花的时间在常量时间c内，所以时间复杂度就等于 &#x3D; c*N*(N−1)&#x2F;2 &#x3D; O(N^2)。但如果第一次迭代中就已经排好序，之后迭代就不再需要。容易发现，当内部迭代元素没有发生交换，说明已经实现排序完毕，结束操作，这种最好情况下时间复杂度将将为O(N)，Java实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swap</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> array.length - <span class="number">1</span>;  <span class="comment">// 数组长度-1，因为每次比较两个元素，最后一个不需要迭代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; l; a++) &#123;  <span class="comment">//外部每迭代一次，实现从一个该迭代中最大值位置放到最后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; l - a; b++) &#123;  <span class="comment">// 内部迭代次数为l - a，a可以理解已经排序好位置不变的元素个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array[b];  <span class="comment">//靠前元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array[b + <span class="number">1</span>];  <span class="comment">//靠后元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">                array[b] = (array[b + <span class="number">1</span>] = i) ^ (i ^ n); <span class="comment">//实现两个元素交互位置</span></span><br><span class="line">                swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(swap == <span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">//等于false说明内部循环没有发生交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序（SelectionSort）"><a href="#选择排序（SelectionSort）" class="headerlink" title="选择排序（SelectionSort）"></a>选择排序（SelectionSort）</h2><hr>
<p><img src="/%5Cimages%5Cdatastructure%5CSelectionSort.gif" alt="选择排序"><br>给定N个元素的数组，L &#x3D; 0，选择排序将： </p>
<ol>
<li>在[L … N-1]的范围内找到最小元素X的位置</li>
<li>交换X与第L项</li>
<li>将下限L增加1并重复步骤1直到L &#x3D; N-2</li>
</ol>
<p>上述操作每次将迭代到的最小值放到前面，这样N元素将迭代N-1次，</p>
<ol>
<li>第1次迭代，从0位置开始，总共需要N-1次比较，找到最小值，将其交换到0位置</li>
<li>第2次迭代，从1位置开始，总共需要N-2次比较，找到第二小值，将其交换到1位置</li>
<li>第3次迭代，从2位置开始，，总共需要N-3次比较，找到第三小值，将其交换到2位置<br>…</li>
<li>第N-1次迭代，从N-2位置开始，总共需要1次比较，找到倒数第二小值，将其交换到N-2位置</li>
</ol>
<p>与冒泡排序类似，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; length; a++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; b &lt; length; b++) &#123;</span><br><span class="line">            min = array[min] &lt; array[b + <span class="number">1</span>] ? min : b + <span class="number">1</span>;  <span class="comment">//获取最小元素的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array[a];</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array[min];</span><br><span class="line">        array[a] = (array[min] = n) ^ (m ^ n);  <span class="comment">//与当前循环最小元素互换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与冒泡排序一样，其时间复杂度也为O(N^2)。</p>
<h2 id="插入排序（InsertionSort）"><a href="#插入排序（InsertionSort）" class="headerlink" title="插入排序（InsertionSort）"></a>插入排序（InsertionSort）</h2><hr>
<p><img src="/%5Cimages%5Cdatastructure%5CInsertionSort.gif" alt="插入排序"><br>插入排序是从第二个元素开始，依次与前面的元素比较，一直比较到比它大的元素，就将它插入到该该元素之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">1</span>;a &lt; array.length; a++)&#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> array[a];  <span class="comment">// x是要插入的元素</span></span><br><span class="line">        <span class="keyword">for</span>(b = a -<span class="number">1</span> ;b &gt;= <span class="number">0</span> &amp;&amp; array[b] &gt; x; b--)&#123; <span class="comment">// array[b] &gt; x表示往前迭代到一个比x大的值为止</span></span><br><span class="line">            array[b + <span class="number">1</span>] = array[b];  <span class="comment">//依次挪动前面的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[b + <span class="number">1</span>] = x; <span class="comment">//插入元素，之所以是b+1，是因为循环会最后执行一次b--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外循环执行N-1次，这很清楚。<br>但内循环的执行次数取决外部循环位置：</p>
<ul>
<li>在最佳情况下，数组已经被排序好，因为i（a [j]&gt; X）总是为false 所以不需要数据的移动，内循环在O（1）中运行， </li>
<li>在最坏情况下，数组是反向排序的，（a [j]&gt; X）总是为true，始终需要在数组前插入，内部循环在O（N）中运行。</li>
</ul>
<p>因此，最佳情况时间为O（N×1）&#x3D; O（N），最坏情况时间为O（N×N）&#x3D; O（N^2）。</p>
<h2 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h2><hr>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>给定一个有N个项的数组，归并排序将： </p>
<ol>
<li>将每对单个元素归并（排序）到2个元素的排序数组中， </li>
<li>将每对2个元素的排序数组合并为4个元素的排序数组， 重复这个过程…， </li>
<li>最后一步：合并2个N &#x2F; 2个元素的排序数组（为了简单的讨论，我们假设N是偶数），以获得N个元素的完全排序的数组。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这只是通用的想法，我们需要更多的细节，然后才能讨论合并排序的真实形式。要讨论归并排序算法，我们首先讨论它的最重要的子程序：O（N）合并。<br>给定两个大小为N1和N2的排序数组A和B，我们可以在O（N）时间内将它们有效地合并成一个大小为N &#x3D; N1 + N2的较大组合排序的数组。这是通过简单地比较两个数组的前端并且始终采用两者中的较小的一个来实现的。此时，我们将需要额外的数组来正确地进行归并。以下为java实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">   <span class="type">int</span>[] merge = <span class="keyword">new</span> <span class="title class_">int</span>[left.length + right.length];<span class="comment">//额外归并数组</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>,l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(l &lt; left.length &amp;&amp; r &lt; right.length)&#123;</span><br><span class="line">       meger[a++] = left[l] &lt; right[r] ? left[l++] : right[r++]; <span class="comment">//依次比较两个数组元素大小，小的放入归并数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两个数组大小不一，最后将剩余的那个全部放入归并数组</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; left.length)&#123;</span><br><span class="line">       meger[a++] = left[l++]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; right.length)&#123;</span><br><span class="line">        meger[a++] = right[r++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们继续之前，让我们来谈谈分治法（Divide and Conquer），它是一个强大的问题解决范式，分治法将一个大的问题分为若干小的问题，分别解决每个小的问题，然后最后合并得出结果。<br><img src="/%5Cimages%5Cdatastructure%5CMergeSort.gif" alt="归并排序"><br>分治法算法可如下步骤解决排序问题：</p>
<ul>
<li>分：将大小N的数组分成两部分</li>
<li>治：将两部分中的元素分别排序</li>
<li>归并：合并并排序分出的两部分的部分</li>
</ul>
<p>上述O（N）合并实现代码中，需要两个部分数组的作为参数，而归并排序递归实现时不会真的拆分数组，而是通过传递数组索引来在一个数组中分割成各个部分，此外每次创建一个额外合并数组比较费时，我们采用传递重用一个临时数组，重写为下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last, <span class="type">int</span>[] temp)</span> &#123; <span class="comment">// first和last为进行合并的数组两部分边界，mid为分割点，temp为临时数组存储排序合并结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first, right = mid + <span class="number">1</span>, tIdx = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= last) &#123;</span><br><span class="line">        temp[tIdx++] = a[left] &lt;= a[right] ? a[left++] : a[right++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">        temp[tIdx++] = a[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= last) &#123;</span><br><span class="line">        temp[tIdx++] = a[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tIdx; i++) &#123;  <span class="comment">//将排序好的两部分数据重新放回数组</span></span><br><span class="line">        a[first + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为递归实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> first,<span class="type">int</span> last, <span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &lt; last)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (first + last) / <span class="number">2</span>;  </span><br><span class="line">        mergeSort(a,first,mid,temp);  <span class="comment">//分割和排序数组左部分</span></span><br><span class="line">        mergeSort(a,mid + <span class="number">1</span>,last,temp);<span class="comment">//分割和排序数组右部分</span></span><br><span class="line">        merge(a,first,mid,last,temp); <span class="comment">//每次递归中，合并两部分元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在归并排序中，大部分的工作在治&#x2F;合并步骤中，分的步骤并没有真正做什么（视为O（1））。当我们调用merge(a,first,mid,last,temp)，处理了 k &#x3D; (high-low+1)项元素，这里有k-1次比较。从数组a到临时数组temp有k次移动，然后又有从数组temp移回数组a的k次操作，因此在merge中总共的操作次数是 &lt; 3k-1 &#x3D; O(k)。<br>而merge被调用的次数为：<br><img src="/%5Cimages%5Cdatastructure%5Cmerge.png" alt="归并排序"></p>
<p>Level 1: 2<sup>0</sup>&#x3D;1 次调用merge()  ，每次合并 N&#x2F;2<sup>1</sup> 项元素, O(2^0 x 2 x N&#x2F;2<sup>1</sup>) &#x3D; O(N)<br>Level 2: 2<sup>1</sup>&#x3D;2 次调用 merge() ，每次合并 N&#x2F;2<sup>2</sup> 项元素, O(2^1 x 2 x N&#x2F;2<sup>2</sup>) &#x3D; O(N)<br>Level 3: 2<sup>2</sup>&#x3D;4 次调用 merge() ，每次合并 N&#x2F;2<sup>3</sup> 项元素, O(2^2 x 2 x N&#x2F;2<sup>3</sup>) &#x3D; O(N)<br>…<br>Level (log N): 2<sup>(log N-1) </sup> (或 N&#x2F;2)次调用 merge() ，每次合并 N&#x2F;2<sup>log N </sup>)(或 1)项元素, O(N)</p>
<p>总共有log N级，并且在每一级我们执行O(N)的工作，因此总体的时间复杂度是O(N log N)，<strong>稍后我们会看到这是一个最优的（基于比较的）排序算法，也就是没有比这更好的了</strong>。</p>
<p>归并排序最重要的优点是无论输入的原始数组如何，其保证O（N log N）性能。就是这样，对于任何N个元素数组的，没有任何对手测试用例可以使归并排序运行的时间超过O（N log N）。因此，归并排序非常适合排序极大数量的输入，因为O（N log N）比我们之前讨论的O（N2）排序算法花费时间增长慢得多。 </p>
<p>然而，合并排序也有几个不太好的部分。首先，从头开始实际上不容易实现（但是我们不需要去实现）。第二，在合并操作期间需要额外的O（N）存储，因此不会真正具有高效的内存。</p>
<h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><hr>
<p>快速排序是另一个分治排序算法。在学习随机和可用版本的快速排序算法前，我们首先看下一种确定性的，非随机的快速排序版本可能会有一个坏的时间复杂度O(N2)。</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>分割步骤：选择一个项p（称为支点(pivot)）<br>然后将a[i..j]的项分成三部分：a [i..m-1]，a [m]和[m + 1..j]。<br>a [i..m-1]（可能为空）包含小于p的项。<br>a [m]是支点p，即索引m是p在排序数组中的正确位置<br>a [m + 1..j]（可能为空）包含大于或等于p的项目。<br>然后，递归地排序这两个部分。 </p>
<p>征服步骤：不要惊讶…我们什么都不做：哦！<br>如果将其与归并排序进行比较，您将看到Quick Sort D＆C步骤与Merge Sort完全相反。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>我们首先通过讨论快速排序最重要的子程序：O（N）分区。<br>为了分割一个数组a[i..j]，我们首先选择一个a[i]作为支点p。 其余项（即a[i + 1..j]）分为3个区域： </p>
<ol>
<li>S1区域  a [i + 1..m]其中项&lt;p， </li>
<li>S2区域  a [m + 1..k-1]其中项≥p</li>
<li>未知区域 a [k..j]，其中项尚未分配给S1或S2。</li>
</ol>
<p>最初，S1和S2区都是空的，也就是除了指定的支点p之外的所有项都处于未知区域。<br>然后，对于未知区域中的每个项a[k]，我们将a[k]与p进行比较，并确定以下两种情况之一： </p>
<ol>
<li>如果a[k]≥p，则将a[k]置于S2 </li>
<li>否则，将a[k]置入S1。</li>
</ol>
<p>最后，我们交换a[i]和a[m]，以使p在S1和S2的中间。<br><img src="/%5Cimages%5Cdatastructure%5Cpartition1.png" alt="划分1"><br><img src="/%5Cimages%5Cdatastructure%5Cpartition2.png" alt="划分2"><br>该部分java实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> a[i];<span class="comment">// 支点p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i; <span class="comment">// S1与S2区域分割处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推进k，探索未知区域</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>;k &lt; j; k++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(a[k] &lt; p)&#123; <span class="comment">//小于支点则m++来拓展S1区域，并将k置于S1中</span></span><br><span class="line">            m++;</span><br><span class="line">            a[m] = (a[k] ^ a[m]) ^ (a[k] = a[m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[m] = (a[i] ^ a[m]) ^ (a[i] = a[m]);<span class="comment">// 最后将支点p与m处交换</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归实现快速排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> first, <span class="type">int</span> last)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &lt; last)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> partition(a,first,last);</span><br><span class="line">        quickSort(a,first,m - <span class="number">1</span>);  <span class="comment">//每次递归中排序m左边的元素</span></span><br><span class="line">        quickSort(a,m + <span class="number">1</span>,last); <span class="comment">//每次递归中排序m右边的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/%5Cimages%5Cdatastructure%5CQuickSort.gif" alt="快速排序"><br>我们将详细说明第一个分区步骤如下：<br>我们设置p &#x3D; a[0] &#x3D; 27。<br>我们设置一个a[1] &#x3D; 38作为S2的一部分，所以S1 &#x3D; {}和S2 &#x3D; {38}。<br>我们用a[2] &#x3D; 12交换a[1] &#x3D; 38，所以S1 &#x3D; {12}和S2 &#x3D; {38}。<br>我们设置一个a[3] &#x3D; 39，后来a[3] &#x3D; 27作为S2的一部分，所以S1 &#x3D; {12}，S2 &#x3D; {38,39,27}。<br>我们用a[5] &#x3D; 16交换a[2] &#x3D; 38，所以S1 &#x3D; {12,16}和S2 &#x3D; {39,27,38}。<br>我们用a[2] &#x3D; 16交换p &#x3D; a [0] &#x3D; 27，所以S1 &#x3D; {12,16}，p &#x3D; {27}，S2 &#x3D; {39,27,38}。 </p>
<p>之后，a[2] &#x3D; 27被保证被排序，现在Quick Sort递归地对左边a[0..1]进行排序，然后递归地排序右边的一个a[3..5]。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>首先，我们分析一次调用partition的成本。 在partition（a，i，j）中，只有一个循环遍历（j-i）次。由于j可以和N-1一样大，i可以低至0，所以partition的时间复杂度为O（N）。类似于合并排序分析，快速排序的时间复杂度取决于调用partition（a，i，j）的次数。</p>
<p>当数组a已经按照升序排列，就像上面的例子一样，快速排序将设置p &#x3D; a [0] &#x3D; 5，并返回m &#x3D; 0，从而使S1区域为空，S2区域包含除了支点[N-1]外的其他元素。 在这种最糟糕的情况下：<br><img src="/%5Cimages%5Cdatastructure%5Cqsort_worstcase.png" alt="快速排序最坏情况"><br>第一个partition耗费O（N）时间，将a分为0，1，N-1项，然后递归。<br>第二个耗费O（N-1）时间，将a分为0，1，N-2项，然后再次递归。<br>… 直到最后，第N个分区将a分为0,1,1个项目，并且快速排序递归停止。 </p>
<p>这是经典的N +（N-1）+（N-2）+ … + 1模式，它是O（N2）…</p>
<p>快速排序的最佳情况是当分区总是将阵列分成两个相等的两部分时，这就像归并排序。 当这种情况发生时，递归的深度是log n。当每个级别进行O（N）比较时，时间复杂度为O（N log N）。 但在实践中，这是罕见的，因此我们需要设计一个更好的方法：随机快速排序。</p>
<h2 id="随机快速排序（Random-QuickSort）"><a href="#随机快速排序（Random-QuickSort）" class="headerlink" title="随机快速排序（Random QuickSort）"></a>随机快速排序（Random QuickSort）</h2><hr>
<p>与快速排序相同，只是在执行分区算法之前，它随机选择[low..high]之间的支点，而不是总是选择a[first]。<br>要解释为什么这个随机版本的Quick Sort可以对N个元素的任何数组上，有预期O（N log N）的时间复杂度，这需要1个小时的讲解，但在这里，我们假设是真的。 如果需要非正式的解释：想象一下随机版本的Quick Sort，它将支点的选择随机化，我们不会总是得到最坏的分区0（空），1（支点）和N-1个其他项。这种最好（一半-支点-一半），次好，不好，非常好（空-支点-其余的）的组合产生了O（N log N）时间复杂度的平均时间复杂度。</p>
<hr>
<h1 id="不基于比较的算法"><a href="#不基于比较的算法" class="headerlink" title="不基于比较的算法"></a>不基于比较的算法</h1><hr>
<ul>
<li><strong>统计排序</strong>,</li>
<li><strong>基数排序</strong>.</li>
</ul>
<p>通过不比较数组的元素，这些排序算法可以比Ω（N log N）的基于比较的排序算法的下限更快。<br>它是已知的（这里没有证明，因为这将需要另外1个小时的讲座），所有基于比较的排序算法具有Ω（N log N）的下限时间复杂度。因此，任何基于比较的算法具有最差情况下O（N log N）时间复杂度，（如归并排序）被认为是一种最佳算法，也就是已经无法再优化。然而，如果存在输入数组的某些假设，因此我们可以避免比较元素以确定排序顺序，所以我们可以实现更快的排序算法，即O（N）。</p>
<h2 id="统计排序（Counting-Sort）"><a href="#统计排序（Counting-Sort）" class="headerlink" title="统计排序（Counting Sort）"></a>统计排序（Counting Sort）</h2><hr>
<p>假设：如果要排序的项 是小范围的整数，我们可以计算每个整数的出现频率（在该小范围内），并循环通过该小范围以排序顺序输出项。</p>
<p>在一个所有整数在[1…9]范围的示例数组上进行统计排序，我们只需要计算整数1出现多少次，整数2多少次， …, 整数9多少次，然后如果频率[y] &#x3D; x，则从1到9循环打印出整数y的x个副本。 时间复杂度是O（N），计算频率操作花费O（k），其中k是输入整数的范围，在该示例中为9-1 + 1 &#x3D; 9。统计排序的时间复杂度是O（N + k），如果k是（非常）小的话，则为O（N）。<br> 由于内存限制，当k相对较大时，我们将无法进行统计排序的统计部分。</p>
<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><hr>
<p>假设：如果要排序的项是具有较大范围的整数，我们可以将统计排序思想与基数排序相结合，以实现线性时间复杂度。</p>
<p>在基数排序中，我们将每个项视为一个d位数字的字符串排序（如果需要，在少于d位的整数前放置0）。 对于最低位（最右边）到最高位（最左边），我们通过N个项目，并将它们根据活动数字放入10个队列（每个数字[0..9一个]），这就像改进的统计排序，因为这保持稳定性。然后，我们再次重新连接组，以便后续的迭代。 </p>
<p>注意，我们只执行O（d×（N + k））次迭代。在这个例子中，d &#x3D; 4和k &#x3D; 10。</p>
<hr>
<h1 id="排序算法的其他属性"><a href="#排序算法的其他属性" class="headerlink" title="排序算法的其他属性"></a>排序算法的其他属性</h1><hr>
<p>还有一些其他属性可用于区分排序算法，无论是基于比较还是不基于比较，递归或迭代。 在本节中，我们将讨论in-place和非in-place，稳定vs不稳定，以及缓存排序算法的性能。</p>
<h2 id="In-place排序"><a href="#In-place排序" class="headerlink" title="In-place排序"></a>In-place排序</h2><hr>
<p>如果排序算法在排序过程中仅需要常量（即O（1））的额外空间，则排序算法被称为in-place排序算法。就是这样，一些常量的额外的变量是可以的，但是我们不允许根据输入大小N而有可变长度的变量。 归并排序，由于其合并子程序，需要额外的大小为N的临时数组，所以是非in-place的。 </p>
<h2 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h2><hr>
<p>如果在排序执行后，算法保留具有相同键值的元素的相对顺序，则排序算法称为稳定。 </p>
<p>稳定排序的示例应用：假设我们有按字母顺序排列的学生姓名。现在，如果这个列表按教程组号重新排序（回想一个教程组通常有很多学生），一个稳定的排序算法将确保同一教程组中的所有学生仍然按照名称的字母顺序显示。 </p>
<p>前面算法中稳定排序有：冒泡排序，插入排序，归并排序，统计排序，基数排序<br>不稳定排序有：选择排序，快速排序</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE 总结</title>
    <url>/2017/08/17/JavaSE-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<style>

</style>


<p><a href="http://docs.oracle.com/javase/tutorial/">原文链接</a></p>
<hr>
<h1 id="Java技术"><a href="#Java技术" class="headerlink" title="Java技术"></a>Java技术</h1><hr>
<p>在Java编程语言中，Java源代码都首先被写在一个拓展名为**.java<strong>的文本文件中，这些源代码被javac编译器编译为</strong>.class<strong>文件，也被称为字节码文件，编译后的字节码文件是由机器语言也就是二进制组成它，使用</strong>Java虚拟机<strong>——</strong>Java Virtual Machine**(<strong>JVM</strong>)来运行字节码文件。<br>![compile](&#x2F;images&#x2F;java base&#x2F;getStarted-compiler.gif)<br>因为**.class**文件是在JVM上运行，而JVM又适配不同的操作系统，所以Java语言是跨平台的，<br>![running on multiple platforms.](&#x2F;images&#x2F;java base&#x2F;helloWorld.gif)<br>Java程序不是在底层硬件上直接运行，运行Java程序的被称为Java平台——Java Platform，它由两部分组成：</p>
<ul>
<li>The Java Virtual Machine</li>
<li>The Java Application Programming Interface (API)</li>
</ul>
<span id="more"></span>
<p>Java平台是完全的软件平台，运行在各种底层硬件平台上，Java程序也通过Java平台与底层硬件平台实现隔离，也因此Java平台运行要比本地代码慢些，但随着JVM的优化和性能提升，它已经接近本地代码的性能。<br>![jvm](&#x2F;images&#x2F;java base&#x2F;getStarted-jvm.gif)</p>
<hr>
<h1 id="面向对象编程概念"><a href="#面向对象编程概念" class="headerlink" title="面向对象编程概念"></a>面向对象编程概念</h1><hr>
<p>真实世界的对象由两个特性组成：<strong>状态</strong>和<strong>行为</strong>。面向对象编程通过一个程序对象（Object）模拟真实世界的对象，一个Object在它的<strong>Field</strong>（字段）（一些其他编程语言叫变量）中存储状态，并且通过<strong>Method</strong>（方法）（一些其他编程语言叫函数）来暴露行为。<br>![concepts-object](&#x2F;images&#x2F;java base&#x2F;concepts-object.gif)<br>对象隐藏自己的状态并且只能通过方法进行交互，这被称作<strong>数据封装</strong>（Data Encapsulation），这是面向对象编程的一个基本原则。</p>
<p>真实世界可能有成百上千个同一种类型的对象，可以把同一种类型的对象抽象归纳为一个类。类可以看作对象的蓝图，每个对象都依靠类来创建，创建的对象也被称为类的实例（instance ）</p>
<hr>
<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr>
<p>Java语言同时使用了<strong>字段（Field）</strong>和<strong>变量（Variable）</strong>两个概念，应该来说字段是变量的一种，Java编程语言中包含以下几种变量：</p>
<ul>
<li><strong>实例变量（非静态字段）</strong>：对象在“非静态字段”中存储它们的独立状态，非静态字段是不用<strong>static</strong>关键字修饰的字段，也被称为实例变量。对于一个类的不同实例，它们的值都是独立的。实例变量是与实例相关的</li>
<li><strong>类变量（静态字段）</strong>：类变量是使用<strong>static</strong>修饰的字段，也叫静态字段，静态字段是随着类加载而加载，并存在于静态区中，一个类的不管有多少实例，它们都共享该类的静态字段。类变量是与类相关的。</li>
<li><strong>局部变量</strong>：局部变量存在于方法中，用于存储临时值。局部变量仅在声明它的方法内可见，并且不能声明为static。</li>
<li><strong>参数</strong>：方法接收的变量被称为参数。</li>
</ul>
<p>不同的编程语言对变量命名由不同的规则，Java编程语言有一些对变量名称的要求和惯例；</p>
<ul>
<li>变量名称可以由字母，数字，”$”符号，”_”下划线组成，并且第一字符不能是数字，通常是字母，并且“$”符基本不使用。</li>
<li>变量名称大小写敏感，在相同作用域内不能有重复，并且不能使用Java关键字或保留关键字作为变量名。</li>
<li>作为惯例，变量由多个单词组成时，采用驼峰命名法，首字母小写。如果变量存储一个常量，使用纯大写字符作为名称，并使用下划线分割单词，如static final int NUM_GEARS &#x3D; 6。惯例，下划线不会在其他地方使用。</li>
</ul>
<h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>Java编程语言支持八种原始数据类型，分别是：</p>
<ul>
<li>整数型<ul>
<li><strong>byte</strong>：byte数据类型是一个占用1个字节，有符号的整数。它的值范围是-128≤boolean&lt;127。</li>
<li><strong>short</strong>：short数据类型是一个占用2个字节，有符号的整数。它的值范围是-32,768≤short&lt; 32,767。</li>
<li><strong>int</strong>：int数据类型是一个占用4个字节，有符号的整数。它的值范围是-2<sup>31</sup>≤int&lt; 2<sup>31</sup>-1。在Java 8之后，可以使用int数据类型表示32-bit的无符号整数，范围从0到2<sup>31</sup>-1。</li>
<li><strong>long</strong>：long数据类型是一个占用8个字节，有符号的整数。它的值范围是-2<sup>63</sup>≤long&lt; 2<sup>63</sup>-1。在Java 8之后，可以使用long数据类型表示64-bit的无符号整数，范围从0到2<sup>64</sup>-1。</li>
</ul>
</li>
<li>浮点型<ul>
<li><strong>float</strong>：float数据类型是一个单精度，占4个字节的浮点数。这个数据类型不应该用于精确值，比如货币。请使用java.math.BigDecimal代替。</li>
<li><strong>double</strong>：double数据类型是一个双精度，占8个字节的浮点数。对于小数值，这个数据类型是默认选择。和float一样，它也不应该用于精确值，例如货币。</li>
</ul>
</li>
<li>布尔型<ul>
<li><strong>boolean</strong>：boolean类型只有两种可能值true和false。在JVM中没有boolean类型专用指令，编译后boolean类型实际使用int类型代替，它占4字节，这是为了CPU存取的高效性，但是使用boolean数组时，为了节约内存，它又会被编译为byte数组，每个boolean元素占1个字节。</li>
</ul>
</li>
<li>字符型<ul>
<li><strong>char</strong>：char数据类型是一个占2个字节的 Unicode字符。它的范围从’\u0000’ (or 0)到’\uffff’ (or 65,535 不包含)。</li>
</ul>
</li>
</ul>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>没有赋值的字段初始化时会被自动赋予一个默认值，下表是默认赋予的值：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值（字段）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>String (or any object)</td>
<td>null</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody></table>
<p>局部变量不会被自动赋值，再使用局部变量前要确保被赋值，不然会报编译错误。</p>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>字面值是一个固定值的源代码表示，可以分配一个字面值给相应的原始类型。<br>一个整数型字面值如果以<strong>L</strong>或<strong>l</strong>结尾，则表示<strong>long</strong>类型，否则表示<strong>int</strong>类型，建议使用<strong>L</strong>，以免误认。<strong>byte</strong>,<strong>short</strong>,<strong>int</strong>,和<strong>long</strong>的字面值都可以使用int类型字面值创建。类型long的值超过int的范围可以从long字面值创建。整型字面值可以以三种数字系统表示：</p>
<ul>
<li>十进制：最常用进制</li>
<li>十六进制：字面值前加<strong>0x</strong></li>
<li>二进制：字面值前加<strong>0b</strong>，在JavaSE 7之后支持二进制字面值</li>
</ul>
<p>一个浮点数字面值如果以<strong>F</strong>或<strong>f</strong>结尾，则表示<strong>float</strong>类型，否则是<strong>double</strong>类型，<strong>double</strong>类型字面值也可以用<strong>D</strong>或<strong>d</strong>结尾。浮点数字面值还可以使用<strong>E</strong>或<strong>e</strong>科学表达式。</p>
<p><strong>char</strong>或<strong>String</strong>类型的字面值可能包含Unicode(UTF-16)字符，也可以使用Unicode转义，如’\u0108’。</p>
<p>最后还有一个特殊的字面值 ，叫<strong>class</strong>字面值，任何一种类型后加“**.class**”，如String.class，这指表示类型的对象（Class类型）。</p>
<blockquote>
<p>Java SE 7之后数值字面值可以插入下划线（_）以增强可读性。如long a &#x3D; 777_777_1;</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数值是一个原始类型或对象的容器，数据长度在创建时指定，并且之后是固定的。数组内的项目被称为元素，通过索引获取，索引从0开始。</p>
<p>数组声明有两种形式，<em><strong>type[] anArray</strong></em> 或 ***type anArray[]<em><strong>，数组初始化也有两种形式，一种使用new关键字new type[length] 另一种直接分配值</strong></em>{type,type,type…}<em><strong>。Java还支持多维数组，Java中多维数组每行长度可以任意。获取数组长度可以使用数组的内置属性</strong>length</em>*。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单赋值赋值</td>
</tr>
</tbody></table>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加（也用于字符串拼接）</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
</tr>
</tbody></table>
<p> 你也可以将算数运算符与赋值运算符结合为复合赋值符，如x+&#x3D;1 与 x&#x3D;x+1结果相同，不同的是复合赋值符隐式包含了一个类型强转。</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>一元加运算符，表示正数</td>
</tr>
<tr>
<td>-</td>
<td>一元减运算符，表示负数</td>
</tr>
<tr>
<td>++</td>
<td>自增运算符，表示加1</td>
</tr>
<tr>
<td>–</td>
<td>自减运算符，表示减1</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符，反转boolean值</td>
</tr>
</tbody></table>
<p>自加&#x2F;自减运算符可以用作操作数前缀或后缀，虽然最终结果一样，但做前缀时（++result）时，评估为递增值，后评估。做后缀时（result++），评估为原始值。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
</tbody></table>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>&amp;#124;</td>
<td>逻辑或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与</td>
</tr>
<tr>
<td>&amp;#124;&amp;#124;</td>
<td>短路或</td>
</tr>
<tr>
<td>?:</td>
<td>三元运算符，if-then-else语句缩写</td>
</tr>
</tbody></table>
<p>三元运算符格式为 ** result &#x3D; someCondition ? value1 : value2;**，它可以解读为，如果someCondition为ture，那么给result赋值value1，否则赋值value2。</p>
<h3 id="类型比较运算符"><a href="#类型比较运算符" class="headerlink" title="类型比较运算符"></a>类型比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>将对象与指定的类型进行比较</td>
</tr>
</tbody></table>
<p>当使用instanceof运算符时，左面的操作元是一个对象,右面是一个类.当左面的对象是右面的类创建的对象时,该运算符运算的结果是true,否则是false，instanceof左边操作元显式声明的类型与右边操作元必须是同种类或右边是左边父类的继承关系,不同的继承关系下,编译出错  请记住，null不是任何类的实例。</p>
<h3 id="位和位移运算符"><a href="#位和位移运算符" class="headerlink" title="位和位移运算符"></a>位和位移运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>一元位运算符，反转每个位</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>有符号左移位运算符，</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>有符号右移位运算符，</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与运算符</td>
</tr>
<tr>
<td>^</td>
<td>位异或运算符</td>
</tr>
<tr>
<td>&amp;#124;</td>
<td>位或运算符</td>
</tr>
</tbody></table>
<p>位和位移运算符只能操作整型数据。</p>
<h3 id="运算符优先权"><a href="#运算符优先权" class="headerlink" title="运算符优先权"></a>运算符优先权</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>优先度（从高到低）</th>
</tr>
</thead>
<tbody><tr>
<td>postfix</td>
<td>expr++ expr–</td>
</tr>
<tr>
<td>一元</td>
<td>++expr –expr +expr -expr ~ !</td>
</tr>
<tr>
<td>multiplicative</td>
<td>* &#x2F; %</td>
</tr>
<tr>
<td>加减</td>
<td>+ -</td>
</tr>
<tr>
<td>位移</td>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &gt; &lt;&#x3D; &gt;&#x3D; instanceof</td>
</tr>
<tr>
<td>等于</td>
<td>&#x3D;&#x3D; !&#x3D;</td>
</tr>
<tr>
<td>位AND</td>
<td>&amp;</td>
</tr>
<tr>
<td>位 exclusive OR</td>
<td>^</td>
</tr>
<tr>
<td>位 inclusive OR</td>
<td>&amp;#124;</td>
</tr>
<tr>
<td>逻辑 AND</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>逻辑 OR</td>
<td>&amp;#124;&amp;#124;</td>
</tr>
<tr>
<td>三元</td>
<td>? :</td>
</tr>
<tr>
<td>赋值</td>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; &amp;#124;&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="表达式，语句和代码块"><a href="#表达式，语句和代码块" class="headerlink" title="表达式，语句和代码块"></a>表达式，语句和代码块</h2><hr>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式是由<strong>变量</strong>，<strong>运算符</strong>和<strong>方法调用</strong>组成的构造，它们根据语言的语法进行构造，并被评估为单个值。表达式返回的数据类型由表达式使用的元素决定。<em>复合表达式建议使用”()”来使代码易读和易于维护</em>。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句大致相当于自然语言中的句子。一个语句形成一个完整的执行单元。以下类型的表达式可以通过用分号（;）终止表达式来形成语句。</p>
<ul>
<li>赋值表达式</li>
<li>++或--的使用</li>
<li>方法调用</li>
<li>对象创建表达式</li>
</ul>
<p>这样的语句被称为<strong>表达式语句</strong>。除了<strong>表达式语句</strong>，还有两种语句：<strong>声明语句</strong>和<strong>流程控制语句</strong>。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>一个代码块是平衡大括号之间的一组零个或多个语句，可以在任何允许单个语句使用的地方使用。以下示例BlockDemo说明了代码块的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">condition</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (condition) &#123; <span class="comment">// begin block 1</span></span><br><span class="line">               System.out.println(<span class="string">&quot;Condition is true.&quot;</span>);</span><br><span class="line">          &#125; <span class="comment">// end block one</span></span><br><span class="line">          <span class="keyword">else</span> &#123; <span class="comment">// begin block 2</span></span><br><span class="line">               System.out.println(<span class="string">&quot;Condition is false.&quot;</span>);</span><br><span class="line">          &#125; <span class="comment">// end block 2</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><hr>
<p>流程控制语句可以改变默认的代码执行顺序，它包括<strong>判断语句</strong>（if-then, if-then-else, switch），<strong>循环语句</strong>（for, while, do-while）和<strong>分支语句</strong>（break, continue, return）。</p>
<h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>if语句形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if-then 语句1</span></span><br><span class="line">   <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">            execute statement...;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//  if-then 语句2</span></span><br><span class="line">   <span class="keyword">if</span>(condition)</span><br><span class="line">            execute statement...;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line"><span class="comment">//  if-then-else 语句1</span></span><br><span class="line">   <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">            execute statement1...;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            execute statement2...;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//  if-then-else 语句2</span></span><br><span class="line">   <span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">            execute statement1...;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">            execute statement2...;</span><br><span class="line">        &#125;...		</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<p>switch语句形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  switch语句1</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">            <span class="keyword">case</span> value1: </span><br><span class="line">		statement1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> value2:  </span><br><span class="line">		statement2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> value3:  </span><br><span class="line">		statement3;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">				...</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">		statementN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">				</span><br><span class="line"><span class="comment">//  switch语句2</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">            <span class="keyword">case</span> value1:</span><br><span class="line">            <span class="keyword">case</span> value2:  </span><br><span class="line">		statement2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> value3:</span><br><span class="line">		statement3;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">				...</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">		statementN;</span><br><span class="line">                <span class="keyword">break</span>;				</span><br></pre></td></tr></table></figure>
<p>switch语句支持<strong>byte</strong>,<strong>short</strong>,<strong>char</strong>,<strong>int</strong>原始类型，<strong>Enum</strong>类型（Java SE 5之后），<strong>String</strong>（Java SE 7之后），以及<strong>Character</strong>,<strong>Byte</strong>,<strong>Short</strong>,<strong>Integer</strong>包装类型。switch块中break语句终止包含它的switch语句，如果没有break语句，匹配case标签之后的所有语句都将按顺序执行，而不管后续case标签的表达，直到遇到break语句。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>&#x2F;&#x2F;  while语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">     statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;  do-while语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     statement(s)</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;  for语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; termination; increment) &#123;</span><br><span class="line">    statement(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p><strong>break</strong>语句有两种形式：标签和无标签。标签break语句将流程控制从被标签的语句之后的语句开始执行。<br><strong>continue</strong>语句跳过for，while或do-while循环的当前迭代。它和break一样也有两种形式，有标签和无标签。<br><strong>return</strong>语句从当前方法退出，并且控制流程返回到调用该方法的位置。return语句有两种形式：一种返回一个值，一个不返回。</p>
<hr>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>方法签名</strong>是指方法的名称和参数类型，Java通过方法签名区分两个不同的方法。Java编程语言支持<strong>方法重载</strong>，也这是方法之间可以有相同的名称，但是参数数量或类型不同。方法重载应该谨慎使用，因为它们可以使代码的可读性降低。<br><strong>Parameters</strong>和<strong>Arguments</strong>都是指参数，但是<strong>Parameters</strong>是方法声明中的变量列表，是形式参数，而<strong>Arguments</strong>是调用方法时传入的变量，是实际参数。<br>当需要向一个方法传入不确定数量的参数时，可以使用可变参数<em><strong>varargs</strong></em>，它实际是数组参数的一种简写形式。可变参数形式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">(<span class="type">int</span>... varargsName)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个方法在以下三种情况下返回</p>
<ul>
<li>执行方法内所有语句</li>
<li>遇到一个return语句</li>
<li>抛出一个异常</li>
</ul>
<p>使用void声明的方法没有返回值，不需要return语句，但也可以使用用来控制流程退出方法，此时不能有返回值，否则编译器会报错。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>编译器会为没有构造方法的类提供一个默认的无参构造，这个默认无参构造会调用父类的无参构造，这时要注意，如果父类没有无参构造，会产生编译器错误。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>在实例方法或者构造方法中，this是对当前对象（被调用实例方法或构造方法的对象）的引用。你在实例方法或构造方法中可以通过this引用当前对象的任何成员。</p>
<h4 id="引用字段"><a href="#引用字段" class="headerlink" title="引用字段"></a>引用字段</h4><p>使用this引用字段一般用在字段被参数或局部变量遮蔽时，通常使用在构造方法中，不能用在静态方法中。引用字段使用<strong>this.X</strong>语法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h4><p>使用this引用方法类似于引用字段，引用方法使用**this.method(arg1,arg2…)**语法,this可以引用静态方法，但是不能用在静态方法中。不过一般不使用this引用方法，而是直接调用。</p>
<h4 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h4><p>this还可以引用构造方法，此时this语句必须在一个构造方法中引用另一个构造方法。这样的调用被称为显式构造方法调用。<strong>当使用this调用另一个构造方法时，this语句必须方法在构造方法中的第一行</strong>。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width, height;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用更大域内的成员"><a href="#引用更大域内的成员" class="headerlink" title="引用更大域内的成员"></a>引用更大域内的成员</h4><p>当使用内部类时，如果内部类的成员遮蔽了外部类的成员，要想引用外部类的成员，可以使用以下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutClassName.<span class="built_in">this</span>.X</span><br></pre></td></tr></table></figure>

<h3 id="类成员访问控制"><a href="#类成员访问控制" class="headerlink" title="类成员访问控制"></a>类成员访问控制</h3><p>访问级别修饰符决定其他类是否可以使用一个特定字段或调用特定方法。有两个级别的访问控制：</p>
<ul>
<li>类级：public或package-private（没有明确的修饰符）</li>
<li>成员级：public，private，protected或package-private（没有明确的修饰符）</li>
</ul>
<p>使用public修饰的类可以在任何地方可见，一个类没有修饰符（默认package-private权限）只能在本包内可见。</p>
<p>成员级上的修饰符多了两种权限，private和protected。private修饰符指定该成员只能在本类访问，而protected修饰符指定该成员只能在它本包中进行访问（与package-private一样），另外还可以通过在其他包中的子类进行访问。</p>
<p>下表显示了每个修饰符允许的成员访问</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同类中</th>
<th>同包中</th>
<th>不同包子类</th>
<th>所有</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>protected</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>默认</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>private</td>
<td>O</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<p>如上可见，同类中总是可以访问它的成员，同包中只有private修饰的类成员无法在类外访问，该包之外声明的类的子类可以访问public或protected权限的成员，只有public修饰的成员可以被所有类访问。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p><strong>类变量</strong>也叫<strong>静态字段</strong>，也就是使用<strong>static</strong>关键字修饰的字段，静态字段被该类的所有的实例共享。一个类的类字段可以不用创建对象来引用，而是直接使用类名引用，使用<strong>ClassName.X</strong>语法。最好使用类名引用，而不是用对象，因为这样使类变量角色更加清晰。</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p><strong>类方法</strong>也叫<strong>静态方法</strong>，也就是方法声明中有<strong>static</strong>修饰符的方法。它也可以使用类名直接调用，并且应当这样做。静态方法的常见用途是访问静态字段。</p>
<p>注意，不是所有的实例和类的变量与方法都能组合使用**</p>
<ul>
<li><strong>实例方法可以直接访问实例变量和实例方法</strong>。</li>
<li><strong>实例方法可以直接访问类变量和类方法</strong>。</li>
<li><strong>类方法可以直接访问类变量和类方法</strong>。</li>
<li><strong>类方法不可以直接访问实例变量或实例方法</strong>——它们必须使用对象引用。同时，类方法也不能使用*<em>this</em>  *关键字，因为类方法与实例无关，它没有this可以引用的实例。</li>
</ul>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p><strong>static</strong>修饰符与<strong>final</strong>结合使用用于定义常量，<strong>final</strong>表示这个字段的值不能再被改变。以这种方式定义的常量不能再重新分配，否则会产生一个编译时期错误。按照惯例，常量名字母全部大写。如果由多个单词组成，使用下划线（_）分隔。</p>
<blockquote>
<p>如果将原始类型或string定义为常量，并且它的值在编译时期已知。编译器会将代码中的常量名替换为它的值。这被称为编译时期常量（compile-time constant）。如果源代码中修改常量值，需要重新编译所有使用了该常量的类。</p>
</blockquote>
<h3 id="字段初始化"><a href="#字段初始化" class="headerlink" title="字段初始化"></a>字段初始化</h3><h4 id="静态字段初始化"><a href="#静态字段初始化" class="headerlink" title="静态字段初始化"></a>静态字段初始化</h4><p>通常将字段声明和初始化放在一起，但有时字段初始化需要一些逻辑处理（例如，错误处理或for循环来填充复杂数组），则需要分开。实例变量可以在构造方法中初始化，以添加一些逻辑。对于类变量，由于它是和类相关的，Java编程语言使用<strong>静态初始化代码块</strong>（static initialization blocks）提供此功能。其形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 进行初始化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以有多个静态初始化代码块，并且可以在类体内任意位置，运行时期系统按照它们在源代码中的顺序进行调用。<br>此外也可以使用一个私有静态方法来初始化静态变量字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Whatever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">varType</span> <span class="variable">myVar</span> <span class="operator">=</span> initializeClassVariable();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> varType <span class="title function_">initializeClassVariable</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialization code goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有静态方法的优点是，如果需要重新初始化类变量，它们可以稍后重用。</p>
<h4 id="实例成员初始化"><a href="#实例成员初始化" class="headerlink" title="实例成员初始化"></a>实例成员初始化</h4><p>实例变量除了可以在构造方法中初始化外，还有两个选择：<strong>初始化代码块</strong>和<strong>final方法</strong>。</p>
<p>初始化代码块就像静态初始化代码块一样，除了没有static关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// whatever code is needed for initialization goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:#ec70ae;">Java编译器会将初始化代码块复制到每个构造方法中。</font>  </p>
<p>因此，这种方法可以用于在多个构造方法之间共享一个代码块。</p>
<p>final方法不可以在子类中重写，所以它也可以用于初始化实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Whatever</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">varType</span> <span class="variable">myVar</span> <span class="operator">=</span> initializeInstanceVariable();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> varType <span class="title function_">initializeInstanceVariable</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialization code goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类想要重用初始化方法时，这特别适用。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><hr>
<p>对象创建语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">varName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(args1,args2);</span><br></pre></td></tr></table></figure>
<p>每个对象创建语句都包含三部分</p>
<ol>
<li>声明：Object varName属于变量声明部分，不像原始类型变量声明，引用类型声明不会为其分配内存空间。</li>
<li>实例化：new关键字是一个Java操作符，它为变量分配内存并返回分配的内存的引用，它还同时调用对象构造方法</li>
<li>初始化：new操作符后跟着一个 构造方法调用，它初始化这个新对象。</li>
</ol>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><hr>
<p>嵌套类分为两种：<strong>静态</strong>和<strong>非静态</strong>。使用static声明的嵌套类称为静态嵌套类。非静态嵌套类称为内部类。<br>嵌套类是包含它的类的成员。非静态嵌套类（内部类）可以访问其他的类成员，即使是被private修饰的。静态嵌套类则无法访问其他类成员（实例成员）。作为外部类（OuterClass）的成员，嵌套类可以使用private, public, protected, 或package private来声明。<br>使用嵌套了有以下三种理由：</p>
<ul>
<li><strong>它是将只会在一个地方使用的类逻辑分组的方式。</strong>如果一个类只对另一个类有用，，那么把它嵌入该类并将它们保持在一起是合乎逻辑的。嵌套的例如”助手类“使它们的包结构更加精简。</li>
<li><strong>它增加了封装性。</strong>考虑两个顶级类，A和B，B需要访问A需要声明尾private的成员。通过将类B藏在类A中，A的成员可以声明为private，而B还可以访问它们。此外，B本身也可以从外界隐藏起来。</li>
<li><strong>它可以导致更可读和可维护的代码：</strong>在顶级类中嵌套小类将代码更接近使用的位置。</li>
</ul>
<h3 id="静态嵌套类"><a href="#静态嵌套类" class="headerlink" title="静态嵌套类"></a>静态嵌套类</h3><p>与类方法和类变量一样，静态嵌套类是与其外部类相关的。就像静态类方法，静态嵌套类不能直接引用包含它的类的实例变量或方法。只能通过对象引用来使用。静态嵌套类可以用包含它的类的类名来访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.StaticNestedClass</span><br></pre></td></tr></table></figure>
<p>例如，要想创建静态嵌套类的对象，使用以下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.<span class="type">StaticNestedClass</span> <span class="variable">nestedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticNestedClass();</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>与实例方法和实例变量一样，内部类是与包含它的类的实例相关的，并且可以直接访问对象的方法和字段。<font style="color:#ec70ae;">同时，由于内部类是与实例相关，所以它不能定义任何静态成员</font>。<br>内部类的实例只能存在于外部类的实例中，要想实例化一个内部类，必须首先实例化外部类。然后在外部对象中创建内部对象，如下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">innerObject</span> <span class="operator">=</span> outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>
<p>还有两种特殊的内部类：<strong>局部类</strong>和<strong>匿名类</strong>。</p>
<blockquote>
<p>强类不建议序列化内部类，不然在不同的JRE实现反序列化时可能出现不兼容性。</p>
</blockquote>
<h4 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h4><p>　　局部类是定义在代码块（如for循环，if字句或方法）中的类，通常定义在方法体中。<font style="color:#ec70ae;">局部类可以访问包含它的类中的成员。此外，局部类还可以访问局部变量或方法参数，但是局部类只能访问声明为final的变量。</font>局部类访问的局部变量或参数叫做捕获变量（captured variable），局部类会复制一份该变量，为了保持两份变量一致性，所以只能访问final修饰的，<strong>但在Java 8 之后局部类还可以访问事实上不变（effectively final）的变量，也就是虽然没有用final修饰，但是局部类内没有修改它的值</strong>。<br>　　局部类类似于内部类，不能定义或声明任何静态成员，在静态方法中的局部类只能引用包含它的类的静态成员。<br>　　局部类是非静态的，因为它们可以访问包含它们的类的实例成员。因此，它们不能包含大多数类型的静态声明。<br>　　不能在代码块中声明接口，因为接口本质上是静态的。也不能在局部类中声明静态初始化器或成员接口。但是局部类可以具有静态成员，只要它们是常量变量（常量变量是原始类型或类型的字符串，它被声明为final，并使用编译时常量表达式初始化。）。</p>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>匿名类能够同时声明和实例化一个类。匿名类表达式包含以下内容：</p>
<ul>
<li>new操作符</li>
<li>要实现的接口或要继承的类的名字。</li>
<li>包含构造方法参数的括号，就如普通类实例创建表达式。注意：当实现接口时没有构造方法，所以可以使用一个空的括号。</li>
<li>类声明体。</li>
</ul>
<p>就像局部类，匿名类也能捕获变量；它们对包含它们的域中的局部变量有相同的访问权限：</p>
<ul>
<li>匿名类可以访问包含它的类的成员；</li>
<li>匿名类不能访问包含它们域中不是final或事实final的变量；</li>
<li>就如嵌套类，匿名类中的声明类型（比如变量）会遮蔽它们所处域中同名的声明。</li>
</ul>
<p>匿名类对于它们的成员有和局部类一样的限制</p>
<ul>
<li>不可以在匿名类中声明静态初始化器或者成员接口</li>
<li>匿名类可以有静态成员，只要它们是常量变量。</li>
</ul>
<p>请注意，您可以在匿名类中声明以下内容：</p>
<ul>
<li>字段</li>
<li>额外的方法（即使他们没有实现任何超类型的方法）</li>
<li>实例初始化器</li>
<li>局部类</li>
</ul>
<p><strong>但是，你不可以在匿名类中声明构造方法</strong>。   </p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>与局部类与匿名类一样，lambda表达式可以捕获变量，并且对封闭域内的局部变量有相同的访问权限，只能访问final或事实fianl的局部变量。然而，不像局部类和匿名类，lambda表达式不会有任何变量遮蔽问题，Lambda表达式是词法上确定范围。这意味着它们不会从超类型继承任何名称或引入新的域级别。在lambda表达式中的声明就像在包含它的域中声明一样。</p>
<h3 id="嵌套类适用场景"><a href="#嵌套类适用场景" class="headerlink" title="嵌套类适用场景"></a>嵌套类适用场景</h3><ul>
<li><strong>局部类</strong>：如果需要创建一个类的多个实例，访问其构造方法或引入新的命名类型（因为，例如，以后需要调用其他方法），请使用它。</li>
<li><strong>匿名类</strong>：需要声明字段或额外方法的时候使用它</li>
<li><strong>Lambda表达式</strong><ul>
<li>如果需要封装单个行为单位，并传递给其他代码，请使用它</li>
<li>如果需要一个函数接口的简单实例，并且不适用前面的条件（例如，你不需要构造函数，命名类型，字段或其他方法）</li>
</ul>
</li>
<li><strong>嵌套类</strong>：如果类似于局部类的要求，并希望其类型更广泛地可用，并且不需要访问局部变量或方法参数，使用它。<ul>
<li>如果需要访问包含它的实例的非公开字段和方法，使用非静态嵌套类，否则使用静态嵌套类。</li>
</ul>
</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><hr>
<p>枚举类型（ enum type）是一种特殊的数据类型，可使变量成为一组预定义的常量。因为是常量，所以枚举类型字段名称都是大写字母。使用enum关键字定义枚举类型。</p>
<blockquote>
<p>所有枚举隐式继承了java.lang.Enum。因为一个类之类继承一个父类，Java不支持多继承，所以枚举无法继承其他类。</p>
</blockquote>
<p>枚举中常量需要先于字段和方法继承。常量要以分号结尾。枚举的构造方法必须是<strong>package-private</strong>或<strong>private</strong>权限。它会自动创建在枚举正文开头定义的常量。不能自己调用枚举的构造方法。</p>
<hr>
<h1 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h1><hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><hr>
<p>在Java编程语言中，接口是类似于类的引用类型，只能包含常量，方法签名，default方法，static方法和嵌套类型。只用default方法和static方法拥有方法体。接口不能被实例化，它们只能被类实现，或被其他接口继承。</p>
<h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>接口定义语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Name</span> extend ParentInterface1,ParentInterface2...&#123;</span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">		<span class="keyword">default</span> <span class="title function_">mehtod2</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">//code...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">//code...</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和类不同，接口可以继承多个父接口。使用逗号（,）分割多个父接口。接口体可以包含<strong>abstract方法</strong>,<strong>default方法</strong>以及<strong>static方法</strong>。abstract方法后跟一个分号，但没有大括号（抽象方法不包含实现）。接口中所有的abstract，default，static方法隐式使用public修饰，所以public可以忽略。</p>
<p>此外接口可以包含常量声明。接口中所有的常量值隐式使用public，static，和final修饰，所以这些也可以忽略。</p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类可以实现多个接口，使用implements关键字实现接口。多个接口使用逗号（,）分割，如果这个类同时还继承其他类，按惯例，implements字句放在extend字句后。</p>
<h3 id="Dafault方法"><a href="#Dafault方法" class="headerlink" title="Dafault方法"></a>Dafault方法</h3><p>如果有一个接口名为DoiT：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DoIt</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> x)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">doSomethingElse</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想向这个接口中添加第三个方法，直接添加的话会破坏类结构，因为原来实现该接口的类都必须实现新的方法。为了避免这个问题有两种解决方法。<br>第一种是创建新的接口继承DoIt：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DoItPlus</span> <span class="keyword">extends</span> <span class="title class_">DoIt</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">didItWork</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> x, String s)</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你的代码可以选择使用旧接口或者新的升级接口。<br>第二种是在原来接口中将新添方法定义为default方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DoIt</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> x)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">doSomethingElse</span><span class="params">(String s)</span>;</span><br><span class="line">   <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">didItWork</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> x, String s)</span> &#123;</span><br><span class="line">       <span class="comment">// Method body </span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，必须为default方法提供实现。此外还可以定义一个新的static方法到已有接口中。原来这样实现该接口的类不必修改或重新编译以适应新添的方法。</p>
<p>当另一个接口继承一个拥有default方法的接口，你可以做以下事：</p>
<ul>
<li>没有提到default方法，这允许扩展的接口继承default方法。</li>
<li>重新声明default方法，使它变为abstract。</li>
<li>重新定义default方法，这会重写它。</li>
</ul>
<h3 id="Static方法"><a href="#Static方法" class="headerlink" title="Static方法"></a>Static方法</h3><p>除了default方法之外，还可以在接口中定义静态方法。（静态方法是与定义它的类相关联的方法，而不是与任何对象相关联。类的每个实例都共享其静态方法。）这样更容易在库中组织辅助方法;可以在同一个接口中指定静态方法到接口上，而不是分开的类上。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<p>子类会从父类继承所有的<strong>public</strong>和<strong>protected</strong>成员（字段，方法，嵌套类），无论子类的包在哪。如果子类和父类同包，它还可以继承<strong>package-private</strong>成员。构造方法不是成员，所以不会继承，但是可以从子类调用父类的构造方法。以下是子类可以在继承关系中执行的操作：</p>
<ul>
<li>可以直接使用继承字段</li>
<li>可以在子类声明和父类字段相同名称的字段，这样隐藏了父类该字段</li>
<li>可以声明一个父类中没有的字段</li>
<li>可以直接使用继承的方法</li>
<li>可以在子类写一个新的实例方法，与父类中的有相同方法签名，这样重写了父类该方法</li>
<li>可以在子类写一个新的static方法，与父类中的有相同方法签名，这样隐藏了父类该方法</li>
<li>可以声明一个父类中没有的新方法</li>
<li>可以写一个子类构造方法，隐式调用或通过使用super关键字。来调用父类中的构造方法。</li>
</ul>
<p>子类不能继承父类的private成员，但是可以通过父类public或protecteds方法间接访问。由于嵌套类可以访问包含它的类的所有成员，包括private，所以也可以通过public或protected的 嵌套类间接访问父类private成员。</p>
<h3 id="接口多继承"><a href="#接口多继承" class="headerlink" title="接口多继承"></a>接口多继承</h3><p><font style="color:#ec70ae;">类与接口的一个显著区别是，类有字段而接口不可以有字段，因为对象使用字段保存状态，Java编程语言不允许多继承的一个原因就是避免状态的多继承 问题。因为接口没有字段，所以不会有状态的多继承问题。</font></p>
<p><strong>实现的多继承</strong>（Multiple inheritance of implementation）是从多个类中继承方法定义的能力，但也因此会产生一些问题。比如，一个接口多个父类中包含冲突和歧义的名称。此外，default方法也引入了一种实现的多重继承形式。一个类可以可以实现多个接口，接口中可能包含相同名称的default方法。Java编译器提供了一些规则来确定特定类使用的default方法。</p>
<p>Java编程语言支持<strong>类型的多继承</strong>（multiple inheritance of type），它是类实现多个接口的能力。一个对象可能有多个类型：它自身类的类型，它实现的多个接口的类型。</p>
<h3 id="方法重写与隐藏"><a href="#方法重写与隐藏" class="headerlink" title="方法重写与隐藏"></a>方法重写与隐藏</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>与父类方法拥有有相同签名（名称，以及其参数的数量和类型）的子类实例方法重写了父类方法。</p>
<p><strong>重写方法</strong>（overriding method ）和它重写的方法有相同的<strong>名称</strong>，<strong>参数数量和类型</strong>，以及<strong>返回类型</strong>。一个重写方法还可以返回一个被重写方法返回类型的子类型。这个子类型称为<strong>协变返回类型</strong>（covariant return type）。</p>
<p>如果想要重写一个方法，可以使用**@Override**注解指示编译器要重写父类的方法。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>如果子类定义一个静态方法和父类中的静态方法有相同的签名，那么子类中的方法隐藏（hide）了父类中的对应方法。</p>
<p>隐藏静态方法和重写实例方法之间的区别有重要意义：</p>
<ul>
<li><strong>被调用的重写实例方法版本是在子类中的那一个。</strong></li>
<li><strong>被调用的隐藏实例方法版本取决于它是用父类中调用还是子类中调用。</strong></li>
</ul>
<p>考虑下面一个例子包含了两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The static method in Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInstanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The instance method in Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The static method in Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInstanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The instance method in Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> myCat;</span><br><span class="line">        myAnimal.testClassMethod();</span><br><span class="line">        myAnimal.testInstanceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cat类覆盖了Animal中的实例方法，并隐藏了在Animal中静态方法。控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The static method in Animal</span><br><span class="line">The instance method in Cat</span><br></pre></td></tr></table></figure>

<h4 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h4><p>接口中的default方法和abstract方法像实例方法一样被继承。但是，当类或接口的父类型提供具有相同签名的多个default方法时，Java编译器遵循继承规则来解决名称冲突。这些规则是由以下两个原则驱动的：</p>
<ul>
<li><strong>实例方法优于接口default方法。</strong><br>考虑以下类和接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am a horse.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am able to fly.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mythical</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am a mythical creature.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pegasus</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Flyer</span>, Mythical &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">Pegasus</span> <span class="variable">myApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pegasus</span>();</span><br><span class="line">        System.out.println(myApp.identifyMyself());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
控制台输出“I am a horse”。</li>
<li><strong>已经被其他候选者重写的方法被忽略。</strong>当超类型共享共同父级时，可能会出现这种情况。<br>考虑以下接口和类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am an animal.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayer</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am able to lay eggs.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FireBreather</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dragon</span> <span class="keyword">implements</span> <span class="title class_">EggLayer</span>, FireBreather &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">Dragon</span> <span class="variable">myApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dragon</span>();</span><br><span class="line">        System.out.println(myApp.identifyMyself());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
控制台输出“I am able to lay eggs”</li>
</ul>
<p>如果两个或多个独立定义的default方法冲突，或default方法与abstract方法冲突，则Java编译器将生成编译器错误。你必须显式重写超类型方法。<br>考虑以下两个接口OperateCar与FlyCar ，它们有两个相同的方法(startEngine):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OperateCar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startEngine</span><span class="params">(EncryptedKey key)</span> &#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlyCar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startEngine</span><span class="params">(EncryptedKey key)</span> &#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类同时实现OperateCar和FlyCar必须重写方法startEngine。<font style="color:#ec70ae;">可以使用super关键字调用父类型中任何一个这个default实现。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyingCar</span> <span class="keyword">implements</span> <span class="title class_">OperateCar</span>, FlyCar &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startEngine</span><span class="params">(EncryptedKey key)</span> &#123;</span><br><span class="line">        FlyCar.<span class="built_in">super</span>.startEngine(key);</span><br><span class="line">        OperateCar.<span class="built_in">super</span>.startEngine(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>super关键字之前的名称（这个例子中是FlyCar或OperateCar）必须引用直接的父接口，该父接口定义或继承了调用的default方法。这种形式的方法调用不限于区分多个包含具有相同签名的default方法的实现的接口。你可以使用super关键字在类和接口中调用default方法。</p>
<p><font style="color:#ec70ae;">从类继承的实例方法可以重写抽象接口方法。</font>考虑以下接口和类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mammal</span> &#123;</span><br><span class="line">    String <span class="title function_">identifyMyself</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">identifyMyself</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am a horse.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mustang</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Mammal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">Mustang</span> <span class="variable">myApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mustang</span>();</span><br><span class="line">        System.out.println(myApp.identifyMyself());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出“I am a horse”。Mustang从Horse继承了identifyMyself方法，该方法重写了在接口Mammal中相同名字的抽象方法。</p>
<blockquote>
<p><strong>接口中的静态方法从不会被继承</strong>。</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p><strong>重写方法的访问权限可以比被重写的方法更大，但不能更小。</strong>例如一个在父类中protected修饰的实例方法，可以在子类中设置为public，但不能是private。<br><strong>此外如果将父类中的实例方法在子类中改为静态方法，会产生编译时期错误，反之亦然。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下表总结了当使用与超类中的方法相同的签名定义方法时会发生什么。</p>
<table>
<thead>
<tr>
<th></th>
<th>父类<br/>实例方法</th>
<th>父类<br/>静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>子类<br/>实例方法</td>
<td>重写</td>
<td>编译时期错误</td>
</tr>
<tr>
<td>子类<br/>静态方法</td>
<td>编译时期错误</td>
<td>隐藏</td>
</tr>
</tbody></table>
<blockquote>
<p>在一个子类中，可以重载从超类继承的方法。这种重载的方法既不隐藏也不重写超类实例方法 - 它们是子类新的方法。</p>
</blockquote>
<h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>在多态的情况下，声明为父类类型的引用变量只能调用父类中的方法，但如果此变量实际引用的是子类对象，而子类对象中重写了父类的方法，这时父类对象调用的是子类中的方法，这种机制就成为<strong>虚方法调用</strong>（virtual method invocation ）。</p>
<p>在Java中，所有非静态方法都是默认的“虚函数（virtual functions.）”。只有标有关键字final（不能被重写）的方法以及不能被继承的private方法都是非虚的。虚方法在编译时期和运行时期被区别对待。JVM专门利用一个虚方法表来用于虚方法分配。</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在一个类中，如果有和父类中相同名称的字段，该字段会隐藏父类字段，<strong>即使字段类型并不相同</strong>。子类可以通过super关键字来引用父类被隐藏字段。一般来说，不建议隐藏字段，因为它使代码难以阅读。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><strong>super</strong>关键字可以在子类中调用父类被隐藏的字段和方法。此外，<strong>super</strong>还可以调用父类的构造方法，使用<strong>super</strong>调用父类构造方法时，必须放在子类构造方法方法体第一行。</p>
<blockquote>
<p>如果构造方法没有显式调用父类构造方法，Java编译器会自动将插入对父类的无参数构造的调用。如果父类没有无参构造，那么会产生一个编译时期错误。Object有这样一个构造函数，所以如果Object是唯一的父类，没有问题。</p>
</blockquote>
<p>子类构造方法显式或隐式地调用其父类的构造方法时，会有一整链的构造方法调用，一直返回到Object的构造方法。这被称为构造链。</p>
<h3 id="写一个final类和方法"><a href="#写一个final类和方法" class="headerlink" title="写一个final类和方法"></a>写一个final类和方法</h3><p>你可以声明一个类的部分或全部方法为<strong>final</strong>。你在方法声明中使用final关键字来表示这个方法不能被子类重写。Object类有一些方法就是final的。<br>从构造方法调用的方法一般都被声明为final。如果一个构造方法调用一个非final方法，子类可能会以不期望的方法重定义这个方法。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">		initMethod();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;init Father method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">		initMethod();	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;init Son method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init Son method</span><br><span class="line">init Son method</span><br></pre></td></tr></table></figure>
<p>注意，你也可以声明整个类为final，被声明为final的类不能被子类化。当创建一个不可变类时这是非常有用的，像String类。</p>
<h3 id="抽象方法和类"><a href="#抽象方法和类" class="headerlink" title="抽象方法和类"></a>抽象方法和类</h3><p>抽象类可能包含也可能不包含抽象方法。当抽象类被子类化，子类需要提供所有抽象方法的实现，否则则类必须被声明为abstract。</p>
<blockquote>
<p>接口中未声明为default或static的方法隐式声明abstract，所以abstract修饰符不与接口方法一起使用（可以使用，但是没有必要）。</p>
</blockquote>
<h4 id="抽象类与接口比较"><a href="#抽象类与接口比较" class="headerlink" title="抽象类与接口比较"></a>抽象类与接口比较</h4><p>抽象类和接口都不能实例化，并且都可以混合包含使用或不使用实现声明的方法。然而，对于抽象类，可以声明不是static和final的字段，并且可以定义public，protected，和private的具体方法。对于接口，所有的字段自动为public, static, 和final，并且所有你声明或定义（如default方法）的方法都是public。</p>
<p>抽象类也可以实现接口，此时可以不必实现接口的方法。</p>
<hr>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><hr>
<p>package语句必须放在源文件的第一行。每个源文件只能有一个package语句，并且它适用于文件中所有的类型。</p>
<blockquote>
<p>如果将多个类型放入一个源文件，只能有一个为public，并且它必须与源文件使用相同的名字。</p>
</blockquote>
<h2 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h2><hr>
<p>包名采用小写形式，以避免与类或接口冲突。公司使用他们反向的互联网域名来开始他们的包名——例如由example.com创建的名为mypackage的软件包的com.example.mypackage。</p>
<p>Java语言中的本身的包就以**java.<strong>或</strong>javax.**开头</p>
<p>在某些情况下，互联网域名可能不是有效的包名称。如包含一个连字符或特殊字符。如果包名称以数字或其他字符开头，作为Java名称的开头是非法的，或者如果包名包含保留的Java关键字，例如“int”。在这种情况下，建议的惯例是添加下划线。</p>
<h2 id="使用包成员"><a href="#使用包成员" class="headerlink" title="使用包成员"></a>使用包成员</h2><hr>
<p>构成包的类型称为包成员。要在其包之外使用public包成员，必须执行以下操作之一：</p>
<ul>
<li>以完全限定名称引用成员</li>
<li>导入包成员</li>
<li>导入成员的整个包</li>
</ul>
<h3 id="导入包成员"><a href="#导入包成员" class="headerlink" title="导入包成员"></a>导入包成员</h3><p>使用import关键字导入包成员，import位于package语句后，类型定义前。如果使用一个包很多成员的话，可以使用（*）通配符导入整个包。import语句中的星号只能用于指定包中的所有类，它不能用于匹配包中的类的一个子集。</p>
<blockquote>
<p>import还可以导入一个封闭类中的public嵌套类。如graphics.Rectangle包含一个嵌套类Rectangle.DoubleWide和Rectangle.Square, 你可以使用以下两个语句导入Rectangle及其嵌套类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> graphics.Rectangle;</span><br><span class="line"><span class="keyword">import</span> graphics.Rectangle.*;</span><br></pre></td></tr></table></figure>
<p>请注意，第二个import语句不会导入Rectangle。<br>如果导入的两个包中包含相同名称的类型，这种情况，必须使用完全限定名称来正确指出要使用的类型。</p>
<p>为方便起见，Java编译器会为每个源文件自动导入两个完整的包：</p>
<ol>
<li><strong>java.lang</strong></li>
<li><strong>当前包</strong></li>
</ol>
<h3 id="包的明显层次结构"><a href="#包的明显层次结构" class="headerlink" title="包的明显层次结构"></a>包的明显层次结构</h3><p><strong>首先，包似乎是分级的，但实际不是。</strong>例如Java API包含java.awt包，java.awt.color包，java.awt.font包以及许多以java.awt开头的其他包。但是，java.awt.color包，java.awt.font包和其他java.awt.xxxx包不包含在java.awt包中。前缀java.awt（Java抽象窗口工具包）用于许多相关的包，是用来使包关系变的明显，但不显示包含关系。</p>
<p>导入java.awt.*导入java.awt包中的所有类型，但它不导入java.awt.color，java.awt.font或其他任何java.awt.xxxx包。</p>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>有些情况需要频繁访问一个或两个类的静态final字段（常量）和静态方法，这时可以使用<strong>静态导入</strong>（static import ）语句。例如，可以使用静态导入语句导入java.lang.Math的静态成员，这样不需要在类名前缀Math。 Math的静态成员可以单独导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br></pre></td></tr></table></figure>
<p>或以组导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>
<p>一旦它们被导入，静态成员就可以不使用限定名使用。如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> cos(PI * theta);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
  </entry>
  <entry>
    <title>《Maven官方文档》（一）入门指南</title>
    <url>/2017/07/01/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><a href="http://maven.apache.org/guides/getting-started/index.html">原文链接</a>  </p>
<h1 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h1><p>　　乍一看Maven有很多东西，但简而言之，Maven是一个通过在最佳实践的使用中提供一个明确的路径，将模式应用于项目的基础构建，用于促进理解和生产力的尝试。Maven实质上是一个项目管理与理解工具，它提供了一种帮助管理的方法：</p>
<ul>
<li>构建（Builds）</li>
<li>文档（Documentation）</li>
<li>报表（Reporting）</li>
<li>依赖（Dependencies）</li>
<li>SCMs</li>
<li>发布（Releases）</li>
<li>分布式（Distribution）</li>
</ul>
<p>如果你想要了解Manver的更多背景信息，可以查阅<a href="http://maven.apache.org/background/philosophy-of-maven.html">Maven的哲学</a>和<a href="http://maven.apache.org/background/history-of-maven.html">Maven的历史</a>现在我们来看看用户如何从使用Maven中获益。</p>
<span id="more"></span>

<h1 id="使用Maven对我的开发进程有怎么样好处"><a href="#使用Maven对我的开发进程有怎么样好处" class="headerlink" title="使用Maven对我的开发进程有怎么样好处"></a>使用Maven对我的开发进程有怎么样好处</h1><p>　　Maven通过采用标准的惯例和做法来加快您的开发周期，同时也帮助你实现更高的成功率，为你的构建进程提供诸多好处。</p>
<h1 id="如何配置Maven"><a href="#如何配置Maven" class="headerlink" title="如何配置Maven"></a>如何配置Maven</h1><p>　　Maven的默认配置通常就足够了，但是如果你需要更改本地缓存，或者需要一个HTTP代理，你将需要创建配置。更多信息参阅“<a href="http://maven.apache.org/guides/mini/guide-configuring-maven.html">Maven配置指南</a>”。</p>
<h1 id="怎么创建我第一个Maven项目"><a href="#怎么创建我第一个Maven项目" class="headerlink" title="怎么创建我第一个Maven项目"></a>怎么创建我第一个Maven项目</h1><p>　　我们要直接进入创建你的第一个Maven项目。要创建我们的第一个Maven项目，我们将使用Maven的原型机制。原型被定义为原始模式或模型，从该模式或模型中可以制作同一种类的其他所有东西。在Maven中，原型是项目的一个模板，它与一些用户输入相结合，以生成针对用户要求定制的Maven工作。我们将向您展示原型机制如何运作，但如果您想了解更多关于原型的信息，请参阅我们的“<a href="http://maven.apache.org/guides/introduction/introduction-to-archetypes.html">原型简介</a>”。<br>　　现在创建你的第一个项目！为了创建最简单的Maven项目，请从命令行执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -B archetype:generate \</span><br><span class="line">  -DarchetypeGroupId=org.apache.maven.archetypes \</span><br><span class="line">  -DgroupId=com.mycompany.app \</span><br><span class="line">  -DartifactId=my-app</span><br></pre></td></tr></table></figure>
<p>　　一旦你执行了这个命令，你会注意到一些事情发生了。首先，您将注意到，为新项目创建了一个名为my-app的目录，此目录包含一个名为pom.xml的文件，该文件应如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　pom.xml包含此项目的项目对象模型（POM）。POM是Maven的基本工作单位。这点很重要，需要被牢记，因为Maven本质上是以项目为中心的，在这里一切都是围绕着一个项目的概念。简而言之，POM包含了关于你的项目的所有重要信息，并且它实质上是一个为查找与您的项目相关的任何内容一站式服务。明白了POM的重要性，我们推荐新用户参阅“<a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html">POM简介</a>”。</p>
<p>　　这是一个非常简单的POM，但仍然展示了每个POM包含的关键元素，所以让我们来看看每个元素，以熟悉POM的基本要素：</p>
<ul>
<li><strong>project</strong> 这是所有Maven pom.xml文件中的顶级元素。</li>
<li><strong>modelVersion</strong> 这个元素指示了该POM正在使用的对象模型的版本。模型本身的版本很少变化，但是如果Maven开发人员认为有必要更改这个模型，则为了确保使用的稳定性，它是强制性的。</li>
<li><strong>groupId</strong> 此元素指示创建项目的组织或组的唯一标识符。groupId是项目的关键标识符之一，通常基于您组织的完全限定域名。例如，org.apache.maven.plugins是所有Maven插件的指定groupId。</li>
<li><strong>artifactId</strong>此元素指示此项目正在生成的主要artifact的唯一基础名称。项目的主要artifact通常是一个JAR文件。诸如源码包之类的辅助artifacts也使用artifactId作为其最终名称的一部分。由Maven生成的典型artifacts将具有&lt;artifactId&gt; - &lt;version&gt;.&lt;extension&gt;（例如myapp-1.0.jar）的形式。</li>
<li><strong>packaging</strong> 此元素指示此artifact 使用的包类型（例如JAR，WAR，EAR等）。这不仅意味着如果生成的artifact是JAR,WAR,或者EAR，同时也指示了用作构建过程一部分的特定生命周期。（生命周期是我们将在指南中进一步讲解的一个话题。现在只需要记住，一个项目指示的packaging可以在定制构建生命周期中发挥作用。）packaging元素的默认值是JAR，所以你不必为大多数项目指定。</li>
<li><strong>version</strong> 该元素指示项目生成的artifact的版本。Maven在帮助您进行版本管理方面有很长的路要走，并且您会经常在version中看到SNAPSHOT指示符，这表明一个项目还处于开发状态。我们将在本指南中讨论<a href="#%E4%BB%80%E4%B9%88%E6%98%AFSNAPSHOT%E7%89%88%E6%9C%AC%EF%BC%9F">snapshots</a>的使用及其进一步工作。</li>
<li><strong>name</strong> 此元素指示用于项目的显示名称。这通常用在Maven生成的文档中。</li>
<li><strong>url</strong> 这个元素指示可以在哪里找到该项目的地址。这通常用在Maven生成的文档中。</li>
<li><strong>description</strong> 该元素提供了您的项目的基本描述。这通常用在Maven生成的文档中。</li>
</ul>
<p>有关可用于POM的元素的完整参考，请参阅我们的<a href="http://maven.apache.org/ref/current/maven-model/maven.html">“POM参考”</a>。现在让我们回到手头的项目。</p>
<p>　　在你的第一个项目的原型生成后，你会注意到以下的目录结构被创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   `-- java</span><br><span class="line">    |       `-- com</span><br><span class="line">    |           `-- mycompany</span><br><span class="line">    |               `-- app</span><br><span class="line">    |                   `-- App.java</span><br><span class="line">    `-- test</span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如您所见，从原型创建的项目有一个POM，一个应用程序源的源代码树和一个测试源的源代码树。这是Maven项目的标准布局（应用程序源代码在“${basedir}&#x2F;src&#x2F;main&#x2F;java”中，测试源代码在“ ${basedir}&#x2F;src&#x2F;test&#x2F;java”中，其中“${basedir}”表示包含了pom.xml的目录）。<br>　　如果要手动创建一个Maven项目，这是我们建议使用的目录结构。这是Maven惯例，要了解更多信息，您可以阅读我们的<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">“标准目录布局简介”</a>。<br>　　现在我们有一个POM，一些应用程序源码和一些测试源码，你可能会问…</p>
<h1 id="如何编译我的程序源码？"><a href="#如何编译我的程序源码？" class="headerlink" title="如何编译我的程序源码？"></a>如何编译我的程序源码？</h1><p>　　切换到由原型创建的pom.xml所在的目录：生成并执行以下命令来编译程序源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>
<p>执行该命令后，您将看到如下所示的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Building Maven Quick Start Archetype</span><br><span class="line">[INFO]    task-segment: [compile]</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] artifact org.apache.maven.plugins:maven-resources-plugin: \</span><br><span class="line">  checking for updates from central</span><br><span class="line">...</span><br><span class="line">[INFO] artifact org.apache.maven.plugins:maven-compiler-plugin: \</span><br><span class="line">  checking for updates from central</span><br><span class="line">...</span><br><span class="line">[INFO] [resources:resources]</span><br><span class="line">...</span><br><span class="line">[INFO] [compiler:compile]</span><br><span class="line">Compiling 1 source file to &lt;dir&gt;/my-app/target/classes</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESSFUL</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 3 minutes 54 seconds</span><br><span class="line">[INFO] Finished at: Fri Sep 23 15:48:34 GMT-05:00 2005</span><br><span class="line">[INFO] Final Memory: 2M/6M</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>　　第一次执行这个（或任何其他）命令时，Maven将需要下载其完成命令所需的所有插件和相关依赖项。对于一个简洁安装的Maven，这可能需要相当长的一段时间（在上面的输出中，它花了差不多4分钟）。如果再次执行该命令，Maven现在已经有了它所需的东西，因此不需要下载任何新内容，并能够更快地执行命令。<br>　　从输出可以看出，编译的类被放在$ {basedir} &#x2F; target &#x2F; classes中，这是Maven使用的另一个标准惯例。所以，如果你是一个敏锐的观察者，你会注意到，通过使用标准约定，上面的POM非常小并且你不必明确地告诉Maven你的任何源代码在哪里或者应该输出到哪里。通过遵循标准的Maven约定，您可以用很少的精力完成很多工作！就做一个随意的比较，让我们来看下要想完成相同的事情，在Ant中你必须需要做哪些事。<br>　　现在这只是简单编译一个程序源代码树，所以显示的Ant脚本和上面显示的POM大小大概相同。但是，我们还可以看到我们可以只使用这个简单的POM做多少事情！</p>
<h1 id="如何编译测试源码并运行我的单元测试？"><a href="#如何编译测试源码并运行我的单元测试？" class="headerlink" title="如何编译测试源码并运行我的单元测试？"></a>如何编译测试源码并运行我的单元测试？</h1><p>　　现在，您正在成功地编译程序的源代码，现在您已经有了一些要编译和执行的单元测试（因为每个程序员总是编写和执行单元测试）<br>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>
<p>执行该命令后，您将看到如下所示的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Building Maven Quick Start Archetype</span><br><span class="line">[INFO]    task-segment: [test]</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] artifact org.apache.maven.plugins:maven-surefire-plugin: \</span><br><span class="line">  checking for updates from central</span><br><span class="line">...</span><br><span class="line">[INFO] [resources:resources]</span><br><span class="line">[INFO] [compiler:compile]</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO] [resources:testResources]</span><br><span class="line">[INFO] [compiler:testCompile]</span><br><span class="line">Compiling 1 source file to C:\Test\Maven2\test\my-app\target\test-classes</span><br><span class="line">...</span><br><span class="line">[INFO] [surefire:test]</span><br><span class="line">[INFO] Setting reports dir: C:\Test\Maven2\test\my-app\target/surefire-reports</span><br><span class="line"> </span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">[surefire] Running com.mycompany.app.AppTest</span><br><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0 sec</span><br><span class="line"> </span><br><span class="line">Results :</span><br><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span><br><span class="line"> </span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESSFUL</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 15 seconds</span><br><span class="line">[INFO] Finished at: Thu Oct 06 08:12:17 MDT 2005</span><br><span class="line">[INFO] Final Memory: 2M/8M</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>　　关于输出有些事情需要注意：</p>
<ul>
<li>Maven这时下载更多的依赖。这些是执行测试所必需的依赖和插件（用于编译所需的依赖已经存在，所以就不会再次下载）</li>
<li>在编译和执行测试之前，Maven会编译主代码（因为所有这些类都是最新的，因为自从上次编译后没有进行任何的修改）</li>
</ul>
<p>如果您只想编译测试源码（但不执行测试），则可以执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn test--compile</span><br></pre></td></tr></table></figure>
<p>　　现在，您可以编译程序源码，编译测试并执行测试，您会想要继续下一个逻辑步骤，所以您会问…</p>
<h1 id="如何创建一个JAR并且安装到我的本地库"><a href="#如何创建一个JAR并且安装到我的本地库" class="headerlink" title="如何创建一个JAR并且安装到我的本地库"></a>如何创建一个JAR并且安装到我的本地库</h1><p>　　创建一个JAR是相当简单直接，可以通过执行下面命令来完成这项工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>　　如果您查看项目的POM，您会注意到packaging元素被设置为jar。这是上面命令中Maven如何知道要生成的是JAR文件（稍后我们将讲解更多）。您现在可以查看$ {basedir} &#x2F; target目录，您将看到生成的JAR文件。<br>　　现在你会想将已经生成的artifact（该JAR文件）安装到你的本地库（默认位置是${user.home}&#x2F;.m2&#x2F;repository）。有关库的更多信息，请参阅我们的<a href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html">“库简介”</a>但我们继续安装我们的artifact！为此执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>
<p>执行此命令后，您将看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Building Maven Quick Start Archetype</span><br><span class="line">[INFO]    task-segment: [install]</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] [resources:resources]</span><br><span class="line">[INFO] [compiler:compile]</span><br><span class="line">Compiling 1 source file to &lt;dir&gt;/my-app/target/classes</span><br><span class="line">[INFO] [resources:testResources]</span><br><span class="line">[INFO] [compiler:testCompile]</span><br><span class="line">Compiling 1 source file to &lt;dir&gt;/my-app/target/test-classes</span><br><span class="line">[INFO] [surefire:test]</span><br><span class="line">[INFO] Setting reports dir: &lt;dir&gt;/my-app/target/surefire-reports</span><br><span class="line"> </span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">[surefire] Running com.mycompany.app.AppTest</span><br><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.001 sec</span><br><span class="line"> </span><br><span class="line">Results :</span><br><span class="line">[surefire] Tests run: 1, Failures: 0, Errors: 0</span><br><span class="line"> </span><br><span class="line">[INFO] [jar:jar]</span><br><span class="line">[INFO] Building jar: &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] [install:install]</span><br><span class="line">[INFO] Installing &lt;dir&gt;/my-app/target/my-app-1.0-SNAPSHOT.jar to \</span><br><span class="line">   &lt;local-repository&gt;/com/mycompany/app/my-app/1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESSFUL</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 5 seconds</span><br><span class="line">[INFO] Finished at: Tue Oct 04 13:20:32 GMT-05:00 2005</span><br><span class="line">[INFO] Final Memory: 3M/8M</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>　　请注意，surefire插件（它会执行测试）会查找包含在具有特定命名约定的文件中的测试。默认测试包括：</p>
<ul>
<li>**&#x2F;*Test.java</li>
<li>**&#x2F;Test*.java</li>
<li>**&#x2F;*TestCase.java</li>
</ul>
<p>默认排除的是：</p>
<ul>
<li>**&#x2F;Abstract*Test.java</li>
<li>**&#x2F;Abstract*TestCase.java</li>
</ul>
<p>　　您已经完成了建立，构建，测试，打包和安装典型Maven项目的过程。这可能是使用Maven的项目要做的绝大多数工作，并且如果您注意到，您所能做的一切都是由一个被称为项目模型或者POM的18行文件驱动的。如果您看到一个提供了我们迄今为止所实现的相同功能的典型的Ant构建文件，您会发现它已经是POM的两倍大小，而且我们刚刚开始！Maven还有更多可用的功能，而且不需要对我们目前的POM做额外的补充。要想获得超出我们示例更多的功能，Ant构建文件必须作出很多容易出错的补充。<br>　　那么还有什么可以免费获得的？还有大量的Maven插件，即使是我们以上的简单POM，也可以开箱即用。我们在这里特别提到一个，因为它是Maven非常珍贵的功能之一：不需要任何工作，您的这个POM有足够的信息为您的项目生成一个网站！你最可能想要定制你的Maven网站，但是如果你时间紧迫的话，所有你需要做的只是执行以下命令，来提供关于你的项目基本信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure>
<p>还有很多其他可以执行的独立goal，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>
<p>这将在启动之前删除所有构建数据的target目录，以便它是最新的。<br>也许你想为项目生成一个IntelliJ IDEA描述符？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn idea:idea</span><br></pre></td></tr></table></figure>
<p>这可以运行在以前的IDEA项目的根目录 - 它会更新原来的项目设置，而不是新建一个。<br>如果您正在使用Eclipse IDE，只需调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn eclipse:eclipse</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Maven 1.0中的一些熟悉的goal依然存在，比如jar：jar，但他们可能不会像你所期望的那样行事。目前，jar：jar不会重新编译源代码 - 它只是简单地从target&#x2F;classes目录创建一个JAR，这是在其他的一切工作已经完成的前提下。</p>
</blockquote>
<h1 id="什么是SNAPSHOT版本？"><a href="#什么是SNAPSHOT版本？" class="headerlink" title="什么是SNAPSHOT版本？"></a>什么是SNAPSHOT版本？</h1><p>注意在pom.xml文件中version标签的值如下显示，它有一个后缀：-SNAPSHOT。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　SNAPSHOT值是指开发分支的“最新”代码，它并不保证代码稳定或不再改变。相反，“release”版本中的代码（任何没有SNAPSHOT后缀的版本值）都是不再变更的。<br>　　换句话说，SNAPSHOT版本是最终“发布”版本之前的“开发”版本。SNAPSHOT要比它的发布版本老。<br>　　在发布过程中，<strong>x.y-SNAPSHOT</strong>的版本更改为<strong>x.y</strong>.发布过程还将开发版本增加到<strong>x.(y + 1)-SNAPSHOT</strong>。例如，版本<strong>1.0-SNAPSHOT</strong>被发布为<strong>1.0</strong>版本，新的开发版本是<strong>1.1-SNAPSHOT</strong>版本。</p>
<h1 id="如何使用插件"><a href="#如何使用插件" class="headerlink" title="如何使用插件"></a>如何使用插件</h1><p>　　无论何时要自定义Maven项目的构建，都可以通过添加或重新配置插件来实现。<br>　　<strong>Maven 1.0用户注意事项</strong>：在Maven 1.0中，您需要向maven.xml添加一些preGoal，并将一些条目添加到project.properties中。这里有点不同。<br>　　比如这个例子，我们会配置Java编译器来允许使用JDK5.0源码。只需要简单的将以下添加到你的POM中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>　　你会注意到，Maven中的所有插件看起来都像一个依赖 - 在某些方面它们确实是。这个插件将被自动下载并使用 - 包括一个特定的版本，如果你要求它的话（默认是使用最新可用的）。<br>　　configuration元素将给定的参数应用于编译器插件的每个goal上。在上述情况下，编译器插件已经被用作构建过程的一部分，这只是改变了配置。还可以为流程添加新goal，并配置特定goal。有关信息，请参阅<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">“构建生命周期简介”</a>。<br>　　要想了解插件有哪些可用配置，你可以查阅插件列表，并浏览你正在使用的插件和goal。有关如何配置插件的可用参数的通用信息，请参阅<a href="http://maven.apache.org/guides/mini/guide-configuring-plugins.html">“配置插件指南”</a>。</p>
<h1 id="如何向JAR添加资源？"><a href="#如何向JAR添加资源？" class="headerlink" title="如何向JAR添加资源？"></a>如何向JAR添加资源？</h1><p>　　另一个可以满足的常见用例是没有更改我们上面的POM而将资源打包进了JAR文件。对于这个常见的任务，Maven再次依赖于标准目录布局，意味着通过使用标准的Maven约定，您可以仅仅通过将这些资源放进一个标准目录结构中，就可以资源打包进JAR文件。<br>　　您在下面的示例中看到，我们添加了目录${basedir}&#x2F;src&#x2F;main&#x2F;resources，可以将我们希望在JAR中打包的任何资源放入其中。Maven采用的简单规则是：${basedir}&#x2F;src&#x2F; main&#x2F;resources目录中放置的任何目录或文件都会在以JAR基础上开始的完全相同的结构打包进JAR内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   |-- java</span><br><span class="line">    |   |   `-- com</span><br><span class="line">    |   |       `-- mycompany</span><br><span class="line">    |   |           `-- app</span><br><span class="line">    |   |               `-- App.java</span><br><span class="line">    |   `-- resources</span><br><span class="line">    |       `-- META-INF</span><br><span class="line">    |           `-- application.properties</span><br><span class="line">    `-- test</span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure>
<p>　　所以在我们的示例中可以看到我们有一个META-INF目录，该目录中包含一个application.properties文件。如果您解压缩Maven为您创建的JAR，并查看它，您将看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- META-INF</span><br><span class="line">|   |-- MANIFEST.MF</span><br><span class="line">|   |-- application.properties</span><br><span class="line">|   `-- maven</span><br><span class="line">|       `-- com.mycompany.app</span><br><span class="line">|           `-- my-app</span><br><span class="line">|               |-- pom.properties</span><br><span class="line">|               `-- pom.xml</span><br><span class="line">`-- com</span><br><span class="line">    `-- mycompany</span><br><span class="line">        `-- app</span><br><span class="line">            `-- App.class</span><br></pre></td></tr></table></figure>
<p>　　您可以看到，${basedir}&#x2F;src&#x2F;main&#x2F;resources的内容可以从JAR的基础开始，我们的application.properties文件位于META-INF目录中。你还会注意到一些其他文件，比如META-INF&#x2F;MANIFEST.MF以及一个pom.xml和pom.properties文件. 这些是Maven中JAR的标准生成的。如果你选择的话可以创建你自己的清单，但是如果你没有创建的话Maven会默认生成一个（你可以修改默认清单中的实体。稍后我们会介绍）。pom.xml和pom.propertities文件被打包进JAR中，这样每个Maven产生的artifact都是可以自我描述，并且可以允许你在有需要时利用自己的应用程序的元数据。一个简单的用法可能是获取您的应用程序的版本。操作POM文件可能需要你使用一些Maven实用程序，但是使用标准的Java API利用这些属性，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Generated by Maven</span><br><span class="line">#Tue Oct 04 15:43:21 GMT-05:00 2005</span><br><span class="line">version=1.0-SNAPSHOT</span><br><span class="line">groupId=com.mycompany.app</span><br><span class="line">artifactId=my-app</span><br></pre></td></tr></table></figure>
<p>　　要为您的单元测试添加资源到类路径下，你遵循与向JAR添加资源相同的模式，除了放置资源的目录是${basedir}&#x2F;src&#x2F;test&#x2F;resources之外。此时，您将有一个项目目录结构，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   |-- java</span><br><span class="line">    |   |   `-- com</span><br><span class="line">    |   |       `-- mycompany</span><br><span class="line">    |   |           `-- app</span><br><span class="line">    |   |               `-- App.java</span><br><span class="line">    |   `-- resources</span><br><span class="line">    |       `-- META-INF</span><br><span class="line">    |           |-- application.properties</span><br><span class="line">    `-- test</span><br><span class="line">        |-- java</span><br><span class="line">        |   `-- com</span><br><span class="line">        |       `-- mycompany</span><br><span class="line">        |           `-- app</span><br><span class="line">        |               `-- AppTest.java</span><br><span class="line">        `-- resources</span><br><span class="line">            `-- test.properties</span><br></pre></td></tr></table></figure>
<p>在单元测试中，您可以使用简单的代码片段来访问以下测试所需的资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Retrieve resource</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream( <span class="string">&quot;/test.properties&quot;</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Do something with the resource</span></span><br><span class="line"> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="如何过滤资源文件？"><a href="#如何过滤资源文件？" class="headerlink" title="如何过滤资源文件？"></a>如何过滤资源文件？</h1><p>　　有时一个资源文件会需要包含一个只能在构建时提供的值。要在Maven中完成此操作，请使用语法${&lt;property name&gt;}将包含该值的属性引用到你的资源文件中。该属性可以是您的pom.xml中定义的值之一，一个定义在用户的settings.xml中的值，一个定义在外部属性文件的值，或者一个系统属性。<br>　　要在复制时让Maven过滤资源，只需将pom.xml中的资源目录的filtering设置为true即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　你会注意到，我们需要添加之前没有的build，resources和resource元素。除此之外，我们还需要明确指出资源位于src&#x2F;main&#x2F;resources目录中。所有这些信息之前都被当作默认值提供，但是因为filtering的默认值是false，所以我们需要自己将其添加到pom.xml中，以用来覆盖该默认值设置filtering为true。<br>　　要引用一个定义在你的pom.xml中的属性，该属性名称要使用定义值的XML元素的名称，“pom”被运行作为project（root）元素的别名。所以$ {project.name}指的是项目的名称，$ {project.version}是指项目的版本，$ {project.build.finalName}是指在构建项目打包时产生的文件的最终名称，等等。需要注意，POM的某些元素有默认值，所以不必明确的在你的POM中定义这些可用的值。类似地，可以使用以“settings”开头的属性名称来引用用户的settings.xml中的值（例如，$ {settings.localRepository}是指用户本地仓库的路径）。<br>　　继续我们的例子，让我们将一些属性添加到application.properties文件中（我们放在src&#x2F;main&#x2F;resources目录中），当资源被过滤时，其值将被提供：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">application.name=$&#123;project.name&#125;</span><br><span class="line">application.version=$&#123;project.version&#125;</span><br></pre></td></tr></table></figure>
<p>到了这一步，您可以执行以下命令（process-resources是资源被复制和过滤的构建生命周期阶段）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn process-resources</span><br></pre></td></tr></table></figure>
<p>并且target&#x2F;classes下的application.properties文件（最终将进入该jar）如下所示：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # application.properties</span><br><span class="line">application.name=Maven Quick Start Archetype</span><br><span class="line">application.version=1.0-SNAPSHOT</span><br></pre></td></tr></table></figure><br> 要引用外部文件中定义的属性，您需要做的是在pom.xml中添加对该外部文件的引用。首先，我们创建我们的外部属性文件，并将其称为src&#x2F;main&#x2F;filters&#x2F;filter.properties：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># filter.properties</span><br><span class="line">my.filter.value=hello!</span><br></pre></td></tr></table></figure>
<p>接下来，我们要在pom.xml中添加这个新文件的引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，如果我们在application.properties文件中添加对该属性的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">application.name=$&#123;project.name&#125;</span><br><span class="line">application.version=$&#123;project.version&#125;</span><br><span class="line">message=$&#123;my.filter.value&#125;</span><br></pre></td></tr></table></figure>
<p>　　在下面mvn process-resources命令的执行中会将我们的新的属性值放入application.properties中。作为在外部文件中定义my.filter.value属性的替代方法，您还可以在pom.xml的properties部分中定义它，您将获得相同的效果（注意，我也不需要对src &#x2F; main&#x2F;filters&#x2F;filter.properties的引用）；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my.filter.value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">my.filter.value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>过滤资源也可以从系统属性获取值;内置于Java（如java.version或user.home）中的系统属性或使用标准Java -D参数在命令行中定义的属性。要继续这个例子，我们来更改我们的application.properties文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">java.version=$&#123;java.version&#125;</span><br><span class="line">command.line.prop=$&#123;command.line.prop&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当您执行以下命令（注意命令行上的command.line.prop属性的定义）时，application.properties文件将包含系统属性中的值。</p>
<h1 id="如何使用外部依赖？"><a href="#如何使用外部依赖？" class="headerlink" title="如何使用外部依赖？"></a>如何使用外部依赖？</h1><p>　　你可能已经注意到我们已经在POM中使用了一个dependencies元素作为示例。事实上，你一直在使用一个外部的依赖，但是在这里我们将会详细介绍一下这个的工作原理。有关更全面的介绍，请参阅我们的<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">“依赖机制介绍”</a>。<br>　　pom.xml的dependencies部分列举我们的项目需要构建的所有外部依赖（无论是在编译时期，测试时期，允许时期或者什么时候的依赖）。现在，我们的项目只依赖于JUnit（为了清楚起见，我拿出了所有资源过滤的东西）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　对于每个外部依赖，你会需要至少定义四样东西：groupId,artifactId,version以及scope。groupId，artifactId和version与构建该依赖项目的pom.xml中给出的相同。scope元素指示您的项目如何使用该依赖关系，它的值可以是compile，test和runtime。有关可以为依赖项指定的所有内容的更多信息，请参阅<a href="http://maven.apache.org/ref/current/maven-model/maven.html">“项目描述符参考”</a>。<br>　　有关依赖机制整体的更多信息，请参阅<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">“依赖机制简介”</a>。<br>　　通过有关依赖的信息，Maven将在构建项目时引用依赖。Maven在哪里引用依赖关系呢？Maven在您的本地仓库（默认位置是${user.home}&#x2F;.m2&#x2F;repository）中查找所有依赖项。在上一节中，我们将项目（my-app-1.0-SNAPSHOT.jar）中的artifact安装到本地仓库中。一旦它被安装在那里，另一个项目可以通过将依赖信息添加到它的pom.xml来引用该jar作为依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-other-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　其他地方的依赖怎么使用呢？如果将它们获取到我的本地仓库？每当项目引用本地仓库中不可用的依赖项时，Maven将从远程仓库下载依赖项到本地仓库。当您构建您的第一个项目时，您可能已经注意到Maven下载了很多东西（这些下载是用于构建项目的各种插件的依赖）。默认情况下，Maven使用的远程仓库可以在<a href="http://repo.maven.apache.org/maven2/">http://repo.maven.apache.org/maven2/</a> 中找到（并浏览）。您还可以设置自己的远程仓库（可能是您公司的中央仓库），来代替或补充默认的远程仓库。有关仓库的更多信息，请参阅<a href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html">“仓库简介”</a>。<br>　　让我们在我们的项目中添加其他的依赖项。假设我们添加了一些日志记录到代码中，需要添加log4j作为依赖。首先，我们需要知道log4j的groupId，artifactId和version是什么。我们可以浏览ibiblio并寻找它，或者通过使用Google来帮助搜索“site:ww.ibiblio.org maven2 log4j”。搜索显示一个名为&#x2F;maven2&#x2F;log4j&#x2F;log4j （或&#x2F;pub&#x2F;packages&#x2F;maven2&#x2F;log4j&#x2F;log4j）的目录。该目录有一个名为maven-metadata.xml的文件。以下是log4j的maven-metadata.xml的内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">versions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　从这个文件中我们可以看到我们想要的groupId是“log4j”，而artifactId是“log4j”。我们可以看到很多不同的版本值可供选择;现在，我们将使用最新版本1.2.12（一些maven-metadata.xml文件也可以指定哪一个是当前发布版本）。除了maven-metadata.xml文件，我们可以看到对应每个版本的log4j库的目录。在每个这些文件中，我们将找到实际的jar文件（例如log4j-1.2.12.jar）以及一个pom文件（这是依赖项的pom.xml，表明它可能有其他依赖关系和一些其他信息）和另一个maven-metadata.xml文件。还有一个与这些文件相对应的md5文件，其中包含这些文件的MD5哈希值。您可以使用它来验证库，或找出您可能正在使用的特定库是哪个版本。<br>　　现在我们知道我们需要的信息，我们可以将依赖项添加到我们的pom.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，当我们编译项目（mvn compile）时，我们将看到Maven为我们下载log4j依赖项。</p>
<h1 id="如何在我的远程仓库中部署我的jar？"><a href="#如何在我的远程仓库中部署我的jar？" class="headerlink" title="如何在我的远程仓库中部署我的jar？"></a>如何在我的远程仓库中部署我的jar？</h1><p>要将jar部署到外部仓库，你必须在pom.xml中配置仓库的url以及在settting.xml中配置用来连接仓库的验证信息。<br>以下是使用scp和username &#x2F; password认证的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Quick Start Archetype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>src/main/filters/filters.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>MyCompany Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mycompany-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>jvanzyl<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Default value is ~/.ssh/id_dsa --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>/path/to/identity<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span> (default is ~/.ssh/id_dsa)</span><br><span class="line">      <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>my_key_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，如果你连接到一个将sshd_confing中的“PasswordAuthentication”参数设置为“no”的openssh ssh服务器,，您都必须为每次用户名&#x2F;密码认证输入密码（虽然您可以通过输入用户名和密码登录使用另一个ssh客户端）在这种情况下，您可能需要切换到公钥认证。<br>在settings.xml中使用密码应该小心。有关详细信息，请参阅<a href="http://maven.apache.org/guides/mini/guide-encryption.html">“密码加密”</a>。    </p>
<h1 id="如何创建文档？"><a href="#如何创建文档？" class="headerlink" title="如何创建文档？"></a>如何创建文档？</h1><p>为了让您从Maven的文档系统开始，您可以使用原型机制来使用以下命令为现有项目生成一个站点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">  -DarchetypeGroupId=org.apache.maven.archetypes \</span><br><span class="line">  -DarchetypeArtifactId=maven-archetype-site \</span><br><span class="line">  -DgroupId=com.mycompany.app \</span><br><span class="line">  -DartifactId=my-app-site</span><br></pre></td></tr></table></figure>
<p>现在转到<a href="http://maven.apache.org/guides/mini/guide-site.html">“创建一个网站的指南”</a>，了解如何为您的项目创建文档。</p>
<h1 id="如何建立其他类型的项目？"><a href="#如何建立其他类型的项目？" class="headerlink" title="如何建立其他类型的项目？"></a>如何建立其他类型的项目？</h1><p>请注意，生命周期适用于任何项目类型。例如，在基本目录中，我们可以创建一个简单的Web应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    -DarchetypeGroupId=org.apache.maven.archetypes \</span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp \</span><br><span class="line">    -DgroupId=com.mycompany.app \</span><br><span class="line">    -DartifactId=my-webapp</span><br></pre></td></tr></table></figure>
<p>请注意，这些都必须在单独的一行上。这将创建一个名为my-webapp的目录，其中包含以下项目描述符：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意&lt;packaging&gt;元素-它告诉Maven以WAR形式构建。Change into the webapp project’s directory and try:<br>中文(简体)<br>切换到webapp项目的目录，然后尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>你可以看到target&#x2F;my-webapp.war被构建，并且所有正常步骤都已执行。</p>
<h1 id="如何一次构建多个项目？"><a href="#如何一次构建多个项目？" class="headerlink" title="如何一次构建多个项目？"></a>如何一次构建多个项目？</h1><p>处理多个模块的概念被内置于Maven。在本节中，我们将展示如何构建上述的WAR，并在一步中包含以前的JAR。<br>首先，我们需要在另外两个目录上面添加一个父pom.xml文件，所以应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+- pom.xml</span><br><span class="line">+- my-app</span><br><span class="line">| +- pom.xml</span><br><span class="line">| +- src</span><br><span class="line">|   +- main</span><br><span class="line">|     +- java</span><br><span class="line">+- my-webapp</span><br><span class="line">| +- pom.xml</span><br><span class="line">| +- src</span><br><span class="line">|   +- main</span><br><span class="line">|     +- webapp</span><br></pre></td></tr></table></figure>
<p>您将创建的POM文件应包含以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-webapp<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在webapp中需要一个JAR依赖项，所以将其添加到my-webapp&#x2F;pom.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，将以下&lt;parent&gt;元素添加到子目录中的其他pom.xml文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mycompany.app<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>现在，从顶级目录尝试它，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>
<p>WAR现在已经在my-webapp&#x2F;target&#x2F;my-webapp.war中创建，并且JAR包含在内：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jar tvf my-webapp/target/my-webapp-1.0-SNAPSHOT.war</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 META-INF/</span><br><span class="line"> 222 Fri Jun 24 10:59:54 EST 2005 META-INF/MANIFEST.MF</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 META-INF/maven/</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 META-INF/maven/com.mycompany.app/</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 META-INF/maven/com.mycompany.app/my-webapp/</span><br><span class="line">3239 Fri Jun 24 10:59:56 EST 2005 META-INF/maven/com.mycompany.app/my-webapp/pom.xml</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 WEB-INF/</span><br><span class="line"> 215 Fri Jun 24 10:59:56 EST 2005 WEB-INF/web.xml</span><br><span class="line"> 123 Fri Jun 24 10:59:56 EST 2005 META-INF/maven/com.mycompany.app/my-webapp/pom.properties</span><br><span class="line">  52 Fri Jun 24 10:59:56 EST 2005 index.jsp</span><br><span class="line">   0 Fri Jun 24 10:59:56 EST 2005 WEB-INF/lib/</span><br><span class="line">2713 Fri Jun 24 10:59:56 EST 2005 WEB-INF/lib/my-app-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>它是怎么工作的呢？首先，父POM被创建（称作app），它有一个pom包和定义的模块列表。这告诉Maven运行所有的项目，而不仅仅是当前的项目（要覆盖此行为，可以使用–non-recursive命令行选项）。<br>接下来，我们告诉WAR它需要my-app的JAR。这做了一些事情：它使得它在类路径中可用于WAR中的任何代码（在这种情况下都不是），它确保JAR始终在WAR之前构建，并且它向WAR插件指示将JAR包括在其库目录。 您可能已经注意到，junit-4.11.jar是依赖依赖项，但并没有在WAR中结束。原因是&lt;scope&gt;test&lt;&#x2F;scope&gt;元素 - 它只需要用来进行测试，因此它不像依赖项my-app一样在编译时期被包含在web应用程序中。</p>
<p>最后一步包括一个父定义。这与您可能从Maven 1.0熟悉的extend元素不同：即使项目与它的父级分开分布，这样可以通过在仓库中查找以确保POM始终可以被定位。<br>与Maven 1.0不同，它不需要你允许install来成功执行这些步骤-你可以在它自己上运行package并且生成的artifact会从target目录使用，而不是本地仓库。<br>您可能希望从顶层目录再次生成您的IDEA工作区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn idea:idea</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《Maven官方文档》（十一）POM参考</title>
    <url>/2017/07/03/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89POM%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p><a href="http://maven.apache.org/pom.html">原文链接</a>    </p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="什么是POM"><a href="#什么是POM" class="headerlink" title="什么是POM"></a>什么是POM</h2><p>POM表示项目对象模型（Project Object Model）。它是在一个名为pom.xml的文件中代表Maven项目的XML。在Maven用户前，说到一个项目是在哲学的意义上说的，而不只是包含代码的文件的集合。一个项目包含配置文件，以及涉及的开发人员和它们所扮演的角色，缺陷追逐系统，组织和许可证，项目存在的URL，项目的依赖，以及其他给代码生命的小的部分。这是一个关于所有关于项目的事情的一站式服务。事实上，在Maven世界中，项目根本不需要包含任何代码，仅仅只需一个pom.xml。</p>
<span id="more"></span>
<h2 id="快速概览"><a href="#快速概览" class="headerlink" title="快速概览"></a>快速概览</h2><p>这是POM项目元素下的元素列表。请注意，modelVersion包含4.0.0。这是目前唯一支持Maven 2和3的POM版本，并且始终是必需的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">&lt;!-- 基本设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>...<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>...<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">&lt;!-- 构建设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">&lt;!-- 更多项目信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>...<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>...<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>...<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span>...<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">contributors</span>&gt;</span>...<span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">&lt;!-- 环境设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>...<span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>...<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h1><p>POM包含关于项目的所有必要信息，以及在构建过程中要使用的插件的配置。它实际上是“谁”，“什么”和“哪里”的宣告性表现，而构建生命周期是“何时”和“如何”。这并不是说POM不会影响生命周期的流动 - 它可以。例如，通过配置maven-antrun-plugin，可以在POM中有效地嵌入ant任务。然而，最终它是一个声明。一个buid.xml当程序运行的时候它告诉ant去做什么，而一个POM说明它的配置（声明）。如果一些外部力量导致生命周期跳过ant插件执行，它将不会停止执行的插件继续做他们的工作。这个build.xml不同，它的任务几乎总是依赖于它之前执行的行。</p>
<h2 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面定义的POM是Maven 2和3将允许的最小定义。groupId：artifactId：version都是必需的字段（尽管如果从父级继承，则不需要明确定义groupId和version - 稍后会有更多关于继承）。这三个字段的行为非常类似于地址和时间戳。这在仓库中标记了一个特定的位置，就像Maven项目的坐标系统一样。</p>
<ul>
<li>**groupId:**这个通过在一个组织或者项目之中是唯一的。例如，所有核心的Maven atrifact（应该）在groupId org.apache.maven下。在groupId不一定使用点符号，例如junit项目。注意，点标记的groupId不必与项目包含的包结构相对应。尽管这是一个很好的做法。当存储在仓库中时，该组的作用与操作系统中的Java包装结构非常相似。点被OS指定的目录分隔符（例如Unix中的“&#x2F;”）替换后，它就从基本库变成了相对目录结构。在给出的示例中，org.codehaus.mojo组存在于$M2_REPO&#x2F;org&#x2F;codehaus&#x2F;mojo目录中。</li>
<li>**artifactId:**artifactId通常是该项目被熟知的名称。尽管干groupId很重要，但是组内的人们很少会在讨论中提及groupId（它们通常都是相同的ID，例如Codehaus Mojo项目groupId：org.codehaus.mojo）它与groupId一起创建一个将该项目与世界上其他项目区分开的键（至少应该是:)）。和groupId一起，artifactId完全定义了仓库中的artifact的生存区。在上面的项目中，my-project存在于$M2_REPO&#x2F;org&#x2F;codehaus&#x2F;mojo&#x2F;my-project。</li>
<li>**version:**这是命名拼图的最后一块。groupId：artifactId表示单个项目，但它们不能描述我们正在讨论的该项目的化身。我们想要今天的junit：junit（版本4）还是四年前（版本2）？简而言之：代码更改，这些更改应该进行版本控制，并且该元素将这些版本保持一致。它也用于artifact仓库中以将版本彼此分离。my-project 1.0 版本文件存在于$M2_REPO&#x2F;org&#x2F;codehaus&#x2F;mojo&#x2F;my-project&#x2F;1.0目录结构中。</li>
<li>**packaging:**现在我们有了我们的地址结构：groupId:artifactId:version，但这里还有一个更加标准的标签给我们一个真正完整的地址。那就是项目的artifact类型。在我们的例子中，上面定义的org.codehaus.mojo:my-project:1.0的示例POM将被打包成jar。我们也可以通过声明一个不同的packaging将它打包成war。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
当没有packaging被声明的时候，Maven假定artifact是默认值：jar。有效的类型是组件角色org.apache.maven.lifecycle.mapping.LifecycleMapping的Plexus角色提示（有关Plexus的更多信息，了解角色和角色提示的说明）。当前packaging的核心值有：pom,jar,maven-plugin,ejb,war,ear,rar,par。这些定义了针对特定包结构，执行到每个相应构建生命周期阶段的默认目标列表。<br>有时你会看到Maven以groupId:artifactId:packaging:version.打印一个项目的坐标。</li>
<li>**classifier:**你可能在坐标上偶尔发现第五个元素，那就是classifier。我们稍后会查看classifier，但现在只要知道这些项目可以显示为groupId:artifactId:packaging:classifier:version就足够了。</li>
</ul>
<h2 id="POM关系"><a href="#POM关系" class="headerlink" title="POM关系"></a>POM关系</h2><p>Maven的一个强大方面是它对项目关系的处理;这包含依赖（以及传递依赖），继承和聚合（多模块项目）。依赖管理有一个很长的传统，那就一切都变得复杂而混乱，但是对项目来说又最微不足道。随着依赖树变得庞大而复杂，”Jarmageddon（Jar末日）” 很快随之而来。接着就是“Jar Hell（Jar 地狱）”，一个系统依赖的版本和开发的版本并不等同，要么是给定了错误的版本，要么类似命名的jar之间的版本冲突。Maven通过通用的本地仓库来解决这两个问题，从而正确地链接到项目，版本以及所有。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>POM的基石是它的依赖列表。大多数项目都依赖其他项目来正确构建和运行，如果Maven所做的所有只是为你管理这个列表，那么你已经获益良多。Maven在编译或者其他需要依赖的goal时，为你下载并链接到这些依赖。作为额外的好处，Maven还引入了这些依赖的依赖（传递依赖），允许您的列表专注于项目所需的依赖项。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**groupId, artifactId, version:**你会经常看到这些元素。这个三位一体被用于及时计算特定项目的坐标，将其划分为该项目的依赖。此计算的目的是选择一个与所有依赖关系声明相匹配的版本（由于传递依赖关系，对于相同的artifact可能会有多个依赖关系声明）<ul>
<li>**groupId, artifactId: **依赖的直接对应坐标。</li>
<li>**version: **一个依赖的版本说明规范，这将用来计算依赖的有效版本。</li>
</ul>
</li>
</ul>
<p>自从依赖由Maven坐标来描述，你可能会想：“这意味着我的项目只能依靠Maven artifact”，而答案是“当然，但这是一件好事情”。这迫使您完全依靠于Maven可以管理的依赖关系。有时候，不幸的是，当一个项目无法从Maven中央库中下载时。例如，一个项目可能依赖于具有封闭源许可证的jar，该jar禁止它在中央仓库中。处理这种情况有三种方法。</p>
<ol>
<li>使用install插件本地安装依赖。该方法是最简单的推荐方法。比如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=non-maven-proj.jar -DgroupId=some.group -DartifactId=non-maven-proj -Dversion=1 -Dpackaging=jar</span><br></pre></td></tr></table></figure>
 注意这里依旧需要地址，只有这时使用命令行和安装插件会为你给定的地址创建一个POM。</li>
<li>创建自己的仓库并将其部署在那里。这是对于拥有内网并需要使每个人都能同步的公司最受欢迎的方法。这有一个Maven目标称作deploy:deploy-file，它与install:install-file目标相似（阅读插件的目标页面了解更多信息）。</li>
<li>设置依赖范围为system，并且定义一个systemPath。然而，并不建议这么做，但是它使我们要解释以下元素。<ul>
<li>**classifier:**classifier允许我们区分从同一个POM构建但是内容不同的artifact。它是一些可选的和任意的字符串， - 如果存在的话 - 附加到artifact名称后，就是在版本号之后。<br>  此元素的用意是，考虑这样一个例子，一个项目提供一个针对JRE 1.5的artifact，但是同时也依然支持JRE 1.4。这样第一个artifact可以配备classifier jdk15，而第二个是jdk14，以便客户端选择一个使用。<br>  classifier的另一个常见用例是将辅助artifact附加到项目的主artifact上。如果你浏览Maven的中央仓库，你会注意到classifier source和javadoc经常和打包类文件一起用于部署项目源代码和API文档。   </li>
<li><strong>type:</strong><br> 对应于依赖artifact的packaging类型。默认值是jar。它通常表示依赖文件名的拓展名，但并不都是这样。一个可以映射到不同的拓展名和classifier。type通常对应于packaging所使用的，但也并非总是如此。一些例子比如jar，ejb-client和test-jar。新的类型可以由插件设置extension为true来定义，因此这不是完整的列表。</li>
<li><strong>scope:</strong><br> 该元素指的是当前任务的类路径（编译和运行，测试等）以及如何限制依赖关系的传递性。这又五个scope可用。      <ul>
<li>**compile - **这是默认的scope，如果没有指定的话，默认使用它。编译范围依赖在所有classpath中都可用。此外，这些依赖关系被传播到依赖项目。</li>
<li>**provided -**这很像compile，但是表示您期望JDK或容器在运行时提供它。它只适用于编译和测试类路径，不可传递。</li>
<li>**runtime - **这个scope表示编译时不需要该依赖，但是执行时需要。它是在运行时和测试时的类路径，而不是编译时类路径。</li>
<li>**test -**这个scope表示应用程序正常使用的时候并不需要该依赖，只是适用于测试的编译和执行阶段。它不可传递。</li>
<li>**system -**这个scope与provided类似，只是你必须提供明确包含它的JAR。该artifact始终可用，但不是在存储库中查找。</li>
</ul>
</li>
<li>**systemPath:**只有在依赖scope是system时使用。否则的话，如果设置这个元素构建会失败。这个路径必须是绝对路径，因此建议使用属性来指定特定于机器的路径（关于属性以下更多），比如${java.home}&#x2F;lib。由于假设先前安装了system范围的依赖，Maven将不会为项目检查仓库，而是检查该路径以确保这个文件存在。如果不存在的话，Maven会构建失败并且建议你手工下载安装它。</li>
<li>**optional:**当项目本身是一个依赖的时候，标记项目的依赖为optional。困惑？比如，假设一个项目A依赖项目B来编译可能在运行时不使用的的一部分代码，则我们可能对于整个项目来说不需要项目B。所以如果项目X添加项目A作为它的依赖，那么Maven根本就不需要安装项目B。符号上，如果 &#x3D;&gt;表示所需的依赖关系，而 - &gt;表示可选的，尽管A &#x3D;&gt; B是在构建A时的情况，但是构建X时则是X&#x3D;&gt;A–&gt;B 。<br> 简而言之，optional让其他项目知道，当你使用这个项目，你不需要该依赖也能正确运行。</li>
</ul>
</li>
</ol>
<h4 id="依赖版本要求规范"><a href="#依赖版本要求规范" class="headerlink" title="依赖版本要求规范"></a>依赖版本要求规范</h4><p>依赖的version元素定义了版本说明，用来极速有效的依赖版本。版本要求具有以下语法：</p>
<ul>
<li>1.0: “软”要求1.0（只是一个建议，如果它匹配所有其他范围的依赖）</li>
<li>[1.0]：1.0的“硬”要求</li>
<li>(，1.0]：x &lt;&#x3D; 1.0</li>
<li>[1.2,1.3]：1.2 &lt;&#x3D; x &lt;&#x3D; 1.3</li>
<li>[1.0,2.0]：1.0 &lt;&#x3D; x &lt;2.0</li>
<li>[1.5，)：x&gt; &#x3D; 1.5</li>
<li>(，1.0]，[1.2，)：x &lt;&#x3D; 1.0或x&gt; &#x3D; 1.2;多个集合以逗号分隔</li>
<li>(，1.1)，(1.1,)：排除1.1（例如，如果知道不与此库结合使用）</li>
</ul>
<h4 id="Exclusions"><a href="#Exclusions" class="headerlink" title="Exclusions"></a>Exclusions</h4><p>Exclusions明确的告诉Mave，你不想包含这个指定的项目是这个依赖的一个依赖（换句话说，它的传递依赖）。比如，maven-embedder需要maven-core，但是我们不希望使用它或它的依赖，这样我们就可以添加它作为一个exclution。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时用来剪切一个依赖的传递依赖也是很有用的。一个依赖可能不正确的指定scope，或者依赖可能与你项目中的其他依赖相冲突。使用通配符来排除可以轻松的排除一个依赖的所有传递依赖。在下面的情况中，您可能正在使用maven-embedder，并且你希望使用自己的来管理依赖项，所以你剪切掉了所有的传递依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**exclutions:**Exclusions包含一个或多个exclution元素，每一个都包含一个groupId和artifactId表示该依赖被排除。不像optional，它表示可能被安装使用，也可能没有被安装使用，exclutions主动将它们自己从依赖树中删除。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Maven带来的一个强大的附加功能就是项目继承的概念。虽然在构建系统比如Ant中，确实可以模拟继承，但是Maven更进一步的明确了项目对象模型的继承关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于parent和aggregation（多模块）项目packaging被要求使用pom。这些类型定义了绑定到一组生命周期阶段的目标。例如，如果packaging 是jar，那么package时期将执行jar：jar目标。如果packagin是pom，执行的目标会是site:attach-descriptor。现在我们可以在父POM中添加值，该POM将由其子类继承。父POM中的大多数元素都由其子项继承，包括：</p>
<ul>
<li>groupId</li>
<li>version</li>
<li>description</li>
<li>url</li>
<li>inceptionYear</li>
<li>organization</li>
<li>licenses</li>
<li>developers</li>
<li>contributors</li>
<li>mailingLists</li>
<li>scm</li>
<li>issueManagement</li>
<li>ciManagement</li>
<li>properties</li>
<li>dependencyManagement</li>
<li>dependencies</li>
<li>repositories</li>
<li>pluginRepositories</li>
<li>build<ul>
<li>plugin executions with matching ids</li>
<li>plugin configuration</li>
<li>etc.</li>
</ul>
</li>
<li>reporting</li>
<li>profiles</li>
</ul>
<p>不被继承的值得注意的元素由</p>
<ul>
<li>aritfactId</li>
<li>name</li>
<li>prerequisites</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../my-parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意relativePath元素。它不是必需的，但可以用作Maven的指示符，用来首先搜索给定该项目父级的路径，然后再搜索本地和远程仓库。<br>要想实际查看继承，可以看一下<a href="https://svn.apache.org/viewvc/maven/pom/trunk/asf/pom.xml?view=markup">ASF</a>和<a href="https://svn.apache.org/viewvc/maven/pom/trunk/maven/pom.xml?view=markup">Maven</a>的父POM。</p>
<h4 id="超级POM"><a href="#超级POM" class="headerlink" title="超级POM"></a>超级POM</h4><p>类似于面向对象编程中对象的继承，POM拓展自一个父POM，并从它的父级继承某些值。而且，就像Java对象最终从java.lang.Object继承而来，所有项目对象模型都从基础超级POM继承而来。下面的代码片段是Maven 3.0.4的超级POM。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> These plugins will be removed from future versions of the super POM --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2-beta-5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">NOTE:</span> The release profile will be removed from future versions of the super POM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>release-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">updateReleaseInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">updateReleaseInfo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您可以通过创建一个最小的pom.xml并在命令行中执行：mvn help:effective-pom来查看超级POM如何影响你的项目对象模型。</p>
<h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>除了继承某些顶级元素之外，父级有一个元素可以为子级POM和传递的依赖配置值。其中一个元素就是dependencyManagement。</p>
<ul>
<li>**dependencyManagement:**是POM用来帮助管理所有子项的依赖信息。如果my-parent项目使用dependencyManagement来定义对junit：junit：4.0的依赖关系，那么继承自它的POM可以只需要给出groupId&#x3D;junit和artifactId&#x3D;junit就能设置它们的依赖，Maven将填充由父级设置的version。这种方法的好处很明显。依赖关系细节可以在一个统一位置设置，这将传播到所有继承的POM。<br>  注意，从传递依赖并入的artifact的version和scope在依赖管理部分同样由版本说明控制。这可能会导致意想不到的后果。考虑这样一个情况，你的项目中有两个依赖，dep1和dep2。dep2也使用dep1，并且需要一个特定最低版本才能运行。然后如果使用dependencyManagement指定一个较旧的版本，dep2将被迫使用旧版本，并且失败。所以，你必须小心检查整个依赖关系树来避免这个问题; mvn dependency:tree会有帮助的。</li>
</ul>
<h3 id="聚合（或多模块）"><a href="#聚合（或多模块）" class="headerlink" title="聚合（或多模块）"></a>聚合（或多模块）</h3><p>具有模块的项目被称为多模块或聚合项目。模块是该POM列出并作为一组执行的项目。一个以pom打包的项目可以通过列举这些项目为模块，来聚合一组项目的构建，模块是指这些项目的相对目录。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>another-project<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您不需要自己在列出模块时考虑模块之间的依赖关系，即POM给出的模块的排序并不重要。Maven将拓扑地对模块进行排序，使得依赖模块始终在需要依赖模块之前构建。</p>
<p>要想实际查看聚合，可以看一下<a href="https://svn.apache.org/viewvc/maven/maven-3/trunk/pom.xml?view=markup">Maven</a>和<a href="https://svn.apache.org/viewvc/maven/plugins/trunk/pom.xml?view=markup">Maven Core Plugins</a>的父POM。</p>
<h4 id="继承v-聚合"><a href="#继承v-聚合" class="headerlink" title="继承v.聚合"></a>继承v.聚合</h4><p>继承和依赖通过单个高级的POM创建了一个很好的动态构建控制。你会经常看到同时是父级和聚合的项目。比如，整个maven核心通过一个基本的POM org.apache.maven:maven运行，所以构建Maven项目可以通过单个命令：mvn compile来执行。然和，尽管POM项目，聚合项目和父项目都不是同一个项目，也不应该被混淆。一个POM项目可以被它聚合的任何模块所继承，但这不是必须的。相反，一个POM项目可能会聚合一个不继承它的项目。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性是了解POM基础知识的最后一个要素。Maven属性是值占位符，就像Ant中的属性一样。在POM中它们的值可以通过符号${X}在任何地方访问，这里X是属性。或者它们可以被插件用作默认值，比如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>他们有五种不同的风格：</p>
<ol>
<li>env.X:在变量前加上前缀“env.”。会返回shell的环境变量。比如${env.PATH}包含PATH环境变量。<br> 注意：虽然环境变量本身在Windows上不区分大小写，但查找属性区分大小写。换而言之，虽然Windows shell为%PATH%和%path%返回相同的值，但Maven还是会区分${env.PATH}和${env.Path}。对于Maven 2.1.0，为了可靠性，环境变量的名称被标准化为全部大写。</li>
<li>project.x:在POM中一个以点（.）标记的路径会包含对应的元素的值。比如&lt;project&gt;&lt;version&gt; 1.0&lt;&#x2F; version&gt;&lt;&#x2F; project&gt;可以通过${project.version}访问。</li>
<li>setting.x:在setting.xml中一个以点（.）标记的路径会包含对应的元素值。比如：&lt;settings&gt;&lt;offline&gt;false&lt;&#x2F; offline&gt;&lt;&#x2F; settings&gt;可通过${settings.offline}访问。</li>
<li>Java系统属性：所有的可以通过java.lang.System.getProperties()访问的属性都可以用作POM属性，比如${java.home}。</li>
<li>x:在POM中的<properties />元素中设置。&lt;properties&gt; &lt;someVar&gt;value&lt;&#x2F; someVar&gt; &lt;&#x2F; properties&gt;可以当作$ {someVar}使用。</li>
</ol>
<h1 id="构建设置"><a href="#构建设置" class="headerlink" title="构建设置"></a>构建设置</h1><p>除了上述POM的基础知识之外，还有两个元素在声明POM的基本能力之前必须要理解。它们是处理像声明你的项目目录结构并且管理插件这些事情的build元素；以及reporting元素，它为报告目的最大的反应构建元素。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建POM 4.0.0 XSD，build元素在概念上被分为两个部分：一个BaseBuild类型，它包含两个build元素共有的元素组（project下的顶级build元素和profile下的build元素，如下所示）；还有一个Build类型，它包含BaseBuild集合以及顶层定义的更多元素。我们首先分析两者之间的共同点。</p>
<p><em><strong>注意：这些不同的build元素可以被表示为“项目构建”和“配置文件构建”。</strong></em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!-- &quot;Project Build&quot;包含比仅仅BaseBuild集更多的元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &quot;Profile Build&quot;包含“Project Build”元素的子集 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基础构建元素"><a href="#基础构建元素" class="headerlink" title="基础构建元素"></a>基础构建元素</h3><p>BaseBuild完全像它听到的一样：是存在于POM中两种build元素的基础元素集。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;artifactId&#125;-$&#123;version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span>filters/filter1.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>defaultGoal：</strong>如果没有给出，则执行的默认目标或阶段。如果给出了一个目标，它应该被定义为它在命令行中（如jar:jar）。如果定义了一个阶段（如install），也是如此。</p>
</li>
<li><p><strong>directory：</strong>这是构建会将它产生的文件转储的目录，或者以Maven的说法来说，构建的target。它恰好默认为${basedir}&#x2F;target。</p>
</li>
<li><p><strong>finalName：</strong>这是捆绑项目最终构建时的名称（没有文件扩展名，例如：my-project-1.0.jar）。它默认为$ {artifactId}-$ {version}。但是，“finalName”有些用词不当，构建捆绑项目的插件有权忽略&#x2F;修改此名称（但通常不会）。比如，如果maven-jar-plugin被配置为给一个jar一个test的classifier，那么上面定义的实际jar将被构建为my-project-1.0-test.jar。</p>
</li>
<li><p><strong>filter：</strong>定义* .properties文件，其中包含适用于接受其设置的资源的属性列表（如下所述）。换句话说，filter文件中定义的“name&#x3D;value”对在构建资源时替换${name}字符串。上面的示例定义了filter&#x2F;directory下的filter1.properties文件。Maven的默认filter目录是${basedir}&#x2F;src&#x2F;main&#x2F;filters&#x2F;。    </p>
<p>  要更全面地了解filter以及可以做什么，请查看<a href="/2017/07/01/%E3%80%8AMaven%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" title="《Maven官方文档》（一）入门指南">《Maven官方文档》（一）入门指南</a>。_</p>
</li>
</ul>
<h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><p>build元素的另一个特征是指定项目中存在资源的位置。资源（通常）不是代码。它们不会被编译，而是意在与你的项目捆绑在一起的条目，或者用于各种其他原因，如代码生成。<br>比如，一个Plexus项目需要在META-INF&#x2F;plexus目录下的configuration.xml文件（它指定容器的组件配置）。虽然我们可以很容易地将这个文件放在src&#x2F;main&#x2F; resource&#x2F;META-INF&#x2F;plexus中，但是我先希望给Plexus一个它自己的目录src&#x2F;main&#x2F;plexus。为了使JAR插件正确地捆绑资源，你应该类似于下面内容指定资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/plexus<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/plexus<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>resources：</strong>是一个resource元素列表，每个resource元素都描述与此项目相关联的有哪些文件，以及这些文件的位置。</li>
<li><strong>targetPath：</strong>指定放置从构建生成的资源集的目录结构。目标路径默认为基本目录。一个会被打包在JAR中资源通用指定目标路径是META-INF。</li>
<li><strong>filtering：</strong>它是true或false，表示是否要为此资源启用过滤。注意，*.properties过滤文件不必被定义用于进行过滤-因为资源可以使用默认定义在POM中的（比如${project.version}），使用”-D”标志传递给命令行的（比如”-Dname&#x3D;valuse”）或者明确使用properties元素定义的属性。过滤文件覆盖上面的这些属性。</li>
<li><strong>directory：</strong>这个元素的值定义了可以在哪里找到资源。构建默认的目录是${basedir}&#x2F;src&#x2F;main&#x2F;resources。</li>
<li><strong>includes：</strong>一组文件模式，指定要作为资源包含在该指定目录下的文件，使用*作为通配符。</li>
<li><strong>excludes：</strong>和includes相同的结构，但是指定的文件是要忽略掉的。在inlcude与exclude发生冲突时，exclude生效。</li>
<li><strong>testResources：</strong>testResources元素块包含testResource元素。它们的定义与resource元素相似，但是是在测试时期使用。一个区别是项目的默认（超级POM定义）测试资源目录是$ {basedir} &#x2F; src &#x2F; test &#x2F; resources。测试资源是不被部署的。</li>
</ul>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>test<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span>...<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了标准坐标：groupId:artifactId:version，还有一些配置插件或与构建交互的元素。</p>
<ul>
<li><p><strong>extensions：</strong>true或者false，是否加载此插件的扩展。默认为false。本文档稍后将介绍extensions。</p>
</li>
<li><p><strong>inherited：</strong>true或者false，该插件配置是否应适用于继承自此插件的POM。默认值为true。</p>
</li>
<li><p><strong>configuration：</strong>这是针对个别的插件。无需深入了解插件的工作原理，就可以在这里指定插件Mojo可能期望的任何属性（这些是Java Mojo bean中的getter和setter）。在上面的例子中，我们在maven-jar-plugin的Mojo中设置classifier的属性为test。可能要注意的是，所有configuration元素，无论它们在POM中的何处，都是将值传递给另一个底层系统，比如插件。换而言之：POM schema从不会明确要求cofiguration元素的值，但是一个插件目标有权要求这个配置值。<br>  如果您的POM声明一个父级，它将从父级的build&#x2F;plugins或pluginManagement部分继承插件配置。</p>
<p>  为了说明，请考虑父POM中的以下片段：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>my.group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>parent-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>parent-2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parentKey</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">parentKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  并考虑使用该父项作为其父项目的以下插件配置：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>my.group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>child-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childKey</span>&gt;</span>child<span class="tag">&lt;/<span class="name">childKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>默认的行为是根据元素名称合并configuration元素的内容。如果子POM有一个特定的元素，该值将成为有效值。如果子POM没有一个元素，但是父POM有，则父值将成为有效值。请注意，这纯粹是对XML的操作;没有涉及插件本身的代码或配置。只涉及元素，而不是它们的值。
</code></pre>
<p>将这些规则应用到示例中，Maven提出：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>my.group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>child-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childKey</span>&gt;</span>child<span class="tag">&lt;/<span class="name">childKey</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parentKey</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">parentKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>您可以通过向configuration元素的子级添加属性来控制子POM如何从父POM继承配置。这些属性是combine.children和combine.self。在子POM中使用这些属性来控制Maven如何将父项的插件配置与子项中的显式配置相结合。
</code></pre>
<p>以下是说明这个两个属性的子配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">items</span> <span class="attr">combine.children</span>=<span class="string">&quot;append&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- combine.children=&quot;merge&quot; 是默认值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>child-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span> <span class="attr">combine.self</span>=<span class="string">&quot;override&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- combine.self=&quot;merge&quot; 是默认值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childKey</span>&gt;</span>child<span class="tag">&lt;/<span class="name">childKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>现在，效果如下：
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">items</span> <span class="attr">combine.children</span>=<span class="string">&quot;append&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>parent-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>parent-2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>child-1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span> <span class="attr">combine.self</span>=<span class="string">&quot;override&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childKey</span>&gt;</span>child<span class="tag">&lt;/<span class="name">childKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>**combine.children =&quot;append&quot;**导致父元素和子元素按顺序并列。另一方面**combine.self =&quot;override&quot;**完全抑制父配置。您不能同时使用**combine.self =&quot;override&quot;**和**combine.children =&quot;append&quot;**两者。如果你这样做，override会生效。
</code></pre>
<p>注意这些属性只能应用于声明它们的cofiguration元素上，而不会传播到嵌套元素。也就是说，如果来自子POM的item元素的内容是复杂的结构而不是文本，则其子元素仍然会受到默认合并策略的约束，除非它们本身也使用这两个属性标记。<br>    combine.*属性从父级继承到子级POM。将这些属性添加到父POM时，请小心，因为这可能会影响到子级或次子级POM。</p>
<ul>
<li><strong>dependencies：</strong>在POM中可以看到很多dependencies，并且是一个在所有plugins元素块下的元素。这个dependencies与在基本构建设置下的拥有相同的结构和功能。在这种情况下的主要区别在于，它们不再作为项目需要的依赖，而是作为其所属插件的依赖。这种差别的作用是可以修改一个插件的依赖列表，可能通过exclusions移除不使用的运行时期依赖，或通过更改所需要依赖的版本。</li>
<li><strong>executions：</strong>重要的是要记住，插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将插件的目标完全绑定到不同的阶段。executions配置插件目标的execution。<br>  比如，假设你想要绑定antrun:run目标到verify阶段。我们希望任务回显构建目录，并且通过设置inherited为false避免传递这个配置给它的子级（假设它是一个父级）。你会获得一个这样的execution：  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>echodir<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">echo</span>&gt;</span>Build Dir: $&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>id：</strong>自我解释。它在所有其他execution中指定了这个execution块。当运行配置的phase的时候，它将以以下形式显示：[plugin：goal execution：id]。在这个示例情况下是：[antrun:run execution: echodir]</li>
<li><strong>goals：</strong>像所有多元化的POM元素一样，它包含单个元素的列表。在这种情况下，这个execution块指定的插件goals列表。</li>
<li><strong>phase：</strong>这是指执行目标列表的阶段。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变Maven的默认行为。   </li>
<li><strong>inherited：</strong>像上面的inherited元素一样，设置它为false会抑制Maven把这个execution传递给它的子代。此元素仅对父POM有意义。</li>
<li><strong>configuration：</strong>与上述相同，但将配置限制在此特定目标列表中，而不是插件下的所有目标。</li>
</ul>
</li>
</ul>
<h4 id="PluginManagement"><a href="#PluginManagement" class="headerlink" title="PluginManagement"></a>PluginManagement</h4><ul>
<li><strong>pluginManagement</strong>是和plugins一起看到的元素。PluginManagement以非常相同的方式包含了plugin元素，除了它不是为了这个特定的项目构建而配插件信息，而是为了配置从这个项目继承的项目构建。但是，这只能配置子级中实际引用的plugins元素。子级有权重写pluginManagement定义。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre-process-classes<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>pre-process<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
如果我们将这些规范添加到plugins元素中，它们将仅应用于单个POM。但是，如果我们将它们应用在pluginManagement元素下，那么这个POM和所有继承的POM将maven-jar-plugin添加到构建中也将获得pre-process-classes的执行。所以相比将上面混乱的包含到每一个子pom.xml中，只需要在子级中这样添加：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Builde元素集"><a href="#Builde元素集" class="headerlink" title="Builde元素集"></a>Builde元素集</h3><p>XSD中的Build类型表示这些元素仅用于“项目构建”。尽管还有更多数量的元素（六个），但实际只有两组元素是项目构建包含而配置文件构建没有的：<strong>directories</strong>和<strong>extensions</strong>.</p>
<h4 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h4><p>directory元素集存在于build元素中，它为整个POM设置了各种目录结构。由于它们不存在于配置文件构建中，因此无法通过配置文件更改。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果上述*Directory元素的值设置为绝对路径（当其属性展开时）那么使用该目录。否则，它是相对于基础构建目录：${basedir}。</p>
<h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><p>Extensions是在此构建中使用的artifact列表。它们将被包含在运行构建的classpath中。他们可以启用extensions给构建过程（例如为Wagon传输机制添加一个ftp提供程序）以及激活插件，从而对构建生命周期进行更改。简而言之，extensions是在构建期间激活的artifacts。extensions不需要实际执行任何操作，也不包含Mojo。因此，extensions对于指定一个通用插件接口的多个实现来说是非常好的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ftp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-alpha-3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h2><p>报告包含特定于站点生成阶段的元素。<br>某些Maven插件可以生成reporting 元素下定义和配置的报告，例如：生成Javadoc报告。就像build元素配置插件，报告命令的功能相同。但明显的区别是，报告使用reportSet元素配置目标，而不是在executions块中插件目标的细粒度控制。而且微妙的区别在于reporting元素下的插件configuration如build插件下的configuration一样工作，尽管这是不正确的（一个build插件的configuration不会影响reporting的插件）。      </p>
<h3 id="报告设置"><a href="#报告设置" class="headerlink" title="报告设置"></a>报告设置</h3><h1 id="更多项目信息"><a href="#更多项目信息" class="headerlink" title="更多项目信息"></a>更多项目信息</h1><h2 id="Licenses"><a href="#Licenses" class="headerlink" title="Licenses"></a>Licenses</h2><h2 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h2><h2 id="Developers"><a href="#Developers" class="headerlink" title="Developers"></a>Developers</h2><h2 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h2><h1 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h1><h2 id="问题管理"><a href="#问题管理" class="headerlink" title="问题管理"></a>问题管理</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h2><h2 id="Plugin-Repositories"><a href="#Plugin-Repositories" class="headerlink" title="Plugin Repositories"></a>Plugin Repositories</h2><h2 id="Distribution-Management"><a href="#Distribution-Management" class="headerlink" title="Distribution Management"></a>Distribution Management</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><h3 id="Site-Distribution"><a href="#Site-Distribution" class="headerlink" title="Site Distribution"></a>Site Distribution</h3><h3 id="Relocation"><a href="#Relocation" class="headerlink" title="Relocation"></a>Relocation</h3><h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><h3 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h3><h3 id="BaseBuild元素集（重览）"><a href="#BaseBuild元素集（重览）" class="headerlink" title="BaseBuild元素集（重览）"></a>BaseBuild元素集（重览）</h3><h1 id="终言"><a href="#终言" class="headerlink" title="终言"></a>终言</h1>]]></content>
      <categories>
        <category>Maven</category>
        <category>参考</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Number和String</title>
    <url>/2017/07/08/Java-Number%E5%92%8CString/</url>
    <content><![CDATA[<h1 id="Number和String"><a href="#Number和String" class="headerlink" title="Number和String"></a>Number和String</h1><hr>
<h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>这一节首先讨论Number类（在java.lang包中）以及其子类。特别地，本节将讨论您将使用这些类的实例而不是原始数据类型的情况。此外，本节还介绍了您可能需要和number一起使用的类，例如格式化或使用数学函数来补充Java语言中内置的运算符。最后，有一个关于自动装箱和拆箱的讨论，这是一个简化代码的编译器功能。</p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>String，在Java编程中被广泛使用，它是一序列的字符。在Java编程语言中，字符串是对象。这节描述使用String类来创建和操作字符串。它同时还比较String和StringBuilder类。</p>
<hr>
<h1 id="Numbers-1"><a href="#Numbers-1" class="headerlink" title="Numbers"></a>Numbers</h1><hr>
<p>本节首先介绍java.lang包中的Number类，它的子类，以及使用这些类的实例而不是基本数字类型的情况。</p>
<p>本节还介绍了PrintStream和DecimalFormat类，它们提供了编写格式化数字输出的方法。</p>
<p> 最后，讨论java.lang包中的Math类。它包含数学函数可以补充Java语言中内置的操作符。这个类有三角函数，指数函数等等的方法。</p>
 <span id="more"></span>
<h2 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h2><p>使用数字时，大部分时间您在代码中使用原始类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">gpa</span> <span class="operator">=</span> <span class="number">3.65f</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0xff</span>;</span><br></pre></td></tr></table></figure>
<p>但是，这有一些使用对象取代原始类型的理由，Java平台为每个基本数据类型提供了包装类。这些类在对象中包装原始类型。通常，包装由编译器完成-如果在一个期望对象的地方使用了原始类型，编译器会为你装箱这个原始类型到它的包装类中。类似的，如果当期望原始类型的时候你使用一个number对象，编译器会为你对对象拆箱出原始类型。更多信息，请看<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1">自动装箱拆箱</a>。<br>所有的数字包装类都是抽象类Number的子类：<br>![数字对象结构](\images\java base\objects-numberHierarchy.gif)</p>
<blockquote>
<p>**注意:**Number类有四个子类，这里没有讨论。BigDecimal和BigInteger用于高精度计算。AtomicInteger和AtomicLong用于多线程应用程序。</p>
</blockquote>
<p>这有三个你可能使用一个Number对象而不是一个原始类型的原因：</p>
<ol>
<li>作为一个期望对象的方法的参数（通常在操作数字集合时使用）。</li>
<li>作为定义在类中的常量使用，比如MIN_VALUE和MAX_VALUE,来提供数据类型的上限和下限。</li>
<li>使用类的方法用于将值与其他原始类型进行转换，与字符串进行转换，与其他系统数字（十进制，八进制，十六进制，二进制）之间进行转换。</li>
</ol>
<p>下表列出了Number类的所有子类实现的实例方法。</p>
<center>***Number的所有子类实现的方法***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte byteValue()<br>short shortValue()<br>int intValue()<br>long longValue()<br>float floatValue()<br>double doubleValue()</td>
<td>将此Number对象的值转换为返回的原始数据类型。</td>
</tr>
<tr>
<td>int compareTo(Byte anotherByte)<br>int compareTo(Double anotherDouble)<br>int compareTo(Float anotherFloat)<br>int compareTo(Integer anotherInteger)<br>int compareTo(Long anotherLong)<br>int compareTo(Short anotherShort)</td>
<td>将此Number对象与参数进行比较。</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>确定此数字对象是否等于参数。如果参数不为null，并且是相同类型和相同数值的对象，那么方法返回true。<br> 对于Java API文档中描述的Double和Float对象，有一些额外的要求。</td>
</tr>
</tbody></table>
<p>每个Number类都包含用于将数字转换为字符串和从数字系统之间转换的其他方法。下面的表格列举了在Integer类中的这些方法。其他Number子类的方法类似。</p>
<center>***Integer类的转换方法***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>static Integer decode(String s)</td>
<td>将String串解码为一个Integer。可以接受十进制，八进制或十六进制数字的字符串表示作为输入。</td>
</tr>
<tr>
<td>static int parseInt(String s)</td>
<td>返回一个整数（只有十进制）</td>
</tr>
<tr>
<td>static int parseInt(String s, int radix)</td>
<td>返回一个整数，给出十进制，二进制，八进制或十六进制的字符串表示形式（radix分别等于10，2，8或者16）的数字作为输入</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回一个表示这个Integer值的String对象</td>
</tr>
<tr>
<td>static String toString(int i)</td>
<td>返回表示指定整数的String对象。</td>
</tr>
<tr>
<td>static Integer valueOf(int i)</td>
<td>返回一个保存指定原始类型值的Integer对象</td>
</tr>
<tr>
<td>static Integer valueOf(String s)</td>
<td>返回一个保存指定字符串表示的值的Integer对象</td>
</tr>
<tr>
<td>static Integer valueOf(String s, int radix)</td>
<td>返回一个保存指定字符串表示的整数值的Integer对象，以radix的值解析。比如，如果是&#x3D;”333”并且radix&#x3D;”8”,方法返回等同于八进制数字333的十进制数字。</td>
</tr>
</tbody></table>
<h2 id="格式化数字打印输出"><a href="#格式化数字打印输出" class="headerlink" title="格式化数字打印输出"></a>格式化数字打印输出</h2><hr>
<p>之前，您看到使用print和println方法将字符串打印到标准输出（System.out）。因为所有的数字都可以转换为字符串（之后课程会看到），你可以使用这些方法来打印字符串和数字的任意混合。然而，Java编程语言还有其他的方法，允许您在包含数字时对打印输出进行更多的控制。</p>
<h3 id="打印和格式化方法"><a href="#打印和格式化方法" class="headerlink" title="打印和格式化方法"></a>打印和格式化方法</h3><p>java.io包包含一个PrintStream类，它有两个格式化方法，这样你可以使用它们取代print和println方法。这些方法，format和printf相互等同。你一直使用的熟悉的System.out恰好是一个PrintStream对象，所以你可以在System.out上调用PrintStream方法。因此，您可以在您以前使用print或println的代码中的任何位置使用format 或printf。例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.format();</span><br></pre></td></tr></table></figure>
<p>这两个java.io.PrintStream方法的语法相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrintStream <span class="title function_">format</span><span class="params">(String format, Object... args)</span></span><br></pre></td></tr></table></figure>
<p>其中format是指定要使用的格式化的字符串，args是要使用该格式打印的变量的列表。一个简单的例子就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.format(<span class="string">&quot;The value of &quot;</span> + <span class="string">&quot;the float variable is &quot;</span> +</span><br><span class="line">     <span class="string">&quot;%f, while the value of the &quot;</span> + <span class="string">&quot;integer variable is %d, &quot;</span> +</span><br><span class="line">     <span class="string">&quot;and the string is %s&quot;</span>, floatVar, intVar, stringVar); </span><br></pre></td></tr></table></figure>
<p>第一个参数format是一个格式化字符串，用于指定第二个参数args中的对象如何进行格式化。这个格式化字符串包含纯文本以及格式格式说明符，格式说明符是用来格式化参数将Object…args的特殊的字符（符号Object… args被称为可变参数（varargs），这意味着参数的数量可能会有所不同）。</p>
<p>格式说明符以一个百分号（%）开头，并且以一个转换符结尾。 转换符是一个指示要格式化的参数类型的字符。在百分号（％）和转换符之间，你可以有一个可选的标志和说明符。有许多转换符，标志和说明符，它们在java.util.Formatter中有记录。</p>
<p>这是一个基本示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">461012</span>;</span><br><span class="line">System.out.format(<span class="string">&quot;The value of i is: %d%n&quot;</span>, i);</span><br></pre></td></tr></table></figure>
<p>％d指示单个变量是十进制整数。％n是一个不依赖的换行符。输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The value of i is: 461012</span><br></pre></td></tr></table></figure>
<p>printf和format方法被重载。每个都有一个具有以下语法的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PrintStream format(Locale l, String format, Object... args)</span><br></pre></td></tr></table></figure>
<p>要在法语系统中打印数字（使用逗号代替浮点数的英文表示形式的小数位），您可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.format(Locale.FRANCE,</span><br><span class="line">    <span class="string">&quot;The value of the float &quot;</span> + <span class="string">&quot;variable is %f, while the &quot;</span> +</span><br><span class="line">    <span class="string">&quot;value of the integer variable &quot;</span> + <span class="string">&quot;is %d, and the string is %s%n&quot;</span>, </span><br><span class="line">    floatVar, intVar, stringVar); </span><br></pre></td></tr></table></figure>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>下表列出了示例程序TestFormat.java中使用的一些转换符和标志。</p>
<center>***TestFormat.java中使用的转换符和标志***</center>

<table>
<thead>
<tr>
<th>转换符</th>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td></td>
<td>一个十进制整数</td>
</tr>
<tr>
<td>f</td>
<td></td>
<td>一个float</td>
</tr>
<tr>
<td>n</td>
<td></td>
<td>适用于运行应用程序的平台的换行符符。您应该始终使用％n，而不是\ n。</td>
</tr>
<tr>
<td>tB</td>
<td></td>
<td>一个日期和时间转换 - 月份的区域特定全名。</td>
</tr>
<tr>
<td>td, te</td>
<td></td>
<td>一个日期和时间转换 - 两位数表示月份的天数。td有需要的话要有一个前置的0。te不需要</td>
</tr>
<tr>
<td>ty, tY</td>
<td></td>
<td>一个日期和时间转换—ty &#x3D; 两位数表示的年份, tY &#x3D;四位数表示的年份</td>
</tr>
<tr>
<td>tl</td>
<td></td>
<td>一个日期和时间转换—十二小时制的小时数</td>
</tr>
<tr>
<td>tM</td>
<td></td>
<td>一个日期和时间转换—两位数表示的分钟，需要的话要有前置的0</td>
</tr>
<tr>
<td>tp</td>
<td></td>
<td>一个日期和时间转换—区域特定的am &#x2F; pm（小写）。</td>
</tr>
<tr>
<td>tm</td>
<td></td>
<td>一个日期和时间转换—两位数表示的月份，需要的话要有前置的0。</td>
</tr>
<tr>
<td>tD</td>
<td></td>
<td>一个日期和时间转换—%tm%td%ty形式的日期</td>
</tr>
<tr>
<td></td>
<td>08</td>
<td>八个字符宽，需要的话要有前置的0</td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>包括符号，无论整数还是负数</td>
</tr>
<tr>
<td></td>
<td>,</td>
<td>包括特定于语言环境的分组字符。</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>左对齐..</td>
</tr>
<tr>
<td></td>
<td>.3</td>
<td>小数点后三位。</td>
</tr>
<tr>
<td></td>
<td>10.3</td>
<td>十个字符宽，右对齐，小数点后三位。</td>
</tr>
</tbody></table>
<p>以下程序显示了您可以使用格式化的一些格式。输出显示在嵌入式注释中的在双引号内：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFormat</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">461012</span>;</span><br><span class="line">      System.out.format(<span class="string">&quot;%d%n&quot;</span>, n);      <span class="comment">//  --&gt;  &quot;461012&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%08d%n&quot;</span>, n);    <span class="comment">//  --&gt;  &quot;00461012&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%+8d%n&quot;</span>, n);    <span class="comment">//  --&gt;  &quot; +461012&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%,8d%n&quot;</span>, n);    <span class="comment">// --&gt;  &quot; 461,012&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%+,8d%n%n&quot;</span>, n); <span class="comment">//  --&gt;  &quot;+461,012&quot;</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">      System.out.format(<span class="string">&quot;%f%n&quot;</span>, pi);       <span class="comment">// --&gt;  &quot;3.141593&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%.3f%n&quot;</span>, pi);     <span class="comment">// --&gt;  &quot;3.142&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%10.3f%n&quot;</span>, pi);   <span class="comment">// --&gt;  &quot;     3.142&quot;</span></span><br><span class="line">      System.out.format(<span class="string">&quot;%-10.3f%n&quot;</span>, pi);  <span class="comment">// --&gt;  &quot;3.142&quot;</span></span><br><span class="line">      System.out.format(Locale.FRANCE,</span><br><span class="line">                        <span class="string">&quot;%-10.4f%n%n&quot;</span>, pi); <span class="comment">// --&gt;  &quot;3,1416&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">      System.out.format(<span class="string">&quot;%tB %te, %tY%n&quot;</span>, c, c, c); <span class="comment">// --&gt;  &quot;May 29, 2006&quot;</span></span><br><span class="line"></span><br><span class="line">      System.out.format(<span class="string">&quot;%tl:%tM %tp%n&quot;</span>, c, c, c);  <span class="comment">// --&gt;  &quot;2:34 am&quot;</span></span><br><span class="line"></span><br><span class="line">      System.out.format(<span class="string">&quot;%tD%n&quot;</span>, c);    <span class="comment">// --&gt;  &quot;05/29/06&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DecimalFormat类"><a href="#DecimalFormat类" class="headerlink" title="DecimalFormat类"></a>DecimalFormat类</h3><p>你可以使用java.text.DecimalFormat类来控制前导和后置零，前缀和后缀的显示，分组（以千位分组）分隔符和小数分隔符。DecimalFormat在数字格式化方面提供了很大的灵活性，但它可能使你的代码更加复杂。</p>
<p>下面的示例通过将模式字符串传递给DecimalFormat构造函数来创建一个DecimalFormat对象myFormat。然后DecimalFormat从NumberFormat继承的format()方法由myFormatter调用，它接受一个double值作为参数，并返回一个以字符串格式化的数字：</p>
<p>这是一个示例程序，说明了DecimalFormat的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecimalFormatDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customFormat</span><span class="params">(String pattern, <span class="type">double</span> value )</span> &#123;</span><br><span class="line">      <span class="type">DecimalFormat</span> <span class="variable">myFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(pattern);</span><br><span class="line">      <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> myFormatter.format(value);</span><br><span class="line">      System.out.println(value + <span class="string">&quot;  &quot;</span> + pattern + <span class="string">&quot;  &quot;</span> + output);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      customFormat(<span class="string">&quot;###,###.###&quot;</span>, <span class="number">123456.789</span>);</span><br><span class="line">      customFormat(<span class="string">&quot;###.##&quot;</span>, <span class="number">123456.789</span>);</span><br><span class="line">      customFormat(<span class="string">&quot;000000.000&quot;</span>, <span class="number">123.78</span>);</span><br><span class="line">      customFormat(<span class="string">&quot;$###,###.###&quot;</span>, <span class="number">12345.67</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456.789  ###,###.###  123,456.789</span><br><span class="line">123456.789  ###.##  123456.79</span><br><span class="line">123.78  000000.000  000123.780</span><br><span class="line">12345.67  $###,###.###  $12,345.67</span><br></pre></td></tr></table></figure>

<p>下表说明了每行输出。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>模式</th>
<th>输出</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>123456.789</td>
<td>###,###.###</td>
<td>123,456.789</td>
<td>井号（＃）表示数字，逗号是组分隔符的占位符，句点是小数分隔符的占位符。</td>
</tr>
<tr>
<td>123456.789</td>
<td>###.##</td>
<td>123456.79</td>
<td>该值在小数点右侧有三位数，但模式只有两个数字。format方法通过舍入来处理这个。</td>
</tr>
<tr>
<td>123.78</td>
<td>000000.000</td>
<td>000123.780</td>
<td>该模式指定前置和后置的零，因为使用0字符而不是井号（＃）。</td>
</tr>
<tr>
<td>12345.67</td>
<td>$###,###.###</td>
<td>$12,345.67</td>
<td>模式中的第一个字符是美元符号（$）。请注意，它紧接在格式化输出中最左边的数字之前。</td>
</tr>
</tbody></table>
<h2 id="超越基本算数"><a href="#超越基本算数" class="headerlink" title="超越基本算数"></a>超越基本算数</h2><hr>
<p>Java编程语言使用它的基本运算符：+，- ，*，&#x2F;和％支持其基本运算。java.lang包中的Math类提供了进行更高级数学计算的方法和常量。<br>Math类中的方法都是静态的，所以你直接从类中调用它们，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.cos(angle);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>使用静态导入的语言特性，你不必在每个数学函数前再些Math：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>
<p>这允许您通过它们的简单的名称来调用Math类的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cos(angle);</span><br></pre></td></tr></table></figure>

<h3 id="常量和基本方法"><a href="#常量和基本方法" class="headerlink" title="常量和基本方法"></a>常量和基本方法</h3><p>Math类包含两个常量：</p>
<ul>
<li>Math.E ，这是自然对数的基础</li>
<li>Math.PI，这是圆周长与其直径之比。</li>
</ul>
<p>Math类还有超过40个静态方法。下面表格列举了一些基本方法。</p>
<center>***Math基本方法***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double abs(double d)<br>float abs(float f)<br>int abs(int i)<br>long abs(long lng)</td>
<td>返回参数的绝对值。</td>
</tr>
<tr>
<td>double ceil(double d)</td>
<td>返回大于或等于参数的最小整数。返回double类型</td>
</tr>
<tr>
<td>double floor(double d)</td>
<td>返回小于或等于参数的最大整数。返回double类型</td>
</tr>
<tr>
<td>double rint(double d)</td>
<td>返回与参数最接近的整数。返回double类型</td>
</tr>
<tr>
<td>long round(double d)<br>int round(float f)</td>
<td>返回最接近的long或int，如方法的返回类型所示。</td>
</tr>
<tr>
<td>double min(double arg1, double arg2)<br>float min(float arg1, float arg2)<br>int min(int arg1, int arg2)<br>long min(long arg1, long arg2)<br></td>
<td>返回两个参数中较小的一个。</td>
</tr>
<tr>
<td>double max(double arg1, double arg2)<br>float max(float arg1, float arg2)<br>int max(int arg1, int arg2)<br>long max(long arg1, long arg2)</td>
<td>返回两个参数中较大的一个。</td>
</tr>
</tbody></table>
<p>以下程序BasicMathDemo说明了如何使用以下方法之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicMathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">191.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">43.74</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">16</span>, d = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The absolute value &quot;</span> + <span class="string">&quot;of %.3f is %.3f%n&quot;</span>, </span><br><span class="line">                          a, Math.abs(a));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The ceiling of &quot;</span> + <span class="string">&quot;%.2f is %.0f%n&quot;</span>, </span><br><span class="line">                          b, Math.ceil(b));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The floor of &quot;</span> + <span class="string">&quot;%.2f is %.0f%n&quot;</span>, </span><br><span class="line">                          b, Math.floor(b));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The rint of %.2f &quot;</span> + <span class="string">&quot;is %.0f%n&quot;</span>, </span><br><span class="line">                          b, Math.rint(b));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The max of %d and &quot;</span> + <span class="string">&quot;%d is %d%n&quot;</span>,</span><br><span class="line">                          c, d, Math.max(c, d));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The min of of %d &quot;</span> + <span class="string">&quot;and %d is %d%n&quot;</span>,</span><br><span class="line">                          c, d, Math.min(c, d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是程序的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The absolute value of -191.635 is 191.635</span><br><span class="line">The ceiling of 43.74 is 44</span><br><span class="line">The floor of 43.74 is 43</span><br><span class="line">The rint of 43.74 is 44</span><br><span class="line">The max of 16 and 45 is 45</span><br><span class="line">The min of 16 and 45 is 16</span><br></pre></td></tr></table></figure>
<h3 id="指数和对数方法"><a href="#指数和对数方法" class="headerlink" title="指数和对数方法"></a>指数和对数方法</h3><p>下表列出了Math类的指数和对数方法。</p>
<center>***指数和对数方法***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double exp(double d)</td>
<td>返回自然对数的基数e，取决于参数的幂。</td>
</tr>
<tr>
<td>double log(double d)</td>
<td>返回参数的自然对数。</td>
</tr>
<tr>
<td>double pow(double base, double exponent)</td>
<td>将第一个参数的值返回到第二个参数的幂。</td>
</tr>
<tr>
<td>double sqrt(double d)</td>
<td>返回参数的平方根。</td>
</tr>
</tbody></table>
<p>以下程序ExponentialDemo显示e的值，然后调用上表中列出的任意方法中任意选择的数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExponentialDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2.76</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;The value of &quot;</span> + <span class="string">&quot;e is %.4f%n&quot;</span>,</span><br><span class="line">                          Math.E);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;exp(%.3f) &quot;</span> + <span class="string">&quot;is %.3f%n&quot;</span>,</span><br><span class="line">                          x, Math.exp(x));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;log(%.3f) is &quot;</span> + <span class="string">&quot;%.3f%n&quot;</span>,</span><br><span class="line">                          x, Math.log(x));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;pow(%.3f, %.3f) &quot;</span> + <span class="string">&quot;is %.3f%n&quot;</span>,</span><br><span class="line">                          x, y, Math.pow(x, y));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;sqrt(%.3f) is &quot;</span> + <span class="string">&quot;%.3f%n&quot;</span>,</span><br><span class="line">                          x, Math.sqrt(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是运行Exponen时会看到的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The value of e is 2.7183</span><br><span class="line">exp(11.635) is 112983.831</span><br><span class="line">log(11.635) is 2.454</span><br><span class="line">pow(11.635, 2.760) is 874.008</span><br><span class="line">sqrt(11.635) is 3.411</span><br></pre></td></tr></table></figure>
<h3 id="三角方法"><a href="#三角方法" class="headerlink" title="三角方法"></a>三角方法</h3><p>Math类还提供了一组三角函数，如下表所示。传递到这些方法中的每一个的值是以弧度表示的角度。您可以使用toRadians方法将度数转换为弧度。   </p>
<center>***三角方法****</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double sin(double d)</td>
<td>返回指定double值的正弦值。</td>
</tr>
<tr>
<td>double cos(double d)</td>
<td>返回指定double值的余弦值。</td>
</tr>
<tr>
<td>double tan(double d)</td>
<td>返回指定double值的正切值。</td>
</tr>
<tr>
<td>double asin(double d)</td>
<td>返回指定double值的反正弦值。</td>
</tr>
<tr>
<td>double acos(double d)</td>
<td>返回指定double值的反余弦。</td>
</tr>
<tr>
<td>double atan(double d)</td>
<td>返回指定double值的反正切值。</td>
</tr>
<tr>
<td>double atan2(double y, double x)</td>
<td>将直角坐标（x，y）转换为极坐标（r，θ）并返回θ。</td>
</tr>
<tr>
<td>double toDegrees(double d)<br>double toRadians(double d)</td>
<td>将参数转换为度或弧度。</td>
</tr>
</tbody></table>
<p>这里有一个程序TrigonometricDemo，它使用这些方法来计算45度角的各种三角值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrigonometricDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">degrees</span> <span class="operator">=</span> <span class="number">45.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radians</span> <span class="operator">=</span> Math.toRadians(degrees);</span><br><span class="line">        </span><br><span class="line">        System.out.format(<span class="string">&quot;The value of pi &quot;</span> + <span class="string">&quot;is %.4f%n&quot;</span>,</span><br><span class="line">                           Math.PI);</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The sine of %.1f &quot;</span> + <span class="string">&quot;degrees is %.4f%n&quot;</span>,</span><br><span class="line">                          degrees, Math.sin(radians));</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The cosine of %.1f &quot;</span> + <span class="string">&quot;degrees is %.4f%n&quot;</span>,</span><br><span class="line">                          degrees, Math.cos(radians));</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The tangent of %.1f &quot;</span> + <span class="string">&quot;degrees is %.4f%n&quot;</span>,</span><br><span class="line">                          degrees, Math.tan(radians));</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The arcsine of %.4f &quot;</span> + <span class="string">&quot;is %.4f degrees %n&quot;</span>, </span><br><span class="line">                          Math.sin(radians), </span><br><span class="line">                          Math.toDegrees(Math.asin(Math.sin(radians))));</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The arccosine of %.4f &quot;</span> + <span class="string">&quot;is %.4f degrees %n&quot;</span>, </span><br><span class="line">                          Math.cos(radians),  </span><br><span class="line">                          Math.toDegrees(Math.acos(Math.cos(radians))));</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;The arctangent of %.4f &quot;</span> + <span class="string">&quot;is %.4f degrees %n&quot;</span>, </span><br><span class="line">                          Math.tan(radians), </span><br><span class="line">                          Math.toDegrees(Math.atan(Math.tan(radians))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The value of pi is 3.1416</span><br><span class="line">The sine of 45.0 degrees is 0.7071</span><br><span class="line">The cosine of 45.0 degrees is 0.7071</span><br><span class="line">The tangent of 45.0 degrees is 1.0000</span><br><span class="line">The arcsine of 0.7071 is 45.0000 degrees</span><br><span class="line">The arccosine of 0.7071 is 45.0000 degrees</span><br><span class="line">The arctangent of 1.0000 is 45.0000 degrees</span><br></pre></td></tr></table></figure>
<h3 id="随机数字"><a href="#随机数字" class="headerlink" title="随机数字"></a>随机数字</h3><p>random()方法返回0.0和1.0之间的伪随机选择的数字。范围包括0.0但不是1.0。换句话说：0.0 &lt;&#x3D; Math.random()&lt;1.0。要获取不同范围的数字，可以对随机方法返回的值执行算术运算。例如，要生成0到9之间的整数，您可以写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>通过将值乘以10，可能值的范围变为0.0 &lt;&#x3D;数&lt;10.0。</p>
<p>当你需要生成一个随机数时，使用Math.random可以很好地工作。如果需要生成一系列随机数，则应该创建一个java.util.Random实例并调用该对象的方法来生成数字。</p>
<h2 id="Number总结"><a href="#Number总结" class="headerlink" title="Number总结"></a>Number总结</h2><hr>
<p>你可以使用这些包装类之一：Byte，Double，Float，Integer，Long或Short-来包装一个原始类型数字到一个对象中。如果需要的话，Java编译器自动包装（装箱）原始类型并在必要时再次拆箱。</p>
<p>Number类包含常量和有用的类方法。MIN_VALUE和MAX_VALUE常数包含该类型对象可以包含的最小和最大值。 byteValue，shortValue和类似方法将一个数字类型转换为另一个数字类型。valueOf方法将一个字符串转换为一个数字，而toString方法将一个数字转换成一个字符串。</p>
<p>要格式化一个包含数字的字符串用来输出，你可以使用在PrintStream类中的printf()或者format()方法。或者，您可以使用NumberFormat类来使用模式自定义数字格式。</p>
<p>Math类包含用于执行数学函数的各种类方法，包括指数，对数和三角方法。Math还包括基本算术函数，如绝对值和舍入，以及一个用于生成随机数的方法random()。</p>
<hr>
<h1 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h1><hr>
<p>大多数情况下，如果您使用单个字符值，则将使用原始字符类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="comment">// Unicode for uppercase Greek omega character</span></span><br><span class="line"><span class="type">char</span> <span class="variable">uniChar</span> <span class="operator">=</span> <span class="string">&#x27;\u03A9&#x27;</span>;</span><br><span class="line"><span class="comment">// an array of chars</span></span><br><span class="line"><span class="type">char</span>[] charArray = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>有时候，当你需要使用一个char作为一个对象，例如，作为一个对象期望的方法参数。Java编程语言为这种需求提供了一个包装类包装char到一个Character对象中。类型为Character的对象包含一个字段，其类型为char。这个<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">Character</a>类还提供了一些用于操作字符的有用的类（即静态）方法。</p>
<p>你可以使用Character的构造方法创建一个Character对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在某些情况下，Java编译器还将为您创建一个Character对象。例如，如果你传递一个原始类型的char给一个期望对象做参数的方法，则编译器会自动为你将char转换为Character。此特性称为自动装箱或拆箱，如果转换为另一种方式。有关自动装箱和拆箱的更多信息，请参阅<a href="http://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">自动装箱和拆箱</a>。</p>
<blockquote>
<p><strong>注意：</strong>Character类是不可变的，因此一旦创建，则不能更改Character对象。</p>
</blockquote>
<p>下表列出了Character类中一些最有用的方法，但并不详尽。有关此类中所有方法的完整列表（有超过50个），请参阅java.lang.Character API规范。</p>
<center>***Character类中有用的方法***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isLetter(char ch)<br>boolean isDigit(char ch)</td>
<td>分别确定指定的char值是否是字母或数字。</td>
</tr>
<tr>
<td>boolean isWhitespace(char ch)</td>
<td>确定指定的char值是否为空格。</td>
</tr>
<tr>
<td>boolean isUpperCase(char ch)<br>boolean isLowerCase(char ch)</td>
<td>分别是确定指定的char值大写还是小写。</td>
</tr>
<tr>
<td>char toUpperCase(char ch)<br>char toLowerCase(char ch)</td>
<td>返回指定字符值的大写或小写形式。</td>
</tr>
<tr>
<td>toString(char ch)</td>
<td>返回一个表示指定字符值的String对象，即一个字符的字符串。</td>
</tr>
</tbody></table>
<h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><hr>
<p>前面带有反斜杠（\）的字符是一个转义序列，对编译器有特殊的意义。下表显示了Java转义序列：</p>
<p>前面带有反斜杠（\）的字符是一个转义序列，对编译器有特殊的意义。下表显示了Java转义序列：</p>
<center>***转义序列***</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>此时在文本中插入一个tab。</td>
</tr>
<tr>
<td>\b</td>
<td>此时在文本中插入退格。</td>
</tr>
<tr>
<td>\n</td>
<td>此时在文本中插入换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>此时在文本中插入回车符。</td>
</tr>
<tr>
<td>\f</td>
<td>此时在文本中插入换页。</td>
</tr>
<tr>
<td>&#39;</td>
<td>此时在文本中插入单引号。</td>
</tr>
<tr>
<td>&quot;</td>
<td>此时在文本中插入双引号。</td>
</tr>
<tr>
<td>\</td>
<td>此时在文本中插入反斜杠字符。</td>
</tr>
</tbody></table>
<p>当打印语句中遇到转义序列时，编译器将相应地进行解释。例如，如果要在引号内加上引号，您必须在内部引号上使用转义序列“\”。要打印该句子<br>She said “Hello!” to me.<br>你应当写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;She said \&quot;Hello!\&quot; to me.&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Strings-1"><a href="#Strings-1" class="headerlink" title="Strings"></a>Strings</h1><hr>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><hr>
<p>String，在Java编程中广泛使用，它是一序列的字符。在Java编程语言中，字符串是对象。</p>
<p>Java平台提供了String类来创建和操作字符串。</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>创建字符串的最直接方式是写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，“Hello world！”是一个字符串文字 - 代码中的一系列字符，用双引号括起来。每当在代码中遇到字符串文字时，编译器将创建一个带有值的String对象 - 这里是，Hello world！。</p>
<p>与任何其他对象一样，您可以使用new关键字和构造函数来创建String对象。String类有十三个构造函数，允许您使用不同的源（例如字符数组）提供字符串的初始值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] helloArray = &#123; <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">helloString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(helloArray);</span><br><span class="line">System.out.println(helloString);</span><br></pre></td></tr></table></figure>
<p>此代码段的最后一行显示hello。</p>
<blockquote>
<p><strong>注意：</strong>String类是不可变的，所以一旦创建一个String对象，它就不可再改变。String类有许多方法，其中一些将在下面讨论，似乎可以修改字符串。因为String是不可变的，所以这些方法实际是创建并返回了一个新的字符串，它包含了操作的结果</p>
</blockquote>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>用于获取有关对象的信息的方法称为访问器方法。你可以在String中使用的一个访问器方法是length()方法，它返回包含在String对象中的字符数量。在下面两行代码执行后，len等于17：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">palindrome</span> <span class="operator">=</span> <span class="string">&quot;Dot saw I was Tod&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> palindrome.length();</span><br></pre></td></tr></table></figure>
<p> palindrome是一个对称的单词或句子- 忽略大小写和标点符号，它的向前和向后的拼写相同的。这是一个简短且低效的方案来反转palindrome字符串。调用String的charAt(i)方法，它返回字符串中的第i个字符，从0开始计数。<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">palindrome</span> <span class="operator">=</span> <span class="string">&quot;Dot saw I was Tod&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> palindrome.length();</span><br><span class="line">        <span class="type">char</span>[] tempCharArray = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">        <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// put original string in an </span></span><br><span class="line">        <span class="comment">// array of chars</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            tempCharArray[i] = </span><br><span class="line">                palindrome.charAt(i);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reverse array of chars</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            charArray[j] =</span><br><span class="line">                tempCharArray[len - <span class="number">1</span> - j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">reversePalindrome</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">        System.out.println(reversePalindrome);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行程序生成此输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doT saw I was toD</span><br></pre></td></tr></table></figure>
<p>要完成字符串反转，程序必须将字符串转换为字符数组（第一个for循环），将数组转换为第二个数组（第二个循环），然后转换回一个字符串。String类包含一个方法getChars()，将字符串或字符串的一部分转换为字符数组，所以我们可以用以下代码替换上述程序中的第一个for循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">palindrome.getChars(<span class="number">0</span>, len, tempCharArray, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String类包含一个方法用于连接两个字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string1.concat(string2);</span><br></pre></td></tr></table></figure>
<p>这个返回一个新的字符串，它是在string1后添加了string2。</p>
<p>你也以字符串文字使用concat()方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;My name is &quot;</span>.concat(<span class="string">&quot;Rumplestiltskin&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>String更通常的是使用+操作符来连接，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello,&quot;</span> + <span class="string">&quot; world&quot;</span> + <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>
<p>+操作符广泛应用于print语句中，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;saw I was &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Dot &quot;</span> + string1 + <span class="string">&quot;Tod&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>打印出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dot saw I was Tod</span><br></pre></td></tr></table></figure>
<p>这样的连接可以是任何对象的混合物。对于不是String的每个对象，调用其toString()方法将其转换为String。</p>
<blockquote>
<p><strong>注意：</strong>Java编程语言不允许文字字符串跨越源文件中的行，因此您必须在多行字符串中的每一行的末尾使用+连接运算符。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">quote</span> <span class="operator">=</span> </span><br><span class="line">    <span class="string">&quot;Now is the time for all good &quot;</span> +</span><br><span class="line">    <span class="string">&quot;men to come to the aid of their country.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>再次的，中断的字符串在行之间使用+字符串，在print语句中非常常见。</p>
<h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>你已经看到了使用printf()和format()方法来打印输出格式化的数字。String类有一个等同的类方法，format(),它返回一个String对象而不是PrintStream对象。</p>
<p>使用String的静态format()方法运行你创建一个可重用的格式化字符串，而不是一次性打印语句。比如，相比</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;The value of the float &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;variable is %f, while &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;the value of the &quot;</span> + </span><br><span class="line">                  <span class="string">&quot;integer variable is %d, &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;and the string is %s&quot;</span>, </span><br><span class="line">                  floatVar, intVar, stringVar); </span><br></pre></td></tr></table></figure>
<p>你可以这么些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fs;</span><br><span class="line">fs = String.format(<span class="string">&quot;The value of the float &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;variable is %f, while &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;the value of the &quot;</span> + </span><br><span class="line">                   <span class="string">&quot;integer variable is %d, &quot;</span> +</span><br><span class="line">                   <span class="string">&quot; and the string is %s&quot;</span>,</span><br><span class="line">                   floatVar, intVar, stringVar);</span><br><span class="line">System.out.println(fs);</span><br></pre></td></tr></table></figure>
<h2 id="Number与String之间的转换"><a href="#Number与String之间的转换" class="headerlink" title="Number与String之间的转换"></a>Number与String之间的转换</h2><hr>
<h3 id="String转换为Number"><a href="#String转换为Number" class="headerlink" title="String转换为Number"></a>String转换为Number</h3><p>通常，数字数据在程序中以一个字符串对象结束一个程序——比如，用户输入的值。</p>
<p>Number子类包装了原始的数字类型（Byte，Integer，Double，Float，Long和Short）每一个都提供了一个名为valueOf的类方法，它将字符串转换一个那个包装类类型。这有一个例子，ValueOfDemo，它从命令行获取两个字符串，将它们转换为数字，并且在值上执行算数操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueOfDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个程序在命令行上需要两个参数</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//字符串转换为数字</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> (Float.valueOf(args[<span class="number">0</span>])).floatValue(); </span><br><span class="line">            <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> (Float.valueOf(args[<span class="number">1</span>])).floatValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 做一些算数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a + b = &quot;</span> +</span><br><span class="line">                               (a + b));</span><br><span class="line">            System.out.println(<span class="string">&quot;a - b = &quot;</span> +</span><br><span class="line">                               (a - b));</span><br><span class="line">            System.out.println(<span class="string">&quot;a * b = &quot;</span> +</span><br><span class="line">                               (a * b));</span><br><span class="line">            System.out.println(<span class="string">&quot;a / b = &quot;</span> +</span><br><span class="line">                               (a / b));</span><br><span class="line">            System.out.println(<span class="string">&quot;a % b = &quot;</span> +</span><br><span class="line">                               (a % b));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This program &quot;</span> +</span><br><span class="line">                <span class="string">&quot;requires two command-line arguments.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是使用4.5和87.2作为命令行参数时程序的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b = 91.7</span><br><span class="line">a - b = -82.7</span><br><span class="line">a * b = 392.4</span><br><span class="line">a / b = 0.0516055</span><br><span class="line">a % b = 4.5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>每一个Number子类包装了原始数字类型并且提供了一个parseXXX()方法（比如，parseFloat()），它可以用来将字符串转换为原始类型数字。因为返回的是一个原始类型而不是对象，parseFloat()方法要比valueOf()方法更直接。比如在ValueOfDemo程序中，我们会使用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> Float.parseFloat(args[<span class="number">0</span>]);</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> Float.parseFloat(args[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h3><p>有时您需要将一个数字转换为字符串，因为您需要以字符串形式对该值进行操作。将数字转换为字符串有几种简单的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// Concatenate &quot;i&quot; with an empty string; conversion is handled for you.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + i;</span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="comment">// The valueOf class method.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(i);</span><br></pre></td></tr></table></figure>
<p>每一个Number子类都包含一个类方法，toString<br>，它将其原始类型转换为字符串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Integer.toString(i); </span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> Double.toString(d); </span><br></pre></td></tr></table></figure>
<p>ToStringDemo示例使用toString方法将数字转换为字符串。然后，程序使用一些字符串方法来计算小数点前后的位数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">858.48</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Double.toString(d);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">dot</span> <span class="operator">=</span> s.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(dot + <span class="string">&quot; digits &quot;</span> +</span><br><span class="line">            <span class="string">&quot;before decimal point.&quot;</span>);</span><br><span class="line">        System.out.println( (s.length() - dot - <span class="number">1</span>) +</span><br><span class="line">            <span class="string">&quot; digits after decimal point.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 digits before decimal point.</span><br><span class="line">2 digits after decimal point.</span><br></pre></td></tr></table></figure>
<h2 id="操纵字符串中的字符"><a href="#操纵字符串中的字符" class="headerlink" title="操纵字符串中的字符"></a>操纵字符串中的字符</h2><hr>
<p>String类有许多方法用于检查字符串的内容，查找字符串中的字符或子字符串，更改大小写和其他任务。</p>
<h3 id="通过索引获取字符和子字符串"><a href="#通过索引获取字符和子字符串" class="headerlink" title="通过索引获取字符和子字符串"></a>通过索引获取字符和子字符串</h3><p>您可以通过调用charAt()访问器方法来获取字符串中特定索引处的字符。第一个字符的索引为0，而最后一个字符的索引为length() - 1。例如，以下代码在字符串中的索引9处获取字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">anotherPalindrome</span> <span class="operator">=</span> <span class="string">&quot;Niagara. O roar again!&quot;</span>; </span><br><span class="line"><span class="type">char</span> <span class="variable">aChar</span> <span class="operator">=</span> anotherPalindrome.charAt(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>指数从0开始，因此索引9处的字符为“O”。</p>
<p>如果要从字符串中获取多个连续字符，可以使用substring方法。子串方法有两个版本，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>返回一个新字符串，该字符串是此字符串的子字符串。子字符串从指定的beginIndex开始，并扩展到索引endIndex - 1处的字符。</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>返回一个新字符串，该字符串是此字符串的子字符串。 int参数指定第一个字符的索引。这里，返回的子字符串扩展到原始字符串的末尾。</td>
</tr>
</tbody></table>
<h3 id="操作字符串的其他方法"><a href="#操作字符串的其他方法" class="headerlink" title="操作字符串的其他方法"></a>操作字符串的其他方法</h3><p>这里有几个其他用于操作字符串的String方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String[] split(String regex)<br>String[] split(String regex, int limit)</td>
<td>搜索由string参数（包含正则表达式）指定的匹配项，并相应地将此字符串拆分为字符串数组。可选的int参数指定返回的数组的最大大小。</td>
</tr>
<tr>
<td>CharSequence subSequence(int beginIndex, int endIndex)</td>
<td>返回从beginIndex索引建立的新字符序列，直到endIndex - 1。</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回此字符串的拷贝，并删除前导和尾随的空格。</td>
</tr>
<tr>
<td>String toLowerCase()<br>String toUpperCase()</td>
<td>返回一个转换为小写或大写的字符串的拷贝。如果不需要转换，这些方法返回原始字符串。</td>
</tr>
</tbody></table>
<h3 id="搜索字符串中的字符和子字符串"><a href="#搜索字符串中的字符和子字符串" class="headerlink" title="搜索字符串中的字符和子字符串"></a>搜索字符串中的字符和子字符串</h3><p>这里有一些其他String方法用于查找字符串中的字符或子字符串。String类提供访问器方法，返回特定字符或子字符串的字符串中的位置：: indexOf()和lastIndexOf().indexOf()方法从字符串的开头向后搜索，lastIndexOf()方法从字符串的末尾向前搜索。如果没有找到一个字符或子字符串，则indexOf()和lastIndexOf()返回-1。</p>
<p>String类还提供了一个搜索方法contains，如果字符串包含特定的字符序列，则返回true。当您只需要知道该字符串包含一个字符序列，但精确位置并不重要时，请使用此方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int indexOf(int ch)<br>int lastIndexOf(int ch)</td>
<td>返回指定字符第一次（最后）出现的索引</td>
</tr>
<tr>
<td>int indexOf(int ch, int fromIndex)<br>int lastIndexOf(int ch, int fromIndex)</td>
<td>从指定索引向后（向前）查找起，返回指定字符第一次（最后一次）出现的索引</td>
</tr>
<tr>
<td>int indexOf(String str)<br>int lastIndexOf(String str)</td>
<td>返回指定子字符串第一次（最后）出现的索引</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)<br>int lastIndexOf(String str, int fromIndex)</td>
<td>从指定索引向后（向前）查找起，返回指定子字符串第一次（最后一次）出现的索引</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>如果字符串包含指定的字符序列，则返回true。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong>CharSequence是由String类实现的接口。因此，您可以使用一个字符串作为contains()方法的参数。</p>
</blockquote>
<h3 id="将字符和子字符串替换为字符串"><a href="#将字符和子字符串替换为字符串" class="headerlink" title="将字符和子字符串替换为字符串"></a>将字符和子字符串替换为字符串</h3><p>String类在字符串中插入字符或子字符串的方法很少。一般来说，它们不是必需的：您可以通过将您从字符串删除后剩下的子字符串与要插入的子字符串串联来创建一个新字符串。</p>
<p>然而，String类确实有四种替换找到的字符或子字符串的方法。他们是：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String replace(char oldChar, char newChar)</td>
<td>返回使用newChar替换此字符串中所有出现oldChar的新字符串。</td>
</tr>
<tr>
<td>String replace(CharSequence target, CharSequence replacement)</td>
<td>将与字面目标序列匹配的字符串的每个子字符串替换为指定的文字替换序列。</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>替换每个与给定正则表达式匹配的子字符串为给定的替换字符串</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>替换第一个与给定正则表达式匹配的子字符串为给定的替换字符串</td>
</tr>
</tbody></table>
<h3 id="一个示例-1"><a href="#一个示例-1" class="headerlink" title="一个示例"></a>一个示例</h3><p>以下类Filename说明了使用lastIndexOf()和substring()来隔离文件名的不同部分。</p>
<blockquote>
<p><strong>注意：</strong>以下Filename类中的方法不执行任何错误检查，并假定它们的参数包含完整的目录路径和带扩展名的文件名。如果这些方法是生产代码，他们将验证他们的参数是否正确构造。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filename</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String fullPath;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> pathSeparator, </span><br><span class="line">                 extensionSeparator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Filename</span><span class="params">(String str, <span class="type">char</span> sep, <span class="type">char</span> ext)</span> &#123;</span><br><span class="line">        fullPath = str;</span><br><span class="line">        pathSeparator = sep;</span><br><span class="line">        extensionSeparator = ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">extension</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dot</span> <span class="operator">=</span> fullPath.lastIndexOf(extensionSeparator);</span><br><span class="line">        <span class="keyword">return</span> fullPath.substring(dot + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gets filename without extension</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filename</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dot</span> <span class="operator">=</span> fullPath.lastIndexOf(extensionSeparator);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sep</span> <span class="operator">=</span> fullPath.lastIndexOf(pathSeparator);</span><br><span class="line">        <span class="keyword">return</span> fullPath.substring(sep + <span class="number">1</span>, dot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">path</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sep</span> <span class="operator">=</span> fullPath.lastIndexOf(pathSeparator);</span><br><span class="line">        <span class="keyword">return</span> fullPath.substring(<span class="number">0</span>, sep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有一个程序FilenameDemo，它构造一个Filename对象并调用其所有方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilenameDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FPATH</span> <span class="operator">=</span> <span class="string">&quot;/home/user/index.html&quot;</span>;</span><br><span class="line">        <span class="type">Filename</span> <span class="variable">myHomePage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filename</span>(FPATH, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Extension = &quot;</span> + myHomePage.extension());</span><br><span class="line">        System.out.println(<span class="string">&quot;Filename = &quot;</span> + myHomePage.filename());</span><br><span class="line">        System.out.println(<span class="string">&quot;Path = &quot;</span> + myHomePage.path());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是程序的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Extension = html</span><br><span class="line">Filename = index</span><br><span class="line">Path = /home/user</span><br></pre></td></tr></table></figure>
<p>如下图所示，我们的 extension方法使用lastIndexOf来查找文件名中的句点（.）的最后一次出现。然后substring使用lastIndexOf的返回值来提取文件扩展名 - 即从字符串的句点到结尾的子字符串。该代码假定文件名中有一个句点;如果文件名没有句点，则lastIndexOf返回-1，而substring方法会引发StringIndexOutOfBoundsException。<br>![](&#x2F;images&#x2F;java base&#x2F;objects-lastIndexOf.gif)<br>另外，请注意，extension方法使用dot + 1 作为substring的参数。如果期间句点（.）是字符串的最后一个字符，则dot + 1等于字符串的长度，该字符串的长度大于字符串中最大的索引（因为索引从0开始）。这是substring的合法参数，因为该方法接受一个等于但不大于字符串长度的索引，并将其解释为“字符串的结尾”。</p>
<h2 id="比较字符串与字符串的部分"><a href="#比较字符串与字符串的部分" class="headerlink" title="比较字符串与字符串的部分"></a>比较字符串与字符串的部分</h2><hr>
<p>String类有许多用于比较字符串和字符串部分的方法。下表列出了这些方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean endsWith(String suffix)<br>boolean startsWith(String prefix)</td>
<td>如果这个字符串以作为方法参数的指定的字符串开始或结尾，则返回true</td>
</tr>
<tr>
<td>boolean startsWith(String prefix, int offset)</td>
<td>考虑从索引offset开始的字符串，如果以指定为参数的子字符串开头，则返回true。</td>
</tr>
<tr>
<td>int compareTo(String anotherString)</td>
<td>按字典顺序比较两个字符串。返回一个整数，表示该字符串是否大于（result is&gt; 0），等于（result is &#x3D; 0）或小于（result is &lt;0）。</td>
</tr>
<tr>
<td>int compareToIgnoreCase(String str)</td>
<td>按字典顺序比较两个字符串，但不考虑大小写。返回一个整数，表示该字符串是否大于（result is&gt; 0），等于（result is &#x3D; 0）或小于（result is &lt;0）。</td>
</tr>
<tr>
<td>boolean equals(Object anObject)</td>
<td>当且仅当参数是与该对象相同的字符序列的String对象时，才返回true。</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>不考虑大小写，当且仅当参数是与该对象相同的字符序列的String对象时，才返回true。</td>
</tr>
<tr>
<td>boolean regionMatches(int toffset, String other, int ooffset, int len)</td>
<td>测试此字符串的指定区域是否与String参数的指定区域匹配。<br>区域的长度为len，并从该字符串的索引toffset开始，从另一个字符串的ooffset开始。</td>
</tr>
<tr>
<td>boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</td>
<td>测试此字符串的指定区域是否与String参数的指定区域匹配。<br>区域的长度为len，并从该字符串的索引toffset开始，从另一个字符串的ooffset开始。<br>布尔值表示是否应忽略大小写;如果为true，则在比较字符时忽略大小写。</td>
</tr>
<tr>
<td>boolean matches(String regex)</td>
<td>测试此字符串是否与指定的正则表达式匹配。</td>
</tr>
</tbody></table>
<p>以下程序RegionMatchesDemo使用regionMatches方法来搜索另一个字符串中的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegionMatchesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">searchMe</span> <span class="operator">=</span> <span class="string">&quot;Green Eggs and Ham&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">findMe</span> <span class="operator">=</span> <span class="string">&quot;Eggs&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">searchMeLength</span> <span class="operator">=</span> searchMe.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">findMeLength</span> <span class="operator">=</span> findMe.length();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">foundIt</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">             i &lt;= (searchMeLength - findMeLength);</span><br><span class="line">             i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (searchMe.regionMatches(i, findMe, <span class="number">0</span>, findMeLength)) &#123;</span><br><span class="line">              foundIt = <span class="literal">true</span>;</span><br><span class="line">              System.out.println(searchMe.substring(i, i + findMeLength));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!foundIt)</span><br><span class="line">            System.out.println(<span class="string">&quot;No match found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出的结果是Eggs。<br>该程序一步一步地遍历searchMe一个字符引用的字符串。对于每个字符，程序调用regionMatches方法来确定以当前字符开头的子字符串是否与程序正在查找的字符串匹配。</p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>StringBuilder对象就像String对象，除了它可以被修改。在内部，这些对象被视为包含一系列字符的可变长度数组。在任何时候，序列的长度和内容可以通过方法调用来改变。</p>
<p>应该始终使用String，除非StringBuilder在简单代码方面提供了优势（请参阅本节末尾的示例程序）或更好的性能。例如，如果您需要连接大量的字符串，则附加到StringBuilder对象更有效。</p>
<h3 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h3><p>StringBuilder类就像String类一样有一个length()方法，它返回构建器中字符序列的长度。</p>
<p>不像String，每个StringBuilder都有一个容量，它是已分配的字符空间数。由capacity()方法返回的容量始终大于或等于字符长度（通常大于），并根据需要自动扩展以适应字符串构建器的添加。</p>
<center>***StringBuilder构造器***</center>

<table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>创建一个空的字符串构建器，容量为16（16个空元素）。</td>
</tr>
<tr>
<td>StringBuilder(CharSequence cs)</td>
<td>构造一个包含与指定的CharSequence相同的字符的字符串构建器，再在CharSequence尾部加上16个空的元素。</td>
</tr>
<tr>
<td>StringBuilder(int initCapacity)</td>
<td>创建具有指定初始容量的空的字符串构建器。</td>
</tr>
<tr>
<td>StringBuilder(String s)</td>
<td>创建一个字符串构建器，其值由指定的字符串初始化，另外还有一个额外的16个空的元素。</td>
</tr>
</tbody></table>
<p>例如，以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建空的构建器，容量为16 </span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//开始添加9个字符串 </span></span><br><span class="line">sb.append（ “问候”）;</span><br></pre></td></tr></table></figure>
<p>将生成长度为9的字符串构建器，其容量为16：<br>![](&#x2F;images&#x2F;java base&#x2F;objects-stringBuffer.gif)<br>StringBuilder类有一些和长度与容量相关的方法，而在String类中没有的</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void setLength(int newLength)</td>
<td>设置字符序列的长度。如果newLength比length()小，字符序列中最后的字符会被截去。如果newLength比length()大，null字符会被添加到字符序列尾部</td>
</tr>
<tr>
<td>void ensureCapacity(int minCapacity)</td>
<td>确保容量至少等于指定的最小值。</td>
</tr>
</tbody></table>
<p>许多操作（例如，append()，insert()或setLength()）可以增加字符串构建器中字符序列的长度，以使结果的length()大于当前的capacity()。发生这种情况时，容量会自动增加。</p>
<h3 id="StringBuilder操作"><a href="#StringBuilder操作" class="headerlink" title="StringBuilder操作"></a>StringBuilder操作</h3><p>StringBuilder中不能在String中使用的主要操作是append()和insert()方法，它们被重载以便接受任何类型的数据。每个将其参数转换为字符串，然后将该字符串的字符附加或插入字符串构建器中的字符序列。append方法总是在现有字符序列的末尾添加这些字符，而insert方法会在指定的点添加字符。<br>以下是StringBuilder类的一些方法。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder append(boolean b)<br>StringBuilder append(char c)<br>StringBuilder append(char[] str)<br>StringBuilder append(char[] str, int offset, int len)<br>StringBuilder append(double d)<br>StringBuilder append(float f)<br>StringBuilder append(int i)<br>StringBuilder append(long lng)<br>StringBuilder append(Object obj)<br>StringBuilder append(String s)</td>
<td>将参数附加到此字符串构建器。在附加操作发生之前，数据将转换为字符串。</td>
</tr>
<tr>
<td>StringBuilder delete(int start, int end<br>StringBuilder deleteCharAt(int index)</td>
<td>第一个方法删除子StringBuilder字符序列中从start到end-1（包括）的序列。第二个方法删除位于索引处的字符</td>
</tr>
<tr>
<td>StringBuilder insert(int offset, boolean b)<br>StringBuilder insert(int offset, char c)<br>StringBuilder insert(int offset, char[] str)<br>StringBuilder insert(int index, char[] str, int offset, int len)<br>StringBuilder insert(int offset, double d)<br>StringBuilder insert(int offset, float f)<br>StringBuilder insert(int offset, int i)<br>StringBuilder insert(int offset, long lng)<br>StringBuilder insert(int offset, Object obj)<br>StringBuilder insert(int offset, String s)</td>
<td>插入第二个参数到字符串构建器。第一个int参数表示要插入数据前的索引。这个数据在插入操作发生前先转换为字符串类型</td>
</tr>
<tr>
<td>StringBuilder replace(int start, int end, String s)<br>void setCharAt(int index, char c)</td>
<td>替换此字符串构建器中指定的字符。</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>反转此字符串构建器中的字符序列。</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回一个包含构建器中字符序列的字符串。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong>您可以在StringBuilder对象中使用String的任何方法，通过使用StringBuilder类的toString()方法将字符串构建器首先转换为一个字符串。然后使用StringBuilder（String str）构造函数将字符串转换回到字符串构建器。</p>
</blockquote>
<h4 id="一个示例-2"><a href="#一个示例-2" class="headerlink" title="一个示例"></a>一个示例</h4><p>在“Strings”一节中列出的StringDemo程序是一个程序的例子，如果使用StringBuilder而不是String，程序将会更有效。<br>StringDemo反转了一个palindrome。在这里，再次演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">palindrome</span> <span class="operator">=</span> <span class="string">&quot;Dot saw I was Tod&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> palindrome.length();</span><br><span class="line">        <span class="type">char</span>[] tempCharArray = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">        <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// put original string in an </span></span><br><span class="line">        <span class="comment">// array of chars</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            tempCharArray[i] = </span><br><span class="line">                palindrome.charAt(i);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reverse array of chars</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            charArray[j] =</span><br><span class="line">                tempCharArray[len - <span class="number">1</span> - j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">reversePalindrome</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">        System.out.println(reversePalindrome);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序生成此输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doT saw I was toD</span><br></pre></td></tr></table></figure>
<p>要完成字符串反转，程序必须将字符串转换为字符数组（第一个for循环），将数组转换为第二个数组（第二个循环），然后转换回一个字符串。</p>
<p>如果将palindrome 字符串转换为字符串构建器，则可以在StringBuilder类中使用reverse()方法。它使代码更简单，更容易阅读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">palindrome</span> <span class="operator">=</span> <span class="string">&quot;Dot saw I was Tod&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(palindrome);</span><br><span class="line">        </span><br><span class="line">        sb.reverse();  <span class="comment">// reverse it</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序生成相同的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doT saw I was toD</span><br></pre></td></tr></table></figure>
<p>请注意，println()会打印一个字符串构建器，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure>
<p>因为sb.toString()被隐式调用，因为它与println()调用中的任何其他对象一样。</p>
<blockquote>
<p><strong>注意</strong>还有一个StringBuffer类与StringBuilder类完全相同，除了它通过使其方法同步来线程安全。</p>
</blockquote>
<h3 id="Character和String总结"><a href="#Character和String总结" class="headerlink" title="Character和String总结"></a>Character和String总结</h3><p>大多数时间，如果你要使用单个字符值，你可以使用原始类型<strong>char</strong>。然而，有时你需要将字符作为对象使用—例如，一个方法参数是一个对象。Java编程语言提供了一个包转类<strong>Character</strong>包装了<strong>char</strong>。类型为<strong>Character</strong>的对象包含一个类型为<strong>char</strong>的单个字段。此Character类还提供了一些用于操作字符的类（即静态）方法。</p>
<p><strong>String</strong>是一系列字符，并广泛应用于Java编程。在Java编程语言中，<strong>String</strong>是对象。<strong>String</strong>类有超过60个方法和13个构造方法。</p>
<p>最常见的是，是如下语句创建一个String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>而不是使用String构造方法。</p>
<p><strong>String</strong>类有很多方法来查找和检索子字符串；然后可以使用 <strong>+</strong> 连接运算符轻松地将这些重新组合成新的字符串。</p>
<p>String类还包括一些实用方法，其中包括**split()<strong>，</strong>toLowerCase()<strong>，</strong>toUpperCase()<strong>和</strong>valueOf()**。后一种方法在将用户输入字符串转换为数字时不可或缺。Number类也有将字符串转换为数字的方法。反之亦然。</p>
<p>除了<strong>String</strong>类，还有一个<strong>StringBuilder</strong>类。使用StringBuilder对象有时可以比使用String更有效率。<strong>StringBuilder</strong>类提供了一些可用于字符串的方法，其中包括**reverse()**。然而，一般来说，String类具有更多种类的方法。</p>
<p>一个String可以通过使用StringBuilder的构造方法转换为一个StringBuilder。一个StringBuilder也可以使用toString()方法来转换为String。</p>
<hr>
<h1 id="自动装箱拆箱"><a href="#自动装箱拆箱" class="headerlink" title="自动装箱拆箱"></a>自动装箱拆箱</h1><hr>
<p>自动装箱（AutoBoxing）是Java编译器在原始类型与其对应的包装器类之间进行的自动转换。例如，将一个int转换为一个Integer，一个double转换为一个Double，等等。如果进行相反的转换，这称为拆箱（unboxing）。</p>
<p>这有自动装箱的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>本节其余的例子使用泛型。<br>考虑以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">50</span>; i += <span class="number">2</span>)</span><br><span class="line">    li.add(i);</span><br></pre></td></tr></table></figure>
<p>尽管你将int值作为原始类型，而不是以Integer对象添加到li中。由于li是Integer对象列表，而不是int值列表，你可能会想知道为什么Java编译器不会发出编译时错误。编译器之所以不产生错误是因为它从i创建一个Integer对象，并将对象添加到li。因此，编译器在运行时将以前的代码转换为以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">50</span>; i += <span class="number">2</span>)</span><br><span class="line">    li.add(Integer.valueOf(i));</span><br></pre></td></tr></table></figure>
<p><font style="color:#ec70ae;">将原始值（例如int）转换为对应的包装器类（Integer）的对象称为自动装箱。</font>当原始类型值是以下时，Java编译器应用自动装箱：</p>
<ul>
<li>作为参数传递给一个期望相应包装器类的对象的方法。</li>
<li>分配给相应包装类的变量。</li>
</ul>
<p>考虑以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumEven</span><span class="params">(List&lt;Integer&gt; li)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i: li)</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为余数（％）和一元加（+ &#x3D;）运算符不适用于<strong>Integer</strong>对象，你可能会想知道为什么Java编译器编译该方法而不发出任何错误。编译器不产生错误是因为它调用<strong>intValue</strong>方法在运行时将<strong>Integer</strong>转换为<strong>int</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumEven</span><span class="params">(List&lt;Integer&gt; li)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : li)</span><br><span class="line">        <span class="keyword">if</span> (i.intValue() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            sum += i.intValue();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:#ec70ae;">将包装器类型（Integer）的对象转换为对应的原始（int）值称为拆箱。</font>当一个包转类的对象为以下时，Java编译器应用拆箱：</p>
<ul>
<li>作为参数传递给期望相应原始类型的值的方法。</li>
<li>分配给相应原始类型的变量。</li>
</ul>
<p>如下实例展示拆箱的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unboxing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(-<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 通过方法调用拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">absVal</span> <span class="operator">=</span> absoluteValue(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;absolute value of &quot;</span> + i + <span class="string">&quot; = &quot;</span> + absVal);</span><br><span class="line"></span><br><span class="line">        List&lt;Double&gt; ld = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ld.add(<span class="number">3.1416</span>);    <span class="comment">// 通过方法调用π被自动装箱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过分配拆箱</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> ld.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;pi = &quot;</span> + pi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">absoluteValue</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; <span class="number">0</span>) ? -i : i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序打印如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absolute value of -8 = 8</span><br><span class="line">pi = 3.1416</span><br></pre></td></tr></table></figure>

<p>自动装箱和拆箱让开发者可以编写更间接的代码，并易于阅读。下面的表格列举了原始类型和它们相应的包装类，这被用于Java编译器来自动装箱和拆箱：</p>
<table>
<thead>
<tr>
<th>原始类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 重要类</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Date-Time（二）API</title>
    <url>/2017/07/18/Java-Date-Time%EF%BC%88%E4%BA%8C%EF%BC%89API/</url>
    <content><![CDATA[<p>Date-Time API的核心是java.time包。定义在java.time中的类的它们的日历系统是基于ISO日历，它是代表日期和时间的世界标准。ISO日历遵循前公历规则。公历日历在1582年引入；在前公历日历中，日期从那时起向后延伸，以创建一致，统一的时间线，并简化日期计算。</p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<blockquote>
<p>本节比较人类时间和机器时间的概念，提供了java.time包中主要的基于时间的类的表。</p>
</blockquote>
<p>代表时间有两种基本方式。一种是以人为本代表时间的方式，称为人类时间，如年，月，日，时，分，秒。另一种方式是机器时间，以一个纳秒的分辨率，从一个起源的时间线不断地测量时间，被称为时代。Date-Time包提供了丰富的类来代表日期和时间。在Date-Time API中一些类旨在表示机器时间，而另一些则更适合代表人类时间。</p>
<span id="more"></span>
<p>首先确定您需要哪些方面的日期和时间，然后选择满足这些需求的类。当你选择基于时间的类后，你首先决定是否需要代表人类时间还是机器时间。然后，您将确定您需要代表时间的哪些方面。你是需要一个时区？日期和时间？只是日期？如果你需要一个日期，你是需要月，天，年，还是子集？</p>
<blockquote>
<p>术语：在Date-Time API中捕获并使用日期或时间的值的类，比如Instant，LocalDateTime和ZonedDateTime，在本教程中被称为基于时间的类（或类型）。一些提供支持的类型，如TemporalAdjuster接口或DayOfWeek枚举，不包括在此定义内。</p>
</blockquote>
<p>比如，你可能使用一个LocalDate对象来表示生日日期，因为大多数人注意它们的生日，无论他们是在他们的出生城市还是跨过全球，在国际日期变更线的另一边。如果您正在追踪占星术时间，那么您可能希望使用LocalDateTime对象来表示出生日期和时间，或者ZonedDateTime，它还包括时区。如果你创建一个时间戳，那么你最可能想要使用一个Instant，它允许您将时间轴上的一个瞬时点与另一个瞬时点进行比较。</p>
<p>下面的表格总结了java.time包中的基于时间的类，它们存储了日期与&#x2F;或时间的信息，或者可以用来衡量一段时间。在列中的对号指示该类使用该特定类型的数据，并且toString Output列显示使用toString方法打印的实例。Where Discussed列链接到本教程相应的位置。</p>
<style>
table:first-of-type th:first-of-type {
    width: 98px;
}
table:first-of-type th:nth-of-type(2),table:first-of-type th:nth-of-type(3),table:first-of-type th:nth-of-type(4),table:first-of-type th:nth-of-type(5),table:first-of-type th:nth-of-type(6),table:first-of-type th:nth-of-type(7),table:first-of-type th:nth-of-type(8),table:first-of-type th:nth-of-type(9){
    width: 20px;
}

</style>

<table>
<thead>
<tr>
<th>类或枚举</th>
<th>年</th>
<th>月</th>
<th>日</th>
<th>小时</th>
<th>分钟</th>
<th>秒</th>
<th>时区偏移</th>
<th>时区ID</th>
<th>toString Output</th>
<th>Where Discussed</th>
</tr>
</thead>
<tbody><tr>
<td>Instant</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>2013-08-20T15:16:26.355Z</td>
<td><a href="/#Instant">Instant Class</a></td>
</tr>
<tr>
<td>LocalDate</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2013-08-20</td>
<td></td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>2013-08-20T08:16:26.937</td>
<td></td>
</tr>
<tr>
<td>ZonedDateTime</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>2013-08-21T00:16:26.941+09:00[Asia&#x2F;Tokyo]</td>
<td></td>
</tr>
<tr>
<td>LocalTime</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>08:16:26.943</td>
<td></td>
</tr>
<tr>
<td>MonthDay</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>–08-20</td>
<td></td>
</tr>
<tr>
<td>Year</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2013</td>
<td></td>
</tr>
<tr>
<td>YearMonth</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2013-08</td>
<td></td>
</tr>
<tr>
<td>Month</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>AUGUST</td>
<td></td>
</tr>
<tr>
<td>OffsetDateTime</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>2013-08-20T08:16:26.954-07:00</td>
<td></td>
</tr>
<tr>
<td>OffsetTime</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>08:16:26.957-07:00</td>
<td></td>
</tr>
<tr>
<td>Duration</td>
<td></td>
<td></td>
<td>**</td>
<td>**</td>
<td>**</td>
<td>√</td>
<td></td>
<td></td>
<td>PT20H (20 hours)</td>
<td></td>
</tr>
<tr>
<td>Period</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>***</td>
<td>***</td>
<td>P10D (10 days)</td>
<td></td>
</tr>
</tbody></table>
<p>*秒是获得的毫秒精度<br>**这类别不存储这些信息，但是具有在这些单元中提供时间的方法。<br>***当将Period添加到ZonedDateTime时，会观察到夏令时或其他本地时差。</p>
<hr>
<h1 id="DayOfWeek和Month枚举"><a href="#DayOfWeek和Month枚举" class="headerlink" title="DayOfWeek和Month枚举"></a>DayOfWeek和Month枚举</h1><hr>
<blockquote>
<p>本节讨论定义一周中的日期的枚举（DayOfWeek）和定义了月的枚举（Month）。</p>
</blockquote>
<p>Date-Time API提供了指定一周中的日期和一年中的月份的枚举。</p>
<h2 id="DayOfWeek"><a href="#DayOfWeek" class="headerlink" title="DayOfWeek"></a>DayOfWeek</h2><hr>
<p>DayOfWeek枚举包含七个常数，用于描述星期几：从MONDAY到SUNDAY。DayOfWeek常数的整数值范围从1（Monday）到7（Sunday）。使用定义的常量（DayOfWeek.FRIDAY）使您的代码更易读。</p>
<p>这个枚举还提供一些方法，类似基于时间类提供的方法。比如，下面的代码向“Monday”添加3天，并且打印结果。输出是“THURSDAY”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, DayOfWeek.MONDAY.plus(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>通过使用getDisplayName(TextStyle, Locale)方法，你可以以用户区域来检索标识一周中星期几的字符串。TextStyle枚举使您能够指定要显示的字符串类型：FULL,NARROW（通常是单个字母），或者SHORT（一个缩写）。STANDALONE TextStyle常量在某些语言中使用，其输出在用作日期的一部分时不同于自身使用时的输出。以下示例打印“Monday”的TextStyle的三个主要形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dow</span> <span class="operator">=</span> DayOfWeek.MONDAY;</span><br><span class="line"><span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault();</span><br><span class="line">System.out.println(dow.getDisplayName(TextStyle.FULL, locale));</span><br><span class="line">System.out.println(dow.getDisplayName(TextStyle.NARROW, locale));</span><br><span class="line">System.out.println(dow.getDisplayName(TextStyle.SHORT, locale));</span><br></pre></td></tr></table></figure>
<p>此代码对于en语言环境的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Monday</span><br><span class="line">M</span><br><span class="line">Mon</span><br></pre></td></tr></table></figure>
<h2 id="Month"><a href="#Month" class="headerlink" title="Month"></a>Month</h2><hr>
<p>Month枚举包括十二个月份的常量，从JANUARY到DECEMBER。与DayOfWeek枚举一样，Month枚举是强类型，每个常数的整数值对应于从1（January）到12（December）的ISO范围。使用定义的常量（Month.SEPTEMBER）使您的代码更易读。</p>
<p>Month枚举同样包含一些方法。以下代码行使用maxLength方法打印2月份的最大可能天数。输出是“29”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%d%n&quot;</span>, Month.FEBRUARY.maxLength());</span><br></pre></td></tr></table></figure>
<p>Month枚举同样实现了 getDisplayName(TextStyle, Locale) 方法来获取一个以使用指定的TextStyle标识用户区域设置的月份的字符串。如果未定义特定的TextStyle，则返回表示常量数值的字符串。以下代码使用三种主要文本样式打印8月份：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> Month.AUGUST;</span><br><span class="line"><span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault();</span><br><span class="line">System.out.println(month.getDisplayName(TextStyle.FULL, locale));</span><br><span class="line">System.out.println(month.getDisplayName(TextStyle.NARROW, locale));</span><br><span class="line">System.out.println(month.getDisplayName(TextStyle.SHORT, locale));</span><br></pre></td></tr></table></figure>
<p>此代码对于en语言环境的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">August</span><br><span class="line">A</span><br><span class="line">Aug</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><hr>
<blockquote>
<p>本节显示只处理日期的基于时间类，不包括时间和时区。这四个类是Localdate，YearMonth，MonthDay和Year。</p>
</blockquote>
<p>Date-Time API提供四个专门处理日期信息的类，而不考虑时间或时区。这些类由类名称来建议使用：LocalDate，YearMonth，MonthDay和Year。</p>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><hr>
<p>LocalDate表示ISO日历中的一个年-月-日，对于无时间表示日期很有用。您可以使用LocalDate来跟踪重大事件，例如出生日期或婚礼日期。</p>
<p>“本地”，这个术语，我们对它的熟悉来自于Joda-Time。它原本出自ISO-8061的时间和日期标准，它和时区无关。实际上，本地日期只是日期的描述，例如“2014年4月5日”。特定的本地时间，因你在地球上的不同位置，开始于不同的时间线。所以，澳大利亚的本地时间开始的比伦敦早10小时，比旧金山早18小时。</p>
<p>以下示例使用of和with方法创建LocalDate的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, Month.NOVEMBER, <span class="number">20</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWed</span> <span class="operator">=</span> date.with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY));</span><br></pre></td></tr></table></figure>
<p>有关TemporalAdjuster接口的更多信息，请参阅<a href="">时间修改器</a>。  </p>
<p>除了常用的方法之外，LocalDate类还提供了获取有关给定日期信息的getter方法。getDayOfWeek方法返回特定日期所在的星期几。例如，以下代码行返回“MONDAY”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dotw</span> <span class="operator">=</span> LocalDate.of(<span class="number">2012</span>, Month.JULY, <span class="number">9</span>).getDayOfWeek();</span><br></pre></td></tr></table></figure>
<p>以下示例使用TemporalAdjuster来获取在特定日期之后的第一个星期三。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, Month.NOVEMBER, <span class="number">20</span>);</span><br><span class="line"><span class="type">TemporalAdjuster</span> <span class="variable">adj</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.WEDNESDAY);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWed</span> <span class="operator">=</span> date.with(adj);</span><br><span class="line">System.out.printf(<span class="string">&quot;For the date of %s, the next Wednesday is %s.%n&quot;</span>,</span><br><span class="line">                  date, nextWed);</span><br></pre></td></tr></table></figure>
<p>运行代码产生以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For the date of 2000-11-20, the next Wednesday is 2000-11-22.</span><br></pre></td></tr></table></figure>
<p>“Period and Duration”部分还有使用LocalDate类的示例。</p>
<h2 id="YearMonth"><a href="#YearMonth" class="headerlink" title="YearMonth"></a>YearMonth</h2><hr>
<p>YearMonth类代表特定年份的月份。以下示例使用YearMonth.lengthOfMonth()方法来确定多个年份月份组合的拥有的天数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">YearMonth</span> <span class="variable">date</span> <span class="operator">=</span> YearMonth.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;%s: %d%n&quot;</span>, date, date.lengthOfMonth());</span><br><span class="line"></span><br><span class="line"><span class="type">YearMonth</span> <span class="variable">date2</span> <span class="operator">=</span> YearMonth.of(<span class="number">2010</span>, Month.FEBRUARY);</span><br><span class="line">System.out.printf(<span class="string">&quot;%s: %d%n&quot;</span>, date2, date2.lengthOfMonth());</span><br><span class="line"></span><br><span class="line"><span class="type">YearMonth</span> <span class="variable">date3</span> <span class="operator">=</span> YearMonth.of(<span class="number">2012</span>, Month.FEBRUARY);</span><br><span class="line">System.out.printf(<span class="string">&quot;%s: %d%n&quot;</span>, date3, date3.lengthOfMonth());</span><br></pre></td></tr></table></figure>
<p>此代码的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2013-06: 30</span><br><span class="line">2010-02: 28</span><br><span class="line">2012-02: 29</span><br></pre></td></tr></table></figure>
<h2 id="MonthDay"><a href="#MonthDay" class="headerlink" title="MonthDay"></a>MonthDay</h2><hr>
<p>MonthDay代表特定月份的天数，比如元旦在1月1日。</p>
<p>以下示例使用MonthDay.isValidYear方法来确定2月29日是否对2010年有效。调用返回false，确认2010年不是闰年。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MonthDay</span> <span class="variable">date</span> <span class="operator">=</span> MonthDay.of(Month.FEBRUARY, <span class="number">29</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">validLeapYear</span> <span class="operator">=</span> date.isValidYear(<span class="number">2010</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Year"><a href="#Year" class="headerlink" title="Year"></a>Year</h2><hr>
<p>Year类表示一个年数。以下示例使用Year.isLeap方法来确定给定年份是否为闰年。调用返回true，确认2012年是闰年。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">validLeapYear</span> <span class="operator">=</span> Year.of(<span class="number">2012</span>).isLeap();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Date和Time-类"><a href="#Date和Time-类" class="headerlink" title="Date和Time 类"></a>Date和Time 类</h1><hr>
<blockquote>
<p>本节介绍分别处理时间，日期和时间，但没有时区的LocalTime和LocalDateTime类。</p>
</blockquote>
<h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h2><hr>
<p>LocalTime类与名称前缀为Local的其他类相似，但是仅用于处理时间。这个类可以用于表示基于人的时间，例如电影时间，或本地图书馆的开放和关闭时间。它也可以用于创建数字时钟，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime thisSec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    thisSec = LocalTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// display代码的实现留给读者</span></span><br><span class="line">    display(thisSec.getHour(), thisSec.getMinute(), thisSec.getSecond());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LocalTime类不存储时区或夏令时时间信息。</p>
<h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><hr>
<p>用于同时处理日期和时间，而不处理时区的类是LocalDateTime,它是Date-Time API的一个核心类。该类用于表示日期（月 - 日 - 年）和时间（小时 - 分钟 - 秒 - 纳秒），实际上是LocalDate与LocalTime的组合。这个类可以用来代表一个特定的事件，比如在美国杯挑战者系列赛的路易威登杯决赛的第一场比赛，比赛开始于下午1:10在 2013年8月17日。请注意，这意味着下午1点10分在当地时间。要包括时区，您必须使用ZonedDateTime或OffsetDateTime，如Time Zone和Offset类中所述。</p>
<p>除了每个基于时间类都提供的now方法之外，LocalDateTime类都有各种创建LocalDateTime实例的of方法（或者前缀为of方法）。还有一个from方法，它将一个实例从另一个时间格式转换为LocalDateTime实例。还有一些方法可以用来加减小时，分中，天，周，月数。以下示例显示了这些方法中的一些。日期时间表达式为粗体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;now: %s%n&quot;</span>, LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;Apr 15, 1994 @ 11:30am: %s%n&quot;</span>,</span><br><span class="line">                  LocalDateTime.of(<span class="number">1994</span>, Month.APRIL, <span class="number">15</span>, <span class="number">11</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;now (from Instant): %s%n&quot;</span>,</span><br><span class="line">                  LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault()));</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;6 months from now: %s%n&quot;</span>,</span><br><span class="line">                  LocalDateTime.now().plusMonths(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;6 months ago: %s%n&quot;</span>,</span><br><span class="line">                  LocalDateTime.now().minusMonths(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p>此代码生成的输出将类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now: 2013-07-24T17:13:59.985</span><br><span class="line">Apr 15, 1994 @ 11:30am: 1994-04-15T11:30</span><br><span class="line">now (from Instant): 2013-07-24T17:14:00.479</span><br><span class="line">6 months from now: 2014-01-24T17:14:00.480</span><br><span class="line">6 months ago: 2013-01-24T17:14:00.481</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Time-Zone和Offset类"><a href="#Time-Zone和Offset类" class="headerlink" title="Time Zone和Offset类"></a>Time Zone和Offset类</h1><hr>
<blockquote>
<p>本节讨论存储时区（或时区偏移）信息的基于时间类，ZonedDateTime，OffsetDateTime和OffsetTime。还讨论了一些支持类，ZoneId，ZoneRules和ZoneOffset。</p>
</blockquote>
<p>时区是使用了相同标准时间的地球的一个区域。每个时区由一个标识符来描述，通常有区域&#x2F;城市（Asia&#x2F;Tokyo）和与Greenwich&#x2F;UTC 时间偏移这样的格式。例如，东京的偏移是+09：00。</p>
<h2 id="ZoneId和ZoneOffset"><a href="#ZoneId和ZoneOffset" class="headerlink" title="ZoneId和ZoneOffset"></a>ZoneId和ZoneOffset</h2><hr>
<p>Date-Time API提供了两个指定时区或偏移量的类：</p>
<ul>
<li><strong>ZoneId</strong>指定时区标识符，并提供在Instant和LocalDateTime之间转换的规则。</li>
<li><strong>ZoneOffset</strong>指定与Greenwich&#x2F;UTC时间偏移的时区。</li>
</ul>
<p>与Greenwich&#x2F;UTC时间的偏移通常以整个小时定义，但是也有例外。下面TimeZoneId实例代码打印所有不以整小时定义的与Greenwich&#x2F;UTC时间偏移的时区列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; allZones = ZoneId.getAvailableZoneIds();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个时区set创建一个List，并且将其排序</span></span><br><span class="line">List&lt;String&gt; zoneList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(allZones);</span><br><span class="line">Collections.sort(zoneList);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : zoneList) &#123;</span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zone</span> <span class="operator">=</span> ZoneId.of(s);</span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> dt.atZone(zone);</span><br><span class="line">    <span class="type">ZoneOffset</span> <span class="variable">offset</span> <span class="operator">=</span> zdt.getOffset();</span><br><span class="line">    <span class="type">int</span> <span class="variable">secondsOfHour</span> <span class="operator">=</span> offset.getTotalSeconds() % (<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> String.format(<span class="string">&quot;%35s %10s%n&quot;</span>, zone, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将不是整小时偏移的时区写入到标准输出</span></span><br><span class="line">    <span class="keyword">if</span> (secondsOfHour != <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.printf(out);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例将以下列表打印到标准输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  America/Caracas     -04:30</span><br><span class="line">     America/St_Johns     -02:30</span><br><span class="line">        Asia/Calcutta     +05:30</span><br><span class="line">         Asia/Colombo     +05:30</span><br><span class="line">           Asia/Kabul     +04:30</span><br><span class="line">       Asia/Kathmandu     +05:45</span><br><span class="line">        Asia/Katmandu     +05:45</span><br><span class="line">         Asia/Kolkata     +05:30</span><br><span class="line">         Asia/Rangoon     +06:30</span><br><span class="line">          Asia/Tehran     +04:30</span><br><span class="line">   Australia/Adelaide     +09:30</span><br><span class="line">Australia/Broken_Hill     +09:30</span><br><span class="line">     Australia/Darwin     +09:30</span><br><span class="line">      Australia/Eucla     +08:45</span><br><span class="line">        Australia/LHI     +10:30</span><br><span class="line">  Australia/Lord_Howe     +10:30</span><br><span class="line">      Australia/North     +09:30</span><br><span class="line">      Australia/South     +09:30</span><br><span class="line"> Australia/Yancowinna     +09:30</span><br><span class="line">  Canada/Newfoundland     -02:30</span><br><span class="line">         Indian/Cocos     +06:30</span><br><span class="line">                 Iran     +04:30</span><br><span class="line">              NZ-CHAT     +12:45</span><br><span class="line">      Pacific/Chatham     +12:45</span><br><span class="line">    Pacific/Marquesas     -09:30</span><br><span class="line">      Pacific/Norfolk     +11:30</span><br></pre></td></tr></table></figure>
<p>TimeZoneId示例还会将所有时区ID的列表打印到名为timeZones的文件中。</p>
<h2 id="Date-Time类"><a href="#Date-Time类" class="headerlink" title="Date-Time类"></a>Date-Time类</h2><hr>
<p>Date-Time API提供了三个使用时区的基于时间的类：</p>
<ul>
<li><strong>ZonedDateTime</strong>以相应的时区以及与Greenwich&#x2F;UTC的时区偏移来处理日期和时间。</li>
<li>**OffsetDateTime **以相应的与Greenwich&#x2F;UTC时区偏移来处理日期和时间，但是没有时区ID。</li>
<li>**OffsetTime **以相应的与Greenwich&#x2F;UTC时区偏移来处理时间，但是没有时区ID。</li>
</ul>
<p>什么时候使用OffsetDateTime而不是ZonedDateTime？如果你正在编写一个复杂的软件，它基于地理位置来模拟它自己的日期和时间计算规则，或者你要将时间戳存储到一个数据中，值追踪与Greenwich&#x2F;UTC时间的绝对偏移，那么你可能想要使用OffsetDatetime.此外，XML和其他网络格式将日期-时间传输定义为OffsetDateTime或OffsetTime。</p>
<p>虽然所有三类都维持一个与Greenwich&#x2F;UTC 时间的偏移，但是只有ZonedDateTime使用ZoneRules，它是java.time.zone包的一部分，用来决定确定偏移对于特定时区如何变化。例如，当将时钟向前移动到夏令时间时，大多数时区经历一个间隙（通常为1小时），以及一个时间重叠，当将时钟调回标准时间，重复转换前的最后一小时。ZonedDateTime类适应这种情况，而没有访问ZoneRules的OffsetDateTime和OffsetTime类则没有。</p>
<h3 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h3><p>实际上，ZonedDateTime类是将LocalDateTime类与ZoneId类组合。它用于表示具有时区（区域&#x2F;城市，如 Europe&#x2F;Paris）的完整日期（年，月，日）和时间（小时，分，秒，纳秒）。</p>
<p> Flight示例中的以下代码定义了一个从洛杉矶到东京的航班起飞时间为ZonedDateTime，在 America&#x2F;Los Angeles时区。withZoneSameInstant和plusMinutes方法用于创建一个ZonedDateTime的实例，它表示在650分钟飞行后在东京的预计到达时间。ZoneRules.isDaylightSavings方法决定飞机在东京到达时是否是夏令时。</p>
<p> DateTimeFormatter对象用于格式化ZonedDateTime实例进行打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">format</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;MMM d yyyy  hh:mm a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 于2013年7月20日下午7:30离开旧金山。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">leaving</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2013</span>, Month.JULY, <span class="number">20</span>, <span class="number">19</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">leavingZone</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/Los_Angeles&quot;</span>); </span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">departure</span> <span class="operator">=</span> ZonedDateTime.of(leaving, leavingZone);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">out1</span> <span class="operator">=</span> departure.format(format);</span><br><span class="line">    System.out.printf(<span class="string">&quot;LEAVING:  %s (%s)%n&quot;</span>, out1, leavingZone);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeException exc) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s can&#x27;t be formatted!%n&quot;</span>, departure);</span><br><span class="line">    <span class="keyword">throw</span> exc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//飞行时间为10小时50分钟，或650分钟</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">arrivingZone</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>); </span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">arrival</span> <span class="operator">=</span> departure.withZoneSameInstant(arrivingZone)</span><br><span class="line">                                 .plusMinutes(<span class="number">650</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">out2</span> <span class="operator">=</span> arrival.format(format);</span><br><span class="line">    System.out.printf(<span class="string">&quot;ARRIVING: %s (%s)%n&quot;</span>, out2, arrivingZone);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeException exc) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s can&#x27;t be formatted!%n&quot;</span>, arrival);</span><br><span class="line">    <span class="keyword">throw</span> exc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arrivingZone.getRules().isDaylightSavings(arrival.toInstant())) </span><br><span class="line">    System.out.printf(<span class="string">&quot;  (%s daylight saving time will be in effect.)%n&quot;</span>,</span><br><span class="line">                      arrivingZone);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;  (%s standard time will be in effect.)%n&quot;</span>,</span><br><span class="line">                      arrivingZone);</span><br></pre></td></tr></table></figure>
<p>这产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVING:  Jul 20 2013  07:30 PM (America/Los_Angeles)</span><br><span class="line">ARRIVING: Jul 21 2013  10:20 PM (Asia/Tokyo)</span><br><span class="line">  (Asia/Tokyo standard time will be in effect.)</span><br></pre></td></tr></table></figure>
<h3 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h3><p>OffsetDateTime类实际上是将LocalDateTime类与ZoneOffset类组合在一起。它用于表示具有与Greenwich&#x2F;UTC时间偏移（+&#x2F;-小时:分钟，如+06:00或 - 08:00）的完整日期（年，月，日）和时间（小时，分，秒，纳秒）。</p>
<p>以下示例使用TemporalAdjuster.lastDay方法的OffsetDateTime来查找2013年7月的最后一个星期四。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找2013年7月的最后一个星期四。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2013</span>, Month.JULY, <span class="number">20</span>, <span class="number">19</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">ZoneOffset</span> <span class="variable">offset</span> <span class="operator">=</span> ZoneOffset.of(<span class="string">&quot;-08:00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDate</span> <span class="operator">=</span> OffsetDateTime.of(localDate, offset);</span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">lastThursday</span> <span class="operator">=</span></span><br><span class="line">        offsetDate.with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));</span><br><span class="line">System.out.printf(<span class="string">&quot;The last Thursday in July 2013 is the %sth.%n&quot;</span>,</span><br><span class="line">                   lastThursday.getDayOfMonth());</span><br></pre></td></tr></table></figure>
<p>运行代码的输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The last Thursday in July 2013 is the 25th.</span><br></pre></td></tr></table></figure>
<h3 id="OffsetTime"><a href="#OffsetTime" class="headerlink" title="OffsetTime"></a>OffsetTime</h3><p>OffsetTime类实际上是将LocalTime类与ZoneOffset类组合在一起。它用于表示具有与Greenwich&#x2F;UTC时间偏移（+&#x2F;-小时:分钟，如+06:00或 - 08:00）的时间（小时，分，秒，纳秒）。</p>
<p>OffsetTime类在与OffsetDateTime类相同的情况下使用，但不需要跟踪日期时。</p>
<hr>
<h1 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h1><hr>
<blockquote>
<p>本节讨论了Instant类，它代表了时间轴上的瞬间时刻。</p>
</blockquote>
<p>Date-Time API的核心类之一是Instant类，它表示在时间轴上的纳秒的开始。此类可用于生成时间戳来表示机器时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">timestamp</span> <span class="operator">=</span> Instant.now();</span><br></pre></td></tr></table></figure>
<p>从Instant类返回的值是从1970年1月1日（1970-01-01T00：00：00Z）的第一秒开始的计时，这个时间点也被称为EPOCH。发生在在EPOCH之前的instant有一个负值，发生在EPOCH之后instant有一个正值。</p>
<p>其他Instant类提供的常数是MIN，表示最小可能（最近的）时间点，MAX代表最大（最远的）的时间点。</p>
<p>在Instant上调用toString会产生如下所示的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2013-05-30T23:38:23.085Z</span><br></pre></td></tr></table></figure>
<p>此格式遵循ISO-8601标准，用于表示日期和时间。</p>
<p>Instant类提供了各种操纵Instant的方法。它有plus和minus方法来加减时间。以下代码为当前时间添加1小时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">oneHourLater</span> <span class="operator">=</span> Instant.now().plusHours(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>还有方法用来比较instant，比如isAfter和isBefore。until方法返回两个Instant对象之间存在多少时间。以下代码行报告自Java EPOCH开始以来发生了多少秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">secondsFromEpoch</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">0L</span>).until(Instant.now(),</span><br><span class="line">                        ChronoUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>Instant类不适用于人类的时间单位，比如年，月或日。如果要在这些单位中执行计算，您可以通过将Instant绑定到时区，将Instant转换为另一个类，例如LocalDateTime或ZonedDateTime。然后你可以使用期望的单位访问它的值。下面代码使用ofInstant方法和默认时区将一个Instant转换为LocalDateTime对象，并且以更易读形式打印输出日期时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant timestamp;</span><br><span class="line">...</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.ofInstant(timestamp, ZoneId.systemDefault());</span><br><span class="line">System.out.printf(<span class="string">&quot;%s %d %d at %d:%d%n&quot;</span>, ldt.getMonth(), ldt.getDayOfMonth(),</span><br><span class="line">                  ldt.getYear(), ldt.getHour(), ldt.getMinute());</span><br></pre></td></tr></table></figure>
<p>输出将类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAY 30 2013 at 18:21</span><br></pre></td></tr></table></figure>
<p>ZonedDateTime或OffsetTimeZone对象都可以转换为Instant对象，每个都映射到时间轴上的一个精确时刻。然而，反之则不然。要将Instant对象转换为ZonedDateTime或OffsetDateTime对象，需要提供时区或时区偏移信息。</p>
<hr>
<h1 id="解析和格式化"><a href="#解析和格式化" class="headerlink" title="解析和格式化"></a>解析和格式化</h1><hr>
<blockquote>
<p>本节提供了如何使用预定义的formatter来格式和解析日期和时间值的概述。</p>
</blockquote>
<p>java.time.format包是专门用来格式化输出时间&#x2F;日期的。这个包围绕DateTimeFormatter类和它的辅助创建类DateTimeFormatterBuilder展开。</p>
<p>Date-Time API中的基于时间的类提供了用于解析包含日期和时间信息的字符串的parse方法。这些类还提供了format方法用于格式化显示基于时间的对象。在这两个情景中，处理是类似的：你提供一个模式给DateTimeFormatter来创建一个formatter对象。然后这个formatter被传递给parse和format方法。</p>
<p>DateTimeFormatter类提供了许多预定义的formatter，也可以定义自己的formatter。</p>
<p>如果在转换过程中出现问题，则parse和format方法会抛出异常。因此，您的解析代码应该捕获DateTimeParseException错误，您的格式化代码应该捕获DateTimeException错误。</p>
<p>使用静态方法以及DateTimeFormatter中的常量，是最通用的创建格式化器的方式。包括：</p>
<ul>
<li><strong>常用ISO格式常量</strong>，如ISO_LOCAL_DATE</li>
<li><strong>字母模式</strong>，如ofPattern(“dd&#x2F;MM&#x2F;uuuu”)</li>
<li><strong>本地化样式</strong>，如ofLocalizedDate(FormatStyle.MEDIUM)</li>
</ul>
<p>DateTimeFormatter类是不可变的和线程安全的;它可以（并且应该）适当地分配给静态常量。</p>
<blockquote>
<p>版本注意:java.time中的date-time对象可以通过使用的基于模式的格式化形式，直接与java.util.Formatter和String.format一起使用，这是旧的java.util.Date和java.util.Calendar类所使用的方式。。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><hr>
<p>LocalDate类中的单参数 parse(CharSequence)方法使用ISO_LOCAL_DATE formatter。要指定不同的formatter，你可以使用双参数方法parse(CharSequence, DateTimeFormatter)。下面的例子使用预定义的BASIC_ISO_DATE formatter，它将为July 9, 1959使用19590709格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.parse(in, DateTimeFormatter.BASIC_ISO_DATE);</span><br></pre></td></tr></table></figure>
<p>您还可以使用自己的模式定义一个fomatter。 Parse示例中的以下代码创建一个formatter，该formatter应用格式为“MMM d yyyy”。此格式指定三个字符以表示月份，一个数字表示月份的日期，四位数字表示年份。使用此模式创建的formatter将识别字符串，例如“2003年1月3日”或“1993年3月23日”。然而，要将格式指定为“MMM dd yyyy”，用两个字符表示月份的天数，那么您必须始终使用两个字符，对于一位数字的日期会填充一个零：“Jun 03 2003”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span></span><br><span class="line">                      DateTimeFormatter.ofPattern(<span class="string">&quot;MMM d yyyy&quot;</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.parse(input, formatter);</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DateTimeParseException exc) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s is not parsable!%n&quot;</span>, input);</span><br><span class="line">    <span class="keyword">throw</span> exc;      <span class="comment">// 重抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#x27;date&#x27;已成功解析</span></span><br></pre></td></tr></table></figure>
<p>DateTimeFormatter类的文档指定了可用于指定格式化或解析模式的<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns">完整符号列表</a>。</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><hr>
<p>format(DateTimeFormatter)方法使用指定的格式将一个基于时间对象转换为一个字符串代表形式。下面Flight示例的代码中，使用 “MMM d yyy hh:mm a”格式转化了一个ZonedDateTime实例。日期的定义方式与上一个解析示例中使用的方式相同，但此模式还包括小时，分钟，以及a.m.和p.m.组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ZoneId</span> <span class="variable">leavingZone</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">departure</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">format</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;MMM d yyyy  hh:mm a&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> departure.format(format);</span><br><span class="line">    System.out.printf(<span class="string">&quot;LEAVING:  %s (%s)%n&quot;</span>, out, leavingZone);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DateTimeException exc) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s can&#x27;t be formatted!%n&quot;</span>, departure);</span><br><span class="line">    <span class="keyword">throw</span> exc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例的输出打印到达和离开时间如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVING:  Jul 20 2013  07:30 PM (America/Los_Angeles)</span><br><span class="line">ARRIVING: Jul 21 2013  10:20 PM (Asia/Tokyo)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Temporal包"><a href="#Temporal包" class="headerlink" title="Temporal包"></a>Temporal包</h1><hr>
<blockquote>
<p>本节介绍了java.time.temporal包的概述，它支持时间类，字段（TemporalField和ChronoField）和单位（TemporalUnit和ChronoUnit）本节还解释了如何使用时间调整器来检索调整的时间值，例如“4月11日之后的第一个星期二”以及如何执行时间查询。</p>
</blockquote>
<p>java.time.temporal包提供了一组接口，类和枚举，支持日期和时间代码，特别是日期和时间计算。</p>
<p>这些接口旨在用于最低层次。通常应用程序代码应根据具体类型声明变量和参数，如LocalDate或ZonedDateTime，而不是Temporal接口。这与声明一个String类型，而不是CharSequence类型的变量一个道理。</p>
<h2 id="包接口"><a href="#包接口" class="headerlink" title="包接口"></a>包接口</h2><hr>
<h3 id="Temporal和-TemporalAccessor"><a href="#Temporal和-TemporalAccessor" class="headerlink" title="Temporal和 TemporalAccessor"></a>Temporal和 TemporalAccessor</h3><p>Temporal接口提供了一个用于访问基于时间对象的框架，并且它被基于时间的类如Instant，LocalDateTime和ZonedDateTime等所实现。这个接口提供了用于加减时间单位的方法，使得基于时间的算法在各种日期和时间类中更容易和一致。TemporalAccessor提供了一个只读版本的Temporal接口。</p>
<p>Temporal和TemporalAccessor对象按照TemporalField接口中指定的字段进行定义。ChronoField枚举是TemporalField接口的具体实现，并提供了一组丰富的定义常量，如DAY_OF_WEEK，MINUTE_OF_HOUR和MONTH_OF_YEAR。</p>
<p>这些字段的单位由TemporalUnit接口指定。 ChronoUnit枚举实现了TemporalUnit接口。 ChronoField.DAY_OF_WEEK字段是ChronoUnit.DAYS和ChronoUnit.WEEKS的组合。ChronoField和ChronoUnit枚举将在以下部分讨论。</p>
<p>Temporal接口中基于算术的方法需要使用按照TemporalAmount值定义的参数。Period和Duration类（在Period和Duration中讨论）实现TemporalAmount界面。</p>
<h3 id="ChronoField和IsoFields"><a href="#ChronoField和IsoFields" class="headerlink" title="ChronoField和IsoFields"></a>ChronoField和IsoFields</h3><p>ChronoField枚举实现了TemporalField 接口，它提供了一组丰富的常量用来访问日期和时间值。几个例子是CLOCK_HOUR_OF_DAY，NANO_OF_DAY和DAY_OF_YEAR。这个枚举可以用来表达时间的概念方面，比如一年的第三周，一天的第十一个小时，或者这个月的第一个星期一。当你遇到一个未知类型的Temporal 时，你可以使用TemporalAccessor.isSupported(TemporalField)方法来确定这个Temporal是否支持特定字段。下面一行代码返回一个false，表示这个LocalDate不支持ChronoField.CLOCK_HOUR_OF_DAY:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isSupported</span> <span class="operator">=</span> LocalDate.now().isSupported(ChronoField.CLOCK_HOUR_OF_DAY);</span><br></pre></td></tr></table></figure>
<p>特定于ISO-8601日历系统的其他字段在IsoFields类中定义。以下示例显示如何使用ChronoField和IsoFields获取字段的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">time.get(ChronoField.MILLI_OF_SECOND)</span><br><span class="line"><span class="type">int</span> <span class="variable">qoy</span> <span class="operator">=</span> date.get(IsoFields.QUARTER_OF_YEAR);</span><br></pre></td></tr></table></figure>
<p>另外两个类定义了可能有用的附加字段，WeekFields和JulianFields。</p>
<h3 id="ChronoUnit"><a href="#ChronoUnit" class="headerlink" title="ChronoUnit"></a>ChronoUnit</h3><p>ChronoUnit枚举实现了TemporalUnit接口，并提供了一组基于日期和时间的标准单位，从毫秒到千年。请注意，并不是所有类都支持所有ChronoUnit对象。例如，Instant类不支持ChronoUnit.MONTHS或ChronoUnit.YEARS。TemporalAccessor.isSupported（TemporalUnit）方法可用于验证一个类是否支持特定的时间单位。对isSupported的以下调用返回false，确认Instant类不支持ChronoUnit.DAYS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isSupported</span> <span class="operator">=</span> instant.isSupported(ChronoUnit.DAYS);</span><br></pre></td></tr></table></figure>
<h2 id="Temporal-Adjuster"><a href="#Temporal-Adjuster" class="headerlink" title="Temporal Adjuster"></a>Temporal Adjuster</h2><hr>
<p>在java.time.temporal包中的TemporalAdjuster接口提供了接收一个Temporal值，并且返回一个修改值。这个修改器可以与任何基于时间的类型一起使用。</p>
<p>如果修改器与ZonedDateTime一起使用，则会计算新的日期，保留原始时间和时区值。</p>
<h3 id="预定义修改器"><a href="#预定义修改器" class="headerlink" title="预定义修改器"></a>预定义修改器</h3><p>TemporalAdjusters类（注意复数）提供一组预定义的修改器，用于查找本月的第一天或最后一天，一年中的最后一天，每月的最后一个星期三，或特定日期之后的第一个星期二，举几个例子。预定义的调整器被定义为静态方法，并被设计为与静态导入语句一起使用。</p>
<p>下面的示例使用了几个TemporalAdjusters方法，并且与基于时间类中定义的with方法结合使用，根据2000年10月15日这个原始日期来计算新的日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, Month.OCTOBER, <span class="number">15</span>);</span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dotw</span> <span class="operator">=</span> date.getDayOfWeek();</span><br><span class="line">System.out.printf(<span class="string">&quot;%s is on a %s%n&quot;</span>, date, dotw);</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;first day of Month: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.firstDayOfMonth()));</span><br><span class="line">System.out.printf(<span class="string">&quot;first Monday of Month: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)));</span><br><span class="line">System.out.printf(<span class="string">&quot;last day of Month: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.lastDayOfMonth()));</span><br><span class="line">System.out.printf(<span class="string">&quot;first day of next Month: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.firstDayOfNextMonth()));</span><br><span class="line">System.out.printf(<span class="string">&quot;first day of next Year: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.firstDayOfNextYear()));</span><br><span class="line">System.out.printf(<span class="string">&quot;first day of Year: %s%n&quot;</span>,</span><br><span class="line">                  date.with(TemporalAdjusters.firstDayOfYear()));</span><br></pre></td></tr></table></figure>
<p>这产生以下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000-10-15 is on a SUNDAY</span><br><span class="line">first day of Month: 2000-10-01</span><br><span class="line">first Monday of Month: 2000-10-02</span><br><span class="line">last day of Month: 2000-10-31</span><br><span class="line">first day of next Month: 2000-11-01</span><br><span class="line">first day of next Year: 2001-01-01</span><br><span class="line">first day of Year: 2000-01-01</span><br></pre></td></tr></table></figure>
<h3 id="自定义修改器"><a href="#自定义修改器" class="headerlink" title="自定义修改器"></a>自定义修改器</h3><p>你也可以创建自己的自定义修改器。为此，你要创建一个实现了TemporalAdjuster接口和它的adjustInto(Temporal)方法的类。NextPayday示例中的PaydayAdjuster类是一个自定义修改器。PaydayAdjuster评估传入日期并返回下一个发薪日，假设发薪日每月发生两次：第一次在第15日，再次在当月的最后一天。如果计算的日期发生在周末，则使用上一个星期五。假定当前的日历年。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * adjustInto方法接收一个Temporal实例</span></span><br><span class="line"><span class="comment"> * 并且返回一个调节后的LocalDate如果传入</span></span><br><span class="line"><span class="comment"> *的参数不是一个LocalDate，那么抛出一个DateTimeException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal input)</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.from(input);</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">if</span> (date.getDayOfMonth() &lt; <span class="number">15</span>) &#123;</span><br><span class="line">        day = <span class="number">15</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        day = date.with(TemporalAdjusters.lastDayOfMonth()).getDayOfMonth();</span><br><span class="line">    &#125;</span><br><span class="line">    date = date.withDayOfMonth(day);</span><br><span class="line">    <span class="keyword">if</span> (date.getDayOfWeek() == DayOfWeek.SATURDAY ||</span><br><span class="line">        date.getDayOfWeek() == DayOfWeek.SUNDAY) &#123;</span><br><span class="line">        date = date.with(TemporalAdjusters.previous(DayOfWeek.FRIDAY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input.with(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个修改器和预定义的修改器有相同的调用方式，与with方法一起使用。下面的一行代码来自NextPayday示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">nextPayday</span> <span class="operator">=</span> date.with(<span class="keyword">new</span> <span class="title class_">PaydayAdjuster</span>());</span><br></pre></td></tr></table></figure>
<p>在2013年，6月15和6月30都在周末。运行NextPayday示例，分别为6月3日和6月18日（2013年），具有以下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given the date:  <span class="number">2013</span> Jun <span class="number">3</span></span><br><span class="line">the next payday: <span class="number">2013</span> Jun <span class="number">14</span></span><br><span class="line"></span><br><span class="line">Given the date:  <span class="number">2013</span> Jun <span class="number">18</span></span><br><span class="line">the next payday: <span class="number">2013</span> Jun <span class="number">28</span></span><br></pre></td></tr></table></figure>
<h2 id="Temporal-Query"><a href="#Temporal-Query" class="headerlink" title="Temporal Query"></a>Temporal Query</h2><hr>
<p>TemporalQuery可以用于从基于时间的对象中检索信息。</p>
<h3 id="预定义查询"><a href="#预定义查询" class="headerlink" title="预定义查询"></a>预定义查询</h3><p>TemporalQueries类（注意复数）提供了几个预定义的查询，包括当应用程序无法识别基于时间的对象的类型时有用的方法。与修改器一样，预定义的查询被定义为静态方法，并被设计为与静态导入语句一起使用。</p>
<p>例如，precision查询返回由特定的基于时间的对象最小的ChronoUnit。以下示例对几种类型的基于时间的对象使用precision查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TemporalQueries</span> <span class="variable">query</span> <span class="operator">=</span> TemporalQueries.precision();</span><br><span class="line">System.out.printf(<span class="string">&quot;LocalDate precision is %s%n&quot;</span>,</span><br><span class="line">                  LocalDate.now().query(query));</span><br><span class="line">System.out.printf(<span class="string">&quot;LocalDateTime precision is %s%n&quot;</span>,</span><br><span class="line">                  LocalDateTime.now().query(query));</span><br><span class="line">System.out.printf(<span class="string">&quot;Year precision is %s%n&quot;</span>,</span><br><span class="line">                  Year.now().query(query));</span><br><span class="line">System.out.printf(<span class="string">&quot;YearMonth precision is %s%n&quot;</span>,</span><br><span class="line">                  YearMonth.now().query(query));</span><br><span class="line">System.out.printf(<span class="string">&quot;Instant precision is %s%n&quot;</span>,</span><br><span class="line">                  Instant.now().query(query)); </span><br></pre></td></tr></table></figure>
<p>输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate precision is Days</span><br><span class="line">LocalDateTime precision is Nanos</span><br><span class="line">Year precision is Years</span><br><span class="line">YearMonth precision is Months</span><br><span class="line">Instant precision is Nanos</span><br></pre></td></tr></table></figure>
<h3 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h3><p>你也可以创建自己的自定义查询。这样做的一个方式是创建一个实现了TemporalQuery 接口和它的queryFrom(TemporalAccessor) 方法的类。CheckDate示例实现两个自定义查询。第一个自定义查询可以在FamilyVacations类中找到，它实现了TemporalQuery接口。queryFrom方法将传入的日期与预订假期进行比较，如果属于这些日期范围，则返回TRUE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果传入日期发生在家庭假期之一则返回true</span></span><br><span class="line"><span class="comment">// 因为查询只比较月和天，即使Temporal类型不一致</span></span><br><span class="line"><span class="comment">//比较结果依旧认为相同</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">queryFrom</span><span class="params">(TemporalAccessor date)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span>   <span class="operator">=</span> date.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迪士尼乐园过春节</span></span><br><span class="line">    <span class="keyword">if</span> ((month == Month.APRIL.getValue()) &amp;&amp; ((day &gt;= <span class="number">3</span>) &amp;&amp; (day &lt;= <span class="number">8</span>)))</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//史密斯家族团聚在Saugatuck湖上</span></span><br><span class="line">    <span class="keyword">if</span> ((month == Month.AUGUST.getValue()) &amp;&amp; ((day &gt;= <span class="number">8</span>) &amp;&amp; (day &lt;= <span class="number">14</span>)))</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个自定义查询实现在FamilyBirthdays类中。该类提供了一个isFamilyBirthday方法，将传入日期与几个生日进行比较，如果有匹配，则返回TRUE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果传入的日期和家庭生日中的一个一样则返回true</span></span><br><span class="line"><span class="comment">// 因为查询只比较月和天，即使Temporal类型不一致</span></span><br><span class="line"><span class="comment">//比较结果依旧认为相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isFamilyBirthday</span><span class="params">(TemporalAccessor date)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span>   <span class="operator">=</span> date.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安吉的生日是4月3日。</span></span><br><span class="line">    <span class="keyword">if</span> ((month == Month.APRIL.getValue()) &amp;&amp; (day == <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 苏的生日是6月18日。</span></span><br><span class="line">    <span class="keyword">if</span> ((month == Month.JUNE.getValue()) &amp;&amp; (day == <span class="number">18</span>))</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乔的生日是5月29日。</span></span><br><span class="line">    <span class="keyword">if</span> ((month == Month.MAY.getValue()) &amp;&amp; (day == <span class="number">29</span>))</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FamilyBirthday类没有实现TemporalQuery接口并且可以用作lambda表达式的一部分。下面CheckDate中的代码显示了如何调用这两个自定义查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用lambda表达式调用查询</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isFamilyVacation</span> <span class="operator">=</span> date.query(<span class="keyword">new</span> <span class="title class_">FamilyVacations</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda表达式调用查询</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isFamilyBirthday</span> <span class="operator">=</span> date.query(FamilyBirthdays::isFamilyBirthday);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFamilyVacation.booleanValue() || isFamilyBirthday.booleanValue())</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s is an important date!%n&quot;</span>, date);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%s is not an important date.%n&quot;</span>, date);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Period和Duration"><a href="#Period和Duration" class="headerlink" title="Period和Duration"></a>Period和Duration</h1><hr>
<blockquote>
<p>本节介绍如何使用Period和Duration类以及ChronoUnit.between方法来计算一段时间。</p>
</blockquote>
<p>当您编写代码以指定一段时间时，请使用最符合您需求的类或方法：Duration类，Period类，或者ChronoUnit.between方法。Duration使用基于时间的值（秒，纳秒）测量一段时间。而Period使用基于日期的值（年，月，日）。</p>
<blockquote>
<p>注意：表示一天的Duration是精确的24小时。而表示一天的Period添加到ZonedDateTime时，可能会更具时区而有所不同。例如，如果发生在夏令时的第一天或最后一天。</p>
</blockquote>
<h2 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h2><hr>
<p>Duration 最适合于测量基于机器的时间的情况，例如使用Instant对象的代码。一个Duration对象以秒或纳秒为单位测量时间，而不是使用基于日期的结构，比如年，月，日，尽管这个类提供了转换为天，小时和分钟的方法。如果一个Duration终点创建在起点之前，那么它可以有一个负值。</p>
<p>下面代码以纳秒计算两个时间点之间的持续时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant t1, t2;</span><br><span class="line">...</span><br><span class="line"><span class="type">long</span> <span class="variable">ns</span> <span class="operator">=</span> Duration.between(t1, t2).toNanos();</span><br></pre></td></tr></table></figure>
<p>下面代码向一个Instant中添加10秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant start;</span><br><span class="line">...</span><br><span class="line"><span class="type">Duration</span> <span class="variable">gap</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">10</span>);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">later</span> <span class="operator">=</span> start.plus(gap);</span><br></pre></td></tr></table></figure>
<p>Duration未连接到时间轴，因为它不跟踪时区或夏令时。将等于1天的Duration添加到ZonedDateTime会导致正好添加24小时，不管夏令时或其他可能导致的时差。</p>
<h2 id="ChronoUnit-1"><a href="#ChronoUnit-1" class="headerlink" title="ChronoUnit"></a>ChronoUnit</h2><hr>
<p>ChronoUnit枚举已经在在Temporal包中讨论过，它定义了用于测量时间的单位。当您想在单个时间单位（如天或秒）中测量一段时间时，ChronoUnit.between方法很有用。between方法可以与所有的基于时间对象一起使用，但是它只返回单个单位的时间。以下代码计算两个时间戳之间的间隔（以毫秒为单位）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.Temporal;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"></span><br><span class="line">Instant previous, current, gap;</span><br><span class="line">...</span><br><span class="line">current = Instant.now();</span><br><span class="line"><span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">    gap = ChronoUnit.MILLIS.between(previous,current);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h2><hr>
<p>要使用基于日期的值（年，月，日）定义一段时间，请使用Period类。Period类提供了各种get方法，例如getMonths，getDays和getYears，以便您可以从Period中提取时间。</p>
<p>总的持续时期由三个单位一起表示：月，天和年。要呈现在单个时间单位（例如天数）中测量的时间量，可以使用ChronoUnit.between方法。</p>
<p>以下代码报告你是多大年龄，假设你是1960年1月1日出生的。Period类用于确定以年，月和日为单位的时间。以总天数表示的时期，通过使用ChronoUnit.between方法确定，并显示在括号中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthday</span> <span class="operator">=</span> LocalDate.of(<span class="number">1960</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> Period.between(birthday, today);</span><br><span class="line"><span class="type">long</span> <span class="variable">p2</span> <span class="operator">=</span> ChronoUnit.DAYS.between(birthday, today);</span><br><span class="line">System.out.println(<span class="string">&quot;You are &quot;</span> + p.getYears() + <span class="string">&quot; years, &quot;</span> + p.getMonths() +</span><br><span class="line">                   <span class="string">&quot; months, and &quot;</span> + p.getDays() +</span><br><span class="line">                   <span class="string">&quot; days old. (&quot;</span> + p2 + <span class="string">&quot; days total)&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码产生类似于以下内容的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">You are <span class="number">53</span> years, <span class="number">4</span> months, and <span class="number">29</span> days old. (<span class="number">19508</span> days total)</span><br></pre></td></tr></table></figure>
<p>要计算到你下个生日还有多长时间，你可以使用下面Birthday示例中的代码。Period类用于确定以月和日为单位的值。ChronoUnit.between方法返回表示总天数的值，并显示在括号中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">birthday</span> <span class="operator">=</span> LocalDate.of(<span class="number">1960</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextBDay</span> <span class="operator">=</span> birthday.withYear(today.getYear());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你的生日今年已经过过了，那么年数加1</span></span><br><span class="line"><span class="keyword">if</span> (nextBDay.isBefore(today) || nextBDay.isEqual(today)) &#123;</span><br><span class="line">    nextBDay = nextBDay.plusYears(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">p</span> <span class="operator">=</span> Period.between(today, nextBDay);</span><br><span class="line"><span class="type">long</span> <span class="variable">p2</span> <span class="operator">=</span> ChronoUnit.DAYS.between(today, nextBDay);</span><br><span class="line">System.out.println(<span class="string">&quot;There are &quot;</span> + p.getMonths() + <span class="string">&quot; months, and &quot;</span> +</span><br><span class="line">                   p.getDays() + <span class="string">&quot; days until your next birthday. (&quot;</span> +</span><br><span class="line">                   p2 + <span class="string">&quot; total)&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码产生类似于以下内容的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 7 months, and 2 days until your next birthday. (216 total)</span><br></pre></td></tr></table></figure>
<p>这些计算不考虑时区差异。例如，如果你是出生在澳大利亚，但目前住在班加罗尔，这稍微影响到你确切年龄的计算。在这种情况下，请将Period与ZonedDateTime类结合使用。将Period添加到ZonedDateTime时，会观察时间差异。</p>
<hr>
<h1 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h1><hr>
<blockquote>
<p>本节简要介绍了Clock类。您可以使用此类为系统时钟提供替代时钟。</p>
</blockquote>
<p>大多数基于时间的对象提供了一个无参数的now()方法，它使用系统时钟和默认时区提供当前的日期和时间。这些基于时间的对象还提供了一个单参数now(Clock)方法，它允许您传递一个替代的Clock。</p>
<p>当前的日期和时间取决于时区，对于全球化的应用程序，一个Clock是必要的，以确保使用正确的时区创建日期&#x2F;时间。所以，尽管使用Clock类是可选的，但是这个功能允许您测试其他时区的代码，也可以使用固定的时钟，时间不会改变。</p>
<p>Clock类是抽象的，所以你不能创建一个它的实例。以下工厂方法可用于测试。</p>
<ul>
<li>Clock.offset(Clock, Duration) 返回一个根据指定Duration偏移的时钟。</li>
<li>Clock.systemUTC()返回一个表示Greenwich&#x2F;UTC时区的时钟。</li>
<li>Clock.fixed(Instant, ZoneId)总是返回相同的Instant。对于这个时钟，时间依旧。</li>
</ul>
<hr>
<h1 id="非ISO日期转换"><a href="#非ISO日期转换" class="headerlink" title="非ISO日期转换"></a>非ISO日期转换</h1><hr>
<blockquote>
<p>本节解释如果将一个ISO日历系统中的日期转换为一个非ISO日历系统日期，比如JapaneseDate或ThaiBuddhistDate。</p>
</blockquote>
<p>本教程没有讨论关于java.time.chrono包的任何细节。但是，知道这个包可以提供几种不是基于ISO的预定义年表，比如日本历，伊斯兰历，中华民国历和泰国佛教历。您还可以使用此包来创建自己的年表。</p>
<p>本部分介绍如果将基于ISO和其他预定义日历日期之间的相互转换。</p>
<h2 id="转换为非基于ISO日期"><a href="#转换为非基于ISO日期" class="headerlink" title="转换为非基于ISO日期"></a>转换为非基于ISO日期</h2><hr>
<p>您可以使用from(TemporalAccessor)方法将基于ISO的日期转换为其他年表的日期，如JapaneseDate.from（TemporalAccessor）。如果无法将日期转换为有效的实例，则此方法将抛出DateTimeException。以下代码将LocalDateTime实例转换为多个预定义的非ISO日历日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2013</span>, Month.JULY, <span class="number">20</span>, <span class="number">19</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">JapaneseDate</span> <span class="variable">jdate</span>     <span class="operator">=</span> JapaneseDate.from(date);</span><br><span class="line"><span class="type">HijrahDate</span> <span class="variable">hdate</span>       <span class="operator">=</span> HijrahDate.from(date);</span><br><span class="line"><span class="type">MinguoDate</span> <span class="variable">mdate</span>       <span class="operator">=</span> MinguoDate.from(date);</span><br><span class="line"><span class="type">ThaiBuddhistDate</span> <span class="variable">tdate</span> <span class="operator">=</span> ThaiBuddhistDate.from(date);</span><br></pre></td></tr></table></figure>
<p>StringConverter示例将LocalDate转换为ChronoLocalDate到String并返回。 toString方法接收LocalDate和Chronology的实例，并使用提供的Chronology返回转换的字符串。DateTimeFormatterBuilder用于构建可用于打印日期的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用提供的年表将一个LocalDate（ISO）值转换为一个ChronoLocalDate日期，</span></span><br><span class="line"><span class="comment"> *然后用一个使用基于该Chronology和当前LocaleSHORT模式的DateTimeFormatter来格式化ChronoLocalDate为一个String。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localDate - 要转换和格式化的ISO日期。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chrono - 一个可选年表。如果为null，那么默认使用IsoChronology.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(LocalDate localDate, Chronology chrono)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localDate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">        ChronoLocalDate cDate;</span><br><span class="line">        <span class="keyword">if</span> (chrono == <span class="literal">null</span>) &#123;</span><br><span class="line">            chrono = IsoChronology.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cDate = chrono.date(localDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">            chrono = IsoChronology.INSTANCE;</span><br><span class="line">            cDate = localDate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateFormatter</span> <span class="operator">=</span></span><br><span class="line">            DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT)</span><br><span class="line">                             .withLocale(locale)</span><br><span class="line">                             .withChronology(chrono)</span><br><span class="line">                             .withDecimalStyle(DecimalStyle.of(locale));</span><br><span class="line">        <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;M/d/yyyy GGGGG&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateFormatter.format(cDate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当以下日期为预定义的年表调用该方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">1996</span>, Month.OCTOBER, <span class="number">29</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>,</span><br><span class="line">     StringConverter.toString(date, JapaneseChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>,</span><br><span class="line">     StringConverter.toString(date, MinguoChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>,</span><br><span class="line">     StringConverter.toString(date, ThaiBuddhistChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>,</span><br><span class="line">     StringConverter.toString(date, HijrahChronology.INSTANCE));</span><br></pre></td></tr></table></figure>
<p>输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10/29/0008 H</span><br><span class="line">10/29/0085 1</span><br><span class="line">10/29/2539 B.E.</span><br><span class="line">6/16/1417 1</span><br></pre></td></tr></table></figure>
<h2 id="转换为基于ISO日期"><a href="#转换为基于ISO日期" class="headerlink" title="转换为基于ISO日期"></a>转换为基于ISO日期</h2><hr>
<p>您可以使用静态LocalDate.from方法将非ISO日期转换为LocalDate实例，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.from(JapaneseDate.now());</span><br></pre></td></tr></table></figure>
<p>其他基于时间的类也提供了这种方法，如果日期无法转换，它将抛出DateTimeException。</p>
<p>StringConverter示例中的fromString方法，解析一个包含非ISO日期的字符串，并返回一个LocalDate实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个使用基于当前Local和提供的Chronology的short模式的DateTimeFormatter来解析一个String为一个ChronoLocalDate,</span></span><br><span class="line"><span class="comment"> * 然后将其转换为一个LocalDate（ISO）值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text   - 该Chronology 和当前Locale预期的输入日期文本。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chrono - 一个可选Chronology如果为null,那么默认使用IsoChronology。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title function_">fromString</span><span class="params">(String text, Chronology chrono)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (text != <span class="literal">null</span> &amp;&amp; !text.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">        <span class="keyword">if</span> (chrono == <span class="literal">null</span>) &#123;</span><br><span class="line">           chrono = IsoChronology.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;M/d/yyyy GGGGG&quot;</span>;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatterBuilder</span>().parseLenient()</span><br><span class="line">                              .appendPattern(pattern)</span><br><span class="line">                              .toFormatter()</span><br><span class="line">                              .withChronology(chrono)</span><br><span class="line">                              .withDecimalStyle(DecimalStyle.of(locale));</span><br><span class="line">        <span class="type">TemporalAccessor</span> <span class="variable">temporal</span> <span class="operator">=</span> df.parse(text);</span><br><span class="line">        <span class="type">ChronoLocalDate</span> <span class="variable">cDate</span> <span class="operator">=</span> chrono.date(temporal);</span><br><span class="line">        <span class="keyword">return</span> LocalDate.from(cDate);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用以下字符串调用该方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, StringConverter.fromString(<span class="string">&quot;10/29/0008 H&quot;</span>,</span><br><span class="line">    JapaneseChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, StringConverter.fromString(<span class="string">&quot;10/29/0085 1&quot;</span>,</span><br><span class="line">    MinguoChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, StringConverter.fromString(<span class="string">&quot;10/29/2539 B.E.&quot;</span>,</span><br><span class="line">    ThaiBuddhistChronology.INSTANCE));</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, StringConverter.fromString(<span class="string">&quot;6/16/1417 1&quot;</span>,</span><br><span class="line">    HijrahChronology.INSTANCE));</span><br></pre></td></tr></table></figure>
<p>打印的字符串应全部转换为1996年10月29日：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1996-10-29</span><br><span class="line">1996-10-29</span><br><span class="line">1996-10-29</span><br><span class="line">1996-10-29</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="旧的Date-Time代码"><a href="#旧的Date-Time代码" class="headerlink" title="旧的Date-Time代码"></a>旧的Date-Time代码</h1><hr>
<blockquote>
<p>本节提供了有关如何将较旧的java.util.Date和java.util.Calendar代码转换为Date-Time API的一些提示。</p>
</blockquote>
<p>在Java SE 8发行版之前，Java日期和时间机制由java.util.Date，java.util.Calendar和java.util.TimeZone类及其子类（如 java.util.GregorianCalendar）提供。这些类有几个缺点，包括：</p>
<ul>
<li>Calendar类不是类型安全的。</li>
<li>因为类是可变的，所以它们不能用在多线程应用程序。</li>
<li>由于特殊的月份和缺乏类型安全，在应用程序代码中bug很常见。</li>
</ul>
<h2 id="与旧版代码的互操作性"><a href="#与旧版代码的互操作性" class="headerlink" title="与旧版代码的互操作性"></a>与旧版代码的互操作性</h2><hr>
<p>也许以有些使用java.util日期与时间类的旧的代码，并希望在对你的代码最少改动下利用java.time的功能。</p>
<p>有几个方法被添加到JDK 8版本中，允许你在java.util和java.time对象之间进行转换：</p>
<ul>
<li>Calendar.toInstant()将Calendar对象转换为一个Instant。</li>
<li>GregorianCalendar.toZonedDateTime()将GregorianCalendar对象转换为一个ZonedDateTime。</li>
<li>GregorianCalendar.from(ZonedDateTime)使用ZonedDateTime实例中的默认区域创建一个GregorianCalendar对象。</li>
<li>Date.from(Instant)从Instant创建一个Date对象。</li>
<li>Date.toInstant()将Date对象转换为一个Instant。</li>
<li>TimeZone.toZoneId()将TimeZone对象转换为一个ZoneId。</li>
</ul>
<p>下面的示例将一个Calendar实例转换为一个ZonedDateTime实例。注意从Instant转换为ZonedDateTime的时候必须提供一个时区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ZonedDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()));</span><br></pre></td></tr></table></figure>
<p>下面实例显示如何在Date和Instant之间转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">inst</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">newDate</span> <span class="operator">=</span> Date.from(inst);</span><br></pre></td></tr></table></figure>
<p>下面的示例从一个GregorianCalendar 转换为一个ZonedDateTime，然后从一个ZonedDateTime转换为GregorianCalendar。其他基于时间的类使用ZonedDateTime实例创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">cal</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="type">TimeZone</span> <span class="variable">tz</span> <span class="operator">=</span> cal.getTimeZone();</span><br><span class="line"><span class="type">int</span> <span class="variable">tzoffset</span> <span class="operator">=</span> cal.get(Calendar.ZONE_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> cal.toZonedDateTime();</span><br><span class="line"></span><br><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">newCal</span> <span class="operator">=</span> GregorianCalendar.from(zdt);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> zdt.toLocalDateTime();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> zdt.toLocalDate();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> zdt.toLocalTime();</span><br></pre></td></tr></table></figure>
<h2 id="将java-util的日期和时间功能映射到java-time"><a href="#将java-util的日期和时间功能映射到java-time" class="headerlink" title="将java.util的日期和时间功能映射到java.time"></a>将java.util的日期和时间功能映射到java.time</h2><hr>
<p>由于日期和时间的Java实现在Java SE 8版本中已经完全重新设计，因此您无法交换一种方法到另一种方法。如果要使用java.time包提供的丰富功能，最简单的解决方案是使用上一节中列出的toInstant或toZonedDateTime方法。但是，如果您不想使用这种方式或者它不足以满足您的需求，那么你必须重写日期时间代码。</p>
<p>概述页面介绍的表是开始评估哪些java.time类满足您的需求的好地方。</p>
<p>两个API之间没有一对一对应映射关系，但是下面的表格给你一个java.util日期和时间类中哪些功能映射到java.time API的一般概念。</p>
<table>
<thead>
<tr>
<th>java.util功能</th>
<th>java.time功能</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>java.util.Date</td>
<td>java.time.Instant</td>
<td>Instan和Date类是类似的。每个类：<br>- 表示时间轴（UTC）上的一个瞬间时间点<br>- 持有一个不依赖时区的时间<br>- 是表示epoch-seconds（自从1970-01-01T00:00:00Z）加上的毫秒<br><br>Date.from(Instant)和Date.toInstant()方法允许在这两个类之间转换</td>
</tr>
<tr>
<td>java.util.GregorianCalendar</td>
<td>java.time.ZonedDateTime</td>
<td>ZonedDateTime类是GregorianCalendar的替代品。它提供以下类似的功能。<br>如下表示的人类时间<br>LocalDate：年，月，日<br>LocalTime：小时，分钟，秒，毫秒<br>ZoneId：时区<br>ZoneOffset：当前与GMT的偏移<br><br>GregorianCalendar.from(ZonedDateTime)和 GregorianCalendar.to(ZonedDateTime)方法促成这些类之间的转换</td>
</tr>
<tr>
<td>java.util.TimeZone</td>
<td>java.time.ZoneId或 java.time.ZoneOffset</td>
<td>ZoneId类指定时区标识符，并且可以访问每个时区使用的规则。ZoneOffset类仅指定了与Greenwich&#x2F;UTC的偏移量。</td>
</tr>
<tr>
<td>日期设置为1970-01-01的GregorianCalenda</td>
<td>java.time.LocalTime</td>
<td>代码在GregorianCalendar实例中将日期设置为1970-01-01，以便使用的时间组件可以替换为LocalTime的实例。</td>
</tr>
<tr>
<td>时间设置为00:00的GregorianCalenda</td>
<td>java.time.LocalDate</td>
<td>代码在GregorianCalendar实例中将时间设置为00:00 ，以便使用的时间组件可以替换为LocalDate的实例（由于过渡到夏令时，这个GregorianCalendar方法有缺陷，因为一些国家每年不会发生午夜。）。</td>
</tr>
</tbody></table>
<h2 id="日期和时间格式化"><a href="#日期和时间格式化" class="headerlink" title="日期和时间格式化"></a>日期和时间格式化</h2><hr>
<p>虽然java.time.format.DateTimeFormatter提供了强大的格式化日期和时间值的机制，但是你也可以将java.time中基于时间的类直接与java.util.Formatter和String.format一起使用，使用你使用java.util日期和时间类一样的基于模式的格式化。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<p>java.time包中包含许多您的程序可用于表示时间和日期的类。这是一个非常丰富的API。基于ISO的日期的关键入口点如下：</p>
<ul>
<li>Instant类提供时间线的机器视角。</li>
<li>LocalDate，LocalTime和LocalDateTime类提供了一个不涉及时区的时间与日期的人类视角。</li>
<li>ZoneId，ZoneRules和ZoneOffset类描述时区，时区偏移和时区规则。</li>
<li>ZonedDateTime类表示一个带有时区的日期和时间。OffsetDateTime和OffsetTime类分别表示日期与时间，或时间。这些类考虑到时区偏移。</li>
<li>Duration类以秒和纳秒为单位测量的时间量。</li>
<li>Period类使用年，月和日测量一段时间。</li>
</ul>
<p>其他的非ISO日历系统使用java.time.chrono包表示。尽管“非ISO日期转换”页面提供了有关将基于ISO的日期转换为其他日历系统的信息，但此包超出了本教程的范围。</p>
<p>Date Time API是以JSR 310的名义开发的Java社区进程的一部分。有关更多信息，请参阅<a href="http://jcp.org/en/jsr/detail?id=310"> JSR 310: Date and Time API</a>。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java Date-Time</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发</title>
    <url>/2017/09/13/Java-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>通过Java编程语言和Java类库中的基本并发支持，Java平台被设计为从根本上支持并行编程。自5.0版本以来，Java平台还包括高级并发API。本课介绍了平台的基本并发支持，并总结了java.util.concurrent包中的一些高级API。</p>
<hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><hr>
<p>在并发编程中，有两个基本的执行单位：<strong>进程</strong>（process）和<strong>线程</strong>（thread），并发编程主要涉及到线程，然而，进程也十分重要。</p>
<span id="more"></span>
<p>一个计算机系统通常有许多活动的进程和线程。即使在只有单个执行核心的系统中也是如此，因此在任何给定的时刻只有一个线程在实际执行。单个核心的处理时间通过OS的时间分片（time slicing）功能在进程和线程之间共享。</p>
<p>对于计算机系统拥有多个处理器，并且处理器有多个执行内核变得越来越普遍。这大大提高了系统并发执行进程和线程的能力—但是即使在简单的，没有多个处理器或执行内核的系统上也可以并发。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><hr>
<p><strong>进程</strong>拥有独立的执行环境。一个进程通常有一个完整的，私有的基本运行时资源集，特别每个进程都有自己的内存空间。</p>
<p><strong>进程</strong>通常被视为程序或应用程序的代名词。然而，用户将其视为单个的应用程序可能实际上是一组协作的进程。为了促进进程之间的通信，大多数操作系统支持Inter Process Communication（IPC）资源，例如pipe和socket。<strong>IPC</strong>不仅用于同一个系统中的进程交流，同时还用于不同系统进程之间的交流。</p>
<p>大部分Java虚拟机的实现运行在一个进程中。Java应用程序可以使用<strong>ProcessBuilder</strong>对象创建其他进程。多进程应用程序超出了本课的范围。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><hr>
<p>线程有时被称为轻量级进程。进程和线程都提供一个执行环境，但是创建一个新的线程比创建一个新的进程需要少的多的资源。</p>
<p>线程存在于一个进程中 — 每个进程都至少有一个线程共享进程的资源，包括内存和打开的文件。这使程序更加有效，但也导致了可能的通信问题。</p>
<p>多线程执行是Java平台的一个基本特征。每个应用程序有至少一个线程，或多个，如果你将”system”线程算入，它执行诸如内存管理和信号处理等操作。但是从应用程序开发者的角度来看，你只需要一个线程，<strong>主线程</strong>。这个线程有能力创建其他的线程，我们将在下一节演示。</p>
<hr>
<h1 id="Thread对象"><a href="#Thread对象" class="headerlink" title="Thread对象"></a>Thread对象</h1><hr>
<p>每个线程与一个<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>类实例关联。有两种策略来使用Thread对象创建一个并发应用程序：</p>
<ul>
<li>为了直接控制线程创建和管理，每次应用程序需要启动异步任务时，只需实例化Thread。</li>
<li>要从你的应用程序其他部分抽象线程管理，将应用程序任务传递给一个executor。</li>
</ul>
<p>本节讲述Thread对象的使用，Executors 在高级并发对象中讨论。</p>
<h2 id="定义和启动一个Thread"><a href="#定义和启动一个Thread" class="headerlink" title="定义和启动一个Thread"></a>定义和启动一个Thread</h2><hr>
<p>一个应用程序要想创建一个Thread实例，必须要提供在这个线程中运行的代码。有两种方式：</p>
<ul>
<li><strong>提供一个Runable对象</strong>。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runable</a>接口只定义了一个方法，run，意味着包含要在该线程中执行的代码。Runable对象被传递进Thread的构造方法中，如下示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>子类化Thread</strong>。Thread类本身实现了Runable，尽管它的run方法什么也没做。一个应用程序可以子类化Thread，提供它自己的run方法是ixan，如下所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">HelloThread</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意两个示例中Thread.start是为了启动新的线程。</p>
<p>应该使用哪一个种方式呢？使用Runable对象的第一种更为通用，因为Runable对象可以子类化另一个不是Thread的对象。第二种在简单的应用程序中更容易使用，但受限于你的任务类必须是Thread的后代。本课重点介绍第一种方法，它将Runnable任务与执行任务的Thread对象隔离开。这种方式不仅更加灵活，而且它更适用于稍后涉及的高级线程管理。</p>
<p>Thread方法定义了一系列用于线程管理的方法。包含static方法，它们提供了线程调用方法的信息，或影响了线程调用方法的状态。其他的方法是从涉及管理线程和Thread对象的其他线程调用的。我们将在以下部分中查看其中的一些方法。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><hr>
<p><strong>Thread.sleep</strong>导致当前线程在指定的时间段内暂停执行。这是一种使处理器可用于应用程序其他线程，或其他运行在计算机系统中的应用程序的有效手段。sleep方法也可以用于pacing，如下面例子所示，并且用于等待另一个被理解为有时间要求职责的线程，如稍后SimpleThreads示例。</p>
<p>此外还提供了sleep方法的两个重载版本：一个指定毫秒单位的休眠时间，一个指定纳秒单位的休眠时间。然而休眠时间无法保证精确，因为它们受底层操作系统提供的设施的限制。此外，休眠期可以通过中断终止，我们将在后面的部分中看到。在任何情况下，你不能假定调用sleep方法将在指定的时间段内暂停线程。</p>
<p>SleepMessages示例使用sleep以四秒的间隔打印消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepMessages</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String importantInfo[] = &#123;</span><br><span class="line">            <span class="string">&quot;Mares eat oats&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Does eat oats&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Little lambs eat ivy&quot;</span>,</span><br><span class="line">            <span class="string">&quot;A kid will eat ivy too&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">             i &lt; importantInfo.length;</span><br><span class="line">             i++) &#123;</span><br><span class="line">            <span class="comment">//暂停4秒</span></span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            <span class="comment">//打印信息</span></span><br><span class="line">            System.out.println(importantInfo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意main方法声明它throws InterruptedException。这是一个当sleep激活，而其他线程打断当前线程时sleep抛出的异常。由于这个应用程序还没有定义另一个线程来引起中断，所以它并不需要捕获InterruptedException。</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><hr>
<p>中断是指示一个线程应当停止它正执行的工作，而去执行其他内容。由程序员决定线程如何响应中断，但终止线程是非常常见的。这也是本课中强调的使用方法。</p>
<p>一个线程通过调用<strong>Thread</strong>对象上的<strong>interrupt</strong>方法来发送一个中断指示。为使中断机制正常工作，被打断的线程必须自身支持中断。</p>
<h3 id="支持中断"><a href="#支持中断" class="headerlink" title="支持中断"></a>支持中断</h3><p>一个线程如何支持自身的中断？这取决于它目前在做什么。如果线程经常调用抛出<strong>InterruptedException</strong>的方法，它会在捕获该异常之后从<strong>run</strong>方法返回。例如，假设SleepMessages示例中的中央消息循环是在线程<strong>Runnable</strong>对象的<strong>run</strong>方法中。那么可能会如下修改以支持中断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; importantInfo.length; i++) &#123;</span><br><span class="line">    <span class="comment">// Pause for 4 seconds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve been interrupted: no more messages.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们已经中断了：没有更多的消息。</span></span><br><span class="line">    System.out.println(importantInfo[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多抛出<strong>InterruptedException</strong>的方法（如sleep）被设计为在接收到中断时取消当前操作并立即返回。</p>
<p>如果一个线程很长时间没有调用会抛出InterruptedException的方法怎么办？那么它必须定期调用<strong>Thread.interrupted</strong>，如果已经接收到中断指示，则返回true。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    heavyCrunch(inputs[i]);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// 我们已经被打断了：没有更多的捣蛋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个简单的例子中，代码只是测试中断并退出线程（如果已经被接收到中断指示）。在更复杂的应用程序中，抛出<strong>InterruptedException</strong>可能更有意义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这允许中断处理代码集中在一个catch子句中。</p>
<h3 id="中断状态标志"><a href="#中断状态标志" class="headerlink" title="中断状态标志"></a>中断状态标志</h3><p>中断机制使用被称为中断状态（interrupt status）的内部标志来实现。调用<strong>Thread.interrupt</strong>设置此标志。当线程通过调用静态方法<strong>Thread.interrupted</strong>检查中断时，中断状态被清除。非静态的<strong>isInterrupted</strong>方法，由一个线程用于查询另一个线程的中断状态，不改变中断状态标志。</p>
<p>按照惯例，任何通过抛出InterruptedException退出的方法都会在执行此操作时清除中断状态。但是，通过另一个线程调用<strong>interrupt</strong>，始终可以立即重新设置中断状态。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><hr>
<p><strong>join</strong>方法允许一个线程等待另一个线程的完成。它需要在start方法之后调用。如果<strong>t</strong>是一个<strong>Thread</strong>对象，它的线程正在被执行,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.join();</span><br></pre></td></tr></table></figure>
<p>导致当前线程暂停执行，直到t的线程终止。join的重载方法允许程序员指定等待的时间。但是，与sleep一样，join依赖于操作系统的校时，所以你不应该假设join会等待你指定的时间。像sleep一样，join通过抛出InterruptedException响应一个中断。</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><hr>
<p>如果要设计正确行为的并发程序，了解Java内存模型非常重要。Java内存模型指定不同的线程如何以及何时可以看到其他线程写入到共享变量的值，并且如何在必要时同步访问一个共享变量。</p>
<blockquote>
<p>原始的Java内存模型不足，所以Java内存模型在Java 1.5中进行了修改。此版本的Java内存模型仍然在Java 8中使用。</p>
</blockquote>
<h2 id="内部Java内存模型"><a href="#内部Java内存模型" class="headerlink" title="内部Java内存模型"></a>内部Java内存模型</h2><hr>
<p>Java内存模型在JVM内部被使用，将内存分为<strong>线程栈</strong>（stack）和<strong>堆</strong>（heap）。下面示图从逻辑角度说明了Java内存模型：<br>![Java内存模型1](&#x2F;images&#x2F;java base&#x2F;java-memory-model-1.png)<br>每个Java虚拟机上运行的线程都有它自己的线程栈。<font style="color:#ec70ae;">线程栈包含了线程达到当前执行点调用方法的信息。此外还包含每个正执行方法(调用栈中的所有方法)的局部变量</font>。一个线程只可以访问自己的线程栈，由线程栈创建的局部变量对其他线程都不可见，即使两个线程执行相同的代码。</p>
<p>所有原始类型 ( boolean, byte, short, char, int, long, float, double)的局部变量都完全存储在<strong>线程栈</strong>上，因此对其他线程不可见。<strong>堆</strong>包含所有你的Java应用程序创建的对象，无论是哪个线程创建的。不管一个对象是被创建并分配给一个局部变量，或者作为其他对象的成员变量创建，这个对象依旧存储在堆上。</p>
<p>下面一个图示显示了存储在线程栈上的调用栈和局部变量以及存储在堆上的对象：<br>![Java内存模型1](&#x2F;images&#x2F;java base&#x2F;java-memory-model-2.png)</p>
<ol>
<li>一个局部变量可能是原始类型，这是它完全存储在线程栈上。只有局部变量存储在线程栈上。</li>
<li>一个局部变量也可能是一个对象的引用，这种情况引用（局部变量）存储在线程栈上，而对象本身存储在堆中</li>
<li>一个对象的成员变量与对象本身一起存储在堆上。无论成员变量是原始类型还是引用类型。</li>
<li><font style="color:#ec70ae;">静态类变量也与类定义一起存储在堆上。</font></li>
<li>堆上的对象可以被所有拥有它的引用的线程访问。当一个线程访问一个对象时，它也可以访问对象的成员变量，但每个线程都有它自己的局部变量（对象引用）。</li>
</ol>
<h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><hr>
<p>代硬件内存架构与内部Java内存模型有所不同。以下是现代计算机硬件架构的简化图：’<br>![硬件内存架构](&#x2F;images&#x2F;java base&#x2F;java-memory-model-4.png)<br>现代计算机经常有2个或更多的CPU。其中一些CPU也可能有多个内核。也就是说，在有2个或更多个CPU的现代计算机上，可以同时运行多个线程。每个CPU都可以在任何给定的时间运行一个线程。这意味着如果你的Java应用程序是多线程的，则每个CPU可能会在Java应用程序中同时（并发）运行一个线程。</p>
<p>每个CPU都包含一组本质上是CPU内存的<strong>寄存器</strong>。CPU可以在寄存器上对变量执行比在主内存上更快的操作。这是因为CPU可以访问这些寄存器比访问主内存的速度快得多。</p>
<p>每个CPU可能还有CPU缓存层。事实上，大多数现代CPU都有一些大小的缓存层。CPU可以比访问主内存更快的访问它的缓存，但通常不如访问它的内部寄存器快。因此，CPU缓存访问速度介于内部寄存器和主内存之间。某些CPU可能有多个缓存（1级和2级），但是了解Java内存模型如何与内存进行交互这一点并不重要。重要的是知道CPU可以具有某种缓存层。</p>
<p>计算机还包含主内存区（RAM）。所有CPU都可以访问主内存。主内存区通常远大于CPU的高速缓存。</p>
<p>通常，当一个CPU需要访问主内存，它会读取主内存一部分到它的CPU缓存，甚至可以将缓存的一部分读入其内部寄存器，然后在上面执行某些操作。当CPU需要将结果写入到主内存，它会将值从它的内部寄存器刷入到缓存，并在某些时候将值刷入到主内存。</p>
<p>存储在缓存中的值通常在CPU需要在缓存存储其他东西时，被刷回到主内存中。CPU可以以此只读写部分其中的数据，而不用在更新时读写所有的缓存。通常缓存以更小的被称为“缓存行”的内存块被更新。可以将一个或多个缓存行读入缓存中，并且一个或多个缓存行可以再次刷新回主内存。</p>
<h2 id="原子性访问"><a href="#原子性访问" class="headerlink" title="原子性访问"></a>原子性访问</h2><hr>
<p>编程中，原子性动作是可以一次有效完成的动作。它不会在中途停止：也就是要么一次完成，要么根本没有发生。有些表达式看似简单，但并不是原子性动作，比如自加操作a++,它实际是分成几个步骤完成的。这里有一些动作是原子性的：</p>
<ul>
<li>引用类型变量和大多数原始类型变量（除了long和double）的读写是原子性的</li>
<li>所有声明为volatile的变量（包括long和double）都是原子性的</li>
</ul>
<p>原子性操作不用担心多线程干扰，但依然还有可能发生内存一致性错误，此时应该使用volatile关键字减少这些错误。java.util.concurrent包中的一些类提供了不依赖同步的原子性方法。</p>
<h2 id="Java内存模型与硬件内存架构"><a href="#Java内存模型与硬件内存架构" class="headerlink" title="Java内存模型与硬件内存架构"></a>Java内存模型与硬件内存架构</h2><hr>
<p>如前提到，Java内存模型与硬件内存架构并不相同。硬件内存架构并不区分<strong>线程栈</strong>和<strong>堆</strong>。在硬件上，<strong>线程栈</strong>和<strong>堆</strong>都位于<strong>主内存</strong>中。线程栈和堆的一部分有时可能存在于CPU缓存和内部CPU寄存器中。如图所示：<br>![Java内存模型5](&#x2F;images&#x2F;java base&#x2F;java-memory-model-5.png)<br>当对象和变量可以存储在计算机的各种不同的存储区域中时，可能会出现某些问题。两个主要问题是：</p>
<ul>
<li>线程更新（写入）共享变量的可见性</li>
<li>当读写检查共享变量时的竟态条件</li>
</ul>
<h3 id="共享对象的可见性"><a href="#共享对象的可见性" class="headerlink" title="共享对象的可见性"></a>共享对象的可见性</h3><p>如果两个或更多线程共享一个对象，当其中一个线程更新这个对象时，可能对另一个线程不可见。<br>如下图所示，当一个线程复制共享对象到CPU缓存中，并且将它的count变量值改为2，而这个更改还没有刷回主内存的时候，它是对另一个线程不可见的线程，这导致另一个线程复制共享对象到缓存的时候，count值依旧是1。<br>![线程可见性](&#x2F;images&#x2F;java base&#x2F;java-memory-model-6.png)</p>
<p>这个问题的解决方法是使用Java <strong>volatile</strong>关键字。<strong>volatile</strong>关键字可以确保给定的变量直接从主内存中读取，并在更新时总是写回主内存。</p>
<h3 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h3><p>如果两个或更多线程共享一个对象，当超过一个线程更新这个对象中的变量时，<strong>竟态条件</strong>就会发生。<br>如下图所示，两个线程同时访问一个共享变量的成员变量count&#x3D;1，每个线程都同时对count进行加1操作，我们期望的是count结果加3，但是由于每个线程在其CPU缓存都有一份count副本，进行操作后重新刷回主内存，count值为2，并不是预期结果。<br>![竟态条件](&#x2F;images&#x2F;java base&#x2F;java-memory-model-7.png)<br>这个问题的解决方法是使用Java <strong>synchronized</strong>块。同步块保证在任何给定时间只有一个线程可以进入代码的给定临界区。同步块还保证在同步块内访问的所有变量将从主内存中读入，并且当线程退出同步块时，所有更新的变量将被刷回主内存，而不管该变量是否被声明为<strong>volatile</strong>。</p>
<hr>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><hr>
<p>Java volatile关键字用于标记变量“存储在主内存”中。更准确地说，这意味着，每次读取volatile变量都将从计算机的主内存中读取，而不是从CPU缓存中读取，并且每次volatile变量的写入将直接写入主内存中，而不仅仅是写入CPU缓存。</p>
<p>实际上，由于Java 5的volatile关键字不是仅仅保证了变量从主内存中读写。</p>
<h2 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h2><hr>
<p>Java volatile关键字保证了跨线程的变量更改可见性。假设计算机是多CPU的，可以同时运行多个线程，有一个变量count，只有线程一可以操作count，而线程一和线程二都可以读取count，如果count不使用volatile修饰，线程一将count加1，并将结果存入CPU缓存，还没有刷回主内存，此时线程二读取count的值将不是最新值，造成内存不一致。如果count使用volatile修饰，则count的写入都会被直接写回主内存，同时count的读取也都会直接从主内存中读取。确保了线程之间读写变量的可见性。</p>
<h2 id="Happens-Before保证"><a href="#Happens-Before保证" class="headerlink" title="Happens-Before保证"></a>Happens-Before保证</h2><hr>
<p>从Java 5开始，volatile关键字不仅保证了直接从主内存直接读写变量，还保证了：</p>
<ul>
<li>如果线程A写入一个volatile变量，线程B随后读取同一个volatile变量，那么在写入volatile变量之前，所有对线程A可见的变量，在线程B读取该volatile变量后，同样对线程B可见。</li>
<li>volatile变量的读写指令无法被JVM重排序（JVM可能会出于性能原因重新排序指令，只要JVM探测到不会对程序行为有影响的话）。之前和之后的指令可以重排序，但volatile变量读写指令相对位置不会改变。</li>
</ul>
<p>更详细的解释是：<br>当一个线程写入一个volatile变量时，不仅将volatile变量本身写入主内存。在写入volatile变量之前，线程更改的所有其他变量也会刷入到主内存。当一个线程读取一个volatile变量时，它也将从主内存中读取与volatile变量一起刷入到主内存的所有其他变量。如下例所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread A:</span><br><span class="line">    sharedObject.nonVolatile = <span class="number">123</span>;</span><br><span class="line">    sharedObject.counter     = sharedObject.counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Thread B:</span><br><span class="line">    <span class="type">int</span> <span class="variable">counter</span>     <span class="operator">=</span> sharedObject.counter;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nonVolatile</span> <span class="operator">=</span> sharedObject.nonVolatile;</span><br></pre></td></tr></table></figure>
<p>由于线程A在写入volatile变量sharedObject.counter之前写入了变量sharedObject.counter,那么在线程A写入sharedObject.counter（volatile）时，sharedObject.nonVolatile和sharedObject.counter都会被写入到主内存。</p>
<p>由于线程B首先读取volatile变量sharedObject.counter，那么sharedObject.counter和sharedObject.nonVolatile都会从主内存读取到线程B使用的CPU缓存中。当线程B读取sharedObject.nonVolatile时，它将看到线程A写入最新值。</p>
<p>JVM不会重排序volatile变量读写指令意思如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedObject.nonVolatile1 = <span class="number">123</span>;</span><br><span class="line">sharedObject.nonVolatile2 = <span class="number">456</span>;</span><br><span class="line">sharedObject.nonVolatile3 = <span class="number">789</span>;</span><br><span class="line"></span><br><span class="line">sharedObject.<span class="keyword">volatile</span> = <span class="literal">true</span>; <span class="comment">//一个volatile变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">someValue1</span> <span class="operator">=</span> sharedObject.nonVolatile4;</span><br><span class="line"><span class="type">int</span> <span class="variable">someValue2</span> <span class="operator">=</span> sharedObject.nonVolatile5;</span><br><span class="line"><span class="type">int</span> <span class="variable">someValue3</span> <span class="operator">=</span> sharedObject.nonVolatile6;</span><br></pre></td></tr></table></figure>
<p>sharedObject.volatile之前与之后的三个变量读写指令都可以由JVM出于性能原因重排序，只要保证之前的指令排序后依然在sharedObject.volatile 之前，之后的依然在之后。</p>
<p>开发人员可以使用这种扩展的可见性保证来优化线程之间变量的可见性。而不用声明每一个变量为volatile，只需要一个或几个需要声明为volatile。如下面Exchanger类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exchanger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span>   <span class="variable">object</span>       <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">volatile</span> <span class="variable">hasNewObject</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object newObject)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(hasNewObject) &#123;</span><br><span class="line">            <span class="comment">//等待 - 不会覆盖已有的新对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        object = newObject;</span><br><span class="line">        hasNewObject = <span class="literal">true</span>; <span class="comment">//volatile write</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!hasNewObject)&#123; <span class="comment">//volatile read</span></span><br><span class="line">            <span class="comment">//等待 - 不会取走旧对象 (或 null)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> object;</span><br><span class="line">        hasNewObject = <span class="literal">false</span>; <span class="comment">//volatile write</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程A可能会通过调用put()来不时地放置对象。线程B可能会通过调用take()来不时地接收对象。只要线程A调用put()并且只有线程B调用take()，这个Exchanger可以使用volatile变量（不使用synchronized块）就正常工作。</p>
<p>put()方法中的变量写入指令顺序不能改变，如果改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(hasNewObject) &#123;</span><br><span class="line">    <span class="comment">//等待 - 不会覆盖已有的新对象</span></span><br><span class="line">&#125;</span><br><span class="line">hasNewObject = <span class="literal">true</span>; <span class="comment">//volatile write</span></span><br><span class="line">object = newObject;</span><br></pre></td></tr></table></figure>
<p>则会导致两个问题，首先，可能在线程A执行到设置object值之前，线程B就看到hasNewObject设置为true，其次，无法保证在object设置的值什么时候被刷回到主内存中，对线程B可见。而修改前的顺序，通过volatile的Happens-Before保证，确保了object对象值会随着hasNewObject一起立即被刷回到主内存。</p>
<p>此外，Thread的两个操作也创建了这种happens-before 关系：</p>
<ul>
<li>当一个语句调用Thread.start方法，每个对该语句有happens-before关系的语句，同样对新线程内执行的语句有happens-before关系。这导致创建新线程的代码的效果对于新线程是可见的。</li>
<li>当一个线程终止，并导致Thread.join在另一个线程返回，那么由该终止线程执行的语句与join结束后的所有语句拥有happen-before关系。此线程中代码的效果是对join调用处的线程可见的。</li>
</ul>
<h2 id="volatile不足"><a href="#volatile不足" class="headerlink" title="volatile不足"></a>volatile不足</h2><hr>
<p>如前面例子，当一个线程读取或写入一个共享变量，另一个线程只能读取该共享变量，此时通过volatile关键字可以保证程序如预期运行。volatile关键字可以用于32位和64位的变量。</p>
<p>然而，实际可能多个线程同时读写一个共享的volatile变量，如果新的写入值并不依赖它之前的值，那么在主内存中依旧是正确的值，但是如果依赖之前的值，此时volatile再不能确保正确的可见性，因为两个线程可能同时读取一个共享变量，并且对其进行写入，这时就产生了一个<strong>竞态条件</strong>。此时两个线程写回主内存的值可能会互相覆盖，导致非预期的值。这种情况下需要使用synchronized 关键字来确保变量读写的原子性。</p>
<hr>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><hr>
<p>synchronized关键字可以标记一个方法或代码块同步，称为同步方法（ synchronized methods）和同步语句（synchronized statements）。使用synchronized块可以避免静态条件。Java中的同步块在某个对象上同步。在同一个对象上同步的所有同步块在同一时间内只能执行一个线程。所有其他尝试进入代码块的线程都会被阻塞，直到同步块内的线程退出同步块。<br>synchronized关键字可用于标记四种不同类型的代码块：</p>
<ul>
<li><strong>实例方法</strong></li>
<li><strong>静态方法</strong></li>
<li><strong>实例方法内代码块</strong></li>
<li>**静态方法内代码块 **</li>
</ul>
<h2 id="内部锁"><a href="#内部锁" class="headerlink" title="内部锁"></a>内部锁</h2><hr>
<p>同步是围绕着称为内部锁（ intrinsic lock）或监视器锁（monitor lock）的内部实体构建的。内部锁在同步中有作用：强制执行对对象状态的独占访问，并建立对可见性至关重要的happen-before关系。</p>
<p>每个对象都有一个与之相关的内部锁。按照约定，一个线程要想对对象字段进行排他和一致性的访问，在访问之前必须获得该对象的内部锁，然后在完成对象时释放内部锁。线程在获得锁和释放锁的之间被称为拥有内部锁定。只要一个线程拥有对象的内部锁，其他线程都无法获得该锁。当其他尝试获取锁时，会被阻塞。</p>
<p>当一个线程释放内部锁，它与后续获取该锁动作建立了一个happen-before关系。</p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><hr>
<p>同步方法分为同步实例方法和同步静态方法，只需要简单地在方法声明上加上<strong>synchronized</strong>关键字。</p>
<ul>
<li>同步实例方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.count += value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>同步静态方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当一个线程调用同步方法的时候，它自动获得该方法对象的内部锁，并在返回的时候释放它。即使是由未捕获的异常引发的返回，依旧会释放该锁。对于实例同步方法，它的内部锁为调用该方法的实例，对于静态同步方法，它的内部锁为方法所在类的Class实例。</li>
</ul>
<p>同步方法有两个作用：</p>
<ol>
<li>同一个对象的所有同步方法无法被多个线程同时调用。当一个线程调用一个对象上的同步方法，其他调用该对象同步方法的线程都处于阻塞状态，知道正在执行的线程返回。</li>
<li>当一个同步方法退出的时候，它自动与该对象同步方法随后的调用建立happen-before关系。这保证了对对象状态的更改对其他线程可见。</li>
</ol>
<p>注意synchronized关键字无法用在构造方法上，否则的话会导致语法错误。同步构造方法没有意义，因为只有创建对象的线程在构造时才能访问它。</p>
<blockquote>
<p>当构造一个会在多线程中共享的对象的时候，要非常小心该对象引用的过早“泄漏”。例如假如你像维持一个名为instances的List来保存所有类的实例。你可能会在你的构造方法中添加以下代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instances.add(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是其他线程可以使用instances在该对象构造完成前就访问该对象。</p>
</blockquote>
<p>同步方法可以有效的避免线程干扰和内存一致性错误，如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。除了一个重要例外，final字段，它不会在对象构造后被修改，所以可以安全的通过非synchronized方法读取。</p>
<h2 id="同步语句"><a href="#同步语句" class="headerlink" title="同步语句"></a>同步语句</h2><hr>
<p>有时不需要将整个方法同步，只需要同步方法内的一部分，这时可以使用同步语句，同步语句分实例方法内的同步语句和静态方法内的同步语句，与同步方法不同是，同步语句必须指定一个对象来提供内部锁。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">       <span class="built_in">this</span>.count += value;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>同步语句提供内部锁的对象被称为<strong>监视器对象</strong>（monitor object），上面示例中使用this作为监视器对象，它是调用add方法的实例。对于静态方法中的同步语句，由于静态方法是与类相关的，所以需要使用一个类的Class实例作为监视器对象。</p>
<p>同步语句通过指定监视器对象，提升了更细粒度的同步控制。例如，有一个MsLunch 类有两个字段c1和c2，它们从不在一起使用，所有对该字段的更新都必须是同步的，但没有理由在更新c1的时候阻止c2的更新，因此相比使用同步方法，可以通过使用同步语句指定不同的内部锁来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsLunch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">            c2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Java并发工具"><a href="#Java并发工具" class="headerlink" title="Java并发工具"></a>Java并发工具</h2><hr>
<p>synchronized机制是Java第一个同步访问多线程共享对象的机制。synchronized机制不是很先进。这就是为什么Java 5得到了一整套并发工具类，以帮助开发人员实现比synchronized的更精细的并发控制。</p>
<hr>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><hr>
<p>Java中的ThreadLocal类允许创建只能由同一个线程读取和写入的变量。因此，即使两个线程正在执行相同的代码，并且代码对ThreadLocal变量进行引用，那么两个线程也看不到彼此的ThreadLocal变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;String&gt; myThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">myThreadLocal.set(<span class="string">&quot;Hello ThreadLocal&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">threadLocalValue</span> <span class="operator">=</span> myThreadLocal.get();</span><br></pre></td></tr></table></figure>
<p>如上初始化ThreadLocal变量，并且使用set()方法设置值，get()方法获取值。由于设置在ThreadLocal对象上的值仅对设置该值的线程是可见的，所以线程不能使用set()设置一个对所有线程都可见的初始值。但是可以通过子类话ThreadLocal，并重写它的**initialValue()**方法来设置一个初始化值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ThreadLocal</span> <span class="variable">myThreadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is the initial value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>现在所有线程在调用set()之前调用get()时会看到相同的初始值。</p>
<hr>
<h1 id="线程信令"><a href="#线程信令" class="headerlink" title="线程信令"></a>线程信令</h1><hr>
<p>线程信令的目的是使线程能够互相之间发送信号。此外，线程信令使线程能够等待来自其他线程的信号。例如，线程B可能等待来自线程A的信号，指示数据准备好被处理。</p>
<h2 id="使用共享对象"><a href="#使用共享对象" class="headerlink" title="使用共享对象"></a>使用共享对象</h2><hr>
<p>实现线程相互发送信号的一种简单方式是通过将信号值设置在某些共享对象变量中。线程A可以从同步块内部将boolean成员变量hasDataToProcess设置为true，线程B也可以在同步块内部读取hasDataToProcess成员变量。这是一个可以容纳这种信号的对象的简单示例，并提供设置和检查它的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySignal</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">hasDataToProcess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hasDataToProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hasDataToProcess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setHasDataToProcess</span><span class="params">(<span class="type">boolean</span> hasData)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.hasDataToProcess = hasData;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理数据的线程B正在等待数据可用于处理。换而言之，它正在等待来自线程A的信号，这会导致hasDataToProcess()返回true。线程B正在运行循环，同时等待此信号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">MySignal</span> <span class="variable">sharedSignal</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!sharedSignal.hasDataToProcess())&#123;</span><br><span class="line">  <span class="comment">//do nothing... busy waiting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在hasDataToProcess()返回true之前，while循环如何保持执行。这被称为<strong>忙等待</strong>(busy waiting)。</p>
<h2 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(), notify()和notifyAll()"></a>wait(), notify()和notifyAll()</h2><hr>
<p>在运行等待线程时，忙等待对CPU的利用不是非常高效的，除非平均的等待时间非常少。如果使等待的线程可以休眠或者变为待用，可能会更明智些。</p>
<p>Java有一个内置的等待机制，使得线程在等待信号时变为不活动。java.lang.Object类定义了**wait()<strong>，</strong>notify()<strong>和</strong>notifyAll()**这三个方法。</p>
<p>一个线程可以在任何对象上调用wait()方法时线程不活动，直到另一个线程在该对象上调用notify()。为了调用wait()和notify()，调用线程必须首先获得监视器对象上的锁。换句话说，调用线程必须从同步块内部调用wait()或notify()。这是MySignal的修改版本MyWaitNotify，它使用wait()和notify()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorObject</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWaitNotify</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">MonitorObject</span> <span class="variable">myMonitorObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonitorObject</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        myMonitorObject.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待线程可以调用doWait(),而唤醒线程可以调用doNotify()。当一个线程在对象上调用notify(),在该线程上等待的一个线程就会被唤醒继续执行。还有一个notifyAll()方法会唤醒所有在给定对象上等待的线程。</p>
<p>如上所见，调用wait()和notify()的调用都在同步块中，这是强制的。如果没有持有这些方法对象上的锁的话，一个线程无法调用wait(),notify()和notifyAll()方法。如果调用，会抛出IllegalMonitorStateException 异常。</p>
<p>一旦线程调用了wait()方法，它会释放它持有的该监视器对象上的锁。此时其他线程可以获得该锁。<br><font style="color:#ec70ae;">一旦线程被唤醒，它不能立即退出wait()方法，要一直到调用notify()的线程离开它的同步块。</font>换而言之，唤醒的线程必须在它可以退出wait()方法前，重新获得监视器对象上锁,因为wait的调用嵌套在同步块内。如果多个线程被使用notifyAll()唤醒，一次只有一个唤醒的线程可以退出wait()方法，因为每个线程必须在退出wait()之前依次获取监视对象上的锁。</p>
<h2 id="信号丢失"><a href="#信号丢失" class="headerlink" title="信号丢失"></a>信号丢失</h2><hr>
<p>notify（）和notifyAll（）方法不会将保存方法调用，以防止调用时没有线程处于wait状态。然后通知信号就会丢失。因此，如果一个线程在其他线程调用wait()前调用了notify()，信号将被等待线程错过。这可能是或可能不是一个问题，但在某些情况下，这可能导致等待线程永远等待，永远不会醒来，因为唤醒的信号被错过了。</p>
<p>为了避免丢失信号，信号应该存储在信号类中。在MyWaitNotify示例中，通知信号应存储在MyWaitNotify实例中的成员变量中。以下是MyWaitNotify的修改版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWaitNotify2</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">MonitorObject</span> <span class="variable">myMonitorObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonitorObject</span>();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">wasSignalled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="literal">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><hr>
<p>由于不可思议的原因，即使notify（）和notifyAll（）尚未被调用，线程也可以唤醒。这被称为虚假唤醒。唤醒没有任何理由。</p>
<p>如果在MyWaitNofity2类的doWait（）方法中发生虚假唤醒，则等待线程可能会没有收到信号就继续处理！这可能会导致您的应用程序的严重问题。</p>
<p>为了防止虚假唤醒，信号成员变量在一个while循环内被检查，而不是在if语句内部。这样的while循环也称为<strong>自旋锁</strong>。线程直到自旋锁（while循环）中的条件变为false才会真正唤醒。这是MyWaitNotify2的修改版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWaitNotify3</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">MonitorObject</span> <span class="variable">myMonitorObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonitorObject</span>();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">wasSignalled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//清楚信号，继续运行。</span></span><br><span class="line">      wasSignalled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="literal">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意wait（）调用如何嵌套在while循环而不是if语句中。如果等待线程在没有收到信号的情况下唤醒，则isSignalled成员仍将是false，while循环将再次执行，导致唤醒的线程返回等待。</p>
<h2 id="多个线程等待同一个信号"><a href="#多个线程等待同一个信号" class="headerlink" title="多个线程等待同一个信号"></a>多个线程等待同一个信号</h2><hr>
<p>当有多个线程等待，并且被notifyAll()全部唤醒的，但只有一个线程应该运行被执行，此时这个while循环也是一个很好的解决方案。一次只能有一个线程能够获取监视器对象上的锁，这意味着只有一个线程可以退出wait()调用并且清除wasSignalled标记。一旦该线程在doWait()方法中退出同步块，其他线程就可以退出wait()调用，并检查while循环内的wasSignalled成员变量。然而，这个标志被第一个线程清除，所以其余的唤醒的线程返回等待，直到下一个信号到达。</p>
<h2 id="不要在String或全局对象上调用wait-方法"><a href="#不要在String或全局对象上调用wait-方法" class="headerlink" title="不要在String或全局对象上调用wait()方法"></a>不要在String或全局对象上调用wait()方法</h2><hr>
<p>由于JVM&#x2F;编译器别不将常量字符串转换为同一个对象，因此如果使用字符串作为监视器对象，如MyWaitNotify定义“String myMonitorObject &#x3D; “”;”，这将导致一个问题，即使创建多个MyWaitNotify实例，但监视器对象还是同一个，在多个线程等待唤醒的调用中将出现混乱。</p>
<p>所以：不要对wait（）&#x2F; notify（）机制使用全局对象，字符串常量等。使用使用它的构造是唯一的对象。例如，每个MyWaitNotify3（早期部分的示例）实例都有自己的MonitorObject实例，而不是为wait（）&#x2F; notify（）调用使用空字符串。</p>
<hr>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><hr>
<p>![线程生命周期](&#x2F;images&#x2F;java base&#x2F;thread-life.png)<br>创建并运行线程：</p>
<p>① <strong>新建状态</strong>(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。<br>线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</p>
<p>②<strong>就绪状态</strong>(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</p>
<p>③<strong>运行状态</strong>(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。</p>
<ul>
<li>可以通过Thread类的isAlive方法来判断线程是否处于就绪&#x2F;运行状态：当线程处于就绪&#x2F;运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。</li>
</ul>
<p>④ <strong>阻塞和唤醒线程</strong><br><strong>阻塞状态</strong>(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：</p>
<ol>
<li>当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。</li>
<li>当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。</li>
<li>当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()&#x2F;notify()方法的执行要求线程首先获得该对象的锁。</li>
</ol>
<p>⑤<strong>死亡状态</strong>(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。</p>
<p>终止线程的三种方法<br>①使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。<br>②使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。<br>③ 使用interrupt方法中断线程。</p>
<hr>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><hr>
<p>如果一个对象在创建之后状态不能改变，那么它被认为是一个不可变对象。不可变对象在并发应用程序中特别有用。由于它们不能改变状态，它们不会被线程干扰所破坏或者在不一致状态下观察到。</p>
<p>程序员通常不愿使用不可变对象，因为他们担心创建一个新对象的花销，而不是更新一个对象。对象创建的影响往往被高估，它可以通过与不可变对象的一些有点带来的效率来抵消。这些包括由于垃圾回收而导致的开销降低，以及为消除为了保护可变对象免受损坏所需的代码。</p>
<p>以下规则定义了创建不可变对象的简单策略。不是所有“不可变”的类都遵循这些规则。这并不一定意味着这些类的创作者都是草率的 - 他们可能有充分的理由相信他们的类在构造后永远不会改变。然而，这种策略需要复杂的分析，不适合初学者。</p>
<ol>
<li>不提供“setter”方法 — 修改字段或引字段引用对象的方法。</li>
<li>使所有的字段final和private</li>
<li>不允许子类重写方法。最简单的方法是将类声明为final。更复杂的方法是使构造函数为私有并在工厂方法中构造实例。</li>
<li>如果实例字段包含可变对象的引用，则不允许更改这些对象：<ul>
<li>不提供修改这些可变对象的方法</li>
<li>不共享可变对象的引用。<br> 不要存储引用到外部，可变对象传递给构造方法；如果需要，创建一个副本，并存储副本引用。同样，如果需要的时候创建内部可变对象副本，以避免在方法中返回原始可变对象。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="高级并发对象"><a href="#高级并发对象" class="headerlink" title="高级并发对象"></a>高级并发对象</h1><hr>
<p>前面是是一些低级并发API，这些API足够用于非常基本的任务，但更高级的构建模块需要更高级的任务。对于充分利用当今多处理器和多核系统的大规模并发应用程序尤其如此。在Java 5.0中引入了一些高级并发功能，大多数这些功能都在新的java.util.concurrent包中实现。 Java Collections Framework（JCF）中还有新的并发数据结构。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><hr>
<p>同步代码依赖于一种简单的重入锁。这种锁便于使用，但也有很多限制。java.util.concurrent.locks包支持更多复杂的同步锁功能。其中最基本的是Lock接口。</p>
<p>Lock对象非常向同步代码块使用的隐式锁。与隐式锁一样，一次只能有一个线程拥有一个Lock对象。锁定对象还通过其关联的Condition对象支持wait&#x2F;notify机制。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><hr>
<p>前面例子中，在由Runable对象定义的要使用线程完成的任务，与有Thread对象定义的线程本身有着紧密联系。这适用于小型应用程序，但在大规模应用程序中，将线程管理和创建与其他应用程序分开是有意义的。封装这些函数的对象被称为执行器（executor），以下是执行器的一些细节：</p>
<ul>
<li>Executor接口：定义了三个执行器对象类型</li>
<li>线程池：最常用的执行器实现方式。</li>
<li>fork&#x2F;join：一个用于利用多个处理器的框架（JDK 7中的新功能）</li>
</ul>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><p>java.util.concurrent包定义了三个执行器接口：</p>
<ul>
<li><strong>Executor</strong>，一个支持启动新任务的简单接口。</li>
<li><strong>ExecutorService</strong>，Executor的一个子接口，它增加了帮助管理独立任务和执行者本身生命周期的功能。</li>
<li><strong>ScheduledExecutorService</strong>，ExecutorService的一个子接口，支持将来和&#x2F;或定期执行任务。</li>
</ul>
<p>通常，引用执行器对象的变量被声明为这三种接口类型之一，而不是执行器类类型。</p>
<h4 id="Executor接口-1"><a href="#Executor接口-1" class="headerlink" title="Executor接口"></a>Executor接口</h4><p>Executor接口只提供了一个方法，execute，被设计为普通线程创建形式的替代品。。如果r是一个Runnable对象，e是一个Executor对象，可以将</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Thread</span>(r)).start();</span><br></pre></td></tr></table></figure>
<p>换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.execute(r);</span><br></pre></td></tr></table></figure>
<p>但是，execute的定义较不具体。第一种语句创建一个线程并立即启动。根据Executor的实现，execute可能执行相同的操作，但更有可能使用现有的一个工作线程来运行r，或者将r置于队列中等待一个工作线程变为可用。（将在线程池部分中描述工作线程。）</p>
<p>java.util.concurrent中的执行器实现旨在充分利用更高级的ExecutorService和ScheduledExecutorService接口，尽管它们也可以与基本Executor接口一起使用。</p>
<h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h4><p>ExecutorService接口使用类似但更通用的submit方法来补充execute方法。像execute一样，submit接受Runnable对象，但也接受Callable对象，这允许任务返回一个值。 submit方法返回一个Future对象，用于检索Callable返回值并管理Callable和Runnable任务的状态。</p>
<p>ExecutorService还提供了用于提交大型Callable对象集合的方法。最后，ExecutorService提供了许多管理执行器关闭的方法。为了支持立即关闭，任务应正确处理interrupt。</p>
<h4 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h4><p>ScheduledExecutorService接口使用schedule补充其父接口ExecutorService中的方法，schedule方法在指定的延迟之后执行Runnable或Callable任务。另外，这个接口定义了scheduleAtFixedRate和scheduleWithFixedDelay，它们以定义的的间隔重复执行指定的任务。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>java.util.concurrent中的大多数执行器实现都使用由<strong>工作线程</strong>（worker thread）组成的<strong>线程池</strong>（thread pool）。这种线程与其执行的Runnable和Callable任务分离开，并且经常用于执行多个任务。</p>
<p>使用工作线程可以最大限度地减少线程创建时的开销。Thread对象使用大量的内存，并且在大规模应用程序中，分配和释放许多线程对象会产生显着的内存管理开销。</p>
<p>一种常见的<strong>线程池</strong>类型是<strong>固定线程池</strong>。这种类型的线程池总是有指定数量的线程在运行;如果一个线程在它还在使用的时候不知何故被终止，则会自动被一个新的线程替换。任务通过它的内部队列被提交到线程池，每当存在比线程更多的活动任务时，多出的任务会被保存到该内部队列。</p>
<p>固定线程池的一个重要优点是使用它的应用程序正常地降级。要理解这一点，请考虑一个Web服务器应用程序，其中每个HTTP请求由单独的线程处理。如果应用程序只是为每个新的HTTP请求创建一个新的线程，并且系统收到比它可以立即处理的更多的请求，当所有这些线程的开销超过系统的容量时，应用程序将突然停止响应所有请求。通过对可以创建的线程数量的限制，应用程序将不会尽快为HTTP请求提供服务，但它将在系统可以承受的时候尽快提供服务。</p>
<p>一个创建使用固定线程池的执行器的简单方法是在java.util.concurrent.Executors中调用<strong>newFixedThreadPool</strong>工厂方法，此类还提供以下工厂方法：</p>
<ul>
<li><strong>newCachedThreadPool</strong>方法创建一个具有可扩展线程池的执行器。这个执行器适用于启动许多短暂任务的应用程序。</li>
<li><strong>newSingleThreadExecutor</strong>方法创建一次执行一个任务的执行器。</li>
<li>几个是上述执行器的ScheduledExecutorService版本的工厂方法。</li>
</ul>
<p>如果上述工厂方法提供的任何执行程序都不满足需求，则构造<strong>java.util.concurrent.ThreadPoolExecutor</strong>或<strong>java.util.concurrent.ScheduledThreadPoolExecutor</strong>的实例将提供其他选项。</p>
<h3 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>fork&#x2F;join框架是ExecutorService接口的一个实现，可以帮助利用多个处理器。它被设计用于可递归地分解成更小的部分的工作。目标是使用所有可用的处理能力来提高应用程序的性能。</p>
<p>与任何ExecutorService实现一样，fork&#x2F;join框架将任务分配到线程池中的工作线程。fork&#x2F;join框架是独特的，因为它使用work-stealing算法。无事可做的工作线程可能会从仍然忙碌的其他线程中窃取任务。</p>
<p>fork&#x2F;join框架的中心是<strong>ForkJoinPool</strong>类，它是<strong>AbstractExecutorService</strong>类的扩展。 <strong>ForkJoinPool</strong>实现了核心的<strong>work-stealing</strong>算法，并且可以执行<strong>ForkJoinTask</strong>进程。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>使用fork&#x2F;join框架的第一步是编写执行工作段的代码，您的代码应类似于以下伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (my portion of the work is small enough)</span><br><span class="line">  do the work directly</span><br><span class="line">else</span><br><span class="line">  split my work into two pieces</span><br><span class="line">  invoke the two pieces and wait for the results</span><br></pre></td></tr></table></figure>
<p>将此代码包装在<strong>ForkJoinTask</strong>子类中，通常使用其更专门的类型之，即<strong>RecursiveTask</strong>（可返回结果）或<strong>RecursiveAction</strong>。</p>
<p>在<strong>ForkJoinTask</strong>子类准备好后，创建表示所有要完成的工作的对象，并将其传递给<strong>ForkJoinPool</strong>实例的<strong>invoke（）</strong>方法。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>为了帮助了解fork&#x2F;join框架的工作原理，请考虑以下示例。假设你想模糊图像。原始的源图像由整数数组表示，其中每个整数包含单个像素的颜色值。模糊的目标图像也用与源的大小相同的整数数组表示。</p>
<p>执行模糊是通过一次处理源数组一个像素来完成的。每个像素与其周围的像素（红色，绿色和蓝色被平均）进行平均，并将结果放到目标数组中。由于图像是一个大的数组，这个过程可能需要很长时间。您可以通过使用fork&#x2F;join框架实现算法来利用多处理器系统上的并发处理。这是一个可能的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkBlur</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mDestination;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理窗口大小，应该是一个奇数.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mBlurWidth</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkBlur</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> start, <span class="type">int</span> length, <span class="type">int</span>[] dst)</span> &#123;</span><br><span class="line">        mSource = src;</span><br><span class="line">        mStart = start;</span><br><span class="line">        mLength = length;</span><br><span class="line">        mDestination = dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">computeDirectly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sidePixels</span> <span class="operator">=</span> (mBlurWidth - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mStart; index &lt; mStart + mLength; index++) &#123;</span><br><span class="line">            <span class="comment">// 计算平均值。</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">rt</span> <span class="operator">=</span> <span class="number">0</span>, gt = <span class="number">0</span>, bt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> -sidePixels; mi &lt;= sidePixels; mi++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mindex</span> <span class="operator">=</span> Math.min(Math.max(mi + index, <span class="number">0</span>),mSource.length - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">pixel</span> <span class="operator">=</span> mSource[mindex];</span><br><span class="line">                rt += (<span class="type">float</span>)((pixel &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>) / mBlurWidth;</span><br><span class="line">                gt += (<span class="type">float</span>)((pixel &amp; <span class="number">0x0000ff00</span>) &gt;&gt;  <span class="number">8</span>) / mBlurWidth;</span><br><span class="line">                bt += (<span class="type">float</span>)((pixel &amp; <span class="number">0x000000ff</span>) &gt;&gt;  <span class="number">0</span>)  / mBlurWidth;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 重新组装目标像素。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dpixel</span> <span class="operator">=</span> (<span class="number">0xff000000</span>     ) | (((<span class="type">int</span>)rt) &lt;&lt; <span class="number">16</span>) |  (((<span class="type">int</span>)gt) &lt;&lt;  <span class="number">8</span>) | (((<span class="type">int</span>)bt) &lt;&lt;  <span class="number">0</span>);</span><br><span class="line">            mDestination[index] = dpixel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>现在实现抽象的compute()方法，它要么直接执行模糊，要么将其分为两个更小的任务。一个简单的数组长度阈值有助于确定工作是要执行还是要拆分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sThreshold</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLength &lt; sThreshold) &#123;</span><br><span class="line">        computeDirectly();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">split</span> <span class="operator">=</span> mLength / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    invokeAll(<span class="keyword">new</span> <span class="title class_">ForkBlur</span>(mSource, mStart, split, mDestination),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ForkBlur</span>(mSource, mStart + split, mLength - split,</span><br><span class="line">                           mDestination));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上一个方法在RecursiveAction类的子类中，则设置在ForkJoinPool中配置要运行的任务是直接的，并且涉及以下步骤：</p>
<ol>
<li>创建一个代表所有要完成的工作的任务。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源图像像素在src中</span></span><br><span class="line"><span class="comment">// 目标图像像素dst中</span></span><br><span class="line"><span class="type">ForkBlur</span> <span class="variable">fb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkBlur</span>(src, <span class="number">0</span>, src.length, dst);</span><br></pre></td></tr></table></figure></li>
<li>创建要运行任务的ForkJoinPoll<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br></pre></td></tr></table></figure></li>
<li>运行任务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool.invoke(fb);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于完整的源代码，包括创建目标映像文件的一些额外的代码，请参阅ForkBlur示例。</p>
<h4 id="标准实现"><a href="#标准实现" class="headerlink" title="标准实现"></a>标准实现</h4><p>除了使用fork&#x2F;join框架来实现在多处理器系统上同时执行的任务的自定义算法（例如上一节中的ForkBlur.java示例），Java SE中有一些常用的功能，它们已经使用fork&#x2F;join框架。一个这样的实现在Java SE 8中引入，它被<strong>java.util.Arrays</strong>类所使用，用于它的<strong>parallelSort()<strong>方法。这些方法类似于</strong>sort（）</strong>，但是通过fork&#x2F;join框架来利用并发性。在多处理器系统上运行时，大型数组的并行排序比顺序排序更快。然而，这些方法如何利用fork&#x2F;join框架是不在本节范围之内的。有关此信息，请参阅Java API文档。 </p>
<p><strong>fork&#x2F;join</strong>框架的另一个实现由<strong>java.util.streams</strong>包中的方法所使用，它是为Java SE 8发行版计划的Project Lambda的一部分。有关更多信息，请参阅[“Lambda表达式”]。</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><hr>
<p>java.util.concurrent包包含许多Java Collections Framework的添加。这些最容易被提供的集合接口分类：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html"><strong>BlockingQueue</strong></a>定义一个先进先出的数据结构，当你尝试向已满queue添加元素或从空queue中检索时，该数据结构将阻塞或超时。 </li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><strong>ConcurrentMap</strong></a>是java.util.Map的一个子接口，它定义了一些有用的原子性操作。这些操作仅在键存在时才删除或替换键值对，或者仅在键不存在时才添加键值对。使这些操作原子化有助于避免同步问题。ConcurrentMap的标准通用实现是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a>，它是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>的并发模拟。</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html"><strong>ConcurrentNavigableMap</strong></a>是ConcurrentMap的一个子接口，它支持近似匹配。ConcurrentNavigableMap的标准通用实现是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">ConcurrentSkipListMap</a>，它是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a>的并发模拟。</li>
</ul>
<p>所有这些集合通过在向一个集合添加元素操作与后续的访问或移除对象的操作之间建立happens-before关系，来避免了内存一致性错误。</p>
<h2 id="原子性变量"><a href="#原子性变量" class="headerlink" title="原子性变量"></a>原子性变量</h2><hr>
<p>java.util.concurrent.atomic包定义了对单个变量支持原子操作的类。所有类都有get和set方法，其工作就像在volatile变量上的读写一样。也就是，在同一个变量上set与任何后续的get有一个happens-before关系。原子性compareAndSet方法也具有这些内存一致性特征，简单的原子性算术方法也适用于整数原子性变量。</p>
<p>要看如何使用这个包，先看线程不安全的Counter类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使Counter避免线程干扰的一种方法是使其方法同步，如SynchronizedCounter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个简单的类，同步是可以接受的解决方案。但是对于一个更复杂的类，我们可能希望避免不必要的同步的活性影响。用AtomicInteger替换int字段可以防止线程干扰，而不要求同步，如AtomicCounter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        c.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        c.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h2><hr>
<p>在JDK 7中，java.util.concurrent包含一个便捷类，<strong>ThreadLocalRandom</strong>，用于希望在多线程或ForkJoinTask使用随机数的应用程序。 </p>
<p>对于并发访问，使用<strong>ThreadLocalRandom</strong>而不是**Math.random()**导致更少的争用，并最终产生更好的性能。 </p>
<p>所有需要做的是调用**ThreadLocalRandom.current()**，然后调用其一个方法来检索一个随机数。这里有一个例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.current() .nextInt(<span class="number">4</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="活性"><a href="#活性" class="headerlink" title="活性"></a>活性</h1><hr>
<p>一个并发应用程序及时执行的能力被称活性（liveness）。下面讨论常见的活性问题。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><hr>
<p>死锁是两个或多个线程永远被阻塞，互相等待彼此释放锁的的情况。死锁会有至少两个内部锁，并且线程在一个同步块中尝试进入另一个同步块。例如线程1持有A锁，尝试获取B锁，而线程2持有B锁，尝试获取A锁，这时死锁发生了。情况如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 1  locks A, waits for B</span><br><span class="line">Thread 2  locks B, waits for A</span><br></pre></td></tr></table></figure>
<p>举例，Alphonse和Gaston是朋友，也是礼貌的信徒。它们你有一个严格的礼貌规则是，当你向朋友鞠躬时，你必须保持鞠躬，直到你的朋友有机会回躬。不幸的是，这个规则不能排除两个朋友可能会同时相互鞠躬的可能。这个例子应用程序, Deadlock，模拟这种可能性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend bower)</span> &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;%s: %s&quot;</span> + <span class="string">&quot;  has bowed to me!%n&quot;</span>, <span class="built_in">this</span>.name, bower.getName());</span><br><span class="line">            bower.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend bower)</span> &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;%s: %s&quot;</span> + <span class="string">&quot; has bowed back to me!%n&quot;</span>,<span class="built_in">this</span>.name, bower.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Friend</span> <span class="variable">alphonse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Friend</span>(<span class="string">&quot;Alphonse&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Friend</span> <span class="variable">gaston</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Friend</span>(<span class="string">&quot;Gaston&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; alphonse.bow(gaston); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; gaston.bow(alphonse); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死锁也可以包含两个以上的线程。这使得更难检测。以下是四个线程死锁的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 1  locks A, waits for B</span><br><span class="line">Thread 2  locks B, waits for C</span><br><span class="line">Thread 3  locks C, waits for D</span><br><span class="line">Thread 4  locks D, waits for A</span><br></pre></td></tr></table></figure>
<p>一个死锁可能会发生的更复杂的情况是数据库事务。数据库事务可能包含许多SQL更新请求。当在一个事务中更新记录时，对于他事务更新该记录将被锁定，直到第一个事务完成。因此，相同事务中的每个更新请求可能会锁定数据库中的一些记录。</p>
<p>如果多个事务正在同时运行，需要更新相同的记录，那么就有可能会导致死锁。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transaction 1, request 1, locks record 1 for update</span><br><span class="line">Transaction 2, request 1, locks record 2 for update</span><br><span class="line">Transaction 1, request 2, tries to lock record 2 for update.</span><br><span class="line">Transaction 2, request 2, tries to lock record 1 for update.</span><br></pre></td></tr></table></figure>
<p>因为锁在采用自不同的请求，因此并不是提前知道给定事务所需的所有锁，很难检测或防止数据库事务中的死锁。</p>
<h2 id="饥饿与公平锁"><a href="#饥饿与公平锁" class="headerlink" title="饥饿与公平锁"></a>饥饿与公平锁</h2><hr>
<p>饥饿描述了线程无法获得对共享资源的正常访问并且无法继续执行的情况。以下三个常见原因可能导致Java中线程的饥饿：</p>
<ul>
<li>具有高优先级的线程相比较低优先级的线程，占据了所有的CPU时间。</li>
<li>线程被无限期阻塞等待进入同步块，因为其他线程一直在它之前先进入。</li>
<li>线程无限期在等待被唤醒，因为其他线程一直在它之前被唤醒。</li>
</ul>
<p>饥饿问题的解决方案被称为公平锁，它使所有线程公平的获得执行权限。</p>
<h3 id="使用Lock代替同步块"><a href="#使用Lock代替同步块" class="headerlink" title="使用Lock代替同步块"></a>使用Lock代替同步块</h3><p>同步代码依赖于一种简单的可重入锁。这种锁很容易使用，但有很多限制。java.util.concurrent.locks包支持更复杂的锁。其中最基本的是Lock接口。</p>
<p>Lock对象的工作非常像同步代码使用的隐式锁。</p>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>java 并发</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 核心技术（三）验证，数据绑定和类型转换</title>
    <url>/2017/08/05/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%89%EF%BC%89%E9%AA%8C%E8%AF%81%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}
</style>

<p><a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#validation">原文链接</a></p>
<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">*JSR-303/JSR-349 Bean 验证*   
Spring Framework 4.0在安装支持方面支持Bean Validation 1.0（JSR-303）和Bean Validation 1.1（JSR-349），也适用于Spring的Validator接口。</br>
应用程序可以选择一次全局启用Bean验证，如[第8节“Spring验证"](#pring验证)中所述，并专门用于所有验证需求。</br>
应用程序还可以为每个DataBinder实例注册额外的Spring Validator实例，如[第8.3节“配置DataBinder"](#配置DataBinder)中所述。这可能有助于不使用注解来插入验证逻辑。
</div> 
将验证视为业务逻辑有利有弊，而Spring提供了一种验证（和数据绑定）的设计，不排除任何一种。明确的的验证不应该与Web层相关联，应该易于本地化，并且应该可以插入任何可用的验证器。考虑到上述情况，Spring已经提出了一个**Validator**接口，它对应用程序的每一层都是基本和非常可用的。

<span id="more"></span>
<p>数据绑定对于允许将用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）是有用的。Spring提供了所谓的<strong>DataBinder</strong>来做到这一点。<strong>Validator</strong>和<strong>DataBinder</strong>构成<strong>validation</strong>包，主要用于但不限于MVC框架。</p>
<p><strong>BeanWrapper</strong>是Spring框架中的一个基本概念，并且用于很多地方。但是，你可能不需要直接使用BeanWrapper。因为这是参考文档，我们觉得有些解释可能需要按顺序来。我们将在本章中解释BeanWrapper，如果你要使用它，你最可能在尝试绑定数据到对象的时候这么做。</p>
<p>Spring的<strong>DataBinder</strong>和较低级别的<strong>BeanWrapper</strong>都使用<strong>PropertyEditor</strong>来解析和格式化属性值。<strong>PropertyEditor</strong>概念是JavaBeans规范的一部分，本章还将对此进行说明。Spring 3引入了一个“<strong>core.convert</strong>“包，它提供一个通用的类型转换工具，而且还有一个更高级的“format”包,用于格式化UI字段值。这些新的包可能被用作<strong>PropertyEditor</strong>的更简单的替代方法，本章还将讨论这些新的包。</p>
<hr>
<h1 id="使用Spring-Validator接口验证"><a href="#使用Spring-Validator接口验证" class="headerlink" title="使用Spring Validator接口验证"></a>使用Spring Validator接口验证</h1><hr>
<p>Spring具有可用于验证对象的<strong>Validator</strong>接口。<strong>Validator</strong>接口使用<strong>Errors</strong>对象进行工作，以便在验证时，验证器可以向<strong>Errors</strong>对象报告验证失败。</p>
<p>我们来考虑一个小数据对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通常的getters和setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将通过实现<strong>org.springframework.validation.Validator</strong>接口的以下两种方法为Person类提供验证行为：</p>
<ul>
<li><strong>supports(Class)</strong> —— 此Validator可以验证提供的Class的实例吗？</li>
<li><strong>validate(Object, org.springframework.validation.Errors)</strong> —— 验证给定的对象，并在验证错误的情况下，注册这些错误给给定的<strong>Errors</strong>对象</li>
</ul>
<p>实现Validator是非常简单的，特别是当您知道Spring Framework还提供的<strong>ValidationUtils</strong>帮助类时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个Validator验证*只是*Person实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object obj, Errors e)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(e, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.empty&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;negativevalue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;too.darn.old&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，<strong>ValidationUtils</strong>类上的<strong>static</strong> **rejectIfEmpty(..)**方法用于拒绝’name’属性,如果它为null或是空字符串的话。看下ValidationUtils的javadocs，除了上面显示的例子，它还提供了什么功能。</p>
<p>虽然确实可以通过实现一个单个的<strong>Validator</strong>类来验证富对象中的每个嵌套对象，但最好为对象中的每个嵌套类在它自己的Validator实现中封装验证逻辑。一个’富’对象的简单示例是由两个String属性（firstName和surname）以及一个复杂的Address对象组成的Customer。Address对象可能独立于Customer对象使用，因此已经实现了一个不同的AddressValidator。如果你希望你的CustomerValidator无需复制和粘贴，就能重用AddressValidator类中包含的逻辑，你可以在你的CustomerValidator中依赖注入或实例化AddressValidator，如下一样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerValidator</span><span class="params">(Validator addressValidator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (addressValidator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] is &quot;</span> +</span><br><span class="line">                <span class="string">&quot;required and must not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] must &quot;</span> +</span><br><span class="line">                <span class="string">&quot;support the validation of [Address] instances.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.addressValidator = addressValidator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此Validator验证Customer实例以及Customer的任何子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;surname&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> (Customer) target;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            errors.pushNestedPath(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">            ValidationUtils.invokeValidator(<span class="built_in">this</span>.addressValidator, customer.getAddress(), errors);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            errors.popNestedPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证错误被报告给传递给验证器的Errors对象。在Spring Web MVC的情况下，你可以使用&lt;spring:bind&#x2F;&gt;标签来检查错误消息，但是当然你也可以自己检查错误对象。有关其提供的方法的更多信息可以在javadoc中找到。</p>
<hr>
<h1 id="解析代码到错误消息"><a href="#解析代码到错误消息" class="headerlink" title="解析代码到错误消息"></a>解析代码到错误消息</h1><hr>
<p>我们已经讨论了数据绑定和验证。输出与验证错误相对应的消息是我们需要讨论的最后一件事。在上面显示的示例中，我们拒绝了name和age字段。如果我们要使用<strong>MessageSource</strong>输出错误消息，我们将在拒绝该字段（在这种情况下为’name’和’age’）时使用已经给出的错误代码来完成输出。当你从Errors接口调用（直接，或间接，使用例如ValidationUtils类）<strong>rejectValue</strong>或者其他<strong>reject</strong>方法之一时，底层实现将不仅注册您传递的代码，还会注册一些其他错误代码。它要注册什么错误代码由所使用的<strong>MessageCodesResolver</strong>决定。默认情况下，使用<strong>DefaultMessageCodesResolver</strong>，例如，它不仅注册了您提供的代码的消息，还包括传递给reject方法的字段名称的消息。因此，如果你使用rejectValue(“age”, “too.darn.old”)拒绝一个字段，除了too.darn.old代码之外，Spring还将注册too.darn.old.age和too.darn.old.age.int（所以第一个将包括字段名称，第二个将包括该字段的类型）;这样做是为了方便开发人员定位错误消息等。</p>
<p>有关<strong>MessageCodesResolver</strong>和默认策略的更多信息可以分别在<strong>MessageCodesResolver</strong>和<strong>DefaultMessageCodesResolver</strong>的javadoc中在线查找。</p>
<hr>
<h1 id="Bean操作和BeanWrapper"><a href="#Bean操作和BeanWrapper" class="headerlink" title="Bean操作和BeanWrapper"></a>Bean操作和BeanWrapper</h1><hr>
<p><strong>org.springframework.beans</strong>包遵循Oracle提供的JavaBeans标准。JavaBean只是一个带有默认无参构造的类，它遵循一个命名规则（作为一个例子）一个名为bingoMadness的属性会有一个setter方法setBingoMadness(..)以及一个getter方法getBingoMadness()。有关JavaBeans和规范的更多信息，请参考Oracle网站（<a href="https://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html">javabeans</a>）。</p>
<p>Bean包中的一个非常重要的类是<strong>BeanWrapper</strong>接口及其相应的实现（<strong>BeanWrapperImpl</strong>）。从javadocs引用，BeanWrapper提供了设置和获取属性值（单独或批量），获取属性描述符和查询属性以确定它们是可读写还是可写的功能。此外，<strong>BeanWrapper</strong>还提供对嵌套属性的支持，可以使子属性的属性设置为无限深度。然后，<strong>BeanWrapper</strong>支持添加标准JavaBeans <strong>PropertyChangeListeners</strong>和<strong>VetoableChangeListeners</strong>的能力，而不需要在目标类中有支持代码。最后但并非最不重要的是，BeanWrapper提供了对索引属性设置的支持。BeanWrapper通常不直接由应用程序代码使用，而是由<strong>DataBinder</strong>和<strong>BeanFactory</strong>使用。</p>
<p>BeanWrapper的工作方式部分由其名称指示：它包装一个bean以对该bean执行操作，例如设置和检索属性。</p>
<h2 id="设置和获取基本及嵌套属性"><a href="#设置和获取基本及嵌套属性" class="headerlink" title="设置和获取基本及嵌套属性"></a>设置和获取基本及嵌套属性</h2><hr>
<p>属性的设置和获取是使用**setPropertyValue(s)<strong>和</strong>getPropertyValue(s)**方法完成的，这两个方法都带有几个重载变体。它们都在Spring附带的javadocs中有更详细的描述。重要的是知道这有几个约定用于指示对象的属性。几个例子：</p>
<p><em>属性示例</em></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>name</strong></td>
<td>指示与方法getName()或isName()和setName(..)对应的属性<strong>name</strong></td>
</tr>
<tr>
<td><strong>account.name</strong></td>
<td>指示与方法getAccount().setName()或getAccount().getName()对应的属性account的嵌套属性name。</td>
</tr>
<tr>
<td><strong>account[2]</strong></td>
<td>指示索引属性<strong>account</strong>的第三个元素。索引属性可以是*array，list或其他自然排序集合类型。</td>
</tr>
<tr>
<td><strong>account[COMPANYNAME]</strong></td>
<td>指示由Map属性<strong>account</strong>的键COMPANYNAME索引的map entry的值</td>
</tr>
</tbody></table>
<p>下面你会发现一些使用<strong>BeanWrapper</strong>来获取和设置属性的例子。</p>
<p><em>（如果你不打算直接使用BeanWrapper，下一节对您来说并不重要。如果你只是使用DataBinder和BeanFactory及其开箱即用的实现，您应该跳过关于PropertyEditors的部分。）</em></p>
<p>考虑以下两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Employee managingDirector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getManagingDirector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setManagingDirector</span><span class="params">(Employee managingDirector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.managingDirector = managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">float</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码片段显示了如何检索和操作实例化的Companies和Employees的某些属性的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Company</span>());</span><br><span class="line"><span class="comment">// 设置company name..</span></span><br><span class="line">company.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line"><span class="comment">// ...也可以这样做:</span></span><br><span class="line"><span class="type">PropertyValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line">company.setPropertyValue(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的，让我们创建一个director并把它绑在company上：:</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">jim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Employee</span>());</span><br><span class="line">jim.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jim Stravinsky&quot;</span>);</span><br><span class="line">company.setPropertyValue(<span class="string">&quot;managingDirector&quot;</span>, jim.getWrappedInstance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过company检索manageDirector的salary </span></span><br><span class="line"><span class="type">Float</span> <span class="variable">salary</span> <span class="operator">=</span> (Float) company.getPropertyValue(<span class="string">&quot;managingDirector.salary&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="内置PropertyEditor实现"><a href="#内置PropertyEditor实现" class="headerlink" title="内置PropertyEditor实现"></a>内置PropertyEditor实现</h2><hr>
<p>Spring使用<strong>PropertyEditor</strong>的概念来实现<strong>Object</strong>和<strong>String</strong>之间的转换。如果你考虑到这一点,有时以一个不同的方式，而不是用对象本身来表示属性可能更为方便。例如，Date可以用人类可读的方式表示（以String ‘2007-14-09’），而我们仍然能够将人类可读的形式转换回原来的date（或甚至更好：将以人类可读形式输入的任何日期转换回Date对象）。这种行为可以通过注册<strong>java.beans.PropertyEditor</strong>类型的自定义编辑器来实现。在<strong>BeanWrapper</strong>或者在上一章中提到的特定IoC容器中注册自定义编辑器，可以了解如何将属性转换为所需类型。在Oracle提供的java.beans包的javadoc中阅读有关<strong>PropertyEditor</strong>的更多信息。</p>
<p>Spring中使用了一些属性编辑的例子：</p>
<ul>
<li>在bean上设置属性是通过使用<strong>PropertyEditor</strong>完成的。当提及的java.lang.String作为您声明在XML文件中的某个bean的属性的值时，Spring会（如果相应属性的setter具有Class参数）使用ClassEditor尝试将参数解析为一个Class对象。</li>
<li>在Spring的MVC框架中解析HTTP请求参数是使用各种<strong>PropertyEditor</strong>完成的，这些<strong>PropertyEditor</strong>可以手动绑定CommandController的所有子类。</li>
</ul>
<p>Spring有一些内置的<strong>PropertyEditor</strong>，使工作变得轻松。其中的每个都列在下面，它们都位于<strong>org.springframework.beans.propertyeditors</strong>包中。大多数但不是全部（如下所示），默认情况下由<strong>BeanWrapperImpl</strong>注册。属性编辑器可以以一些方式配置，你当然可以注册自己的变体来覆盖默认的：</p>
<p><em>内置PropertyEditors</em></p>
<table>
<thead>
<tr>
<th>Class</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayPropertyEditor</strong></td>
<td>字节数组编辑器。String将简单的转换为它们的字节表现形式。由BeanWrapperImpl默认注册</td>
</tr>
<tr>
<td><strong>ClassEditor</strong></td>
<td>解析String表示的class为实际的类和反过来也是。当没有找到这个类时，抛出IllegalArgumentException。由BeanWrapperImpl默认注册</td>
</tr>
<tr>
<td><strong>CustomBooleanEditor</strong></td>
<td>Boolean属性的可自定义属性编辑器。由BeanWrapperImpl默认注册，但是，可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><strong>CustomCollectionEditor</strong></td>
<td>Collection的属性编辑器，将任何源Collection转换为给定的目标Collection类型。</td>
</tr>
<tr>
<td><strong>CustomDateEditor</strong></td>
<td>可自定义的java.util.Date属性编辑器，支持自定义DateFormat。默认情况下未注册。必须使用适当format进行用户注册。</td>
</tr>
<tr>
<td><strong>CustomNumberEditor</strong></td>
<td>任何Number子类的可自定义属性编辑器，如Integer，Long，Float，Double。由BeanWrapperImpl默认注册，但是可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><strong>FileEditor</strong></td>
<td>能够将String解析为java.io.File对象。由BeanWrapperImpl默认注册。</td>
</tr>
<tr>
<td><strong>InputStreamEditor</strong></td>
<td>单向属性编辑器，能够获取文本字符串并生成（通过中间的ResourceEditor和Resource）InputStream，因此InputStream属性可以直接设置为String。请注意，默认使用情况不会为你关闭InputStream！由BeanWrapperImpl默认注册。</td>
</tr>
<tr>
<td><strong>LocaleEditor</strong></td>
<td>能够将String解析为Locale对象，反之亦然（String格式为[country] [variant]，这与Locale提供的toString()方法相同）。由BeanWrapperImpl默认注册。</td>
</tr>
<tr>
<td><strong>PatternEditor</strong></td>
<td>能够将String解析为java.util.regex.Pattern对象，反之亦然。</td>
</tr>
<tr>
<td><strong>PropertiesEditor</strong></td>
<td>能够转换String（使用java.util.Properties类的javadocs中定义的格式格式化）为Properties对象。由BeanWrapperImpl默认注册。</td>
</tr>
<tr>
<td><strong>StringTrimmerEditor</strong></td>
<td>修剪字符串的属性编辑器。可选的允许将空字符串转换为null值。默认情况下未注册;必须根据需要进行用户注册。</td>
</tr>
<tr>
<td><strong>URLEditor</strong></td>
<td>能够将URL的String表示形式解析为实际的URL对象。由BeanWrapperImpl默认注册。</td>
</tr>
</tbody></table>
<p>Spring使用<strong>java.beans.PropertyEditorManager</strong>设置可能需要的属性编辑器的搜索路径。搜索路径中还包括sun.bean.editors，它包括用于诸如Font，Color和大多数原始类型之类的PropertyEditor实现。还要注意的是，标准的JavaBeans基础框架会自动发现<strong>PropertyEditor</strong>类（不需要显示地注册它们），如果它们与他们处理的类在同一个包中，并且具有与该类相同的附加“Editor”的名称;例如，可能有如下类和包结构，这足以使FooEditor类被识别并用作Foo类型属性的PropertyEditor。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">  chank</span><br><span class="line">    pop</span><br><span class="line">      Foo</span><br><span class="line">      FooEditor // Foo类的PropertyEditor</span><br></pre></td></tr></table></figure>
<p>请注意，你也可以在这里使用标准的BeanInfo JavaBeans机制（<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">在这里不详细</a>的描述）。在下面的一个示例中，使用BeanInfo机制来显式注册一个或多个具有关联类的属性的PropertyEditor实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">  chank</span><br><span class="line">    pop</span><br><span class="line">      Foo</span><br><span class="line">      FooBeanInfo // Foo类的BeanInfo </span><br></pre></td></tr></table></figure>
<p>这里是被引用的FooBeanInfo类的Java源代码。这会将一个CustomNumberEditor与Foo类的age属性关联起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooBeanInfo</span> <span class="keyword">extends</span> <span class="title class_">SimpleBeanInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">PropertyEditor</span> <span class="variable">numberPE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomNumberEditor</span>(Integer.class, <span class="literal">true</span>);</span><br><span class="line">            <span class="type">PropertyDescriptor</span> <span class="variable">ageDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyDescriptor</span>(<span class="string">&quot;age&quot;</span>, Foo.class) &#123;</span><br><span class="line">                <span class="keyword">public</span> PropertyEditor <span class="title function_">createPropertyEditor</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> numberPE;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertyDescriptor</span>[] &#123; ageDescriptor &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IntrospectionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册其他自定义PropertyEditor"><a href="#注册其他自定义PropertyEditor" class="headerlink" title="注册其他自定义PropertyEditor"></a>注册其他自定义PropertyEditor</h3><p>当将bean属性设置为字符串值时，Spring IoC容器最终会使用标准的JavaBeans <strong>PropertyEditor</strong>将这些字符串转换为该属性的复杂类型。Spring预注册了一些自定义的<strong>PropertyEditor</strong>（例如，将一个字符串表达的类名转换为一个真正的Class对象）。另外，Java的标准JavaBeans <strong>PropertyEditor</strong>查找机制允许一个类的<strong>PropertyEditor</strong>只需被适当地命名，并且被放置在与它提供的类相同的包中，就会被自动找到。</p>
<p>如果需要注册其他自定义PropertyEditor，这有几种可用机制。最手动的方式，也是通常不方便或不推荐的，是只要使用<strong>ConfigurableBeanFactory</strong>接口的<strong>registerCustomEditor()<strong>方法，假设你有一个</strong>BeanFactory</strong>引用的话。另一个稍微更方便的机制就是使用一个名为<strong>CustomEditorConfigurer</strong>的特殊bean工厂的后处理器。虽然Bean工厂后处理器可以与<strong>BeanFactory</strong>实现一起使用，但<strong>CustomEditorConfigurer</strong>有一个嵌套属性设置，因此强烈建议将其与<strong>ApplicationContext</strong>一起使用，它可以与其他任何bean类似的样式被部署，并且被自动检测和应用。</p>
<p>请注意，所有bean工厂和应用程序上下文都会自动使用一些内置的属性编辑器，通过使用一些名为<strong>BeanWrapper</strong>的东西来处理属性转换。<strong>BeanWrapper</strong>注册的标准属性编辑器在上一节中都被列出。此外，<strong>ApplicationContexts</strong>还会以适合特定应用程序上下文类型的方式覆盖或添加额外数量的编辑器来处理资源查找。</p>
<p>标准JavaBeans <strong>PropertyEditor</strong>实例用于将表示为字符串的属性值转换为属性的实际复杂类型。<strong>CustomEditorConfigurer</strong>，一个bean工厂后处理器，可以用来方便地向<strong>ApplicationContext</strong>添加额外的<strong>PropertyEditor</strong>实例。</p>
<p>考虑一个用户类ExoticType，另一个类DependsOnExoticType需要ExoticType设置为一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExoticType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExoticType</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependsOnExoticType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExoticType type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(ExoticType type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这些正确设置后，我们希望能够将type属性以字符串形式分配，PropertyEditor会在后台将其转换为实际的ExoticType实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.DependsOnExoticType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aNameForExoticType&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>PropertyEditor</strong>实现可能类似于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串表示转换为ExoticType对象 </span></span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExoticTypeEditor</span> <span class="keyword">extends</span> <span class="title class_">PropertyEditorSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        setValue(<span class="keyword">new</span> <span class="title class_">ExoticType</span>(text.toUpperCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们使用<strong>CustomEditorConfigurer</strong>向<strong>ApplicationContext</strong>注册新的<strong>PropertyEditor</strong>，然后可以根据需要使用它：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customEditors&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;example.ExoticType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example.ExoticTypeEditor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用PropertyEditorRegistrars"><a href="#使用PropertyEditorRegistrars" class="headerlink" title="使用PropertyEditorRegistrars"></a>使用PropertyEditorRegistrars</h3><p>使用Spring容器注册属性编辑器的另一种机制是创建并使用<strong>PropertyEditorRegistrar</strong>。当你需要在几种不同情况下使用同一组属性编辑器时，此接口特别有用：编写一个相应的registrar并且再每种情况下重用它。<strong>PropertyEditorRegistrars</strong>与名为<strong>PropertyEditorRegistry</strong>的接口配合使用，PropertyEditorRegistry是一个由Spring BeanWrapper（和DataBinder）实现的接口。当PropertyEditorRegistrars与<strong>CustomEditorConfigurer</strong>（<a href="#%E6%B3%A8%E5%86%8C%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89PropertyEditor">这里</a>介绍）一起使用时特别方便，它暴露出一个名为setPropertyEditorRegistrars(..)的属性：以这种方式添加到CustomEditorConfigurer中的PropertyEditorRegistrars可以轻松地与DataBinder和Spring MVC Controllers共享。此外，它避免了在自定义编辑器上同步的需要：PropertyEditorRegistrar预期为每个bean的创建企图创建新的PropertyEditor实例。</p>
<p>使用PropertyEditorRegistrar或许最好通过一个例子来说明。首先，你需要创建自己的PropertyEditorRegistrar实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.foo.editors.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CustomPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title class_">PropertyEditorRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 希望将创建新的PropertyEditor实例</span></span><br><span class="line">        registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> <span class="title class_">ExoticTypeEditor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你可以在这里注册尽可能多的自定义属性编辑器...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以参阅<strong>org.springframework.beans.support.ResourceEditorRegistrar</strong>作为<strong>PropertyEditorRegistrar</strong>实现的一个示例。注意在它的registerCustomEditors(..)方法的实现中如何创建每个属性编辑器的新实例。</p>
<p>接下来，我们配置一个<strong>CustomEditorConfigurer</strong>并将我们的<strong>CustomPropertyEditorRegistrar</strong>的一个实例注入它：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyEditorRegistrars&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;customPropertyEditorRegistrar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customPropertyEditorRegistrar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;com.foo.editors.spring.CustomPropertyEditorRegistrar&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，与本章重点有所偏离，对于那些使用Spring MVC Web框架的人，使用与数据绑定的<strong>Controllers</strong>（如<strong>SimpleFormController</strong>）结合使用的<strong>PropertyEditorRegistrars</strong>非常方便。在下面的一个示例中，使用PropertyEditorRegistrar实现一个initBinder(..)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RegisterUserController</span> <span class="keyword">extends</span> <span class="title class_">SimpleFormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterUserController</span><span class="params">(PropertyEditorRegistrar propertyEditorRegistrar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            ServletRequestDataBinder binder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册用户的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种风格的PropertyEditor注册可以导致简洁的代码（initBinder(..)的实现只有一行！），并允许通用的PropertyEditor注册代码封装在一个类中，然后根据需要在多个Controller之间共享。</p>
<hr>
<h1 id="Spring类型转换"><a href="#Spring类型转换" class="headerlink" title="Spring类型转换"></a>Spring类型转换</h1><hr>
<p>Spring 3引入了一个<strong>core.convert</strong>包来提供通用的类型转换系统。该系统定义了一个SPI来实现类型转换逻辑，以及一个在运行时执行类型转换的API。在Spring容器中，该系统可以用作PropertyEditor的替代方法，将外部化的bean属性值的字符串转换为必需的属性类型。这个公共API也可以在应用程序中需要类型转换的任何地方使用。</p>
<h2 id="Converter-SPI"><a href="#Converter-SPI" class="headerlink" title="Converter SPI"></a>Converter SPI</h2><hr>
<p>SPI实现类型转换逻辑是简单和强类型的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(S source)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要创建自己的转换器，只需实现上面的接口。参数化S作为你需要转换的类型，而T是你要转换为的类型。如果需要将S的集合或数组转换为T的数组或集合，则这种转换器也可以透明地应用，前提是已经注册了一个委托array&#x2F;collection转换器（默认情况下是DefaultConversionService）。</p>
<p>对于<strong>convert(S)<strong>的每个调用，源参数保证不为null。如果转换失败，转换器可能会抛出任何未经检查的异常;具体来说，应该抛出一个</strong>IllegalArgumentException</strong>来报告一个无效的源值。注意确保你的<strong>Converter</strong>实现是线程安全的。</p>
<p>为方便起见，在<strong>core.convert.support</strong>包中提供了几个转换器实现。这些包括从Strings到Numbers和其他常见类型的转换器。考虑<strong>StringToInteger</strong>作为典型的Converter实现的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(S source)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h2><hr>
<p>当您需要集中整个类层次结构的转换逻辑时，例如，当从String转换为java.lang.Enum对象时，实现<strong>ConverterFactory</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConverterFactory</span>&lt;S, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">R</span>&gt; Converter&lt;S, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数化S是你需要转换的类型，R为定义您转换为类的范围的基本类型。然后实现**getConverter(Class &lt;T&gt;)**，其中T是R的子类。</p>
<p>以<strong>StringToEnum</strong> ConverterFactory为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringToEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title class_">ConverterFactory</span>&lt;String, Enum&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&gt; Converter&lt;String, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringToEnumConverter</span>(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringToEnumConverter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&gt; <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Class&lt;T&gt; enumType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StringToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.enumType = enumType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Enum.valueOf(<span class="built_in">this</span>.enumType, source.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GenericConverter"><a href="#GenericConverter" class="headerlink" title="GenericConverter"></a>GenericConverter</h2><hr>
<p>当你需要一个复杂的<strong>Converter</strong>实现时，请考虑<strong>GenericConverter</strong>接口。<strong>GenericConverter</strong>具有更灵活但不太强的类型签名，支持在多种源和目标类型之间进行转换。此外，<strong>GenericConverter</strong>可以提供源和目标字段的上下文，这样你可以在实现转换逻辑时使用。这种上下文允许类型转换由字段注解或在字段签名上声明的泛型信息来驱动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现GenericConverter，getConvertibleTypes()返回支持的源→目标类型对。然后实现convert(Object，TypeDescriptor，TypeDescriptor)来实现你的转换逻辑。转换源的TypeDescriptor提供对持有正在转换的值的转换源字段的访问。转换目标的TypeDescriptor提供对会被设置转换后值的目标字段的访问。</p>
<p>GenericConverter是转换器的一个很好的例子是在Java Array和Collection之间进行转换。这样的ArrayToCollectionConverter会内省声明目标Collection类型的字段，来解析Collection的元素类型。这将允许源数组中的每个元素在Collection被设置在目标字段上之前转换为Collection元素类型。</p>
<blockquote>
<p>因为GenericConverter是一个更复杂的SPI接口，只有当您需要它时才可以使用它。Favor Converter或ConverterFactory用于基本类型转换的需要。</p>
</blockquote>
<h3 id="ConditionalGenericConverter"><a href="#ConditionalGenericConverter" class="headerlink" title="ConditionalGenericConverter"></a>ConditionalGenericConverter</h3><p>有时候，你只想在指定条件成立时，才执行<strong>Converter</strong>。例如，你可能只想在目标字段上存在特定注解的时候，才执行一个<strong>Converter</strong>。或者你可能只想如果在目标类上定义了一个特定的方法，例如<strong>static valueOf</strong>方法，才执行一个<strong>Converter</strong>。<strong>ConditionalGenericConverter</strong>是<strong>GenericConverter</strong>和<strong>ConditionalConverter</strong>接口的组合，允许您定义这样的自定义匹配条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConditionalConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConditionalGenericConverter</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">GenericConverter</span>, ConditionalConverter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConditionalGenericConverter</strong>的一个很好的例子是EntityConverter，它在持久性实体标识符和实体引用之间进行转换。这样一个EntityConverter只有如果目标实体类型声明一个静态的finder方法，如findAccount(Long)，才会匹配。你会在matches(TypeDescriptor,TypeDescriptor)的实现中执行这样的finder方法检查。</p>
<h2 id="ConversionService-API"><a href="#ConversionService-API" class="headerlink" title="ConversionService API"></a>ConversionService API</h2><hr>
<p>ConversionService定义了一个统一的在运行时执行类型转换逻辑的API。Converters 通常在这个正面接口后面执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConversionService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数ConversionService实现还实现了ConverterRegistry，它提供了一个用于注册转换器的SPI。在内部，ConversionService的实现委托给它注册的转换器来执行类型转换逻辑。</p>
<p><strong>core.convert.support</strong>包中提供了一个强大的ConversionService实现。<strong>GenericConversionService</strong>是适用于大多数环境的通用实现。<strong>ConversionServiceFactory</strong>为创建通用的<strong>ConversionService</strong>配置提供了便利的工厂。</p>
<h2 id="配置ConversionService"><a href="#配置ConversionService" class="headerlink" title="配置ConversionService"></a>配置ConversionService</h2><hr>
<p>ConversionService是一种无状态对象，并且被设计为在应用程序启动时实例化，然后在多个线程之间共享。在Spring应用程序中，你通常为每个Spring容器（或ApplicationContext）配置一个ConversionService实例。这个ConversionService将被Spring采用，然后在框架需要执行类型转换时使用。你也可以将此ConversionService注入任何你的bean中，并直接调用。</p>
<blockquote>
<p>如果没有向Spring注册ConversionService，则使用原始的基于PropertyEditor的系统。</p>
</blockquote>
<p>要在Spring中注册默认的ConversionService，请使用id conversionService添加以下bean定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认的ConversionService可以在字符串，数字，枚举，集合，map和其他常见类型之间进行转换。要使用你自己的自定义转换器补充或覆盖默认的转换器，设置<strong>converters</strong>属性。属性值可以实现Converter，ConverterFactory或GenericConverter接口之一。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.MyCustomConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Spring MVC应用程序中使用ConversionService也很常见。参见Spring MVC章节的<a href="">第16.3节“转换和格式化”</a>。</p>
<p>在某些情况下，您可能希望在转换期间应用格式化。有关使用<strong>FormattingConversionServiceFactoryBean</strong>的详细信息，请参见[第6.3节“FormatterRegistry SPI”](#FormatterRegistry SPI)。</p>
<h2 id="编程式使用ConversionService"><a href="#编程式使用ConversionService" class="headerlink" title="编程式使用ConversionService"></a>编程式使用ConversionService</h2><hr>
<p>要以编程方式使用ConversionService实例，只需像其他bean那样注入它的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(ConversionService conversionService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conversionService.convert(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于大多数用例，可以使用指定targetType的<strong>convert</strong>方法，但它不适用于更复杂的类型，例如参数化元素的集合。如果你想编程式的将一个Integer的List转换为一个String的List，你需要提供源和目标类型的正式定义。</p>
<p>幸运的是，<strong>TypeDescriptor</strong>提供了各种各样的选项，使之简单化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultConversionService</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConversionService</span>();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; input = ....</span><br><span class="line">cs.convert(input,</span><br><span class="line">    TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt;类型描述符</span></span><br><span class="line">    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</span><br></pre></td></tr></table></figure>
<p>请注意，DefaultConversionService会自动注册适用于大多数环境的转换器。这包括集合转换器，scalar 转换器以及基本的Object到String转换器。可以使用DefaultConversionService类上的静态addDefaultConverters方法向任何ConverterRegistry注册相同的转换器。</p>
<p>值类型转换器会被重用于数组和集合，所以不需要创建溢恶特定的转换器来将S的Collection转换为T的Collection，假如标准集合处理合适的话。</p>
<hr>
<h1 id="Spring字段格式化"><a href="#Spring字段格式化" class="headerlink" title="Spring字段格式化"></a>Spring字段格式化</h1><hr>
<p>如上一节所述，<strong>core.convert</strong>是一个通用类型转换系统。它提供了一个统一的ConversionService API以及一个强类型Converter SPI，用于实现从一种类型到另一种类型的转换逻辑。Spring容器使用此系统绑定bean属性值。此外，Spring表达式语言（Spel）和DataBinder都使用此系统绑定字段值。例如，当SpEL需要强转一个Short为Long来完成一个<strong>expression.setValue(Object bean，Object value)<strong>尝试时，</strong>core.convert</strong>系统执行此强转。</p>
<p>现在考虑一个典型的客户端环境（如Web或桌面应用程序）的类型转换要求。在这样的环境中，你通常会从String转换为支持客户端回发过程，以及转回到String以支持视图渲染过程。此外，你经常需要本地化String值。更通用的core.convert Converter SPI不能直接解决这种格式化要求。为了直接解决它们，Spring 3引入了一个方便的Formatter SPI，为客户端环境提供了一个简单而强大的PropertyEditor替代方案。</p>
<p>一般来说，当需要实现通用类型转换逻辑时，使用Converter SPI ;例如，用于在java.util.Date和java.lang.Long之间进行转换。当您在客户端环境（如Web应用程序）中工作，并且需要解析和打印本地化的字段值时，请使用Formatter SPI。</p>
<h2 id="Formatter-SPI"><a href="#Formatter-SPI" class="headerlink" title="Formatter SPI"></a>Formatter SPI</h2><hr>
<p>Formatter SPI实现字段格式化逻辑是简单和强类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Formatter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Printer</span>&lt;T&gt;, Parser&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Formatter继承自Printer和Parser 构建块接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span>&lt;T&gt; &#123;</span><br><span class="line">    String <span class="title function_">print</span><span class="params">(T fieldValue, Locale locale)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Parser</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要创建你自己的Formatter，只需实现上面的Formatter接口。将参数化T是要格式化的对象的类型，例如java.util.Date。实现print()操作来打印T的示例以显示在客户端语言环境中显示。实现parse()操作来从客户端语言环境返回的格式化表现形式中解析出T的一个实例。如果解析尝试失败，你的Formatter应抛出ParseException或IllegalArgumentException异常。注意确保您的Formatter实现是线程安全的。</p>
<p>为方便起见，<strong>format</strong>子包中提供了几个Formatter实现。<strong>number</strong>包提供一个<strong>NumberFormatter</strong>,<strong>CurrencyFormatter</strong>,和<strong>PercentFormatter</strong>使用<strong>java.text.NumberFormat</strong>来格式化<strong>java.lang.Number</strong>对象。<strong>datetime</strong>包提供一个<strong>DateFormatter</strong>使用<strong>java.text.DateFormat</strong>来格式化<strong>java.util.Date</strong>对象。<strong>datetime.joda</strong>包基于Joda Time库提供完整的datetime格式支持。</p>
<p>考虑<strong>DateFormatter</strong>作为一个<strong>Formatter</strong>实现的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format.datetime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DateFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateFormatter</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(Date date, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (date == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat(locale).format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String formatted, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">if</span> (formatted.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getDateFormat(locale).parse(formatted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> DateFormat <span class="title function_">getDateFormat</span><span class="params">(Locale locale)</span> &#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="built_in">this</span>.pattern, locale);</span><br><span class="line">        dateFormat.setLenient(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> dateFormat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring团队欢迎社区推动Formatter的贡献;见<a href="https://jira.spring.io/browse/SPR">jira.spring.io</a>贡献。</p>
<h2 id="注解驱动的格式化"><a href="#注解驱动的格式化" class="headerlink" title="注解驱动的格式化"></a>注解驱动的格式化</h2><hr>
<p>如你所见，现字段格式化可以通过字段类型或注解进行配置。要将注解绑定到formatter，请实现AnnotationFormatterFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnnotationFormatterFactory</span>&lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</span><br><span class="line"></span><br><span class="line">    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数化A是你想要将格式化逻辑相关联的字段annotationType，例如，org.springframework.format.annotation.DateTimeFormat。getFieldTypes()返回可以使用注解的字段类型。getPrinter()返回一个要打印注解字段的值的Printer。getParser()返回一个用来解析注解字段的clientValue的Parser 。</p>
<p>下面AnnotationFormatterFactory实现的示例将@NumberFormat注解绑定到一个格式化器上。此注解允许指定数字样式或模式样式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NumberFormatAnnotationFormatterFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">AnnotationFormatterFactory</span>&lt;NumberFormat&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Class&lt;?&gt;&gt;(asList(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;</span><br><span class="line">            Short.class, Integer.class, Long.class, Float.class,</span><br><span class="line">            Double.class, BigDecimal.class, BigInteger.class &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Printer&lt;Number&gt; <span class="title function_">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Parser&lt;Number&gt; <span class="title function_">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title function_">configureFormatterFrom</span><span class="params">(NumberFormat annotation,</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; fieldType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!annotation.pattern().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NumberFormatter</span>(annotation.pattern());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Style</span> <span class="variable">style</span> <span class="operator">=</span> annotation.style();</span><br><span class="line">            <span class="keyword">if</span> (style == Style.PERCENT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PercentFormatter</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == Style.CURRENCY) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CurrencyFormatter</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NumberFormatter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要触发格式化，只需使用@NumberFormat注解字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NumberFormat(style=Style.CURRENCY)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal decimal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格式化注解API"><a href="#格式化注解API" class="headerlink" title="格式化注解API"></a>格式化注解API</h3><p><strong>org.springframework.format.annotation</strong>包中有一个易移植的格式注解API。使用**@NumberFormat<strong>格式化</strong>java.lang.Number<strong>字段。使用</strong>@DateTimeFormat<strong>格式化</strong>java.util.Date<strong>，</strong>java.util.Calendar<strong>，</strong>java.util.Long**，或Joda Time字段。</p>
<p>下面的示例使用**@DateTimeFormat**将java.util.Date格式化为ISO日期（yyyy-MM-dd）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat(iso=ISO.DATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FormatterRegistry-SPI"><a href="#FormatterRegistry-SPI" class="headerlink" title="FormatterRegistry SPI"></a>FormatterRegistry SPI</h2><hr>
<p><strong>FormatterRegistry</strong>是用于注册格式化器和转换器的SPI。<br><strong>FormattingConversionService</strong>是一个适用于大多数环境的FormatterRegistry的实现。这个实现可以编程式或使用<strong>FormattingConversionServiceFactoryBean</strong>声明为一个Spring bean来配置。由于此实现还实现了<strong>ConversionService</strong>，因此可以直接配置为与Spring的<strong>DataBinder</strong>和<strong>Spring Expression Language（Spel）</strong>配合使用。</p>
<p>请查看下面的FormatterRegistry SPI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title class_">ConverterRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，可以通过fieldType或注解注册Formatter。</p>
<p>FormatterRegistry SPI允许你集中配置格式化规则，而不是在你的Controller上复制此类配置。例如，你可能想要强制所有的Date字段以某种方式格式化；或带有指定注解的字段以某种方式格式化。使用一个共享的FormatterRegistry，你可以一次性定义这些规则，并且在需要格式化时应用它们。</p>
<h2 id="FormatterRegistrar-SPI"><a href="#FormatterRegistrar-SPI" class="headerlink" title="FormatterRegistrar SPI"></a>FormatterRegistrar SPI</h2><hr>
<p><strong>FormatterRegistrar</strong>是一个通过<strong>FormatterRegistry</strong>注册格式化器和转换器的SPI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FormatterRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerFormatters</span><span class="params">(FormatterRegistry registry)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为一个给定的格式化类别（如Date格式化）注册多个相关的转换器和格式化器时，FormatterRegistrar很有用。在声明性注册不足够的情况下也是有用的。例如，当一个格式化器需要在与其自己的<T>不同的特定字段类型下索引时，或者在注册 Printer&#x2F;Parser对时进行索引。下一节提供有关下一节提供有关转换器和格式化器注册的更多信息。</p>
<h2 id="在Spring-MVC中配置格式化"><a href="#在Spring-MVC中配置格式化" class="headerlink" title="在Spring MVC中配置格式化"></a>在Spring MVC中配置格式化</h2><hr>
<p>参见Spring MVC章节的<a href="#">第16.3节“转换和格式化”</a>。</p>
<hr>
<h1 id="配置全局日期和时间格式"><a href="#配置全局日期和时间格式" class="headerlink" title="配置全局日期和时间格式"></a>配置全局日期和时间格式</h1><hr>
<p>默认情况下，未使用**@DateTimeFormat<strong>注解的日期和时间字段使用</strong>DateFormat.SHORT**样式从字符串转换。如果你愿意，你可以通过定义你自己的全局格式化来改变。</p>
<p>你将需要确保Spring不注册默认格式化器，而应手动注册所有格式化器。根据您是否使用Joda Time库，使用<strong>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</strong>或<strong>org.springframework.format.datetime.DateFormatterRegistrar</strong>类。</p>
<p>例如，以下Java配置会注册一个全局“yyyyMMdd”格式。此示例不依赖于Joda Time库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FormattingConversionService <span class="title function_">conversionService</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用DefaultFormattingConversionService，但不要注册默认值</span></span><br><span class="line">        <span class="type">DefaultFormattingConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFormattingConversionService</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保@NumberFormat仍然受支持</span></span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> <span class="title class_">NumberFormatAnnotationFormatterFactory</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用指定的全局格式注册日期转换</span></span><br><span class="line">        <span class="type">DateFormatterRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateFormatterRegistrar</span>();</span><br><span class="line">        registrar.setFormatter(<span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您喜欢基于XML的配置，你可以使用FormattingConversionServiceFactoryBean。这是同一个的例子，这次使用Joda Time：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;bean id=&quot;</span><span class="attr">conversionService</span>&quot; <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;registerDefaultFormatters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatterRegistrars&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormatter&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyyMMdd&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Joda Time提供单独的不同类型来表示date,time和date-time值。JodaTimeFormatterRegistrar的dateFormatter, timeFormatter和dateTimeFormatter属性应该用来配置每个类型的不同格式。DateTimeFormatterFactoryBean提供了一种便捷的方式来创建格式化器。</p>
</blockquote>
<p>如果你使用Spring MVC，请记住要显示配置所使用的 conversion service。对于基于Java的@Configuration，这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法。对于XML，你应该使用mvc:annotation-driven元素的’conversion-service’属性。更多细节参见Spring MVC章节的<a href="#">第16.3节“转换和格式化”</a>。</p>
<hr>
<h1 id="Spring-验证"><a href="#Spring-验证" class="headerlink" title="Spring 验证"></a>Spring 验证</h1><hr>
<p>Spring 3对其验证支持进行了几个增强。首先，现在已经完全支持JSR-303 Bean Validation API。其次，当使用编程方式时，Spring的<strong>DataBinder</strong>现在可以验证对象并且绑定到它们。第三，Spring MVC现在支持声明性地验证**@Controller**输入。</p>
<h2 id="JSR-303-Bean-Validation-API概述"><a href="#JSR-303-Bean-Validation-API概述" class="headerlink" title="JSR-303 Bean Validation API概述"></a>JSR-303 Bean Validation API概述</h2><hr>
<p>JSR-303标准化Java平台的验证约束声明和元数据。使用此API，您可以使用声明性验证约束来注解域模型属性，并且运行时会强制执行它们。这有一些你可以利用的内置约束。你也可以定义自己的自定义约束。</p>
<p>为了说明，考虑一个简单的有两个属性的PersonForm模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSR-303允许您针对这些属性定义声明性的验证约束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当此类的实例由JSR-303 Validator验证时，这些约束将被强制执行。</p>
<p>有关JSR-303&#x2F;JSR-349的一般信息，请参阅<a href="http://beanvalidation.org/"> Bean Validation website</a>。有关默认引用实现的具体功能的信息，请参阅<a href="https://www.hibernate.org/412.html">Hibernate Validator</a>文档。要了解如何将Bean Validation  provider设置为Spring bean，请继续阅读。</p>
<h2 id="配置一个Bean-Validation-Provider"><a href="#配置一个Bean-Validation-Provider" class="headerlink" title="配置一个Bean Validation Provider"></a>配置一个Bean Validation Provider</h2><hr>
<p>Spring提供对Bean Validation Provider的全面支持。这还包含对将JSR-303&#x2F;JSR-349 Bean Validation provider 作为Spring bean引导的便捷支持。这允许将<strong>javax.validation.ValidatorFactory</strong>或<strong>javax.validation.Validator</strong>注入到你的应用程序需要验证的地方。</p>
<p>使用<strong>LocalValidatorFactoryBean</strong>以Spring bean形式配置一个默认的Validator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;validator&quot;</span></span><br><span class="line">    class=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>上述基本配置将触发Bean Validation，使用它的默认引导机制进行初始化。这期望一个JSR-303&#x2F;JSR-349提供商，如Hibernate Validator存在于类路径中，它会被自动探测到。</p>
<h3 id="注入一个Validator"><a href="#注入一个Validator" class="headerlink" title="注入一个Validator"></a>注入一个Validator</h3><p><strong>LocalValidatorFactoryBean</strong>实现了<strong>javax.validation.ValidatorFactory</strong>和<strong>javax.validation.Validator</strong>，以及Spring的<strong>org.springframework.validation.Validator</strong>。你可以将这些接口中的任一个注入到需要调用验证逻辑的bean中。</p>
<p>如果您喜欢直接使用Bean Validation API，请注入javax.validation.Validator的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br></pre></td></tr></table></figure>
<p>如果您的bean需要Spring Validation API，请注入对org.springframework.validation.Validator的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h3><p>每个Bean Validation约束由两部分组成。第一，一个声明约束及其可配置属性的@Constraint注解。第二，实现约束行为的<strong>javax.validation.ConstraintValidator</strong>接口的实现。要将声明与实现相关联，每个@Constraint注解引用相应的ValidationConstraint实现类。在运行时期，当你的域模型中遇到约束注解时，ConstraintValidatorFactory实例化这个引用的实现。</p>
<p>默认情况下，LocalValidatorFactoryBean配置一个使用Spring创建ConstraintValidator实例的SpringConstraintValidatorFactory。这允许您的自定义ConstraintValidator像其他Spring bean一样，从依赖注入中受益。</p>
<p>下面显示了一个自定义@Constraint声明的例子，后跟一个使用Spring进行依赖注入的相关联的ConstraintValidator实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy=MyConstraintValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConstraint &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>;</span><br><span class="line">    <span class="keyword">private</span> Foo aDependency;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，ConstraintValidator实现可以像其他任何Spring bean一样，有它自己的依赖@Autowired。</p>
<h3 id="Spring驱动的方法验证"><a href="#Spring驱动的方法验证" class="headerlink" title="Spring驱动的方法验证"></a>Spring驱动的方法验证</h3><p>方法验证功能由Bean Validation 1.1支持，并且作为Hibernate Validator 4.3的自定义扩展，可以通过MethodValidationPostProcessor bean定义将其集成到Spring上下文中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="额外的配置选项"><a href="#额外的配置选项" class="headerlink" title="额外的配置选项"></a>额外的配置选项</h3><p>对于大多数情况，默认的<strong>LocalValidatorFactoryBean</strong>配置应该足够。这有各种Bean Validation结构的配置选项，从消息插入到遍历解析。有关这些选项的更多信息，请参阅<strong>LocalValidatorFactoryBean</strong> javadocs。</p>
<h2 id="配置DataBinder"><a href="#配置DataBinder" class="headerlink" title="配置DataBinder"></a>配置DataBinder</h2><hr>
<p>从Spring 3起，可以使用Validator来配置DataBinder实例。一旦配置，可以通过调用binder.validate()来调用Validator。任何验证Errors都会自动添加到binder的BindingResult中。</p>
<p>以编程方式使用DataBinder时，可以在绑定到目标对象之后调用验证逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(target);</span><br><span class="line">binder.setValidator(<span class="keyword">new</span> <span class="title class_">FooValidator</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到target对象</span></span><br><span class="line">binder.bind(propertyValues);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证target对象</span></span><br><span class="line">binder.validate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取包含任何验证错误的BindingResult</span></span><br><span class="line"><span class="type">BindingResult</span> <span class="variable">results</span> <span class="operator">=</span> binder.getBindingResult();</span><br></pre></td></tr></table></figure>
<p>DataBinder还可以通过<strong>dataBinder.addValidators</strong>和<strong>dataBinder.replaceValidators</strong>配置多个<strong>Validator</strong>实例。当将全局配置的Bean Validation与在DataBinder实例上本地配置的Spring Validator 组合时，此功能非常有用。见???</p>
<h2 id="Spring-MVC-3验证"><a href="#Spring-MVC-3验证" class="headerlink" title="Spring MVC 3验证"></a>Spring MVC 3验证</h2><hr>
<p>参见Spring MVC章节的<a href="">第16.4节“验证”</a>。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java Servlet</title>
    <url>/2017/06/21/java-Servlet/</url>
    <content><![CDATA[<p><a href="https://docs.oracle.com/javaee/7/tutorial/servlets.htm#BNAFD">原文链接：</a><br>Java Servlet技术使用请求 - 响应编程模型在Web应用程序中提供动态的面向用户的内容。</p>
<hr>
<h1 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet?"></a>什么是Servlet?</h1><hr>
<p>　　servlet是Java编程语言中的类，它用于扩展托管那些使用请求 - 响应编程模型来访问的应用程序的服务器的功能。虽然servlet可以响应任何类型的请求，但它们通常用于扩展由Web服务器托管的应用程序。对于这样的应用程序，Java Servlet技术定义了HTTP特定的servlet类。<br>　　<em>javax.servlet</em> 和 <em>javax.servlet.http</em> 包提供用于编写servlet的接口和类。所有servlet都必须实现<strong>Servlet</strong>接口，它定义了生命周期方法。实现通用服务时，你可以使用或继承Java Servlet API提供的<strong>GenericServlet</strong>类。而<strong>HttpServlet</strong>类提供了诸如<strong>doGet</strong>和<strong>doPost</strong>等方法来处理特定于HTTP的服务。  </p>
<span id="more"></span>
<hr>
<h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><hr>
<p>servlet的生命周期由其部署在的容器来控制。当请求映射到servlet时，容器将执行以下步骤。<br>1.	如果servlet的实例不存在，则Web容器：<br>    a)	加载servlet类<br>    b)	创建servlet类实例<br>    c)	通过调用init方法来初始化servlet实例(<a href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAServlet">创建并初始化一个Servlet</a>)<br>2.	容器调用service方法，传递request和response对象。service方法在[ 编写Service方法](# 编写Service方法)中讨论。</p>
<p>如果需要移除servlet，容器通过调用servlet的<strong>destroy</strong>方法来最终回收servlet。有关更多信息，请参阅[ 终结一个Servlet](# 终结一个Servlet)。</p>
<h2 id="处理Servlet生命周期事件"><a href="#处理Servlet生命周期事件" class="headerlink" title="处理Servlet生命周期事件"></a>处理Servlet生命周期事件</h2><hr>
<p>　　你可以通过定义监听器对象来监听和响应servlet的生命周期事件，该监听器对象的方法会在servlet生命周期事件发生时被调用。要使用这些监听器对象，必须定义并指定监听器类。</p>
<h3 id="定义监听器类"><a href="#定义监听器类" class="headerlink" title="定义监听器类"></a>定义监听器类</h3><p>　　你定义了一个监听器类作为listener接口的实现。下表列举了可以被监听的事件，以及必须实现的对应接口。当调用一个监听器方法时，它传递会一个包含与事件相关的信息的事件。例如，一个<strong>HttpSessionEvent</strong>会被传递给在<strong>HttpSessionListener</strong>接口中的方法，<strong>HttpSessionEvent</strong>包含了一个HttpSession Servlet生命周期事件</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Event</th>
<th>Listener Interface and Event Class</th>
</tr>
</thead>
<tbody><tr>
<td>Web context</td>
<td>初始化和销毁</td>
<td>javax.servlet.ServletContextListener<br/>ServletContextEvent</td>
</tr>
<tr>
<td>Web context</td>
<td>属性添加，删除或替换</td>
<td>javax.servlet.ServletContextAttributeListener<br/>ServletContextAttributeEvent</td>
</tr>
<tr>
<td>Session</td>
<td>创建，失效，激活，钝化和超时</td>
<td>javax.servlet.http.HttpSessionListener<br/>javax.servlet.http.HttpSessionActivationListener<br/>HttpSessionEvent</td>
</tr>
<tr>
<td>Session</td>
<td>属性添加，删除或替换</td>
<td>javax.servlet.http.HttpSessionAttributeListenerr<br/>HttpSessionBindingEvent</td>
</tr>
<tr>
<td>Request</td>
<td>web组件开始处理servlet请求</td>
<td>javax.servlet.ServletRequestListener<br/>ServletRequestEvent</td>
</tr>
<tr>
<td>Request</td>
<td>属性添加，删除或替换</td>
<td>javax.servlet.ServletRequestAttributeListener<br/>ServletRequestAttributeEvent</td>
</tr>
</tbody></table>
<p>使用@WebListener注解来定义一个监听器，来获取特定Web应用程序中context。用@WebListener注解的类必须实现以下接口之一：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.servlet.ServletContextListener  </span><br><span class="line">javax.servlet.ServletContextAttributeListener   </span><br><span class="line">javax.servlet.ServletRequestListener  </span><br><span class="line">javax.servlet.ServletRequestAttributeListener  </span><br><span class="line">javax.servlet..http.HttpSessionListener  </span><br><span class="line">javax.servlet..http.HttpSessionAttributeListener  </span><br></pre></td></tr></table></figure>
<p>例如，以下代码片段定义了一个实现其中两个接口的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeListener;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServletListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>,</span><br><span class="line">        ServletContextAttributeListener &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="处理Servlet错误"><a href="#处理Servlet错误" class="headerlink" title="处理Servlet错误"></a>处理Servlet错误</h2><hr>
<p>当servlet执行时，可能会发生任何一个异常。发生异常时，Web容器生成一个包含以下消息的默认页面：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Servlet Exception Has Occurred  </span><br></pre></td></tr></table></figure>
<p>但是你也可以指定容器应该返回给定异常的特定错误页面。</p>
<h1 id="共享信息"><a href="#共享信息" class="headerlink" title="共享信息"></a>共享信息</h1><p>Web组件与大多数对象一样，通常可以与其他对象一起工作来完成任务。 Web组件可以通过执行以下操作来实现。  </p>
<ul>
<li>使用私有帮助对象(例如，JavaBeans组件)。</li>
<li>共享作为公共域属性的对象。</li>
<li>使用数据库</li>
<li>调用其他web资源。Java Servlet 技术机制允许一个web组件调用其他的web资源。(在Invoking Other Web Resources有讲述)</li>
</ul>
<h2 id="使用域对象"><a href="#使用域对象" class="headerlink" title="使用域对象"></a>使用域对象</h2><hr>
<p>协作的web组件通过作为四个作用域对象属性的对象来共享信息。你可以使用表示域的类的getAttribute和setAttribute方法来访问这些属性。下表列举了这些域对象。  </p>
<table>
<thead>
<tr>
<th>Scope Object</th>
<th>Class</th>
<th>Accessible From</th>
</tr>
</thead>
<tbody><tr>
<td>Web context</td>
<td>javax.servlet.ServletContext</td>
<td>web上下文中的web组件。</td>
</tr>
<tr>
<td>Session</td>
<td>javax.servlet.http.HttpSession</td>
<td>web组件处理一个属于session的请求。</td>
</tr>
<tr>
<td>Request</td>
<td>Subtype of javax.servlet.ServletRequest</td>
<td>Web组件处理请求。</td>
</tr>
<tr>
<td>Page</td>
<td>javax.servlet.jsp.JspContext</td>
<td>创建对象的JSP页面。</td>
</tr>
</tbody></table>
<h2 id="控制共享资源并发访问"><a href="#控制共享资源并发访问" class="headerlink" title="控制共享资源并发访问"></a>控制共享资源并发访问</h2><p>　　在多线程服务器中，可以并发访问共享资源。除了范围对象属性之外，共享资源还包括内存中的数据，例如实例或类变量，以及外部对象，如文件，数据库连接和网络连接。<br>并发访问可能会在几种情况下出现。</p>
<ul>
<li>多个Web组件访问存储在Web上下文中的对象。</li>
<li>多个Web组件访问存储在session中的对象。</li>
<li>Web组件中的多个线程访问变量实例。Web容器通常会为每一个请求创建一个线程来处理。为了确保servlet实例一次只处理一个请求，servlet可以实现SingleThreadModel接口。如果一个servlet实现了这个接口，那么在servlet的service方法中并不会同时执行两个线程。Web容器可以通过同步对servlet的单个实例的访问或通过维护Web组件实例池并将每个新请求分派到空闲实例来实现此保证。此接口不会阻止Web组件访问共享资源(如静态类变量或外部对象)导致的同步问题。</li>
</ul>
<p>　　当资源可以同时访问时，它们可以以不一致的方式使用。你可以通过使用 <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/">http://docs.oracle.com/javase/tutorial/essential/concurrency/</a> 中的线程课程中描述的同步技术来控制访问来防止这种情况。</p>
<hr>
<h1 id="创建并初始化一个Servlet"><a href="#创建并初始化一个Servlet" class="headerlink" title="创建并初始化一个Servlet"></a>创建并初始化一个Servlet</h1><hr>
<p>　　在Web应用程序使用**@WebServlet<strong>注解来定义一个servlet组件。此注解在一个类上指定，并包含有关正在声明的servlet的元数据。注解的servlet必须至少指定一个URL模式。这可以通过在注解上使用</strong>urlPatterns<strong>或</strong>value<strong>属性来完成。所有其他属性都是可选的，都有默认设置。当注解唯一的属性是URL时，使用value属性。否则，当使用其他属性时，使用</strong>urlPatterns**属性。</p>
<p>使用**@WebServlet<strong>注解的类必须继承</strong>javax.servlet.http.HttpServlet<strong>类。例如，以下代码片段使用URL模式</strong>&#x2F;report**定义了一个servlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/report&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoodServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>　　Web容器在加载和实例化servlet类之后，客户端递送请求之前初始化一个servlet。要自定义这个过程以允许servlet能读取持久配置数据，初始化资源并执行任何其他一次性活动，你可以重写<strong>Servlet</strong>接口的<strong>init</strong>方法，也可以指定**@WebServlet<strong>注解的</strong>initParams<strong>属性。</strong>initParams<strong>属性包含</strong>@WebInitParam<strong>注解。如果无法完成初始化过程，则servlet会抛出一个</strong>UnavailableException**。</p>
<p>　　使用一个初始化参数来提供特定的servlet所需的数据。相比之下，上下文参数提供了所有Web应用程序组件都可用的数据。</p>
<hr>
<h1 id="编写Service方法"><a href="#编写Service方法" class="headerlink" title="编写Service方法"></a>编写Service方法</h1><hr>
<p>　　Servlet提供的service在<strong>GenericServlet</strong>的<strong>service</strong>方法中，在<strong>HttpServlet</strong>对象的<strong>doMethod</strong>方法(Method可以是Get，Delete，Options，Post，Put或Trace中的一个)，或者由实现Servlet接口的类中定义的任何其他特定协议方法中来实现。术语<strong>service方法</strong>用于servlet中用来给客户端提供服务的任何方法来。service方法的一般模式是从请求中提取信息，访问外部资源，然后根据该信息填充响应。对于HTTP servlet，填写响应的正确过程是执行以下操作：<br>1.	从response中获取一个输出流<br>2.	填写响应头<br>3.	在输出流中写入主体内容</p>
<p>　　在提交响应之前，必须始终设置响应头。Web容器将在响应提交后忽略任何设置或添加头信息的尝试。接下来的两节介绍如何从请求中获取信息并生成响应。</p>
<h2 id="从请求中获取信息"><a href="#从请求中获取信息" class="headerlink" title="从请求中获取信息"></a>从请求中获取信息</h2><hr>
<p>　　request包含在客户端和servlet之间传递的数据。所有的请求都实现了ServletRequest接口。该接口定义了访问以下信息的方法：</p>
<ul>
<li>参数，通常用于在客户端和servlet之间传递信息</li>
<li>对象值属性，通常用于在Web容器和servlet之间或协作servlet之间传递信息</li>
<li>关于用于通信请求的协议以及涉及到客户端和服务器的请求的信息</li>
<li>与本地化有关的信息</li>
</ul>
<p>　　你还可以从request中检索输入流，并手动解析数据。要想读取字符数据，使用由request的<strong>getReader</strong>方法返回的<strong>BufferedReader</strong>对象。要想读取二进制数据，使用<strong>getInputStream</strong>方法返回的<strong>ServletInputStream</strong>对象。</p>
<p>　　HTTP servlet传入一个HTTP request对象，<strong>HttpServletRequest</strong>，它包含了请求的URL，HTTP头，查询字符串，等等。一个HTTP 请求URL包好一下部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://[host]:[port][request-path]?[query-string]</span><br></pre></td></tr></table></figure>
<p>请求路径(request-path)进一步由以下元素组成。</p>
<ul>
<li><strong>Context Path</strong>：由一个正斜杠(&#x2F;)与servlet的web程序的根contenxt连接</li>
<li><strong>Servlet path</strong>：与激活此请求的组件别名对应的路径部分。此路径以正斜杠(&#x2F;)开头。</li>
<li><strong>Path Info</strong>：不是context路径或servlet路径的请求路径部分。</li>
</ul>
<p>　　你可以使用<strong>HttpServletRequest</strong>接口的<strong>getContextPath</strong>，<strong>getServletPath</strong>和<strong>getPathInfo</strong>方法来访问此信息。除了request  URI和路径部分之间的URL编码差异外，request URI始终由context路径加上servlet路径加上路径信息组成。</p>
<p>查询字符串由一组参数和值组成。通过使用<strong>getParameter</strong>方法从请求中检索各个参数。这有两种生成查询字符串的方式。</p>
<ul>
<li>查询字符串可以显式地显示在网页中。</li>
<li>当提交具有GET HTTP方法的表单时，将查询字符串附加到URL。</li>
</ul>
<h2 id="构建响应"><a href="#构建响应" class="headerlink" title="构建响应"></a>构建响应</h2><hr>
<p>　　response包含在服务器和客户端之间传递的数据。所有的响应都实现了<strong>ServletResponse</strong>接口。此接口定义了允许你执行以下操作的方法。</p>
<ul>
<li>检索用于向客户端发送数据的输出流。要发送字符数据，使用response的getWriter方法返回的PrinteWriter对象。要在多用途因特网邮件扩充(MIME)响应中发送二进制数据，使用getOutputStream方法返回的ServletOutputStream对象。要混合二进制和文本数据，如在多部分响应中，使用ServletOutputStream并手动管理字符部分。</li>
<li>使用**setContentType(String)**方法指定response返回的内容类型(如，text&#x2F;html)。这个方法必须在响应提交前调用。内容类型名称的注册表由互联网号码分配机构(IANA)保存，网址为<a href="http://www.iana.org/assignments/media-types/%E3%80%82">http://www.iana.org/assignments/media-types/。</a></li>
<li>指示是否使用**setBufferSize(int)**方法缓冲输出。默认情况下，写入输出流的任何内容都将立即发送到客户端。缓冲允许在将任何内容发回客户端之前写入内容，从而为servlet提供更多的时间来设置适当的状态代码和响应头，或转发到另一个Web资源。这个方法必须在任何内容被写入或者在响应提交前。</li>
<li>设置本地化信息，如区域设置和字符编码。有关详细信息，请参见第20章“国际化和本地化Web应用程序”。</li>
</ul>
<p>HTTP response对象<strong>javax.servlet.http.HttpServletResponse</strong>具有表示HTTP标头的字段，如下所示。</p>
<ul>
<li><strong>状态码</strong>，用于指示请求不满足或请求被重定向的原因。</li>
<li><strong>Cookies</strong>，用于在客户端存储应用程序特定的信息。有时，cookies用于维护用于跟踪用户会话的标识符(请参阅“会话跟踪”)。</li>
</ul>
<hr>
<h1 id="过滤请求和响应"><a href="#过滤请求和响应" class="headerlink" title="过滤请求和响应"></a>过滤请求和响应</h1><hr>
<p>　　过滤器（filter）是一个可以转换请求或响应头和内容(或两者)的对象。过滤器不同于Web组件，因为过滤器通常不会创建响应。相反，过滤器提供可以“附加”到任何类型的Web资源的功能。因此，过滤器不应具有与作为过滤器作用的Web资源的任何依赖关系; 这样，它可以由多种类型的网络资源组成。</p>
<p>过滤器可以执行的主要任务如下。</p>
<ul>
<li>查询请求并相应地进行操作。</li>
<li>阻止请求&#x2F;响应对进一步传递。</li>
<li>修改请求头和数据。你可以通过提供自定义版本的请求来执行此操作。</li>
<li>修改响应头和数据。你可以通过提供自定义版本的响应来实现。</li>
<li>与外部资源交互。</li>
</ul>
<p>过滤器的应用包括验证，日志，图像转换，数据压缩，加密，分解字符串，XML转换等。<br>你可以配置一个web资源，由特定顺序的零个，一个或者多个过滤器组成的过滤链来过滤。当包含组件的Web应用程序被部署时，该过滤链被指定，并且当web容器加载组件时，它被实例化。  </p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><hr>
<p>　　过滤API由<strong>javax.servlet</strong>包中的<strong>Filter</strong>，<strong>FilterChain</strong>和<strong>FilterConfig</strong>接口定义。你可以通过实现<strong>Filter</strong>接口定义一个过滤器。<br>　　使用**@WebFilter<strong>注解来定义Web应用程序中的过滤器。此注解在类上指定，并包含有关正在声明的过滤器的元数据。注解的过滤器必须至少指定一个URL模式。这可以通过在注解上使用</strong>urlPatterns<strong>或</strong>value<strong>属性来完成。所有其他属性都是可选的，都有一个默认设置。当注解上唯一的属性是URL模式时，使用</strong>value<strong>属性;当其他属性也被使用时，使用</strong>urlPatterns<strong>属性。<br>使用</strong>@WebFilter<strong>注解注解的类必须实现</strong>javax.servlet.Filter<strong>接口。<br>　　要向过滤器添加配置数据，请指定使用</strong>@WebFilter<strong>注解的</strong>initParams<strong>属性。该</strong>initParams<strong>在属性包含一个</strong>@WebInitParam**注解。以下代码片段定义了一个过滤器，指定了一个初始化参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;TimeOfDayFilter&quot;,</span></span><br><span class="line"><span class="meta">urlPatterns = &#123;&quot;/*&quot;&#125;,</span></span><br><span class="line"><span class="meta">initParams = &#123;</span></span><br><span class="line"><span class="meta">    @WebInitParam(name = &quot;mood&quot;, value = &quot;awake&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeOfDayFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>　　<strong>Filter</strong>接口中最重要的方法是<strong>doFilter</strong>，它有三个参数，分别是<strong>request</strong>，<strong>response</strong>和<strong>filter chain</strong>对象。此方法可以执行以下操作。</p>
<ul>
<li>检查请求头</li>
<li>自定义请求对象，如果过滤器希望修改请求头或数据。</li>
<li>自定义响应对象，如果过滤器希望修改响应头或数据。</li>
<li>调用过滤器链中的下一个实体。如果当前的过滤器是以目标为Web组件或静态资源结束的链中的最后一个过滤器，那么下一个实体是链末尾的资源; 否则，它是在WAR中配置的下一个过滤器。过滤器通过调用链对象上的<strong>doFilter</strong>方法来调用下一个实体，并传入被调用的请求和响应或它可能创建的包装版本为参数。或者过滤器可以通过不调用下一个实体来阻止请求。在后一种情况下，过滤器负责填写响应。</li>
<li>在链中调用下一个过滤器后，检查响应头。</li>
<li>抛出异常以指示处理中的错误。</li>
</ul>
<p>　　除了<strong>doFilter</strong>，你还必须实现<strong>init</strong>和<strong>destroy</strong>方法。当过滤器被实例化时，容器调用<strong>init</strong>方法。如果你想将初始化参数传递给过滤器，则可以从传递给init的<strong>FilterConfig</strong>对象中检索它们。</p>
<h2 id="自定义请求和响应"><a href="#自定义请求和响应" class="headerlink" title="自定义请求和响应"></a>自定义请求和响应</h2><hr>
<p>　　过滤器有许多方法来修改请求或响应。例如，过滤器可以向请求添加属性，或者可以在响应中插入数据。<br>　　过滤器要修改一个响应，那么它通常必须在响应返回客户端前捕获它。为此，你将一个备用流传递给生成响应的servlet。备用流阻止servlet在完成时关闭原始响应流，并允许过滤器修改servlet的响应。<br>　　要将这个备用流传递给servlet，过滤器将创建一个响应包装器，它重写getWriter或getOutputStream方法以返回此备用流。包装器被传递给过滤器链的doFilter方法。包装方法默认调用到包装的请求或响应对象。<br>　　要重写请求方法，将请求包装在一个继承ServletRequestWrapper或HttpServletRequestWrapper的对象中。要重写响应方法，将响应包装在一个继承了ServletResponseWrapper 或者HttpServletResponseWrapper的对象中.</p>
<h2 id="指定过滤器映射"><a href="#指定过滤器映射" class="headerlink" title="指定过滤器映射"></a>指定过滤器映射</h2><hr>
<p>　　Web容器使用过滤器映射(filter mappings)来决定如何将过滤器应用于Web资源。一个过滤器映射通过名称匹配一个过滤器到一个web组件，或者通过URL模式到一个web资源。过滤器按照过滤器映射在WAR的过滤器映射列表中显示的顺序来调用。你可以在部署描述文件中为一个WAR指定一个过滤器映射列表，通过使用NetBeans IDE或使用XML编写该列表。<br>　　如果要将每个请求记录到Web应用程序，请将命中计数器过滤器映射到URL模式&#x2F; *。<br>  <img src="/images/javaweb/jeett_dt_018.png"><br>　　你可以将过滤器映射到一个或多个Web资源，并且可以将多个过滤器映射到一个Web资源。这在图17-1中示出，其中过滤器F1被映射到servlets S1，S2和S3;过滤器F2映射到servlet S2;并且滤波器F3被映射到servlets S1和S2。<br>　　回想一下，filter chain是传递给过滤器的doFilter方法的对象之一。该链通过过滤器映射间接形成。链中过滤器的顺序与过滤器映射在Web应用程序部署描述符中显示的顺序相同。<br>　　当过滤器映射到servlet S1时，Web容器调用F1的doFilter方法。S1的过滤器链中每个过滤器的doFilter方法通过前一个过滤器的chain.doFilter方法来调用。因为S1的过滤器链包含过滤器F1和F3，所以F1调用chain.doFilter调用过滤器F3的doFilter方法。当F3的doFilter方法完成时，控制返回到F1的doFilter方法。</p>
<h3 id="使用NetBeans-IDE来指定过滤器映射"><a href="#使用NetBeans-IDE来指定过滤器映射" class="headerlink" title="使用NetBeans IDE来指定过滤器映射"></a>使用NetBeans IDE来指定过滤器映射</h3><ol>
<li><pre><code>在Project选项卡中展开应用程序的项目节点。
</code></pre>
<ol start="2">
<li><pre><code>展开project下的Web Pages 和 WEB-INF节点。
</code></pre>
<ol start="3">
<li><pre><code>双击web.xml。
</code></pre>
<ol start="4">
<li><pre><code>点击编辑器窗口上的Filters。
</code></pre>
<ol start="5">
<li><pre><code>展开编辑器窗口中的Servelt Filters节点。
</code></pre>
<ol start="6">
<li><pre><code>点击Add Filter Element通过名称或者URL去映射一个过滤器到一个web资源上
</code></pre>
<ol start="7">
<li><pre><code>在Add Servlet Filter 对话窗口，在Filter Name字段输入过滤器的名称
</code></pre>
<ol start="8">
<li><pre><code>点击Browse找到过滤器应用到的servlet类。
</code></pre>
你可以包含通配符，以便你可以将过滤器应用于多个servlet。<ol start="9">
<li><pre><code>点击OK
</code></pre>
<ol start="10">
<li><pre><code>要限制过滤器如何应用于请求，请按照下列步骤操作。  
</code></pre>
a)	展开Filter Mappings节点<br>b)	从过滤器列表中选择过滤器<br>c)	点击Add<br>d)	在Add Filter Mapping对话窗口，选择以下dispatcher类型之一：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>  	  	</p>
<ul>
<li><strong>REQUEST</strong>: 只有当请求直接来自客户端时  </li>
<li><strong>ASYNC</strong>：只有异步请求来自客户端  </li>
<li><strong>FORWARD</strong>: 只有当请求被转发到组件时(请参阅Transferring Control to Another Web Component)  </li>
<li><strong>INCLUDE</strong>：只有当请求被包含的组件处理时(请参阅Including Other Resources in the Response) </li>
<li><strong>ERROR</strong>：只有当使用错误页面机制处理请求时(请参阅Handling Servlet Errors)</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>你可以通过选择多个dispatcher类型来指示过滤器应用于上述情况的任何组合。如果没有指定类型，默认选项为REQUEST。  </p>
<hr>
<h1 id="调用其他Web资源"><a href="#调用其他Web资源" class="headerlink" title="调用其他Web资源"></a>调用其他Web资源</h1><hr>
<p>　　Web组件可以间接和直接地调用其他Web资源。Web组件通过在返回给客户端的内容中嵌入指向另一个Web组件的URL来间接调用另一个Web资源。当它正在执行时，Web组件通过包含另一资源的内容或将请求转发到另一资源来直接调用其他资源。<br>　　要调用运行Web组件的服务器上可用的资源，必须首先使用<strong>getRequestDispatcher(“URL”)<strong>方法获取一个</strong>RequestDispatcher</strong>对象。你可以从一个request或Web context中获取<strong>RequestDispatcher</strong>对象; 然而，两种方法的行为略有不同。该方法将所请求资源的路径作为参数。Request可以使用一个相对路径(也就是，一个不以&#x2F;开头的路径)，但是web context需要一个绝对路径。如果资源不可用或服务器尚未为该类型的资源实现<strong>RequestDispatcher</strong>对象，则<strong>getRequestDispatcher</strong>将返回null。你的servlet应该准备好处理这种情况。  </p>
<h2 id="在response中包含其他资源"><a href="#在response中包含其他资源" class="headerlink" title="在response中包含其他资源"></a>在response中包含其他资源</h2><hr>
<p>　　在Web组件返回的响应中，包含其他Web资源(例如横幅内容或版权信息)通常是有用的。要包含另一个资源，调用<strong>RequestDispatcher</strong>对象的<strong>include</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">include(request, response);</span><br></pre></td></tr></table></figure>
<p>　　如果资源是静态的，这个include方法启用编程式服务端包含。如果资源是一个web组件，这个方法的作用是发送请求到这个包含的web组件中，执行Web组件，然后将在被包含的servlet中的响应的执行结果包含在内。被包含的Web组件可以访问该请求对象，但是它对该响应对象可执行操作有限制。</p>
<ul>
<li>它可以写入响应的正文并提交响应。</li>
<li>它不能设置头或调用任何影响响应标头的方法，如setCookie。</li>
</ul>
<h2 id="转交控制权给另一个web组件"><a href="#转交控制权给另一个web组件" class="headerlink" title="转交控制权给另一个web组件"></a>转交控制权给另一个web组件</h2><hr>
<p>　　在某些应用程序中，你可能希望有一个Web组件对请求进行初步处理，然后另一个组件生成响应。例如，你可能希望部分地处理请求，然后根据请求的性质转移到另一个组件。<br>　　要将控制权转发到另一个Web组件，可以调用<strong>RequestDispatcher</strong>的<strong>forward</strong>方法。当转发请求时，请求的URL被设置为转发页面的路径。原始URI及其组成部分保存为以下请求属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.servlet.forward.request_uri</span><br><span class="line">javax.servlet.forward.context_path</span><br><span class="line">javax.servlet.forward.servlet_path</span><br><span class="line">javax.servlet.forward.path_info</span><br><span class="line">javax.servlet.forward.query_string</span><br></pre></td></tr></table></figure>
<p>　　forward方法将回复用户的责任给了另一个资源。如果你已经在servlet中访问了<strong>ServletOutputStream</strong>或<strong>PrintWriter</strong>对象，则不能使用此方法;否则会抛出IllegalStateException。</p>
<hr>
<h1 id="访问Web-Context"><a href="#访问Web-Context" class="headerlink" title="访问Web Context"></a>访问Web Context</h1><hr>
<p>　　Web组件执行的上下文是一个实现<strong>ServletContext</strong>接口的对象。你可以使用<strong>getServletContext</strong>方法检索Web context。 Web context提供了以下访问的方法</p>
<ul>
<li>初始化参数</li>
<li>与Web context相关联的资源</li>
<li>对象值属性</li>
<li>日志功能</li>
</ul>
<p>　　计数器的访问方法是同步的，以防止并发运行的servlet执行不兼容的操作。过滤器使用context的getAttribute方法检索计数器对象。计数器的递增值记录在日志中。  </p>
<hr>
<h1 id="维持客户端状态"><a href="#维持客户端状态" class="headerlink" title="维持客户端状态"></a>维持客户端状态</h1><hr>
<p>　　许多应用程序要求来自客户端的一系列的相互联系的请求。例如，Web应用程序可以跨请求保存用户购物车的状态。基于Web的应用程序负责维护这种状态，这被称为会话(session)，因为HTTP是无状态的。为了支持一个需要维持状态的应用程序，Java Servlet技术提供了一个用于管理会话的API，并实现了允许会话的几种机制。  </p>
<h2 id="访问一个会话"><a href="#访问一个会话" class="headerlink" title="访问一个会话"></a>访问一个会话</h2><hr>
<p>　　会话由<strong>HttpSession</strong>对象表示。通过调用request对象的getSession方法来访问session。此方法返回与此request相关联的当前session;或者，如果request没有session，则此方法创建一个session。</p>
<h2 id="将对象与session相关联"><a href="#将对象与session相关联" class="headerlink" title="将对象与session相关联"></a>将对象与session相关联</h2><hr>
<p>　　你可以按名称将对象值属性与session相关联。这些属性可以由属于相同Web context的任何Web组件访问，并且可以由相同session的任一个request来处理。<br>　　回想一下，你的应用程序可以通知Web context和session的监听器对象servlet生命周期事件(请看处理Servlet生命周期事件)。你还可以通知对象与某个session关联的某些事件，例如以下情况。</p>
<ul>
<li>对象在一个session中被添加或者删除时。要接收此通知，你的对象必须实现<strong>javax.servlet.http.HttpSessionBindingListener</strong>接口。</li>
<li>当连接对象的session将被钝化或激活时。一个session会被钝化或激活，当它在虚拟机中被移动或者被保存并且从持久化存储中被恢复时。要接收此通知，你的对象必须实现<strong>javax.servlet.http.HttpSessionActivationListener</strong>接口。</li>
</ul>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><hr>
<p>　　因为HTTP客户端无法示意它不再需要会话，所以每个会话都有一个关联的超时时间，以便它的资源可以被回收。可以通过使用session的<strong>getMaxInactiveInterval</strong>和<strong>setMaxInactiveInterval</strong>方法来访问超时时间。</p>
<ul>
<li>为了确保活动会话没有超时，你应该通过使用service方法定期访问session，因为这会重置会话的生存时间计数器。</li>
<li>特定客户端交互完成后，你可以使用session的<strong>invalidate</strong>方法来使服务器端的session失效，并删除任何session数据。</li>
</ul>
<h3 id="使用NetBeans-IDE设置会话超时时间"><a href="#使用NetBeans-IDE设置会话超时时间" class="headerlink" title="使用NetBeans IDE设置会话超时时间"></a>使用NetBeans IDE设置会话超时时间</h3><p>要使用NetBeans IDE在部署描述符中设置超时时间，请按照下列步骤操作。<br>1.	打开项目如果你还没有打开的话<br>2.	在“Projects”选项卡中展开项目的节点。<br>3.	展开项目节点下的“Web Pages” 和 “WEB-INF”节点。<br>4.	双击web.xml<br>5.	点击编辑器上部的General<br>6.	在Session Timeout字段，输入一个整数值</p>
<p>整数值表示会话超时之前必须通过的不活动分钟数。  </p>
<h2 id="会话追踪"><a href="#会话追踪" class="headerlink" title="会话追踪"></a>会话追踪</h2><hr>
<p>　　为了将会话与用户相关联，Web容器可以使用多种方法，所有这些方法都涉及在客户端和服务器之间传递标识符。该标识符可以作为cookie保存在客户端上，或者Web组件可以在返回给客户端的每个URL中包括标识符。<br>　　如果你的应用程序使用session对象，则必须确保通过在客户端关闭Cookie时使应用程序重写URL来启用会话跟踪。你可以通过在servlet返回的所有URL上调用response的**encodeURL(URL)**方法来执行此操作。该方法仅在Cookie被禁用时才在URL中包含的session ID;否则，该方法返回URL不变。</p>
<hr>
<h1 id="终结一个Servlet"><a href="#终结一个Servlet" class="headerlink" title="终结一个Servlet"></a>终结一个Servlet</h1><hr>
<p>　　Web容器可能会决定servlet应该从服务中删除(比如，当一个容器想要回收内存资源或者当它准备关闭的时候)。在这种情况下，容器调用Servlet接口的destroy方法。在此方法中，你可以释放servlet正在使用的任何资源，并保存任何持久状态。destroy方法释放在init方法中创建的数据库对象。<br>　　一个servlet的service方法应该在servlet移除的时候全部结束。服务器尝试通过仅在当所有的服务请求已经返回，或者在服务器指定宽限期之后，才调用destroy方法来确保这点。如果你的servlet操作可能运行的比服务器宽限时间更久的话，那么在调用destroy方法时，操作仍然可以运行。你必须确保任何线程仍处理客户端请求完成。<br>本节的其余部分将介绍如何执行以下操作。  </p>
<ul>
<li>跟踪当前运行service方法的线程数。</li>
<li>通过使用destroy方法提醒长时间运行的线程，关闭操作在等待它们的完成，以此提供一个干净的关机。</li>
<li>长时间运行的方法定期检查关机，如有必要，停止工作，清理并返回。</li>
</ul>
<h2 id="跟踪服务请求"><a href="#跟踪服务请求" class="headerlink" title="跟踪服务请求"></a>跟踪服务请求</h2><hr>
<p>　　要跟踪服务请求，请在servlet类中包含一个计算正在运行的service方法数的字段。该字段应该具有同步访问方法来递增，递减并返回其值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownExample</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serviceCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Access methods for serviceCounter</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enteringServiceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        serviceCounter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">leavingServiceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        serviceCounter--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">numServices</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceCounter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Service方法应当每次在进入方法的时候递增service counter，并且应当怎每次方法返回的时候递减counter。这是几种你的HttpServlet子类应该重写service方法的情景之一。新方法应该调用super.service来保留原始service方法的功能：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                       HttpServletResponse resp)</span></span><br><span class="line">                       <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">    enteringServiceMethod();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.service(req, resp);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        leavingServiceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提醒方法关闭"><a href="#提醒方法关闭" class="headerlink" title="提醒方法关闭"></a>提醒方法关闭</h2><hr>
<p>　　为了确保清洁关机，你的destroy方法不应该释放任何共享资源，直到所有的服务请求全部完成。这样做的一部分就是检查service counter。另一部分是去提醒长时间运行的方法，现在是关闭的时间了。对于此通知，需要另一个字段。该字段应具有通常的访问方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownExample</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> shuttingDown;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Access methods for shuttingDown</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setShuttingDown</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        shuttingDown = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isShuttingDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shuttingDown;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是使用这些字段提供清洁关机的destroy方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Check to see whether there are still service methods /*</span></span><br><span class="line"><span class="comment">    /* running, and if there are, tell them to stop. */</span></span><br><span class="line">    <span class="keyword">if</span> (numServices()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        setShuttingDown(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for the service methods to stop. */</span></span><br><span class="line">    <span class="keyword">while</span> (numServices()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建礼让长时间运行的方法"><a href="#创建礼让长时间运行的方法" class="headerlink" title="创建礼让长时间运行的方法"></a>创建礼让长时间运行的方法</h2><hr>
<p>　　提供干净关闭的最后一步是使任何长时间运行的方法表现得礼貌。可能运行很长时间的方法应该检查通知他们关闭的字段的值，并且如果需要的话应该中断他们的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ((i &lt; lotsOfStuffToDo) &amp;&amp;</span><br><span class="line">         !isShuttingDown()); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            partOfLongRunningOperation(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="使用Java-Servlet技术上传文件"><a href="#使用Java-Servlet技术上传文件" class="headerlink" title="使用Java Servlet技术上传文件"></a>使用Java Servlet技术上传文件</h1><p>***　<br>　支持文件上传是许多Web应用程序的一个非常基本和通用的要求。在以前版本的Servlet规范中，实现文件上传需要使用外部库或复杂的输入处理。Java Servlet规范现在帮助以通用和便捷的方式为这个问题提供一个可行的解决方案。Java Servlet技术现在支持文件上传开箱即用，因此实现此规范的任何Web容器都可以解析多部分请求，并通过HttpServletRequest对象使mime附件可用。<br>　　一个新的注解，javax.servlet.annotation.MultipartConfig，用于指示声明它的servlet的期望使用multipart&#x2F;form-data的MIME类型的请求。一个使用@MultipartConfig注解的Servlet可以获取给定multipart&#x2F;form-data请求的Part组件，通过调用request.getPart(String name) 或者request.getParts() 方法.  </p>
<h2 id="MultipartConfig-注解"><a href="#MultipartConfig-注解" class="headerlink" title="@MultipartConfig 注解"></a>@MultipartConfig 注解</h2><hr>
<p>@MultipartConfig注解支持以下可选属性。</p>
<ul>
<li><strong>Location</strong>：一个文件系统上目录的绝对路径。location属性不支持相对于应用程序上下文的路径。此路径用于临时存储文件，当part被处理时或者文件大小超过指定的fileSizeThreshold设置时。默认的location是“”。</li>
<li><strong>fileSizeThreshold</strong>：文件暂时存储在磁盘上时的大小，以字节为单位。默认大小是0字节</li>
<li><strong>MaxFileSize</strong>：允许上传的文件的最大大小，以字节为单位。如果任何上传的文件大小超过此设置，web容器会抛出一个异常(IllegalStateException)。默认大小是无限制。</li>
<li><strong>maxRequestSize</strong>：允许multipart&#x2F;form-data请求的最大大小，以字节为单位。如果所有上传的文件的总体大小超过此阈值，Web容器将会抛出一个异常。默认大小是无限制。</li>
</ul>
<p>例如，@MultipartConfig注解可以以如下构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MultipartConfig(location=&quot;/tmp&quot;, fileSizeThreshold=1024*1024,</span></span><br><span class="line"><span class="meta">    maxFileSize=1024*1024*5, maxRequestSize=1024*1024*5*5)</span></span><br></pre></td></tr></table></figure>
<p>你可以在web.xml文件中添加以下作为servlet配置元素的子元素，而不是使用@MultipartConfig注解来对文件上传servlet中的这些属性进行硬编码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/tmp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>20848820<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>418018841<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="getParts和getPart方法"><a href="#getParts和getPart方法" class="headerlink" title="getParts和getPart方法"></a>getParts和getPart方法</h2><hr>
<p>Servlet规范支持两种额外的HttpServletRequest方法：</p>
<ul>
<li>Collection&lt;Part&gt; getParts()</li>
<li>Part getPart(String name)</li>
</ul>
<p>　　request.getParts()方法返回所有Part对象的集合。如果你有多个类型文件的输入，则返回多个Part对象。因为Part对象是有名称的，所以getPart(String name)方法可用于访问特定的Part。或者，可以使用返回Iterable &lt;Part&gt;的getParts()方法来获取所有Part对象上的迭代器。<br>　　javax.servlet.http.Part接口是一个简单的接口，它提供了允许对每个Part进行内省的方法。方法如下： </p>
<ul>
<li>获取Part的名称，大小，和内容类型</li>
<li>查询Part提交的头部信息</li>
<li>删除Part</li>
<li>将一个Part写入磁盘</li>
</ul>
<p>　　例如，Part接口提供一个write(String filename)方法使用指定的名称来写入文件。然后，该文件可以保存在使用@MultipartConfig注释的location属性指定的目录中，或者，在fileupload示例的情况下，在由表单中的目标字段指定的位置。 </p>
<hr>
<h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><hr>
<p>　　在应用程序服务器中的web容器通常为每个客户端请求使用一个服务线程。在重负载条件下，容器需要大量线程来满足所有的客户端请求。可扩展性限制包括内存不足或容器线程池的耗尽。要创建可扩展的Web应用程序，你必须确保与请求相关联的线程没有空闲，这样容器可以使用它们来处理新的请求。<br>　　下面有两种与请求相关的线程被闲置的情况</p>
<ul>
<li>在创建响应之前，线程需要等待资源变为可用或者正在处理数据。例如，应用程序可能需要在生成响应之前查询数据库或从远程Web服务访问数据。</li>
<li>线程需要等待事件才能生成响应。例如，应用程序可能必须在生成响应之前等待JMS消息，来自其他客户端的新信息或队列中可用的新数据。</li>
</ul>
<p>　　这些场景表示了阻塞式操作，它们会限制web应用程序的可拓展性。异步处理是指将这些阻塞操作分配给新线程，并将与请求相关联的线程立即重新调用到容器。</p>
<h2 id="Servlet中的异步处理"><a href="#Servlet中的异步处理" class="headerlink" title="Servlet中的异步处理"></a>Servlet中的异步处理</h2><hr>
<p>　　Java EE为servlet和过滤器提供异步处理支持。如果servlet或过滤器在处理请求时遇到潜在的阻塞操作，则可以将操作分配给异步执行上下文，并将与请求相关联的线程立即返回到容器而不产生响应。阻塞操作在异步执行上下文中在不同的线程中完成，可以生成响应或将请求发送到另一个servlet。<br>要在servlet上启用异步处理，请将@WebServlet注释上的参数asyncSupported设置为true，如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/asyncservlet&quot;&#125;, asyncSupported=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>　　javax.servlet.AsyncContext类提供了在service方法中执行异步处理所需的功能。要获取AsyncContext的实例，请在service方法的request对象上调用startAsync()方法;例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="type">AsyncContext</span> <span class="variable">acontext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　此调用将请求置于异步模式，并确保退出service方法后不提交响应。你必须在异步上下文中等待阻塞式操作完成后或者将请求转发到另一个servlet后，生成一个响应。<br>下表介绍了AsyncContext类提供的基本功能。 </p>
<table>
<thead>
<tr>
<th>Method Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>void start(Runnable run)</td>
<td>容器提供了可以处理阻塞操作的不同线程。<br><br>你用一个实现了Runable接口的类为阻塞式操作提供代码。可以提供这个类作为内部类，当调用start方法，或者使用使用其他机制将AsyncContext实例传递给你的类。</td>
</tr>
<tr>
<td>ServletRequest getRequest()</td>
<td>返回用于初始化此异步上下文的request。在上面的例子中，request与service方法中的相同。<br>你可以在异步上下文中使用此方法从request中获取参数。</td>
</tr>
<tr>
<td>ServletResponse getResponse()</td>
<td>返回用于初始化此异步上下文的response。在上面的例子中，response与service方法中的相同。<br>你可以在异步上下文中使用此方法，将阻塞操作的结果写入响应。</td>
</tr>
<tr>
<td>void complete()</td>
<td>完成异步操作并关闭与此异步上下文相关联的响应。在写入异步上下文中的响应对象之后调用此方法。</td>
</tr>
<tr>
<td>void dispatch(String path)</td>
<td>将请求和响应对象调度到给定的路径。<br>在阻止操作完成后，你可以使用此方法让另一个servlet写入响应。</td>
</tr>
</tbody></table>
<h2 id="等待资源"><a href="#等待资源" class="headerlink" title="等待资源"></a>等待资源</h2><hr>
<p>本节演示如何在下面示例中使用AsyncContext提供的功能：<br>1.	一个servlet接收一个来自GET请求中的参数。<br>2.	servlet使用资源(如数据库或Web服务)根据参数的值检索信息。资源有时会很慢，所以这可能是一个阻塞操作。<br>3.	servlet使用资源的结果生成响应</p>
<p>以下代码显示了不使用异步处理的基本servlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/syncservlet&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> MyRemoteResource resource;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> &#123;</span><br><span class="line">      resource = MyRemoteResource.create(<span class="string">&quot;config1=x,config2=y&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                     HttpServletResponse response)</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> resource.process(param);</span><br><span class="line">      <span class="comment">/* ... print to the response ... */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码显示了使用异步处理的同一servlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/asyncservlet&quot;&#125;, asyncSupported=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="comment">/* ... Same variables and init method as in SyncServlet ... */</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                     HttpServletResponse response)</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">acontext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">      acontext.start(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> acontext.getRequest().getParameter(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> resource.process(param);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> acontext.getResponse();</span><br><span class="line">            <span class="comment">/* ... print to the response ... */</span></span><br><span class="line">            acontext.complete();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncServlet将asyncSupported &#x3D; true添加到@WebServlet注解。其余的差异在服务方法之内。  </p>
<ul>
<li>request.startAsync()导致请求被异步处理;该响应不会在服务方法结束时发送给客户端。</li>
<li>acontext.start(new Runnable(){…})从容器中获取一个新的线程。</li>
<li>内部类的run()方法中的代码在新线程中执行。内部类可以访问异步上下文以从请求读取参数并写入响应。调用异步上下文的complete()方法提交响应并将其发送给客户端。<br>AsyncServlet的服务方法立即返回，而请求在异步上下文中处理。</li>
</ul>
<h1 id="非阻塞式I-x2F-O"><a href="#非阻塞式I-x2F-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h1><p>　　在应用程序服务器中的web容器通常为每个客户端请求使用一个服务线程。要开发可扩展的Web应用程序，你必须确保与客户端请求相关联的线程从不闲置需要等待阻塞操作完成。“异步处理”提供了一种在新线程中执行应用程序特定阻塞操作，并将与请求相关联的线程立即返回到容器中的机制。即使你在服务方法中使用异步处理来处理所有特定于应用程序的阻塞操作，基于与input&#x2F;output会阻塞的考虑，与客户端请求相关联的线程仍然可能暂时闲置。<br>　　例如，如果客户端通过缓慢的网络连接提交大型HTTP POST请求，相比客户端提供的请求速度，服务器可以更快的处理请求。使用传统的I &#x2F; O，与此请求关联的容器线程有时会空闲等待请求的剩余部分完成。<br>　　在异步模式下处理请求时，Java EE为servlet和过滤器提供非阻塞I &#x2F; O支持。以下步骤总结了如何使用非阻塞I &#x2F; O来处理请求并在服务方法中写入响应。<br>1.	将request置入如“异步处理”中所述的异步模式。<br>2.	在service方法中从request和response对象中获取一个输入流或输出流。<br>3.	分配一个读取监听器给输入流或者一个写入监听器给输出流。<br>4.	在监听器的回调方法内处理请求和响应。</p>
<p>表17-4和表17-5描述了用于非阻塞I &#x2F; O支持的servlet输入和输出流中可用的方法。表17-6描述了读取监听器和写入监听器的接口。<br>Table 17-4 Nonblocking I&#x2F;O Support in javax.servlet.ServletInputStream</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>void setReadListener(ReadListener rl)</td>
<td>将此输入流与一个包含回调方法的监听器对象关联起来，以用来异步读取数据。你以匿名类形式提供这个监听器对象，或者使用其他机制将输入流传递给这个读取监听器对象。</td>
</tr>
<tr>
<td>boolean isReady()</td>
<td>如果数据可以读取数据而不阻塞时，则返回true。</td>
</tr>
<tr>
<td>boolean isFinished()</td>
<td>当所有的数据读取完毕后返回true。</td>
</tr>
</tbody></table>
<p>Table 17-5 Nonblocking I&#x2F;O Support in javax.servlet.ServletOutputStream</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>void setWriteListener(WriteListener wl)</td>
<td>将此输出流与一个包含回调方法的监听器对象关联起来，以用来异步写入数据。你以匿名类形式提供这个写入监听器对象，或者使用其他机制将输出流传递给这个写入监听器对象。</td>
</tr>
<tr>
<td>boolean isReady()</td>
<td>如果数据可以写入而不阻塞时，则返回true。</td>
</tr>
</tbody></table>
<p>Table 17-6 Listener Interfaces for Nonblocking I&#x2F;O Support</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Methods</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>ReadListener</td>
<td>void onDataAvailable()<br>void onAllDataRead()<br>void onError(Throwable t)</td>
<td>当有数据可用来读取、所有的数据被读取完毕或者当有错误发生时，一个ServletInputStream实例在它的监听器上调用这些方法。</td>
</tr>
<tr>
<td>WriteListener</td>
<td>void onWritePossible()<br>void onError(Throwable t)</td>
<td>当有可以写入数据时或者当有错误发生时，一个ServletOutputStream实例在它的监听器上调用这些方法。</td>
</tr>
</tbody></table>
<h2 id="使用非阻塞I-x2F-O-读取一个大的HTTP-POST-请求"><a href="#使用非阻塞I-x2F-O-读取一个大的HTTP-POST-请求" class="headerlink" title="使用非阻塞I&#x2F;O 读取一个大的HTTP POST 请求"></a>使用非阻塞I&#x2F;O 读取一个大的HTTP POST 请求</h2><p>本节中的代码显示了如何通过将请求置于异步模式(如“异步处理”中所述)并使用表17-4和表17-6中的非阻塞I &#x2F; O功能来读取servlet内的大型HTTP POST请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/asyncioservlet&quot;&#125;, asyncSupported=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncIOServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                      HttpServletResponse response)</span></span><br><span class="line">                      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">acontext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ServletInputStream</span> <span class="variable">input</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">      </span><br><span class="line">      input.setReadListener(<span class="keyword">new</span> <span class="title class_">ReadListener</span>() &#123;</span><br><span class="line">         <span class="type">byte</span> buffer[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>*<span class="number">1024</span>];</span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">sbuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataAvailable</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> input.read(buffer);</span><br><span class="line">                  sbuilder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">               &#125; <span class="keyword">while</span>(input.isReady());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123; ... &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAllDataRead</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               acontext.getResponse().getWriter()</span><br><span class="line">                                     .write(<span class="string">&quot;...the response...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123; ... &#125;</span><br><span class="line">            acontext.complete();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123; ... &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　此示例使用@WebServlet注解参数asyncSupported &#x3D; true声明这个web servlet带有异步支持。服务方法首先通过调用request对象的startAsync()方法将请求置于异步模式，这是为了使用非阻塞I &#x2F; O所必需的。然后，服务方法获得与请求相关联的输入流，并分配一个定义为内部类的读取监听器。监听器读取请求的一部分，当它可用时，然后在完成读取请求后向客户端写入一些响应。</p>
<h1 id="协议升级处理"><a href="#协议升级处理" class="headerlink" title="协议升级处理"></a>协议升级处理</h1><p>　　在HTTP &#x2F; 1.1中，客户端可以通过使用Upgrade头字段来请求切换在当前连接上的不同协议。如果服务器接受客户端指示的切换协议请求，它会使用状态吗101(切换协议)产生一个HTTP响应。在此交换之后，客户端和服务器使用新协议进行通信。<br>例如，一个客户端可以使一个HTTP请求切换到XYZP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /xyzpresource HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Accept: text/html</span><br><span class="line">Upgrade: XYZP</span><br><span class="line">Connection: Upgrade</span><br><span class="line">OtherHeaderA: Value</span><br></pre></td></tr></table></figure>
<p>客户端可以使用HTTP头为新协议指定一个参数。服务器可以接受这个请求并且产生如下的一个响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: XYZP</span><br><span class="line">Connection: Upgrade</span><br><span class="line">OtherHeaderB: Value</span><br><span class="line"></span><br><span class="line">(XYZP data)</span><br></pre></td></tr></table></figure>
<p>Java EE支持Servlet中的HTTP协议升级功能，如表17-7所示。<br>Table 17-7 Protocol Upgrade Support</p>
<table>
<thead>
<tr>
<th>Class or Interface</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>HttpServletRequest</td>
<td>HttpUpgradeHandler upgrade(Class handler)<br>Upgrade方法开始协议升级处理。这个方法实例化一个实现了 HttpUpgradeHandler 接口的类，并且将连接委托给它。<br>你在接受来自一个客户端切换协议的请求时，在service里调用upgrade方法。</td>
</tr>
<tr>
<td>HttpUpgradeHandler</td>
<td>void init(WebConnection wc)<br>当servlet接受切换协议请求后，调用init方法。你可以实现这个方法，并且从Webconnection对象中获取输入输出流 来实现新的协议.</td>
</tr>
<tr>
<td>HttpUpgradeHandler</td>
<td>void destroy()<br>当客户端断开连接后调用destroy方法。你可以实现这个方法并且释放任何与处理新协议相关联的资源。</td>
</tr>
<tr>
<td>WebConnection</td>
<td>ServletInputStream getInputStream()<br>getInputStream方法提供对连接的输入流的访问。你可以在返回的流中使用非阻塞I&#x2F;O来实现新协议</td>
</tr>
<tr>
<td>WebConnection</td>
<td>ServletOutputStream getOutputStream()<br>getOutputStream方法提供对连接的输出流的访问。你可以在返回的流中使用非阻塞I&#x2F;O来实现新协议</td>
</tr>
</tbody></table>
<p>以下代码演示如何接受来自客户端的HTTP协议升级请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/xyzpresource&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XYZPUpgradeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                     HttpServletResponse response)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;XYZP&quot;</span>.equals(request.getHeader(<span class="string">&quot;Upgrade&quot;</span>))) &#123;</span><br><span class="line">         <span class="comment">/* Accept upgrade request */</span></span><br><span class="line">         response.setStatus(<span class="number">101</span>);</span><br><span class="line">         response.setHeader(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;XYZP&quot;</span>);</span><br><span class="line">         response.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>);</span><br><span class="line">         response.setHeader(<span class="string">&quot;OtherHeaderB&quot;</span>, <span class="string">&quot;Value&quot;</span>);</span><br><span class="line">         <span class="comment">/* Delegate the connection to the upgrade handler */</span></span><br><span class="line">         XYZPUpgradeHandler = request.upgrade(XYZPUpgradeHandler.class);</span><br><span class="line">         <span class="comment">/* (the service method returns immedately) */</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* ... write error response ... */</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XYZPUpgradeHandler类处理这个连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XYZPUpgradeHandler</span> <span class="keyword">implements</span> <span class="title class_">HttpUpgradeHandler</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(WebConnection wc)</span> &#123;</span><br><span class="line">      <span class="type">ServletInputStream</span> <span class="variable">input</span> <span class="operator">=</span> wc.getInputStream();</span><br><span class="line">      <span class="type">ServletOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> wc.getOutputStream();</span><br><span class="line">      <span class="comment">/* ... implement XYZP using these streams (protocol-specific) ... */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　实现HttpUpgradeHandler的类使用当前连接的流与客户端使用新协议进行通信。有关HTTP协议升级支持的详细信息，请参阅<a href="http://jcp.org/en/jsr/detail?id=340%E4%B8%8A%E7%9A%84Servlet">http://jcp.org/en/jsr/detail?id=340上的Servlet</a> 3.1规范。</p>
]]></content>
      <categories>
        <category>javaEE</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java JDBC（二）使用JDBC处理SQL语句</title>
    <url>/2017/06/30/java-JDBC%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><p>首先，与要使用的数据源建立一个连接。数据源可以是一个DBMS，一个传统的文件系统，或者其他具有相应JDBC驱动的数据源。通常，JDBC应用程序使用以下两个类来与一个目标数据源建立连接。</p>
<ul>
<li><strong>DriverManager</strong>：这个已经完全实现的类将应用程序连接到一个由数据库URL指定的数据源上。当这个类第一次尝试建立一个连接的时候，它会自动加载在class路径下的任何JDBC4.0驱动。需要注意的是，在4.0版本之前你的程序必须手动加载任何一个JDBC驱动。</li>
<li><strong>Datasource</strong>：这个接口优于DriverManager，因为它允许底层数据源的详细信息对你的程序透明。通过设置DataSource对象的属性使其代表特定的数据源。更多信息参阅”使用Datasource对象连接“。有关使用DataSource类开发应用程序的更多信息，请参阅最新的<a href="http://docs.oracle.com/javaee/6/tutorial/doc/">Java EE教程</a>。</li>
</ul>
<span id="more"></span>

<blockquote>
<p><strong>注意</strong>：本教程中的示例使用DriverManager类而不是DataSource类，因为它更易于使用，并且示例不需要DataSource类的功能。</p>
</blockquote>
<h2 id="使用DriverManager类"><a href="#使用DriverManager类" class="headerlink" title="使用DriverManager类"></a>使用DriverManager类</h2><p>使用DriverManager类连接到你的DBMS涉及调用DriverManager.getConnection方法。以下JDBCTutorialUtilities.getConnection方法建立了一个数据库连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">connectionProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    connectionProps.put(<span class="string">&quot;user&quot;</span>, <span class="built_in">this</span>.userName);</span><br><span class="line">    connectionProps.put(<span class="string">&quot;password&quot;</span>, <span class="built_in">this</span>.password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.dbms.equals(<span class="string">&quot;mysql&quot;</span>)) &#123;</span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">                   <span class="string">&quot;jdbc:&quot;</span> + <span class="built_in">this</span>.dbms + <span class="string">&quot;://&quot;</span> +</span><br><span class="line">                   <span class="built_in">this</span>.serverName +</span><br><span class="line">                   <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.portNumber + <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                   connectionProps);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.dbms.equals(<span class="string">&quot;derby&quot;</span>)) &#123;</span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">                   <span class="string">&quot;jdbc:&quot;</span> + <span class="built_in">this</span>.dbms + <span class="string">&quot;:&quot;</span> +</span><br><span class="line">                   <span class="built_in">this</span>.dbName +</span><br><span class="line">                   <span class="string">&quot;;create=true&quot;</span>,</span><br><span class="line">                   connectionProps);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connected to database&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DriverManager.getConnection方法用来建立一个数据库连接。这个方法需要一个数据库URL，它取决于你的DBMS。下面是一些数据库URL的示例。<br>1.	Mysql：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;，localhost是你的数据库的服务主机名称，3306是端口号<br>2.	Java DB：jdbc:derby:testdb;create&#x3D;true,testdb]是要连接到的数据库的名字，而create &#x3D; true则指示DBMS创建数据库。</p>
<pre><code>&gt;**注意**：此URL与Java DB Embedded Driver建立数据库连接。Java DB还包括使用不同URL的Network Client Driver。
</code></pre>
<p>这个方法还需要指定用户名和密码，这里使用Properties对象用来访问DBMA。<br><strong>注意</strong></p>
<ul>
<li><p>通常在数据库URL中，你还需要指定你想连接的一个已经存在的数据库名称，URL jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mysql表示一个名为mysql 的MySQL数据库的URL。本教程中的示例使用不指定特定数据库的URL，因为本示例想要创建一个新的数据库。</p>
</li>
<li><p>在之前的JDBC版本，要想获取一个连接，你首先必须通过调用Class.forName方法来初始化你的JDBC驱动。该方法需要一个java.sql.Driver类型的对象。每个JDBC驱动都包含一个或多个实现java.sql.Driver接口的类。Java DB的driver类是org.apache.derby.jdbc.EmbeddedDriver 以及org.apache.derby.jdbc.ClientDriver，而MySQL Connector &#x2F; J中的一个是com.mysql.jdbc.Driver. 请参阅DBMS驱动程序的文档，以获取实现接口java.sql.Driver的类的名称。</p>
<p>  任何在class路径下找到的JDBC4.0的驱动都会被自动加载。（然而，你必须使用Class.forName方法手动加载任何早于JDBC4.0的驱动）</p>
</li>
</ul>
<p>这个方法返回一个Connection对象，它代表一个同DBMS或者指定数据库的连接。通过这个对象来查询数据库。</p>
<h2 id="指定数据库库连接URL"><a href="#指定数据库库连接URL" class="headerlink" title="指定数据库库连接URL"></a>指定数据库库连接URL</h2><p>一个数据库连接URL是一个你的DBMS JDBC驱动用来连接数据库的字符串。它可能包含这些信息，比如去哪里查找数据库，要连接的数据库名称，以及配置属性。数据库连接URL的具体语法由你的DBMS来指定。</p>
<h3 id="Java-DB-数据库连接URL"><a href="#Java-DB-数据库连接URL" class="headerlink" title="Java DB 数据库连接URL"></a>Java DB 数据库连接URL</h3><p>以下是Java DB的数据库连接URL语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:derby:[subsubprotocol:][databaseName][;attribute=value]*</span><br></pre></td></tr></table></figure>
<ul>
<li>subsubprotocol指定Java DB应在目录，内存，类路径或JAR文件中搜索数据库的位置。通常省略。</li>
<li>databaseName是要连接的数据库的名称。</li>
<li>attribute &#x3D; value表示可选的以分号分隔的属性列表。这些属性使你能够指示Java DB执行各种任务，包括以下内容：<ul>
<li>创建连接URL中指定的数据库。 </li>
<li>加密连接URL中指定的数据库。 </li>
<li>指定目录以存储日志记录和跟踪信息。 </li>
<li>指定连接到数据库的用户名和密码。</li>
</ul>
</li>
</ul>
<h3 id="MySQL-Connector-x2F-J-数据库连接URL"><a href="#MySQL-Connector-x2F-J-数据库连接URL" class="headerlink" title="MySQL Connector&#x2F;J 数据库连接URL"></a>MySQL Connector&#x2F;J 数据库连接URL</h3><p>以下是MySQL Connector &#x2F; J的数据库连接URL语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://[host][,failoverhost...]</span><br><span class="line">    [:port]/[database]</span><br><span class="line">    [?propertyName1][=propertyValue1]</span><br><span class="line">    [&amp;propertyName2][=propertyValue2]...</span><br></pre></td></tr></table></figure>
<ul>
<li>host:port是托管数据库的主机名和端口号。如果没有指定，host和port的默认值分别是127.0.0.1和3306。</li>
<li>database是你要连接到的数据库的名称。如果没有指定，则连接不具有默认数据库。</li>
<li>failover是备用数据库的名称（MySQL Connector &#x2F; J支持故障切换）。</li>
<li>propertyName &#x3D; propertyValue表示一个可选的，和用用&amp;符分隔的属性列表。这些属性使你能够指示MySQL Connector &#x2F; J执行各种任务。</li>
</ul>
<h1 id="使用DataSource对象连接"><a href="#使用DataSource对象连接" class="headerlink" title="使用DataSource对象连接"></a>使用DataSource对象连接</h1><p>　　本节涵盖了DataSource对象，它是连接到数据源的首选方式。除了它的会在后面介绍的优点之外，Datasource对象还可以提供连接池和分布式事务。此功能对企业数据库计算至关重要。特别地，它是Enterprise JavaBeans（EJB）技术的组成部分。<br>　　本章节展示如何使用DataSource接口来获取一个连接，以及如何使用分布式事务与连接池。这两者在你的JDBC应用程序中只涉及很少的代码修改。<br>　　系统管理员通常使用一个工具（比如Apache Tomcat 或 Oracle WebLogic Server）执行部署这些类来实现以上的功能操作，但这会根据正在部署的DataSource对象的类型而有所不同。因此，本节的大部分内容都致力于显示系统管理员如何设置环境，以便程序员可以使用DataSource对象获取连接。  </p>
<h2 id="使用DataSource来获取一个连接"><a href="#使用DataSource来获取一个连接" class="headerlink" title="使用DataSource来获取一个连接"></a>使用DataSource来获取一个连接</h2><p>　　在”<a href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5">建立连接</a>“中，你学会了如何使用DriverManager类来获取一个连接。这个章节将会为你展示如何使用DataSource对象来获取一个连接，到你的数据源中，这是一个更好的方式。<br>　　由实现DataSource的类的实例化对象表示特定的DBMS或某些其他数据源，比如一个文件。一个DataSource对象表示一个特定的DBMS或者其他的数据源，比如一个文件。如果一个公司使用超过一个数据源的话，它会为其中的每个都部署一个单独的DataSource对象。DataSource接口由驱动程序供应商来实现。它可能以以下三种方式来实现。</p>
<ul>
<li>一个基本的DataSource实现提供标准的Connection对象，这些对象不在连接池中或者在分布式事务中使用。</li>
<li>支持连接池的DataSource实现产生参与在连接池中的Connection对象，也就是说，连接可以被回收。</li>
<li>支持分布式事务的DataSource实现产生可在分布式事务中使用的Connection对象，也就是说，一个事务可以访问两个或多个DBMS服务器。</li>
</ul>
<p>一个JDBC驱动应该至少包含一个基本的DataSource实现。比如，JavaDB JDBC驱动包含实现org.apache.derby.jdbc.ClientDataSource，并且对于MySQL，也包含一个DataSource实现com.mysql.jdbc.jdbc2.optional.MysqlDataSource. 如果你的客户端运行在Java 8 Compact Profile 2上，那么Java DB JDBC驱动程序就是org.apache.derby.jdbc.BasicClientDataSource40. 本教程的示例需要compact profile 3或更高版本。<br>　　一个支持分布式事务的DataSource类通常也会实现对连接池的实现。例如，由EJB供应商提供的DataSource类几乎总是支持连接池和分布式事务。</p>
<p>　　在之前的例子中，假设The Coffee Break商店蓬勃发展的连锁店的所有者决定通过在互联网上销售咖啡来进一步扩张。随着预期的大量在线交易，所有者无疑需要一个连接池。连接的开启和关闭涉及大量开销，并且所有者预计这种在线订购系统将需要大量的查询和更新。通过连接池，池中的连接可以一次又一次地使用，从而避免为每次数据库访问来创建新连接的开销。此外，所有者现在有第二个DBMS,其中包含最近收购的咖啡焙烧公司的数据。这意味着所有者会希望能够编写同时使用旧的DBMS服务器和新的服务器的分布式事务。<br>　　连锁经营者重新配置了计算机系统，为新的更加广大的客户群服务。所有者已经购买了最新的JDBC驱动程序和一个EJB应用程序服务器，这可以用来做分布式事务，并且能够获得连接池带来的性能增长。许多JDBC驱动程序可用于与最近购买的EJB服务器兼容。所有者现在拥有了一个三层架构，一个新的EJB应用程序服务器和JDBC驱动在中间层，并且两个DBMS服务器作为第三层。发出请求的客户端计算机是第一层。</p>
<h2 id="部署一个基础DataSource对象"><a href="#部署一个基础DataSource对象" class="headerlink" title="部署一个基础DataSource对象"></a>部署一个基础DataSource对象</h2><p>　　系统管理员需要部署DataSource对象，这样The Coffee Break的编程团队可以开始使用它们。部署一个DataSource对象包含以下三个任务。<br>1.	创建一个DataSource类的实例<br>2.	设置它的属性。<br>3.	使用Java命名和目录接口（JNDI）API的命名服务注册它。</p>
<p>首先，考虑使用一个DataSource接口基本实现的最基础情况，也就是一个不支持连接池或分布式事务的DataSource。这种情况下只有一个DataSource对象需要部署。一个DataSource的基础实现提供与DriverManager类提供的相同种类的连接。</p>
<h3 id="创建DataSource类实例并设置它的属性"><a href="#创建DataSource类实例并设置它的属性" class="headerlink" title="创建DataSource类实例并设置它的属性"></a>创建DataSource类实例并设置它的属性</h3><p>　　假设一个公司只想要一个DataSource的基础实现，它已经从JDBC供应商DB Access Inc购买了一个驱动。这个驱动包含了com.dbaccess.BasicDataSource类，它实现了DataSource接口。下面的代码片段创建了一个BasicDataSource类的实例，并且设置了它的属性。在BasicDataSource的实例部署后，程序员可以调用DataSource.getConnection方法来获取一个到公司数据库CUSTOMER_ACCOUNTS的连接。首先系统管理员使用默认构造器创建了BasicDataSource对象ds。然后系统管理员设置了三个属性。注意，以下代码通常由部署工具执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dbaccess.<span class="type">BasicDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.dbaccess.BasicDataSource();</span><br><span class="line">ds.setServerName(<span class="string">&quot;grinder&quot;</span>);</span><br><span class="line">ds.setDatabaseName(<span class="string">&quot;CUSTOMER_ACCOUNTS&quot;</span>);</span><br><span class="line">ds.setDescription(<span class="string">&quot;Customer accounts database for billing&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　变量ds现在表示托管在在服务器上的数据库CUSTOMER_ACCOUNTS。任何由BasicDataSource对象ds产生的连接都是到数据库CUSTOMER_ACCOUNTS的连接。</p>
<h3 id="使用JNDI命名服务注册DataSource对象"><a href="#使用JNDI命名服务注册DataSource对象" class="headerlink" title="使用JNDI命名服务注册DataSource对象"></a>使用JNDI命名服务注册DataSource对象</h3><p>　　通过设置属性，系统管理员可以使用JNDI（Java命名和目录接口）命名服务注册BasicDataSource对象。所使用的命名服务通常由系统属性确定，这里不展示。下面代码片段注册BasicDataSource对象并且将它与逻辑名称jdbc&#x2F;billingDB绑定在一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ctx.bind(<span class="string">&quot;jdbc/billingDB&quot;</span>, ds);</span><br></pre></td></tr></table></figure>
<p>　　这里的代码使用了JNDI API。第一行创建了一个InitialContext对象，服务器把它作为命名起点，类似于一个文件系统的根目录。第二行将BasicDataSource对象ds关联或者说绑定到逻辑名jdbc&#x2F;billingDB上。在下个代码片段，你传递给命名服务这个逻辑名，然后它返回给你BasicDataSource对象。逻辑名可以是任何字符串。在这种情况下，公司决定使用名称billingDB作为CUSTOMER_ACCOUNTS数据库的逻辑名称。<br>　　在前面的示例中，jdbc是初始上下文中的一个子上下文，就像在根目录下的目录是一个子目录一样。Jdbc&#x2F;billingDB就像一个路径名称，路径中最后一个项目类似于文件名。在这种情况下，billingDB是赋予BasicDataSource对象ds的逻辑名称。子上下文jdbc保留用于绑定到DataSource对象的逻辑名，因此jdbc将始终是数据源的逻辑名的第一部分。</p>
<h3 id="使用部署的DataSource对象"><a href="#使用部署的DataSource对象" class="headerlink" title="使用部署的DataSource对象"></a>使用部署的DataSource对象</h3><p>　　在一个基础DataSource实现被系统管理员部署后，它已经可以被程序员所使用。这意味着程序员可以给出一个被绑定到DataSource类实例上的逻辑数据源名称，然JNDI命名服务会返回一个DataSource类的实例。DataSource对象上的getConnection方法可以被调用，用来获取一个到它所表示的数据源上的连接。比如，一个程序员可以编写以下两行代码来获取一个DataSource对象，它产生一个到数据库CUSTOMER_ACCOUNTS的连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)ctx.lookup(<span class="string">&quot;jdbc/billingDB&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　第一行代码获取一个初始上下文作为接收DataSource对象的起点。当你提供这个逻辑名jdbc&#x2F;billingDB给方法lookup，这个方法返回被系统管理员部署时绑定到jdbc&#x2F;billingDB上的DataSource对象。因为lookup方法的返回值是一个Java Object类型，所以在将它赋给变量ds前，我们必须将它转换为更为具体的DataSource类型。<br>　　变量ds是实现了DataSource接口的类com.dbaccess.BasicDataSource的实例。调用方法ds.getConnection产生一个到数据库CUSTOMER_ACCOUNTS的连接。     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection(<span class="string">&quot;fernanda&quot;</span>,<span class="string">&quot;brewed&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　getConnection方法只需要用户名和密码，因为在变量ds的属性中有与数据库CUSTOMER_ACCOUNTS建立连接所需的其他信息，比如数据库名称和位置。</p>
<h3 id="DataSource对象的优点"><a href="#DataSource对象的优点" class="headerlink" title="DataSource对象的优点"></a>DataSource对象的优点</h3><p>　　由于能设置属性，与获取连接的DriverManager类相比，DataSource对象是一个更好的选择。程序员不再需要在其应用程序中硬编码驱动程序名称或JDBC URL，这使得它们更易移植。此外，DataSource的属性使维护代码更简单。如果有更改，系统管理员可以更新数据源属性，而不用担心更改与数据源建立连接的每个应用程序。例如，如果将数据源移动到其他服务器，所有系统管理员需要做的是设置serverName属性为新的服务器名称。<br>　　除了可移植性和易于维护之外，使用DataSource对象获取连接还可以提供其他优势。当DataSource接口实现为使用ConnectionPoolDataSource实现时，由该DataSource类的实例生成的所有连接将自动成为池连接。类似地，当DataSource的实现也是使用XADataSource的实现时，它产生的所有连接将自动成为可以在分布式事务中使用的连接。下一节将介绍如何部署这些类型的DataSource实现。    </p>
<h2 id="部署其他DataSource实现"><a href="#部署其他DataSource实现" class="headerlink" title="部署其他DataSource实现"></a>部署其他DataSource实现</h2><p>　　系统管理员或相同身份的人可以部署DataSource对象，使其生成的连接是池连接。要想做到这一点，他或她首先部署一个ConnectionPoolDataSource对象，然后部署一个DataSource对象，实现和它一起工作。设置ConnectionPoolDataSource对象的属性，以便它表示要生成连接的数据源。在ConnectionPoolDataSource对象已经使用JNDI命名服务注册之后，DataSource对象被部署。通常只需要为DataSource对象设置两个属性：description和dataSourceName。赋给dataSourceName属性的值是标识先前部署的ConnectionPoolDataSource对象的逻辑名称，该ConnectionPoolDataSource对象包含进行连接所需的属性。<br>　　在ConnectionPoolDataSource和DataSource对象部署后，你可以调用DataSource对象上的方法DataSource.getConnection来获取池连接。此连接将连接到ConnectionPoolDataSource对象的属性中指定的数据源。<br>　　以下示例描述了The Coffee Break的系统管理员如何部署实现的提供池连接的DataSource对象。系统管理员通常将使用部署工具，因此本节中显示的代码片段是部署工具将执行的代码。<br>　　为了获得更好的性能，Coffee Break公司已经从DB Access，Inc.购买了一个JDBC驱动程序，其中包含实现ConnectionPoolDataSource接口的com.dbaccess.ConnectionPoolDS类。系统管理员创建创建此类的实例，设置其属性，并使用JNDI命名服务进行注册。Coffee Break从其EJB服务器供应商Application Logic公司购买了DataSource类的实现 com.applogic.PooledDataSource。com.applogic.PooledDataSource类通过使用ConnectionPoolDataSource类com.dbaccess.ConnectionPoolDS提供的底层支持来实现连接池。</p>
<p>　　ConnectionPoolDataSource对象必须首先被部署。下面代码创建了一个com.dbaceccesss.ConnectionPoolDS类的实例并且设置了它的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dbaccess.<span class="type">ConnectionPoolDS</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.dbaccess.ConnectionPoolDS();</span><br><span class="line">cpds.setServerName(<span class="string">&quot;creamer&quot;</span>);</span><br><span class="line">cpds.setDatabaseName(<span class="string">&quot;COFFEEBREAK&quot;</span>);</span><br><span class="line">cpds.setPortNumber(<span class="number">9040</span>);</span><br><span class="line">cpds.setDescription(<span class="string">&quot;Connection pooling for &quot;</span> + <span class="string">&quot;COFFEEBREAK DBMS&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　在ConnectionPoolDataSource对象被部署后，系统管理员部署DataSource对象。下面的代码使用JNDI命名服务来注册com.dbaccess.ConnectionPoolDS对象cpds。注意，与变量cpds相关联的逻辑名让它的子上下文pool添加到了子上下文jdbc下面，这类似于在一个分层文件系统中添加一个子目录到另一个子目录下。com.dbaccess.ConnectionPoolDS类的任何实例的逻辑名会一直以jdbc&#x2F;pool开头。Oracle建议将所有ConnectionPoolDataSource对象放在子上下文jdbc &#x2F; pool下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ctx.bind(<span class="string">&quot;jdbc/pool/fastCoffeeDB&quot;</span>, cpds);</span><br></pre></td></tr></table></figure>
<p>　　接下来，一个被实现与cpds以及其他com.dbaccess.ConnectionPoolDS类实例交互的DataSource对象被部署。以下代码创建此类的实例并设置其属性。注意，com.applogic.PooledDataSource的实例只设置了两个属性。Description属性被设置，是因为它一直都是需要的。另一个被设置的属性是dataSourceName，它为com.dbaccess.ConnectionPoolDS类的实例cpds提供一个逻辑JNDI名称。换句话说，cpds表示为DataSource对象实现连接池的ConnectionPoolDataSource对象。 </p>
<p>　　下面的代码可能会由一个部署工具来执行，创建一个PooledDataSource对象，设置它的属性，并且将它绑定在逻辑名jdbc&#x2F;fastCoffeeDB上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.applogic.<span class="type">PooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.applogic.PooledDataSource();</span><br><span class="line">ds.setDescription(<span class="string">&quot;produces pooled connections to COFFEEBREAK&quot;</span>);</span><br><span class="line">ds.setDataSourceName(<span class="string">&quot;jdbc/pool/fastCoffeeDB&quot;</span>);</span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ctx.bind(<span class="string">&quot;jdbc/fastCoffeeDB&quot;</span>, ds);</span><br></pre></td></tr></table></figure>
<p>此时，部署了一个DataSource对象，应用程序可以从该对象获取到数据库COFFEEBREAK的池连接。</p>
<h2 id="获取和使用池连接"><a href="#获取和使用池连接" class="headerlink" title="获取和使用池连接"></a>获取和使用池连接</h2><p>　　连接池是一个数据库连接对象的缓存。这些对象表示物理的数据库连接，可以由应用程序用于连接到数据库。在运行时期，应用程序从池中请求获取一个连接。如果池内包含可以满足请求的连接，则返回给应用程序这个连接。如果池内没有连接，则会创建一个新的连接并返回给应用程序。应用程序使用连接来在数据库上执行一些操作，然后返回连接对象给连接池。这样连接可用于下一个连接请求。<br>　　连接池促进连接对象的重用，并减少创建连接对象的次数。连接池显着提高了数据库密集型应用程序的性能，因为创建连接对象在时间和资源方面都是昂贵的。<br>　　现在DataSource和ConnectionPoolDataSource对象都已经被部署，程序员可以使用DataSource对象获得一个池连接。获取池连接的代码就像获取非池连接的代码一样，如以下两行所示：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ds = (DataSource)ctx.lookup(<span class="string">&quot;jdbc/fastCoffeeDB&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　变量ds表示DataSource对象，它产生与数据库COFFEEBREAK的池连接。你只需要获取这个DataSource对象一次，因为你可以使用它按照需要产生许多池连接。在ds变量上调用getConnection方法会自动生成一个池连接，因为ds变量所表示的DataSource对象被配置为产生池连接。<br>　　连接池通常对程序员是透明的。使用池化连接时，只需要做两件事情：<br>1.	使用DataSource对象而不是DriverMananger类来获取一个连接。在下面一行代码中，ds是实现和部署的DataSource对象，因此它将创建池连接，username和password是表示可以访问数据库的用户凭据的变量：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection con = ds.getConnection(username, password);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><pre><code>使用finally语句来关闭一个池连接。下面的finally块出现在应用于使用池连接的代码的try / catch块之后：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection(username, password);</span><br><span class="line">    <span class="comment">// ... code to use the pooled</span></span><br><span class="line">    <span class="comment">// connection con</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex &#123;</span><br><span class="line">    <span class="comment">// ... code to handle exceptions</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (con != <span class="literal">null</span>) con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>　　除此之外，使用池连接的应用程序与使用常规连接的应用程序相同。程序员可能唯一注意到的一件事是，当连接池使用后性能会更好。<br>　　以下示例代码获取一个DataSource对象，该对象生成与数据库COFFEEBREAK的连接，并使用它来更新表COFFEES中的价格：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> javax.sql.*;</span><br><span class="line"><span class="keyword">import</span> javax.ejb.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPoolingBean</span> <span class="keyword">implements</span> <span class="title class_">SessionBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejbCreate</span><span class="params">()</span> <span class="keyword">throws</span> CreateException &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ds = (DataSource)ctx.lookup(<span class="string">&quot;jdbc/fastCoffeeDB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePrice</span><span class="params">(<span class="type">float</span> price, String cofName,</span></span><br><span class="line"><span class="params">                            String username, String password)</span></span><br><span class="line">        <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line"></span><br><span class="line">        Connection con;</span><br><span class="line">        PreparedStatement pstmt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = ds.getConnection(username, password);</span><br><span class="line">            con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            pstmt = con.prepareStatement(<span class="string">&quot;UPDATE COFFEES &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;SET PRICE = ? &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;WHERE COF_NAME = ?&quot;</span>);</span><br><span class="line">            pstmt.setFloat(<span class="number">1</span>, price);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, cofName);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            con.commit();</span><br><span class="line">            pstmt.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="literal">null</span>) con.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码示例中的连接参与连接池，因为：</p>
<ul>
<li>一个实现ConnectionPoolDataSource的类的实例已经被部署。</li>
<li>一个实现DataSource的类的实例已经被部署，并且设置了它的dataSource属性值为我们绑定到之前部署的ConnectionPoolDataSource对象的逻辑名。</li>
</ul>
<p>请注意，虽然这段代码与以前见过的代码非常相似，但它在以下方面是不同的：</p>
<ul>
<li>除了java.sql外，它还导入了javax.sql,javax.ejb以及javax.naming包。<br>DataSource和ConnectionPoolDataSource接口在javax.sql包中，而JNDI构造器InitialContext和Context.lookup方法是javax.naming包中的一部分。该特定示例代码采用EJB组件的形式，该组件使用javax.ejb包中的API。此示例的目的是显示你使用池连接的方式与使用非池连接的相同，因此你不用担心不了解EJB API。</li>
<li>它使用DataSource对象来获取连接，而不是使用DriverManager。</li>
<li>它使用finally块来确保连接已关闭。</li>
</ul>
<p>获取和使用池化连接与获取和使用常规连接类似。当作为系统管理员的人员正确部署了一个ConnectionPoolDataSource对象和一个DataSource对象时，应用程序使用该DataSource对象来获取一个池化的连接。应用程序应该使用finally块来关闭池化连接。为了简单起见，前面的例子使用了一个finally块，但没有catch块。如果try块中的方法抛出异常，它会依照默认抛出异常，而finally子句将在任何情况下执行。   </p>
<h2 id="部署分布式事务"><a href="#部署分布式事务" class="headerlink" title="部署分布式事务"></a>部署分布式事务</h2><p>　　DataSource对象可以被部署用来获取可在分布式事务中使用的连接。和连接池一样，有两个不同的类实例必须被部署：一个XADataSource对象和一个DataSource对象需要被实现来配合使用。<br>　　假设Coffee Break企业家购买的EJB服务器包括DataSource类com.applogic.TransactionalDS，它与XADataSource类，如com.dbaccess.XATransactionalDS，配合工作。事实上，它适用于任何使EJB服务器可以跨JDBC驱动程序移植的XADataSource类。当DataSource和XADataSource对象部署后，生成的连接将能够参与分布式事务。在这个情况下com.applogic.TransactionalDS类同样被实现用来提供池连接。这种DataSource类实现情况通常被作为EJB服务实现的一部分而提供。<br>　　XADataSource必须首先被部署。下面代码创建类一个com.dbaccess.XATransactionalDS的实例，并且设置了它的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dbaccess.<span class="type">XATransactionalDS</span> <span class="variable">xads</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.dbaccess.XATransactionalDS();</span><br><span class="line">xads.setServerName(<span class="string">&quot;creamer&quot;</span>);</span><br><span class="line">xads.setDatabaseName(<span class="string">&quot;COFFEEBREAK&quot;</span>);</span><br><span class="line">xads.setPortNumber(<span class="number">9040</span>);</span><br><span class="line">xads.setDescription(<span class="string">&quot;Distributed transactions for COFFEEBREAK DBMS&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　下面代码使用JNDI命名服务来注册com.dbaccess.XATransactionalDS对象xads。注意，与xads相关联的逻辑名称有一个在jdbc下的子上下文xa。Oracle建议com.dbaccess.XATransactionalDS类的任何实例的逻辑名称始终以jdbc &#x2F; xa开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ctx.bind(<span class="string">&quot;jdbc/xa/distCoffeeDB&quot;</span>, xads);</span><br></pre></td></tr></table></figure>
<p>　　接下来，一个实现与xads以及其他XADataSource对象交互的DataSource对象被部署。请注意，DataSource类，com.applogic.TransactionalDS可以与任何JDBC驱动程序供应商提供的XADataSource类配合使用。部署DataSource对象涉及创建一个com.applogic.TransactionalDS类的实例并设置其属性。dataSourceName属性设置为jdbc&#x2F;xa&#x2F;distCoffeeDB，这是与com.dbaccess.XATransactionalDS关联的逻辑名。它是实现DataSource类的分布式事务功能的XADataSource类。下面的代码部署了一个DataSource类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.applogic.<span class="type">TransactionalDS</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.applogic.TransactionalDS();</span><br><span class="line">ds.setDescription(<span class="string">&quot;Produces distributed transaction &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;connections to COFFEEBREAK&quot;</span>);</span><br><span class="line">ds.setDataSourceName(<span class="string">&quot;jdbc/xa/distCoffeeDB&quot;</span>);</span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">ctx.bind(<span class="string">&quot;jdbc/distCoffeeDB&quot;</span>, ds);</span><br></pre></td></tr></table></figure>
<p>　　现在com.applogic.TransactionalDS 和 com.dbaccess.XATransactionalDS的实例都已经被部署，应用程序可以在TransactionalDS类的实例上调用getConnection方法，以获得可以在分布式事务中使用的COFFEEBREAK数据库的连接。</p>
<h2 id="使用分布式事务连接"><a href="#使用分布式事务连接" class="headerlink" title="使用分布式事务连接"></a>使用分布式事务连接</h2><p>　　要获得可用于分布式事务的连接，必须使用已正确实施和部署的DataSource对象，如“<a href="#%E9%83%A8%E7%BD%B2%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">部署分布式事务</a>”部分所示。使用这样的DataSource对象，调用它上面的getConnection方法。在你获取连接后，使用它就像你使用任何其他的连接一样。因为jdbc &#x2F; distCoffeesDB在JNDI命名服务中已经和XADataSource对象相关联，所以以下代码生成可用于分布式事务的Connection对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)ctx.lookup(<span class="string">&quot;jdbc/distCoffeesDB&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure>
<p>　　当你使用这个连接，而它属于分布式事务的一部分的时候，这儿有一些微小但是重要的限制。事务管理器控制分布式事务何时开始以及何时提交或回滚; 因此，应用程序代码不应该调用Connection.commit或Connection.rollback方法。应用程序也应该永远不会调用Connection.setAutoCommit（true），它启用自动提交模式，因为这也会干扰事务管理器对事务边界的控制。这就解释了为什么默认情况下，在分布式事务范围内创建的新连接的自动提交模式被禁用。请注意，这些限制仅适用于连接参与分布式事务时;当连接不是在分布式事务中时，是没有这个限制的。<br>　　对于以下示例，假设咖啡订单已发货，这会触发位于不同DBMS服务器上的两个表的更新。第一个表是一个新的INVENTORY表，第二个表是COFFEES表。因为这些表位于不同的DBMS服务器上，涉及它们的事务将是分布式事务。以下示例的代码中获取一个连接，更新了COFFEES表并关闭了连接，这是分布式事务的第二部分。<br>　　请注意，代码没有显式提交或回滚更新，因为分布式事务的范围由中间层服务器的基础系统基础架构控制。此外，假设用于分布式事务的连接也是池连接，则应用程序使用finally块关闭连接。这保证了即使一个异常被抛出，这个有效的连接也会被关闭，从而确保将连接返回到连接池以进行回收。<br>　　下面的代码演示了一个enterprise Bean，这是一个实现可以由客户端计算机调用的方法的类。此示例的目的是演示分布式事务的应用程序代码与其他代码没有任何区别，但它不调用Connection方法commit，rollback或setAutoCommit（true）。因此，你不需要担心了解所使用的EJB API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> javax.sql.*;</span><br><span class="line"><span class="keyword">import</span> javax.ejb.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedTransactionBean</span> <span class="keyword">implements</span> <span class="title class_">SessionBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejbCreate</span><span class="params">()</span> <span class="keyword">throws</span> CreateException &#123;</span><br><span class="line"></span><br><span class="line">        ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ds = (DataSource)ctx.lookup(<span class="string">&quot;jdbc/distCoffeesDB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTotal</span><span class="params">(<span class="type">int</span> incr, String cofName, String username,String password)</span></span><br><span class="line">	<span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        Connection con;</span><br><span class="line">        PreparedStatement pstmt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = ds.getConnection(username, password);</span><br><span class="line">            pstmt = con.prepareStatement(<span class="string">&quot;UPDATE COFFEES &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;SET TOTAL = TOTAL + ? &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;WHERE COF_NAME = ?&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">1</span>, incr);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, cofName);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="literal">null</span>) con.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="处理SQLException"><a href="#处理SQLException" class="headerlink" title="处理SQLException"></a>处理SQLException</h1><h2 id="SQLExceptiong概览"><a href="#SQLExceptiong概览" class="headerlink" title="SQLExceptiong概览"></a>SQLExceptiong概览</h2><p>　　当JDBC在与数据源交互期间遇到错误时，它会抛出SQLException异常而不是Exception。（此上下文中的数据源表示Connection对象连接到的数据库。）SQLException实例包含以下信息，可以帮助你确定错误的原因：</p>
<ul>
<li><strong>错误的描述</strong>。通过调用方法SQLException.getMessage来获取包含此描述的String对象。</li>
<li><strong>一个SQLState码</strong>。这些代码及其各自的含义已经通过ISO &#x2F; ANSI和Open Group（X &#x2F; Open）标准化，尽管已经为数据库供应商保留了一些代码来为自己定义。此String对象由五个字母字符组成。通过调用SQLException.getSQLState方法来获取此码。</li>
<li><strong>一个错误码</strong>。它是一个整数值，标识导致抛出SQLException实例的错误。它的值和含义是特定实现的，并且可能是底层数据源返回的实际错误代码。通过调用SQLException.getErrorCode方法来获取错误。</li>
<li><strong>一个引发原因</strong>。SQLException实例可能具有因果关系，它由一个或多个导致抛出SQLException实例的Throwable对象组成。要浏览这个原因链，递归调用SQLException.getCause方法，直到返回一个空值。</li>
<li><strong>一个异常链的引用</strong>。如果发生多个错误，则通过此链引用异常。通过调用抛出异常的SQLException.getNextException方法来检索这些异常。</li>
</ul>
<h2 id="检索异常"><a href="#检索异常" class="headerlink" title="检索异常"></a>检索异常</h2><p>　　以下方法，JDBCTutorialUtilities.printSQLException输出SQLException中包含的SQLState，错误代码，错误描述和引发原因（如果有的话）以及链向此异常的任何其他异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSQLException</span><span class="params">(SQLException ex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Throwable e : ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ignoreSQLException(</span><br><span class="line">                ((SQLException)e).</span><br><span class="line">                getSQLState()) == <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">                System.err.println(<span class="string">&quot;SQLState: &quot;</span> +</span><br><span class="line">                    ((SQLException)e).getSQLState());</span><br><span class="line"></span><br><span class="line">                System.err.println(<span class="string">&quot;Error Code: &quot;</span> +</span><br><span class="line">                    ((SQLException)e).getErrorCode());</span><br><span class="line"></span><br><span class="line">                System.err.println(<span class="string">&quot;Message: &quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> ex.getCause();</span><br><span class="line">                <span class="keyword">while</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Cause: &quot;</span> + t);</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　例如，如果你使用Java DB作为DBMS调用CoffeesTable.dropTable方法，而表COFFEES不存在，并删除对JDBCTutorialUtilities.ignoreSQLException的调用，输出将类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQLState: 42Y55</span><br><span class="line">Error Code: 30000</span><br><span class="line">Message: &#x27;DROP TABLE&#x27; cannot be performed on</span><br><span class="line">&#x27;TESTDB.COFFEES&#x27; because it does not exist.</span><br></pre></td></tr></table></figure>
<p>　　相比输出SQLException信息，你可以首先获取SQLState，然后相应地处理SQLException。例如，如果SQLState等于代码42Y55，方法JDBCTutorialUtilities.ignoreSQLException返回true（并且你正在使用Java DB作为你的DBMS），这将导致JDBCTutorialUtilities.printSQLException忽略这个SQLException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">ignoreSQLException</span><span class="params">(String sqlState)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqlState == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The SQL state is not defined!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X0Y32: Jar file already exists in schema</span></span><br><span class="line">    <span class="keyword">if</span> (sqlState.equalsIgnoreCase(<span class="string">&quot;X0Y32&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 42Y55: Table already exists in schema</span></span><br><span class="line">    <span class="keyword">if</span> (sqlState.equalsIgnoreCase(<span class="string">&quot;42Y55&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取警告"><a href="#获取警告" class="headerlink" title="获取警告"></a>获取警告</h2><p>　　SQLWarning对象是SQLException的子类，用来处理数据库访问警告。警告不会停止应用程序的运行，而异常会；警告只是简单的提醒用户有些事情没有按计划发生。例如，警告可能会让你知道你尝试撤销的权限未被撤销，或者告诉你在请求断开期间发生了一个错误。<br>　　一个警告可能是由一个Connection对象，一个Statement对象（包括PreparedStatement和CallableStatement对象），或者一个ResultSet对象报告。这些类都有一个getWarnings方法，为了看到调用对象报告的第一个警告消息，你必须调用该方法。如果getWarning返回一个警告，可以调用SQLWarning的getNextWarning方法来获取其他任何警告。执行一条语句会自动清空来自上一个语句中的警告，所以它们不会累积。但是，这意味着，如果要获取在语句上报告的警告，则必须在执行其他语句之前执行此操作。<br>　　JDBCTutorialUtilities中的以下方法说明了如何获取有关Statement或ResultSet对象上报告的任何警告的完整信息：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getWarningsFromResultSet</span><span class="params">(ResultSet rs)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    JDBCTutorialUtilities.printWarnings(rs.getWarnings());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getWarningsFromStatement</span><span class="params">(Statement stmt)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    JDBCTutorialUtilities.printWarnings(stmt.getWarnings());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printWarnings</span><span class="params">(SQLWarning warning)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (warning != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---Warning---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (warning != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + warning.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;SQLState: &quot;</span> + warning.getSQLState());</span><br><span class="line">        System.out.print(<span class="string">&quot;Vendor error code: &quot;</span>);</span><br><span class="line">        System.out.println(warning.getErrorCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        warning = warning.getNextWarning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　最常见的警告是DataTruncation警告，它是SQLWarning的子类。所有DataTruncation对象的SQLState为01004，表示读取或写入数据有问题。DataTruncation方法可以让你了解哪个列或参数数据被截断，截断是读取还是写入操作，应该传输多少字节以及实际传输的字节数。  </p>
<h2 id="SQLException分类"><a href="#SQLException分类" class="headerlink" title="SQLException分类"></a>SQLException分类</h2><p>　　你的JDBC驱动程序可能会抛出与常见SQLState或常见错误状态相对应的SQLException子类，这不与特定的SQLState类值相关联。这使你能够编写更易移植的错误处理代码。这些异常是以下类之一的子类：    </p>
<ul>
<li><strong>SQLNonTransientException</strong></li>
<li><strong>SQLTransientException</strong></li>
<li><strong>SQLRecoverableException</strong><br>有关这些子类的更多信息，请参阅java.sql包的最新Javadoc或JDBC驱动程序的文档。</li>
</ul>
<h2 id="SQLException其他子类"><a href="#SQLException其他子类" class="headerlink" title="SQLException其他子类"></a>SQLException其他子类</h2><p>SQLException的以下子类也可以被抛出：</p>
<ul>
<li><strong>BatchUpdateException</strong>在批量更新操作发生错误的时候会抛出。除SQLException提供的信息外，BatchUpdateException还提供在发生错误之前执行的所有语句的更新数。</li>
<li><strong>SQLClientInfoException</strong>在Connection上无法设置一个或多个客户端信息属性时会被抛出。除SQLException提供的信息外，SQLClientInfoException还提供未设置的客户端信息属性列表。</li>
</ul>
<h1 id="从ResultSet中检索修改值"><a href="#从ResultSet中检索修改值" class="headerlink" title="从ResultSet中检索修改值"></a>从ResultSet中检索修改值</h1><p>以下方法，CoffeesTable.viewTable输出COFFEES表的内容，并演示使用ResultSet对象和游标：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewTable</span><span class="params">(Connection con, String dbName)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;select COF_NAME, SUP_ID, PRICE, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;SALES, TOTAL &quot;</span> +</span><br><span class="line">        <span class="string">&quot;from &quot;</span> + dbName + <span class="string">&quot;.COFFEES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;COF_NAME&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SUP_ID&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;SALES&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;TOTAL&quot;</span>);</span><br><span class="line">            System.out.println(coffeeName + <span class="string">&quot;\t&quot;</span> + supplierID +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + price + <span class="string">&quot;\t&quot;</span> + sales +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　ResultSet对象是表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。例如，CoffeeTables.viewTable方法通过Statement对象stmt执行查询时创建一个ResultSet对象rs。请注意，可以通过实现Statement接口的任何对象来创建一个ResultSet对象，包括PreparedStatement，CallableStatement和RowSet。<br>　　你可以通过游标访问ResultSet对象中的数据。请注意，此游标不是数据库游标。此游标是指向ResultSet中的一行数据的指针。最初，游标位于第一行之前。 ResultSet.next方法将游标移动到下一行。如果游标位于最后一行之后，此方法返回false。该方法使用while循环重复调用ResultSet.next方法来遍历ResultSet中的所有数据。</p>
<h2 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h2><p>　　ResultSet接口提供检索和操作执行查询后获得的结果的方法，ResultSet对象可以具有不同的功能和特性。这些特性包括<strong>类型</strong>，<strong>并发</strong>和<strong>光标保持性</strong>。</p>
<h3 id="ResultSet类型"><a href="#ResultSet类型" class="headerlink" title="ResultSet类型"></a>ResultSet类型</h3><p>　　ResultSet对象的类型在两个方面确定其功能的级别：可以操纵游标的方式，以及ResultSet对象是否反映出对底层数据源进行的并发更改。<br>　　ResultSet对象的敏感性由以下三个ResulteSet类型来决定：     </p>
<ul>
<li><strong>TYPE_FORWARD_ONLY</strong>：结果集不可滚动；它的游标只能向前移动，从第一行之前到最后一行。结果集中包含的行取决于底层数据库如何生成结果。也就是说，它包含在执行查询时或在检索行时满足查询的行。</li>
<li><strong>TYPE_SCROLL_INSENSITIVE</strong>：结果集可以滚动；其游标可以相对于当前位置向前和向后移动，并且它可以移动到一个任意的位置。但结果集在处于开启状态时，它对底层数据源的修改不敏感。它包含在执行查询时或在检索行时满足查询的行。</li>
<li><strong>TYPE_SCROLL_SENSITIVE</strong>：结果集可以滚动。其游标可以相对于当前位置向前和向后移动，并且它可以移动到一个任意的位置。在结果集保持开启状态时，它会反映底层数据源的修改。</li>
</ul>
<p>默认的ResultSet类型为<strong>TYPE_FORWARD_ONLY</strong>。</p>
<blockquote>
<p><strong>注意</strong>：不是所有的数据库和JDBC驱动都支持所有类型的ResultSet。如果支持指定的ResultSet类型，则<strong>DatabaseMetaData.supportsResultSetType</strong>的方法返回true，否则返回false。</p>
</blockquote>
<h3 id="ResultSet并发性"><a href="#ResultSet并发性" class="headerlink" title="ResultSet并发性"></a>ResultSet并发性</h3><p>ResultSet对象的并发性决定了它支持的更新功能等级。<br>它有两个并发等级。   </p>
<ul>
<li><strong>CONCUR_READ_ONLY</strong>：ResultSet对象无法使用ResultSet接口进行更新。</li>
<li><strong>CONCUR_UPDATABLE</strong>：可以使用ResultSet接口更新ResultSet对象。</li>
</ul>
<p>默认的ResultSet并发性是<strong>CONCUR_READ_ONLY</strong>。   </p>
<blockquote>
<p><strong>注意</strong>：不是所有的数据库和JDBC驱动都支持并发。如果驱动程序支持指定的并发级别，则<strong>DatabaseMetaData.supportsResultSetConcurrency</strong>方法返回true，否则返回false。</p>
</blockquote>
<p>方法CoffeesTable.modifyPrices演示了如何使用并发级别为CONCUR_UPDATABLE的ResultSet对象。</p>
<h3 id="游标保持性"><a href="#游标保持性" class="headerlink" title="游标保持性"></a>游标保持性</h3><p>　　调用Connection.commit方法可以关闭在当前事务中创建的ResultSet对象。然而，在某些情况下，这可能是不希望的行为。ResultSet的光标保持属性允许应用程序控制在调用commit时是否关闭ResultSet对象（游标）。<br>　　可以将以下ResultSet常量提供给Connection的createStatement，prepareStatement和prepareCall方法：</p>
<ul>
<li><strong>HOLD_CURSORS_OVER_COMMIT</strong>：ResultSet游标未关闭;它们是可以保留的：当调用方法commit时，它们被保持打开。可持续游标对只读ResultSet对象的应用程序是理想的。</li>
<li><strong>CLOSE_CURSORS_AT_COMMIT</strong>：当调用commit方法时，ResultSet对象（游标）被关闭。调用此方法时关闭游标可以为某些应用程序带来更好的性能。</li>
</ul>
<p>默认的游标保持性取决于你的DBMS。</p>
<blockquote>
<p><strong>注意</strong>：不是所有的数据库和JDBC驱动都支持游标的保持或非保持性。以下方法JDBCTutorialUtilities.cursorHoldabilitySupport输出ResultSet对象的默认游标可保持性，以及是否支持HOLD_CURSORS_OVER_COMMIT和CLOSE_CURSORS_AT_COMMIT：。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cursorHoldabilitySupport</span><span class="params">(Connection conn)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatabaseMetaData</span> <span class="variable">dbMetaData</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line">    System.out.println(<span class="string">&quot;ResultSet.HOLD_CURSORS_OVER_COMMIT = &quot;</span> +</span><br><span class="line">        ResultSet.HOLD_CURSORS_OVER_COMMIT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ResultSet.CLOSE_CURSORS_AT_COMMIT = &quot;</span> +</span><br><span class="line">        ResultSet.CLOSE_CURSORS_AT_COMMIT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Default cursor holdability: &quot;</span> +</span><br><span class="line">        dbMetaData.getResultSetHoldability());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Supports HOLD_CURSORS_OVER_COMMIT? &quot;</span> +</span><br><span class="line">        dbMetaData.supportsResultSetHoldability(</span><br><span class="line">            ResultSet.HOLD_CURSORS_OVER_COMMIT));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Supports CLOSE_CURSORS_AT_COMMIT? &quot;</span> +</span><br><span class="line">        dbMetaData.supportsResultSetHoldability(</span><br><span class="line">            ResultSet.CLOSE_CURSORS_AT_COMMIT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从行中获取列值"><a href="#从行中获取列值" class="headerlink" title="从行中获取列值"></a>从行中获取列值</h2><p>　　ResulteSet接口声明了getter方法（比如getBoolean和getLong）用来从当前行内获取列值。你可以使用列的索引号或者列的别名来获取值。使用列的索引通常更有效率。列从1开始编号。为了实现最大的可移植性，每行中的结果集列应以从左到右的顺序读取，每列应只读一次。<br>例如，以下CoffeesTable.alternateViewTable方法通过序号检索列值：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alternateViewTable</span><span class="params">(Connection con)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;select COF_NAME, SUP_ID, PRICE, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;SALES, TOTAL from COFFEES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> rs.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">supplierID</span> <span class="operator">=</span> rs.getInt(<span class="number">2</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> rs.getFloat(<span class="number">3</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sales</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> rs.getInt(<span class="number">5</span>);</span><br><span class="line">            System.out.println(coffeeName + <span class="string">&quot;\t&quot;</span> + supplierID +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + price + <span class="string">&quot;\t&quot;</span> + sales +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　字符串用作getter方法的输入时不区分大小写。当一个getter方法使用字符串作为输入被调用，并当有超过一列数据拥有相同字符串形式的别名或者名称时，只有第一个匹配的列的值被返回。使用字符串而不是整数的选项被设计为在生成结果集的SQL查询中使用列别名和名称时使用。对于查询中未明确命名的列（例如，select * from COFFEES），最好使用列号。当使用列名时，开发人员应保证通过使用列别名来唯一地引用预期的列。列的别名可以有效地重命名结果集的列。要指定列别名，请使用SELECT语句中的SQL AS子句。<br>　　使用适当类型的getter方法来获取每列的值。比如，在方法CoffeeTables.viewTable中，在ResulteSet rs中每一行的第一列时COF_NAME，它存储一个SQL类型VARCHAR的值。获取SQL类型VARCHAR的值的方法时getString。每一行的第二列存储一个SQL类型INTEGER的值，获取该值的方法时getInt。<br>　　请注意，尽管方法getString建议用于获取SQL类型CHAR和VARCHAR，但是可以使用它获取任何基本的SQL类型。使用getString获取所有值可能非常有用，但也有其局限性。例如，如果它用于检索数字类型，getString将数值转换为Java String对象，并且该值必须转换回数字类型才能作为数字操作。在值被视为字符串的情况下，它没有任何缺点。此外，如果你希望应用程序检获取SQL3类型之外的任何标准SQL类型的值，请使用getString方法。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>如前面提到，你可以通过一个游标访问在ResultSet对象中的数据，该游标指向ResultSet对象的一行。然而，当一个ResultSet对象首次被创建的时候，游标指向第一行之前。方法CoffeeTables.viewTable通过调用ResultSet.next方法移动光标。还有其他方法可以移动光标：   </p>
<ul>
<li><strong>next</strong>：将光标向前移动一行。如果光标现在位于行上，则返回true，如果光标位于最后一行之后，则返回false。</li>
<li><strong>previous</strong>：将光标向后移动一行。如果光标现在位于行上，则返回true，如果光标位于第一行之前，则返回false。</li>
<li><strong>first</strong>: 将游标移动到ResultSet对象的第一行。如果游标现在位于第一行，则返回true，如果ResultSet对象不包含任何行，则返回false。</li>
<li><strong>last</strong>：将游标移动到ResultSet对象中的最后一行。如果游标现在位于最后一行，则返回true，如果ResultSet对象不包含任何行，则返回false。</li>
<li><strong>beforFirst</strong>: 将游标放置在第一行之前的ResultSet对象的开头。如果ResultSet对象不包含任何行，则此方法不起作用。</li>
<li><strong>afterLast</strong>：将游标定位在ResultSet对象的最后一行之后。如果ResultSet对象不包含任何行，则此方法不起作用。</li>
<li><strong>relative（int rows）</strong>：相对于当前位置移动光标。</li>
<li><strong>absolute（int row）</strong>：将光标定位在由参数行指定的行上。</li>
</ul>
<p>请注意，ResultSet的默认敏感度为TYPE_FORWARD_ONLY，这意味着它不能被滚动; 如果你的ResultSet无法滚动的话，除了next，你不能调用任何这些移动光标的方法；下面部分描述的CoffeesTable.modifyPrices方法演示了如何移动ResultSet的光标。    </p>
<h2 id="更新ResultSet对象中的行"><a href="#更新ResultSet对象中的行" class="headerlink" title="更新ResultSet对象中的行"></a>更新ResultSet对象中的行</h2><p>　　你不能更新一个默认级别的ResultSet对象，默认级别只能将其光标向前移动。但是，你可以创建可以滚动（光标可以向后移动或移动到绝对位置）并可以更新的ResultSet对象。<br>以下方法，CoffeesTable.modifyPrices，将每行的PRICE列乘以一个参数percentage：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPrices</span><span class="params">(<span class="type">float</span> percentage)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,</span><br><span class="line">                   ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">uprs</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;SELECT * FROM &quot;</span> + dbName + <span class="string">&quot;.COFFEES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (uprs.next()) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> uprs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            uprs.updateFloat( <span class="string">&quot;PRICE&quot;</span>, f * percentage);</span><br><span class="line">            uprs.updateRow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　ResultSet.TYPE_SCROLL_SENSITIVE字段创建一个光标可以相对于当前位置向前和向后移动，或者移动到一个绝对位置的ResultSet对象。<br>　　ResultSet.updateFloat方法更新指定的列（在本示例中，是在游标现在指向的行中带有指定float值的PRICE）。ResultSet包含各种更新方法，是你可以更新各种数据类型的类值。但是，这些更新方法都不会修改数据库;你必须调用ResultSet.updateRow方法来更新数据库。   </p>
<h2 id="使用Statement对象进行批更新"><a href="#使用Statement对象进行批更新" class="headerlink" title="使用Statement对象进行批更新"></a>使用Statement对象进行批更新</h2><p>　　Statement，PreparedStatement和CallableStatement对象有一系列与它们自身相关的命令列表。这些命令可能包括更新，插入或者删除行的语句。并且它也可以包含DDL语句，比如CREATE,TABLE以及DROP TABLE。但是，它不包含能够生成ResultSet对象的语句，比如SELECT语句。换句话说，这些命令列表只能包含产生更新计数的语句。<br>　　与Statement相关联的命令列表在它创建的时候，最初是空的。你可以使用addBatch方法向此列表添加SQL命令，并使用clearBatch方法将其清空。当你完成向列表添加语句时，调用executeBatch方法将它们全部发送到数据库，以作为一个单元或则批处理执行。<br>CoffeesTable.batchUpdate使用批量更新向COFFEES表添加了四行：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        stmt = <span class="built_in">this</span>.con.createStatement();</span><br><span class="line"></span><br><span class="line">        stmt.addBatch(</span><br><span class="line">            <span class="string">&quot;INSERT INTO COFFEES &quot;</span> +</span><br><span class="line">            <span class="string">&quot;VALUES(&#x27;Amaretto&#x27;, 49, 9.99, 0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stmt.addBatch(</span><br><span class="line">            <span class="string">&quot;INSERT INTO COFFEES &quot;</span> +</span><br><span class="line">            <span class="string">&quot;VALUES(&#x27;Hazelnut&#x27;, 49, 9.99, 0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stmt.addBatch(</span><br><span class="line">            <span class="string">&quot;INSERT INTO COFFEES &quot;</span> +</span><br><span class="line">            <span class="string">&quot;VALUES(&#x27;Amaretto_decaf&#x27;, 49, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;10.99, 0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stmt.addBatch(</span><br><span class="line">            <span class="string">&quot;INSERT INTO COFFEES &quot;</span> +</span><br><span class="line">            <span class="string">&quot;VALUES(&#x27;Hazelnut_decaf&#x27;, 49, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;10.99, 0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] updateCounts = stmt.executeBatch();</span><br><span class="line">        <span class="built_in">this</span>.con.commit();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(BatchUpdateException b) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printBatchUpdateException(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SQLException ex) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">        <span class="built_in">this</span>.con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面一行禁用了Connection对象的自动提交模式，这样事务不会在executeBatch方法调用的时候自动提交或者回滚。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.con.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>　　要想能够进行正确的错误处理，始终应该在开始批量更新之前禁用自动提交模式。<br>　　方法Statement.addBatch将一个命令添加到与Statement对象stmt相关联的命令列表中。在这个例子中，这些命令都是INSERT INTO语句，每个都添加一行包含五个列值。COF_NAME和PRICE列的值分别是咖啡的名称及其价格。每一行的第二个值是49，因为这是供应商Superior Coffee的识别号码。最后两个值，列SALES和TOTAL的条目都从零开始，因为还没有销售。 （SALES是本周在本周销售的这排咖啡的磅数; TOTAL是该咖啡的累计销售总额。）<br>以下行将添加到其命令列表的四个SQL命令发送到数据库以作为批处理执行：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] updateCounts = stmt.executeBatch();</span><br></pre></td></tr></table></figure>
<p>　　请注意，stmt使用executeBatch方法发送批量插入命令，而不是使用executeUpdate方法，它只会发送一条命令并且返回一个更新行数。DBMS按照命令的顺序执行这些命令，因此它将首先为Amaretto添加一行值，然后添加Hazelnut的行，然后添加Amaretto decaf的行，最后添加Hazelnut decaf。如果所有四个命令都成功执行，DBMS将按照执行的顺序返回每个命令的更新计数。存储在updateCounts数组中的更新计数表示了每条命令执行所影响的行数。<br>　　如果批中的所有四个命令都执行成功，则updateCounts将包含四个值，所有这些值都为1，因为一条插入命令只影响一行。与stmt相关联的命令列表现在将被清空，因为当stmt调用方法executeBatch时，先前添加的四个命令都已发送到数据库。你也可以随时使用clearBatch方法清空此命令列表。<br>　　请注意，stmt使用executeBatch方法发送批量插入命令，而不是使用executeUpdate方法，它只会发送一条命令并且返回一个更新行数。DBMS按照命令的顺序执行这些命令，因此它将首先为Amaretto添加一行值，然后添加Hazelnut的行，然后添加Amaretto decaf的行，最后添加Hazelnut decaf。如果所有四个命令都成功执行，DBMS将按照执行的顺序返回每个命令的更新计数。存储在updateCounts数组中的更新计数表示了每条命令执行所影响的行数。<br>　　如果批中的所有四个命令都执行成功，则updateCounts将包含四个值，所有这些值都为1，因为一条插入命令只影响一行。与stmt相关联的命令列表现在将被清空，因为当stmt调用方法executeBatch时，先前添加的四个命令都已发送到数据库。你也可以随时使用clearBatch方法清空此命令列表。</p>
<p>　　Connection.commit方法使COFFEES表的批量更新成为永久性的。此方法需要显式调用，因为此连接的自动提交模式先前已禁用。<br>　　下面一行为当前的Connection对象重新设置启用自动提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.con.setAutoCommit(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>现在，示例中的每个语句将在执行后自动提交，并且不再需要调用方法commit。</p>
<h3 id="执行参数化批更新"><a href="#执行参数化批更新" class="headerlink" title="执行参数化批更新"></a>执行参数化批更新</h3><p>也可以进行参数化的批量更新，如下面的代码片段所示，其中con是一个Connection对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(</span><br><span class="line">                              <span class="string">&quot;INSERT INTO COFFEES VALUES( &quot;</span> +</span><br><span class="line">                              <span class="string">&quot;?, ?, ?, ?, ?)&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Amaretto&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">49</span>);</span><br><span class="line">pstmt.setFloat(<span class="number">3</span>, <span class="number">9.99</span>);</span><br><span class="line">pstmt.setInt(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">pstmt.setInt(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line"></span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Hazelnut&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">49</span>);</span><br><span class="line">pstmt.setFloat(<span class="number">3</span>, <span class="number">9.99</span>);</span><br><span class="line">pstmt.setInt(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">pstmt.setInt(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and so on for each new</span></span><br><span class="line"><span class="comment">// type of coffee</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> [] updateCounts = pstmt.executeBatch();</span><br><span class="line">con.commit();</span><br><span class="line">con.setAutoCommit(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>


<h3 id="处理批更新异常"><a href="#处理批更新异常" class="headerlink" title="处理批更新异常"></a>处理批更新异常</h3><p>　　当你调用方法executeBatch时，如果（1）添加到批处理的其中一条SQL语句生成一个结果集（通常是一个查询）或（2）批处理中的一个SQL语句由于其他一些原因不能成功执行，则会得到一个BatchUpdateException 。<br>　　你不应该将一个查询（一个SELECT语句）添加到一批SQL命令中，因为方法executeBatch返回一个更新计数的数组，它希望从执行成功的每个SQL语句中得到一个更新计数。这意味着只有返回更新计数的命令（诸如INSERT INTO，UPDATE，DELETE等命令）或返回0的命令（如CREATE TABLE，DROP TABLE，ALTER TABLE）才能以executeBatch方法成功执行。<br>　　BatchUpdateException包含与方法executeBatch返回的数组类似的更新计数数组。在这两种情况下，更新计数与生成它们的命令的顺序相同。这告诉你批处理中有多少个命令成功执行并且哪些是成功执行的命令。例如，如果五个命令成功执行，该数组将包含五个数字：第一个是第一个命令的更新计数，第二个是第二个命令的更新计数，等等。<br>　　BatchUpdateException派生自SQLException。这意味着你可以使用SQLException对象所有可用的所有方法。以下方法，JDBCTutorialUtilities.printBatchUpdateException打印所有SQLException信息以及BatchUpdateException对象中包含的更新计数。因为BatchUpdateException.getUpdateCounts返回int数组，所以代码使用for循环来打印每个更新计数：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBatchUpdateException</span><span class="params">(BatchUpdateException b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">&quot;----BatchUpdateException----&quot;</span>);</span><br><span class="line">    System.err.println(<span class="string">&quot;SQLState:  &quot;</span> + b.getSQLState());</span><br><span class="line">    System.err.println(<span class="string">&quot;Message:  &quot;</span> + b.getMessage());</span><br><span class="line">    System.err.println(<span class="string">&quot;Vendor:  &quot;</span> + b.getErrorCode());</span><br><span class="line">    System.err.print(<span class="string">&quot;Update counts:  &quot;</span>);</span><br><span class="line">    <span class="type">int</span> [] updateCounts = b.getUpdateCounts();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; updateCounts.length; i++) &#123;</span><br><span class="line">        System.err.print(updateCounts[i] + <span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="在ResultSet对象中插入行"><a href="#在ResultSet对象中插入行" class="headerlink" title="在ResultSet对象中插入行"></a>在ResultSet对象中插入行</h2><p>　　<strong>注意</strong>：并非所有JDBC驱动程序都支持使用ResultSet接口插入新行。如果你尝试插入新行，并且JDBC驱动程序数据库不支持此功能，则抛出SQLFeatureNotSupportedException异常。</p>
<p>　　以下方法CoffeesTable.insertRow通过ResultSet对象将一行插入到COFFEES中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRow</span><span class="params">(String coffeeName, <span class="type">int</span> supplierID,</span></span><br><span class="line"><span class="params">                      <span class="type">float</span> price, <span class="type">int</span> sales, <span class="type">int</span> total)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement(</span><br><span class="line">            ResultSet.TYPE_SCROLL_SENSITIVE</span><br><span class="line">            ResultSet.CONCUR_UPDATABLE);</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">uprs</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;SELECT * FROM &quot;</span> + dbName +</span><br><span class="line">            <span class="string">&quot;.COFFEES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uprs.moveToInsertRow();</span><br><span class="line">        uprs.updateString(<span class="string">&quot;COF_NAME&quot;</span>, coffeeName);</span><br><span class="line">        uprs.updateInt(<span class="string">&quot;SUP_ID&quot;</span>, supplierID);</span><br><span class="line">        uprs.updateFloat(<span class="string">&quot;PRICE&quot;</span>, price);</span><br><span class="line">        uprs.updateInt(<span class="string">&quot;SALES&quot;</span>, sales);</span><br><span class="line">        uprs.updateInt(<span class="string">&quot;TOTAL&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">        uprs.insertRow();</span><br><span class="line">        uprs.beforeFirst();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123; stmt.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　此示例使用两个参数ResultSet.TYPE_SCROLL_SENSITIVE和ResultSet.CONCUR_UPDATABLE调用Connection.createStatement方法。第一个值使得ResultSet对象的光标向前和向后移动。如果要将行插入到ResultSet对象中，则需要第二个值ResultSet.CONCUR_UPDATABLE; 它指定结果集可以更新。<br>　　在getter方法中使用字符串的相同规定也适用于updater方法。<br>　　ResultSet.moveToInsertRow方法将光标移动到插入行。插入行是与可更新结果集相关联的特殊行。它本质上是一个缓冲区，其中可以通过在将行插入结果集之前调用updater方法来构建新行。例如，该方法调用ResultSet.updateString方法将插入行的COF_NAME列更新为Kona。<br>ResultSet.insertRow方法将插入行的内容插入到ResultSet对象中并进入数据库。     </p>
<blockquote>
<p><strong>注意</strong>：在使用ResultSet.insertRow插入一行后，应将光标移动到其他行而不是插入行。例如，此示例使用ResultSet.beforeFirst方法将其移动到结果集中的第一行之前。如果应用程序的其他部分使用相同的结果集，并且光标仍然指向插入行，则可能会发生意外的结果。   </p>
</blockquote>
<h1 id="使用预编译"><a href="#使用预编译" class="headerlink" title="使用预编译"></a>使用预编译</h1><h2 id="预编译概览"><a href="#预编译概览" class="headerlink" title="预编译概览"></a>预编译概览</h2><p>　　有时使用PreparedStatement对象发送SQL语句到数据库更加方便。这个特殊类型的Statement派生自你已经知道的更通用的Statement类。<br>　　如果你想执行一个Statement对象多次，使用PreparedStatement对象代替会减少执行所需的时间。<br>　　PreparedStatement对象的主要特点是它不像Statement对象在创建的时候就给定一个SQL语句。这样做的好处是，在大多数情况下，这个SQL语句立即被发送到DBMS编译。因此，PreparedStatement对象不仅包含SQL语句，还包含已预编译的SQL语句。这意味着，当PreparedStatement被执行时，DBMS可以仅仅运行PrepraredStatement的SQL语句而不用首先编译它。<br>　　尽管PreparedStatement对象可以用于没有参数的SQL语句，但你可能最常用于的还是使用参数的SQL语句。使用采用参数的SQL语句的优点是你可以使用相同的语句，但在每次执行时提供不同的值。这方面的例子如下。<br>　　以下方法，CoffeesTable.updateCoffeeSales，为每种类型的咖啡在SALES列中存储它在本周售出的磅数，并在TOTAL列中更新它的售出总磅数。     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCoffeeSales</span><span class="params">(HashMap&lt;String, Integer&gt; salesForWeek)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">updateSales</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">updateTotal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">updateString</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set SALES = ? where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">updateStatement</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set TOTAL = TOTAL + ? &quot;</span> +</span><br><span class="line">        <span class="string">&quot;where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        updateSales = con.prepareStatement(updateString);</span><br><span class="line">        updateTotal = con.prepareStatement(updateStatement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) &#123;</span><br><span class="line">            updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateSales.executeUpdate();</span><br><span class="line">            updateTotal.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateTotal.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateTotal.executeUpdate();</span><br><span class="line">            con.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Transaction is being rolled back&quot;</span>);</span><br><span class="line">                con.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException excep) &#123;</span><br><span class="line">                JDBCTutorialUtilities.printSQLException(excep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateSales != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateSales.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (updateTotal != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateTotal.close();</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建PreparedStatement对象"><a href="#创建PreparedStatement对象" class="headerlink" title="创建PreparedStatement对象"></a>创建PreparedStatement对象</h2><p>以下创建一个需要两个输入参数的PreparedStatement对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">updateString</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">    <span class="string">&quot;set SALES = ? where COF_NAME = ?&quot;</span>;</span><br><span class="line">updateSales = con.prepareStatement(updateString);</span><br></pre></td></tr></table></figure>
<h2 id="为PreparedStatement参数提供值"><a href="#为PreparedStatement参数提供值" class="headerlink" title="为PreparedStatement参数提供值"></a>为PreparedStatement参数提供值</h2><p>　　在执行PreparedStatement对象之前，必须提供值来替代问号占位符（如果有的话）。通过调用PreparedStatement类中定义的setter方法之一来执行此操作。以下语句在名为updateSales的PreparedStatement中提供两个问号占位符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">updateSales.setString(<span class="number">2</span>, e.getKey());</span><br></pre></td></tr></table></figure>
<p>　　每个这些setter方法的第一个参数指定问号占位符。在此示例中，setInt指定第一个占位符，setString指定第二个占位符。<br>　　在一个参数设置了一个值之后，它保留该值，直到它被重置为另一个值，或者调用clearParameters方法。使用PreparedStatement对象updateSales，以下代码片段说明在重置其中一个参数的值并使另一个参数相同的值之后重新使用预预编译语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// changes SALES column of French Roast</span></span><br><span class="line"><span class="comment">//row to 100</span></span><br><span class="line"></span><br><span class="line">updateSales.setInt(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">updateSales.setString(<span class="number">2</span>, <span class="string">&quot;French_Roast&quot;</span>);</span><br><span class="line">updateSales.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// changes SALES column of Espresso row to 100</span></span><br><span class="line"><span class="comment">// (the first parameter stayed 100, and the second</span></span><br><span class="line"><span class="comment">// parameter was reset to &quot;Espresso&quot;)</span></span><br><span class="line"></span><br><span class="line">updateSales.setString(<span class="number">2</span>, <span class="string">&quot;Espresso&quot;</span>);</span><br><span class="line">updateSales.executeUpdate();</span><br></pre></td></tr></table></figure>
<h3 id="使用循环设置值"><a href="#使用循环设置值" class="headerlink" title="使用循环设置值"></a>使用循环设置值</h3><p>　　你可以通过使用for循环或while循环来设置输入参数的值来使代码编写更容易。<br>　　CoffeesTable.updateCoffeeSales方法使用for-each循环重复设置PreparedStatement对象updateSales和updateTotal中的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">    updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">    updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　方法CoffeesTable.updateCoffeeSales有一个参数HashMap。HashMap参数中的每个元素都包含一种咖啡类型的名称，以及在本周内销售的咖啡类型的磅数。for-each循环遍历HashMap参数的每个元素，并在updateSales和updateTotal中设置相应的问号占位符。</p>
<h2 id="执行PreparedStatement对象"><a href="#执行PreparedStatement对象" class="headerlink" title="执行PreparedStatement对象"></a>执行PreparedStatement对象</h2><p>　　与Statement对象一样，要执行PreparedStatement对象，请调用一条execute语句：如果查询只返回一个ResultSet（如SELECT SQL语句），调用executeQuery，如果查询不返回ResultSet（如UPDATE SQL语句）调用executeUpdate。或者调用execute，如果查询可能返回多个ResultSet对象的话。CoffeesTable.updateCoffeeSales中的两个PreparedStatement对象都包含UPDATE SQL语句，因此它们都通过调用executeUpdate来执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">updateSales.executeUpdate();</span><br><span class="line"></span><br><span class="line">updateTotal.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">updateTotal.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">updateTotal.executeUpdate();</span><br><span class="line">con.commit();</span><br></pre></td></tr></table></figure>
<p>当执行updateSales和updateTotals时不会提供给executeUpdate方法参数; PreparedStatement对象都已经包含要执行的SQL语句。</p>
<blockquote>
<p><strong>注意</strong>：在CoffeesTable.updateCoffeeSales开头，自动提交模式设置为false： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>因此，在调用方法commit之前，不会提交任何SQL语句。有关自动提交模式的详细信息，请参阅”事务”。</p>
<h3 id="executeUpdate方法的返回值"><a href="#executeUpdate方法的返回值" class="headerlink" title="executeUpdate方法的返回值"></a>executeUpdate方法的返回值</h3><p>　　executeQuery返回一个包含发送到DBMS的查询结果的ResultSet对象，而executeUpdate的返回值是一个int值，表示更新了的表的行数。例如，以下代码显示分配给变量n的executeUpdate的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateSales.setInt(<span class="number">1</span>, <span class="number">50</span>);</span><br><span class="line">updateSales.setString(<span class="number">2</span>, <span class="string">&quot;Espresso&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> updateSales.executeUpdate();</span><br><span class="line"><span class="comment">// n = 1 because one row had a change in it</span></span><br></pre></td></tr></table></figure>
<p>　　表COFFEES被更新;用50替换Espresso行中列SALES中的值。该更新影响表中的一行，因此n等于1。<br>　　当方法executeUpdate用于执行DDL（数据定义语言）语句（如创建表）时，返回int值0。因此，在执行用于创建表COFFEES的DDL语句的以下代码片段中，n被赋值为0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> executeUpdate(createTableCoffees);</span><br></pre></td></tr></table></figure>
<p>请注意，当executeUpdate的返回值为0时，可以表示以下两种之一：</p>
<ul>
<li>执行的语句是一个影响零行的更新语句。 </li>
<li>执行的语句是一个DDL语句。</li>
</ul>
<hr>
<h1 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h1><hr>
<p>　　有时除非另外一个语句完成，你不希望一个语句生效。例如，当“The Coffee Break”的所有者更新每周销售的咖啡量时，所有者也想要更新到目前为止销售的总金额。但是，每周销售的金额和销售总额应同时更新; 否则，数据将不一致。要想确保两个操作要么都发生要么都不发生的方法是采用事务。事务是一个或多个语句集合被作为一个单元一起执行，因此要么所有的语句都执行，要么没有一个语句被执行。</p>
<h2 id="禁用自动提交模式"><a href="#禁用自动提交模式" class="headerlink" title="禁用自动提交模式"></a>禁用自动提交模式</h2><p>　　当一个连接创建的时候，它是处于自动提交模式。这意味着每个单独的SQL语句都被视为一个事务，并在执行后自动提交。（更准确地说，默认是在SQL语句完成时提交的，而不是执行时。一个语句在所有它的结果集和更新计数被获取时，算是完成。然而，几乎所有情况下，一个语句在执行完毕之后就已经完成，因此被提交。）<br>　　允许将两个或多个语句分组到事务中的方法是禁用自动提交模式。这在以下代码中演示，其中con是可用连接：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h2><hr>
<p>　　在禁用自动提交模式后，除非你明确调用commit方法，则不会有任何SQL语句被提交。在先调用commit方法后，所有的语句被包含在一个事务中并作为一个单元一起被提交执行。以下方法，CoffeesTable.updateCoffeeSales，其中con是可用连接，演示了一个事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCoffeeSales</span><span class="params">(HashMap&lt;String, Integer&gt; salesForWeek)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">updateSales</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">updateTotal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">updateString</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set SALES = ? where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">updateStatement</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set TOTAL = TOTAL + ? &quot;</span> +</span><br><span class="line">        <span class="string">&quot;where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        updateSales = con.prepareStatement(updateString);</span><br><span class="line">        updateTotal = con.prepareStatement(updateStatement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) &#123;</span><br><span class="line">            updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateSales.executeUpdate();</span><br><span class="line">            updateTotal.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateTotal.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateTotal.executeUpdate();</span><br><span class="line">            con.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Transaction is being rolled back&quot;</span>);</span><br><span class="line">                con.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException excep) &#123;</span><br><span class="line">                JDBCTutorialUtilities.printSQLException(excep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateSales != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateSales.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (updateTotal != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateTotal.close();</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个方法中，连接con的自动提交模式被禁用，这意味着当调用commit方法时，两个预编译语句updateSales和updateTotal会一起提交。无论何时调用commit方法（自动启用自动提交模式或禁用自动提交模式时），所有由事务中的语句导致的更改都将是永久性的。在这个示例中，这意味着Colombian coffee的SALES和TOTAL列已更改为50（如果TOTAL以前为0），并将保持此值，直到与其他更新语句更改为止。<br>　　con.setAutoCommit（true）语句重新启用自动提交模式，这意味着再次每个语句在完成后自动提交。然后，将返回到默认状态，无需调用方法手动提交。建议仅在事务模式下禁用自动提交模式。这样，你避免对多个语句持有数据库锁，从而增加与其他用户冲突的可能性。 </p>
<h2 id="使用事务来保护数据完整性"><a href="#使用事务来保护数据完整性" class="headerlink" title="使用事务来保护数据完整性"></a>使用事务来保护数据完整性</h2><hr>
<p>　　除了将语句成组为一个单元执行外，事务还可以帮助保持表中数据的完整性。例如，假设一个员工应该在COFFEES表中输入新的咖啡价格，但延迟了几天。同时，价格上涨，今天的所有者正在输入一个更高的价格。在所有者试图更新表的同时，员工终于绕过输入了一个过时的价格。插入过时的价格后，员工意识到他们不再有效，并调用了Connection的rollback方法来撤销它们的操作（rollback方法中止一个事务并将值恢复到尝试更新之前）。同时，所有者正在执行SELECT语句并打印新的价格。在这种情况下，所有者可能会打印已经回滚到之前的价格的价格，使打印价格不正确。<br>　　这种情景可以通过使用事务来避免，为两个用户同时访问数据时产生的冲突提供一定程度的保护。<br>　　在事务期间为了避免冲突，DBMS使用锁机制阻止他人访问事务正在访问的数据（请注意，在自动提交模式下，每个语句都是一个事务，锁只持有一个语句。）在锁被锁定之后，它将一直保持有效，直到事务提交或回滚。例如，DBMS可以锁定表的一行，直到它的更新被提交。此锁的作用是防止用户获得脏读，也就是在持久化之前读取了该值（访问一个还没被提交的更新值被认为是脏读，因为这个值可能被回滚到原来的值。如果你读取的值稍后被回滚，则读取的是一个无效值）。<br>　　锁的设置方式由事务隔离级别决定，隔离级别范围可以从不支持事务到支持执行非常严格的访问规则的事务。<br>　　事务隔离级别的一个示例是TRANSACTION_READ_COMMITTED，直到该值被提交前，它不允许该值被访问。换而言之，如果事务的隔离级别被设置为TRANSACTION_READ_COMMITTED，DBMS不会允许脏读发生。Connection接口包含五个值，它们表示你可以在JDBC中使用的事务隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>事务</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>TRANSACTION_<br>NONE</td>
<td>不支持</td>
<td>不适用</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>TRANSACTION_<br>READ_COMMITTED</td>
<td>支持</td>
<td>阻止</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>TRANSACTION_<br>READ_UNCOMMITTED</td>
<td>支持</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>TRANSACTION_<br>REPEATABLE_READ</td>
<td>支持</td>
<td>阻止</td>
<td>阻止</td>
<td>允许</td>
</tr>
<tr>
<td>TRANSACTION_<br>SERIALIZABLE</td>
<td>支持</td>
<td>阻止</td>
<td>阻止</td>
<td>阻止</td>
</tr>
</tbody></table>
<p>　　<strong>不可重复读</strong>发生在当事务A检索一行数据时，事务B随后更新该行，并且事务A之后再次检索该行。这样事务A两次检索相同的行但是看到了不同的数据。<br>　　<strong>幻读</strong>发生在当事务A检索满足给定条件的一系列行，事务B随后插入或者更新一行，这样使得该行现在满足事务A中的条件，并且事务A后号重复该条件的检索。这样事务A现在看到多了一行。这一行被称为一个幻数据。<br>　　通常，你不需要对事务隔离级别做任何事情;你可以只使用你的DBMS默认值。事务隔离级别由你的DBMS决定。比如对于Java DB，它的隔离级别是TRANSACTION_READ_COMMITTED。JDBC允许你查出DBMS设置的事务隔离级别（使用Connection的getTransactionIsolation方法）并且还允许你将其设置为另一个级别（使用Connection的setTransactionIsolation方法）。  </p>
<blockquote>
<p><strong>注意</strong>：JDBC驱动程序可能不支持所有事务隔离级别。如果驱动程序不支持在调用setTransactionIsolation中指定的隔离级别，则驱动程序可以使用一个更高，更严格的事务隔离级别替代。如果驱动程序无法使用较高的事务级别进行替代，则会抛出一个SQLException。使用DatabaseMetaData.supportsTransactionIsolationLevel方法来确定驱动是否支持给定级别。</p>
</blockquote>
<h2 id="设置回滚保存点"><a href="#设置回滚保存点" class="headerlink" title="设置回滚保存点"></a>设置回滚保存点</h2><hr>
<p>　　Connectioin.setSavepoint方法在当前事务内设置一个Savepoint对象。Connection.rollback方法被重载来接收一个Savepoint参数。<br>　　以下方法，CoffeesTable.modifyPricesByPercentage，将特定咖啡的价格提高一个百分比priceModifier。但是，如果新价格大于指定价格，则最高价格，则价格将恢复为原始价格：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPricesByPercentage</span><span class="params">(</span></span><br><span class="line"><span class="params">    String coffeeName,</span></span><br><span class="line"><span class="params">    <span class="type">float</span> priceModifier,</span></span><br><span class="line"><span class="params">    <span class="type">float</span> maximumPrice)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    </span><br><span class="line">    con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">getPrice</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">updatePrice</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;SELECT COF_NAME, PRICE FROM COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;WHERE COF_NAME = &#x27;&quot;</span> + coffeeName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Savepoint</span> <span class="variable">save1</span> <span class="operator">=</span> con.setSavepoint();</span><br><span class="line">        getPrice = con.createStatement(</span><br><span class="line">                       ResultSet.TYPE_SCROLL_INSENSITIVE,</span><br><span class="line">                       ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">        updatePrice = con.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getPrice.execute(query)) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;Could not find entry &quot;</span> +</span><br><span class="line">                <span class="string">&quot;for coffee named &quot;</span> +</span><br><span class="line">                coffeeName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rs = getPrice.getResultSet();</span><br><span class="line">            rs.first();</span><br><span class="line">            <span class="type">float</span> <span class="variable">oldPrice</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;PRICE&quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">newPrice</span> <span class="operator">=</span> oldPrice + (oldPrice * priceModifier);</span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;Old price of &quot;</span> + coffeeName +</span><br><span class="line">                <span class="string">&quot; is &quot;</span> + oldPrice);</span><br><span class="line"></span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;New price of &quot;</span> + coffeeName +</span><br><span class="line">                <span class="string">&quot; is &quot;</span> + newPrice);</span><br><span class="line"></span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;Performing update...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            updatePrice.executeUpdate(</span><br><span class="line">                <span class="string">&quot;UPDATE COFFEES SET PRICE = &quot;</span> +</span><br><span class="line">                newPrice +</span><br><span class="line">                <span class="string">&quot; WHERE COF_NAME = &#x27;&quot;</span> +</span><br><span class="line">                coffeeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;\nCOFFEES table after &quot;</span> +</span><br><span class="line">                <span class="string">&quot;update:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            CoffeesTable.viewTable(con);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newPrice &gt; maximumPrice) &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    <span class="string">&quot;\nThe new price, &quot;</span> +</span><br><span class="line">                    newPrice +</span><br><span class="line">                    <span class="string">&quot;, is greater than the &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;maximum price, &quot;</span> +</span><br><span class="line">                    maximumPrice +</span><br><span class="line">                    <span class="string">&quot;. Rolling back the &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;transaction...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                con.rollback(save1);</span><br><span class="line"></span><br><span class="line">                System.out.println(</span><br><span class="line">                    <span class="string">&quot;\nCOFFEES table &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;after rollback:&quot;</span>);</span><br><span class="line"></span><br><span class="line">                CoffeesTable.viewTable(con);</span><br><span class="line">            &#125;</span><br><span class="line">            con.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getPrice != <span class="literal">null</span>) &#123; getPrice.close(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (updatePrice != <span class="literal">null</span>) &#123;</span><br><span class="line">            updatePrice.close();</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下语句指定当调用commit方法时，从getPrice查询生成的ResultSet对象的游标将被关闭。请注意，如果你的DBMS不支持ResultSet.CLOSE_CURSORS_AT_COMMIT，则该常量将被忽略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getPrice = con.prepareStatement(query, ResultSet.CLOSE_CURSORS_AT_COMMIT);</span><br></pre></td></tr></table></figure>
<p>该方法从以下语句创建一个Savepoint开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Savepoint</span> <span class="variable">save1</span> <span class="operator">=</span> con.setSavepoint();</span><br></pre></td></tr></table></figure>
<p>该方法检查新价格是否大于maximumPrice值。如果是这样，该方法使用以下语句回滚事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con.rollback(save1);</span><br></pre></td></tr></table></figure>
<p>因此，当方法通过调用Connection.commit方法提交事务时，它不会提交任何Savepoint已经回滚的行; 它将提交所有其他更新的行。</p>
<h2 id="释放保存点"><a href="#释放保存点" class="headerlink" title="释放保存点"></a>释放保存点</h2><hr>
<p>　　Connection.releaseSavepoint方法将Savepoint对象作为参数，并将其从当前事务中删除。<br>　　在一个保存点被释放后，尝试在回滚操作中再次引用它会导致一个SQLException被抛出。任何在事务中创建的保存点都会在事务提交，或者回滚后被自动释放而变得失效。回滚一个事务到一个保存点也会使得其他任何在这个保存点之后创建的保存点被自动释放并失效。</p>
<h2 id="何时调用回滚"><a href="#何时调用回滚" class="headerlink" title="何时调用回滚"></a>何时调用回滚</h2><hr>
<p>　　如前面提到的，调用rollback方法会终止一个事务，并且将任何修改的值返回到它们之前的值。如果你尝试在一个事务中执行一个或多个语句，并且获得一个SQLExcepiton，调用rollback方法来终止这个事务，并且重新开始事务。这是能够知道事务是否被提交的唯一方式。捕捉一个SQLException会告诉你有什么问题，但是它并没有告诉你哪些已经被提交。因为你不能去指望并没有提交，所以调用rollback方法是能唯一确保的方式。<br>　　方法CoffeesTable.updateCoffeeSales演示了一个事务，并且在catch块中包含了调用rollback方法。如果应用程序继续并使用事务操作的结果，在catch块中rollback方法的调用会防止这些可能不正确数据的使用。</p>
<hr>
<h1 id="使用RowSet对象"><a href="#使用RowSet对象" class="headerlink" title="使用RowSet对象"></a>使用RowSet对象</h1><hr>
<p>JDBC RowSet对象相比ResultSet对象保存表格数据更灵活，更易于使用。</p>
<p>对于一些更受欢迎的RowSet使用那个，Oracle已经定义了五个接口，并且这些RowSet接口可以使用标准引用。本教程将会学习如何使用那个这些引用实现。</p>
<p>这些版本的RowSet接口以及它们的实现已经作为便利提供给程序员。程序员可以自由编写自己的javax.sql.RowSet接口的版本，以扩展五个RowSet接口的实现，或编写自己的实现。然而，许多程序员可能会发现标准参考实现已经满足了他们的需求，并将按它们所设计的使用。</p>
<p>本节介绍了RowSet接口和扩展此接口的以下接口：</p>
<ul>
<li><strong>JdbcRowSet</strong></li>
<li><strong>CachedRowSet</strong></li>
<li><strong>WebRowSet</strong></li>
<li><strong>JoinRowSet</strong></li>
<li><strong>FilteredRowSet</strong></li>
</ul>
<p>RowSet接口在javax.sql包中。所有RowSet对象都派生自ResultSet接口，因此共享其功能。使JDBC RowSet对象特别的是它们添加这些新功能：</p>
<ul>
<li>作为JavaBean组件</li>
<li>添加可滚动性或可更新性</li>
</ul>
<h2 id="作为JavaBean组件"><a href="#作为JavaBean组件" class="headerlink" title="作为JavaBean组件"></a>作为JavaBean组件</h2><hr>
<p>所有的RowSet对象都是JavaBean组件，这意味着它们有以下：</p>
<ul>
<li>属性（Properties）</li>
<li>JavaBean通知机制</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>所有的RowSet对象都有属性。属性是有相应getter和setter方法的字段。属性将暴露于构建工具（例如随IDE IDE和Eclipse一起提供的工具），使你可以可视化地操作bean。更多信息，请参阅<a href="">JavaBean</a>教程的<a href="">Properties</a>课程。</p>
<h3 id="JavaBean通知机制"><a href="#JavaBean通知机制" class="headerlink" title="JavaBean通知机制"></a>JavaBean通知机制</h3><p>RowSet对象使用JavaBeans事件模型，其中注册的组件在发生某些事件时被通知。对于所有的RowSet对象，有三个时间触发通知：</p>
<ul>
<li>游标移动</li>
<li>更新，插入或删除一行</li>
<li>改变整个RowSet的内容</li>
</ul>
<p>时间通知会发送到所有的监听器，也就是实现了RowSetListener接口的组件，并且监听器已经将自己添加到RowSet对象的组件列表中，以便在三个事件发生时通知。</p>
<p>监听器可以是诸如条形图之类的GUI组件。如果条形图是在RowSet对象中跟踪数据，则每当数据更改时，侦听器都希望知道新的数据值。因此，侦听器将实现RowSetListener方法来定义特定事件发生时将执行的操作。然后，监听器也必须添加到RowSet对象的监听器列表中。以下代码行将条形图组件bg与RowSet对象rs注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rs.addListener(bg);</span><br></pre></td></tr></table></figure>
<p>现在，每当游标移动时，将会通知bg，更改一行，或者所有rs都获取新的数据。</p>
<h2 id="添加可滚动性或可更新性"><a href="#添加可滚动性或可更新性" class="headerlink" title="添加可滚动性或可更新性"></a>添加可滚动性或可更新性</h2><hr>
<p>某些DBMS不支持可滚动（可滚动性）的结果集，有些不支持可更新（可更新性）的结果集。如果该DBMS的驱动不添加滚动或更新结果集的功能，则可以使用RowSet对象来执行此操作。默认情况下，RowSet对象是可滚动和可更新的，因此通过使用结果集的内容填充RowSet对象，可以有效地使结果集滚动并更新。</p>
<h2 id="RowSet对象的种类"><a href="#RowSet对象的种类" class="headerlink" title="RowSet对象的种类"></a>RowSet对象的种类</h2><hr>
<p>RowSet对象可以是连接或断开连接的。连接的RowSet对象使用JDBC驱动连接到关系型数据库，并在整个生命周期内维护该连接。断开连接RowSet只在从ResulteSet对象读取数据或将数据写回数据源时，与数据源建立连接。在从数据源读取或写入数据后，RowSet对象从它断开，因此变为“断开连接”。在其大多生命周期，非连接的RowSet对象与其数据源没有连接，并且独立运行。接下来的两个部分将告诉您连接或断开连接方式意味着什么是RowSet对象可以做什么。</p>
<h3 id="连接RowSet对象"><a href="#连接RowSet对象" class="headerlink" title="连接RowSet对象"></a>连接RowSet对象</h3><p>只有一个标准的RowSet实现是连接的RowSet对象：<strong>JdbcRowSet</strong>。它始终连接到数据库，JdbcRowSet对象与ResultSet对象最相似，通常用作包装器，以使另一种不可滚动和只读的ResultSet对象成为可滚动和可更新的。</p>
<p>作为JavaBeans组件，可以使用JdbcRowSet对象，例如在GUI工具中选择JDBC驱动。JdbcRowSet对象可以这样使用，因为它实际上是获取其连接到数据库驱动的包装器。</p>
<h3 id="断开连接RowSet对象"><a href="#断开连接RowSet对象" class="headerlink" title="断开连接RowSet对象"></a>断开连接RowSet对象</h3><p>其他四个实现是断开连接RowSet实现。断开连接RowSet对象具有连接RowSet对象的所有功能，并且它们具有仅对断开连接RowSet对象可用的附加功能。例如，不必维护与数据源的连接，使断开连接RowSet对象比JdbcRowSet对象或ResultSet对象更加轻量级。断开连接RowSet对象也是可序列化的，并且可序列化和轻量化的组合使它成为通过网络发送数据的理想选择。甚至可以用于将数据发送到瘦客户端，如PDA和手机。</p>
<p><strong>CachedRowSet</strong>接口定义了所有断开连接<strong>RowSet</strong>对象的基本功能。另外三个是CachedRowSet接口的扩展，它们提供更专业的功能。以下信息显示它们是如何相关的：</p>
<p><strong>CachedRowSet</strong>对象具有<strong>JdbcRowSet</strong>对象的所有功能，还可以执行以下操作：</p>
<ul>
<li>获取与数据源的连接并执行查询</li>
<li>从生成的ResultSet对象中读取数据，并使用该数据填充自身</li>
<li>当断开连接时处理并更改数据</li>
<li>重新连接到数据源以将更改写回</li>
<li>检查与数据源的冲突并解决这些冲突</li>
</ul>
<p><strong>WebRowSet</strong>对象具有<strong>CachedRowSet</strong>对象的所有功能，还可以执行以下操作：</p>
<ul>
<li>将自己写为XML文档</li>
<li>读取一个描述WebRowSet对象的XML文档</li>
</ul>
<p><strong>JoinRowSet</strong>对象具有<strong>WebRowSet</strong>对象（因此也有<strong>CachedRowSet</strong>对象的所有功能），还可以执行以下操作：</p>
<ul>
<li>形成相当于SQL JOIN，而不必连接到数据源</li>
</ul>
<p><strong>FilteredRowSet</strong>对象同样具有<strong>WebRowSet</strong>对象（因此也是<strong>CachedRowSet</strong>对象）的所有功能，还可以执行以下操作：</p>
<ul>
<li>应用过滤条件，以便只显示所选数据。这相当于对RowSet对象执行查询，而不必使用查询语言或连接到数据源。</li>
</ul>
]]></content>
      <categories>
        <category>java 基础</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web（一）MVC框架</title>
    <url>/2017/07/29/Spring-Web%EF%BC%88%E4%B8%80%EF%BC%89MVC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}

.quote{
    border: 1px solid #ccc;
    background-color:#f8f8f8;
    padding:20px;
}
</style>

<p><a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc">原文链接</a>：参考文档的这一部分涵盖了Spring框架对表示层（特别是基于Web的演示层）的支持，包括在Web应用程序中支持WebSocket风格的消息传递。</p>
<p>Spring Framework自己的Web框架，Spring Web MVC，在前两章中有介绍。随后的章节涉及Spring框架与其他Web技术（如JSF）的集成。</p>
<p>接下来是Spring Framework的MVC portlet框架。</p>
<span id="more"></span>

<hr>
<h1 id="Spring-Web-MVC框架简介"><a href="#Spring-Web-MVC框架简介" class="headerlink" title="Spring Web MVC框架简介"></a>Spring Web MVC框架简介</h1><hr>
<p>Spring Web模型-视图-控制器（MVC）框架是围绕一个<strong>DispatcherServlet</strong>设计，它将请求分派给处理器（handler），Spring MVC具有可配置的处理器映射器，视图解析器，本地化，时区和主题解析以及上传文件支持。默认的handler是基于**@Controller<strong>和</strong>@RequestMapping<strong>注解，提供了广泛的灵活处理方法。随着Spring 3.0的引入，</strong>@Controller<strong>机制还允许你通过</strong>@PathVariable**注解和其他功能创建RESTful Web站点和应用程序。</p>
<div class="quote">
“开放扩展..."在Spring Web MVC和Spring中的一个关键设计原则是“开放扩展，关闭修改"原则。<br/>
Spring Web MVC的核心类中的一些方法被标记为final。作为开发人员，你不能覆盖这些方法来提供自己的行为。这并不是随意设计的，而是特别考虑到这个原则。<br/>
有关这个原理的解释，请参考Seth Ladd的Expert Spring Web MVC和Web Flow;具体参见第一版第117页的“A Look At Design"一节。或者，参见
[Bob Martin, The Open-Closed Principle (PDF)](https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf)
当你使用Spring MVC时，你不能向final方法添加advice 。例如，你不能向AbstractController.setSynchronizeOnSession()方法添加advice 。有关AOP代理的更多信息，以及为什么不能向final方法添加advice ，请参阅第11.6.1节“[了解AOP代理"](http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#aop-understanding-aop-proxies)。
</div> 

<p>在Spring Web MVC中，你可以使用任何对象作为命令或表单支持对象;你不需要实现框架特定的接口或基类。Spring的数据绑定是高度灵活的：例如，它将类型不匹配视为可由应用程序评估的验证错误，而不是系统错误。因此，你不需要将业务对象的属性复制为表单对象中简单、无类型的字符串，仅用于处理无效提交，或者用于正确转换字符串。相反，它通常最好直接绑定到你的业务对象。   </p>
<p>Spring的视图解析非常灵活。<strong>Controller</strong>通常负责准备一个带有数据和选择的视图名称的模型Map，但它也可以直接写入响应流并完成请求。视图名称解析是高度可配置的，通过文件拓展或Accept header content type negotiation，通过bean名称，一个属性文件，或甚至一个ViewResolver实现。这个model（MVC中的M）是一个Map接口，它允许对视图技术的完全抽象。你可以直接与基于模板的渲染技术（如JSP，Velocity和Freemarker）集成，或直接生成XML，JSON，Atom和许多其他类型的内容。model Map简单地被转换成适当的格式，如JSP请求属性，Velocity模板模型。      </p>
<h2 id="Spring-Web-MVC的特点"><a href="#Spring-Web-MVC的特点" class="headerlink" title="Spring Web MVC的特点"></a>Spring Web MVC的特点</h2><hr>
<div class="quote">
Spring Web Flow
Spring Web Flow（SWF）旨在成为管理Web应用程序页面流的最佳解决方案。<br/>
在Servlet和Portlet环境中，SWF与Spring MVC和JSF等现有框架集成。如果你有一个业务流程会受益于会话模型而不是纯粹的请求模型，那么SWF可能是这个的解决方案。<br/>
SWF允许你捕获逻辑页面流作为自包含模块，以便可以在不同场景中重用，因此非常适合通过controller导航来引导用户驱动业务流程的Web应用程序模块。
</div>

<p>Spring的Web模块包含许多独特的Web支持功能：</p>
<ul>
<li><em>清晰的角色分离</em>。每个角色 — 控制器，验证器，命令对象，表单对象，模型对象，<strong>DispatcherServlet</strong>，处理器映射器，视图解析器等等 - 可以由专门的对象来实现。</li>
<li><em>框架以及作为JavaBeans的应用程序类的强大而直观的配置。</em>此配置功能包括跨上下文的简单引用，例如从Web控制器到业务对象和验证器。</li>
<li><em>适应性，非侵入性和灵活性。</em>定义任何你需要的控制器方法签名，可能使用给定方案的参数注解之一（例如@RequestParam，@RequestHeader，@PathVariable等等）。</li>
<li><em>可重用的业务代码，不需要复制。</em>使用已有的业务对象作为命令或表单对象，而不是镜像它们来继承特定的框架基类。</li>
<li><em>可定制的绑定和验证。</em>类型不匹配作为保持违规值的应用程序级验证错误，本地化日期和数字绑定等，而不是对只使用仅包含字符串的表单对象进行手动解析和转换为业务对象。</li>
<li><em>可定制的处理器映射和视图解析。</em>处理器映射和视图解析策略的范围从简单的基于URL的配置到复杂的专用解析策略。Spring比那些需要特定技术的Web MVC框架更加灵活。</li>
<li><em>灵活的 model 传递。</em>使用name&#x2F;value Map的model传递支持与任何视图技术的轻松集成。</li>
<li><em>可定制的区域设置，时区和主题解析，支持带有或不带有Spring标签库的JSP，支持JSTL，支持Velocity，无需额外的桥接等。</em></li>
<li><em>一个简单而强大的JSP标签库，被称为Spring标签库，为数据绑定和主题等功能提供支持。</em>自定义标签在标记代码方面允许具有最大的灵活性。有关标签库描述符的信息，请参见附录标题为<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#spring-tld">第43章，spring JSP标签库</a></li>
<li><em>在Spring 2.0中引入的JSP表单标签库，使得在JSP页面中的写入表单更容易。</em>有关标签库描述符的信息，请参见附录标题为<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#spring-form-tld">Chapter 44，spring-form JSP Tag Library</a></li>
<li><em>Bean的生命周期作用域在当前的HTTP请求或HTTP Session中</em> 这不是Spring MVC本身的一个特定功能，而是Spring MVC使用的WebApplicationContext容器。这些bean域在第7.5.4节[“Request, session, global session, application和 WebSocket域”](&#x2F;2017&#x2F;07&#x2F;25&#x2F;Spring-核心技术（一）IoC容器&#x2F;#Request, session, global session, application和 WebSocket域<br>)中描述</li>
</ul>
<h2 id="其他MVC实现的可插拔性"><a href="#其他MVC实现的可插拔性" class="headerlink" title="其他MVC实现的可插拔性"></a>其他MVC实现的可插拔性</h2><hr>
<p>对于某些项目，非Spring MVC实现更为可取。许多团队希望利用他们在现有的技能和工具上的投资，例如使用JSF。</p>
<p>如果你不想使用Spring的Web MVC，但打算利用Spring提供的其他解决方案，你可以轻松地将Web MVC框架与你选择的Spring集成。通过它的<strong>ContextLoaderListener</strong>简单地启动一个Spring根应用程序上下文，并通过任何action对象中的ServletContext属性（或Spring的各自的帮助方法）访问它。没有涉及“插件”，因此不需要专门的集成。从Web层的角度来看，你只是将Spring作为库使用，将根应用程序上下文实例作为入口点。</p>
<p>即使不使用Spring Web MVC,注册bean和Spring的Service也是唾手可得的。在这种情况下，Spring不会与其他Web框架竞争。它只是解决了纯Web MVC框架没有解决的许多事情，从bean配置到数据访问和事务处理。所以你可以使用Spring中间层和&#x2F;或数据访问层来丰富你的应用程序，即使你只想使用JDBC或Hibernate的事务抽象。</p>
<hr>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><hr>
<p>Spring的Web MVC框架与许多其他Web MVC框架一样，请求驱动，围绕一个中央Servlet设计，将请求分发给控制器，并提供了其他促进Web应用程序开发的功能。然而，Spring的<strong>DispatcherServlet</strong>做的不仅仅是这些。它完全与Srping Ioc容器集成，这样允许你使用Spring有的其他任何功能。</p>
<p>Spring Web MVC <strong>DispatcherServlet</strong>的请求处理工作流程如下图所示。精通模式的读者会意识到DispatcherServlet是“前端控制器”设计模式的表现（这是Spring Web MVC与许多其他领先的Web框架共享的一种模式）。   </p>
<p><em>Spring Web MVC（高级别）中的请求处理工作流程</em><br><img src="/images/spring/mvc.png" alt="mvc"></p>
<p><strong>DispatcherServlet</strong>实际上是一个Servlet（它继承自HttpServlet基类），并因此在你的web应用程序中声明。你需要通过使用URL映射，来映射你想要<strong>DispatcherServlet</strong>处理的请求。这有一个在Serlvet 3.0+ 环境中标准的Java EE Servlet配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;example&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>());</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/example/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，所有以&#x2F;example开示的请求都会由名为example的DispatcherServlet实例处理。</p>
<p><strong>WebApplicationInitializer</strong>是一个由Spring MVC提供的接口，它确保你的基于代码的配置被检测到，并且自动用于初始化任何Servlet 3 容器。一个这个接口的名为<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>的抽象基类实现，它通过简单地指定其servlet映射和列出配置类来更容易地注册<strong>DispatcherServlet</strong>-它是设置你的Spring MVC应用程序最推荐的方式。更多详细信息，请参阅<a href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84Servlet%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96">“基于代码的Servlet容器初始化”</a>。</p>
<p><strong>DispatcherServlet</strong>实际上是一个<strong>Servlet</strong>（它继承自HttpServlet基类），并因此在你的web应用程序的<strong>web.xml</strong>中声明。你需要在同一个<strong>web.xml</strong>文件中通过使用URL映射，来映射你想要<strong>DispatcherServlet</strong>处理的请求。这是标准的Java EE Servlet配置。以下示例显式了这样的<strong>DispatcherServlet</strong>的声明和映射：</p>
<p>以下是等同于上面基于代码的配置的web.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/example/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如第7.15节<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#context-introduction">“ApplicationContext的附加功能”</a>中所述，Spring中的<strong>ApplicationContext</strong>实例可以被限定作用域。在Web MVC框架中，每个<strong>DispatcherServlet</strong>都有它自己的<strong>WebApplicationContext</strong>，这个上下文继承了在根<strong>WebApplicationContext</strong>中定义的所有bean。根<strong>WebApplicationContext</strong>应该包含应该在其他上下文和Servlet实例之间共享的所有的基础框架bean。这些继承的bean可以在特定servlet域内被覆盖，并且你可以在给定的Servlet实例本地定义一个新的特定域bean。</p>
<p><em>Spring Web MVC中的典型上下文层次结构</em><br><img src="/images/spring/mvc-context-hierarchy.png" alt="mvc"></p>
<p>在初始化<strong>DispatcherServlet</strong>时，Spring MVC将在Web应用程序的<strong>WEB-INF</strong>目录中查找名为**[servlet-name] -servlet.xml**的文件，并创建在那里定义的bean，覆盖在全局域内任何使用相同名称定义的bean的定义。</p>
<p>请考虑以下DispatcherServlet Servlet配置（在web.xml文件中）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>golfing<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>golfing<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/golfing/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>随着上面的Servlet配置到位，你会需要在你的应用程序中有一个名为**&#x2F;WEB-INF&#x2F;golfing-servlet.xml**的文件；这个文件将包含你的所有Spring Web MVC特定组件（beans）。你可以通过Servlet初始化参数更改此配置文件的确切位置（有关详细信息，请参阅下文）。</p>
<p>对于单DispatcherServlet情景来说，也可以只有一个root context。。</p>
<p><em>Spring Web MVC中的单个根上下文</em><br><img src="/images/spring/mvc-root-context.png" alt="mvc"><br>这可以通过设置一个空的l<strong>ContextConfigLocationl</strong> servlet 初始化参数进行配置，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>WebApplicationContext</strong>是普通ApplicationContext的扩展，它有一些Web应用程序所需的额外功能。它与普通的ApplicationContext不同之处在于它能够解析主题（参见<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc-themeresolver">第22.9节“使用主题”</a>），并且知道它与哪个Servlet相关联（通过链接到ServletContext）。<strong>WebApplicationContext</strong>绑定在<strong>ServletContext</strong>中，并且如果你需要访问它，可以通过在<strong>RequestContextUtils</strong>类上使用静态方法，随时查找<strong>WebApplicationContext</strong>。</p>
<p>请注意，我们可以通过基于Java的配置实现相同的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GolfingWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// GolfingAppConfig定义将在root-context.xml中的bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; GolfingAppConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// GolfingWebConfig定义了将在golfing-servlet.xml中的bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; GolfingWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/golfing/*&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebApplicationContext中的特殊Bean类型"><a href="#WebApplicationContext中的特殊Bean类型" class="headerlink" title="WebApplicationContext中的特殊Bean类型"></a>WebApplicationContext中的特殊Bean类型</h2><hr>
<p>Spring <strong>DispatcherServlet</strong>使用特殊的bean来处理请求并渲染适当的视图。这些bean是Spring MVC的一部分。你可以通过在<strong>WebApplicationContext</strong>中简单配置一个或多个选择要使用的特殊bean。但是，你最初不需要这样做，因为如果你没有做任何配置的话，Spring MVC已经维护了一个默认bean列表，。更多信息在下一节。首先看下表列出<strong>DispatcherServlet</strong>依赖的特殊bean类型。</p>
<p><em>WebApplicationContext中的特殊bean类型</em></p>
<table>
<thead>
<tr>
<th>Bean类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HandlerMapping</td>
<td>根据一些标准将传入的请求映射到处理器以及一个pre-和post-processors（处理器拦截器）列表上，其细节因<strong>HandlerMapping</strong>实现而异。最流行的实现支持注解控制器，但其他实现也存在。</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>帮助<strong>DispatcherServlet</strong>调用映射到请求上的处理器，而不管实际调用哪个处理器。例如，调用一个注解的控制器需要解析各种注解。因此，<strong>HandlerAdapter</strong>的主要目的是将<strong>DispatcherServlet</strong>和这些细节屏蔽开。</td>
</tr>
<tr>
<td>HandlerExceptionResolver</td>
<td>映射异常到视图上，也允许更复杂的异常处理代码。</td>
</tr>
<tr>
<td>ViewResolver</td>
<td>解析基于逻辑字符串的视图名称为实际的<strong>View</strong>类型。</td>
</tr>
<tr>
<td>LocaleResolver&amp;LocaleContextResolver</td>
<td>解析客户端使用的区域设置以及可能的时区，以便能够提供国际化的视图</td>
</tr>
<tr>
<td>ThemeResolver</td>
<td>解析你的Web应用程序可以使用的主题，例如，提供个性化的布局</td>
</tr>
<tr>
<td>MultipartResolver</td>
<td>解析multi-part请求，例如支持处理从HTML表单文件上传。</td>
</tr>
<tr>
<td>FlashMapManager</td>
<td>存储并获取“输入”和“输出”的FlashMap，它可以用于将属性从一个请求传递给另一个请求，通常是跨重定向。</td>
</tr>
</tbody></table>
<h2 id="默认DispatcherServlet配置"><a href="#默认DispatcherServlet配置" class="headerlink" title="默认DispatcherServlet配置"></a>默认DispatcherServlet配置</h2><hr>
<p>如上一节中针对每个特殊bean所述，<strong>DispatcherServlet</strong>会维护默认使用的实现列表。这些信息保存在<strong>org.springframework.web.servlet</strong>包中的<strong>DispatcherServlet.properties</strong>文件中。</p>
<p>所有的特殊bean都有一些合理的默认值。虽然迟早你需要自定义一个或多个这些bean提供的属性。例如，配置一个<strong>InternalResourceViewResolver</strong>，设置他的<strong>prefix</strong>属性为视图文件的父路径是很常见的。</p>
<p>不管具体细节，需要明白的一个重要概念是，一旦你在你的<strong>WebApplicationContext</strong>中配置特殊bean（例如InternalResourceViewResolver ），你有效地覆盖了该特殊bean类型的默认实现列表。例如，如果配置了InternalResourceViewResolver，默认的ViewResolver实现列表会被忽视。</p>
<p>在第16节[“配置Spring MVC”](#配置Spring MVC)中，你将了解配置Spring MVC的其他选项，包括MVC Java配置和MVC XML命名空间，这两个都提供了一个简单的起点，这假定你对Spring MVC的工作原理并不太了解。无论你选择如何配置应用程序，本节中介绍的概念都是基本的，应该对你有所帮助。</p>
<h2 id="DispatcherServlet处理顺序"><a href="#DispatcherServlet处理顺序" class="headerlink" title="DispatcherServlet处理顺序"></a>DispatcherServlet处理顺序</h2><hr>
<p>在你设置了一个<strong>DispatcherServlet</strong>，并且对于该特定<strong>DispatcherServlet</strong>进来了一个请求后，<strong>DispatcherServlet</strong>将按如下所示开始处理请求：</p>
<ul>
<li>在这个请求中<strong>WebApplicationContext</strong>被搜索和绑定为一个属性，这样控制器和其他元素在处理过程中可以使用。默认它被绑定到<strong>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</strong>这个key上。</li>
<li>语言环境解析器被绑定到request上，这样使处理过程中的元素能够解析语言环境设置来在处理request时使用（渲染视图，准备数据等）。如果你不需要语言环境解析，则不需要它。</li>
<li>主题解析器被绑定到request上，使元素（如视图）决定要使用哪个主题。如果不使用主题，可以忽略它。</li>
<li>如果你指定了multiparts文件解析器，则会检查该request的multipart;如果找到multipart，request会被包装在一个<strong>MultipartHttpServletRequest</strong>中，以便处理过程中的其他元素进一步处理。有关multiparts处理的更多信息，请参见<a href="#Spring%E7%9A%84multipart%EF%BC%88%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%89%E6%94%AF%E6%8C%81">第10节“Spring的multipart（文件上传）支持”</a>。</li>
<li>搜索适当的处理器。如果找到一个处理器，与处理器关联的执行链（预处理器，后处理器和控制器）被执行，以便准备一个model或rendering。</li>
<li>如果返回一个modle，视图会被渲染。如果没有model返回，（可能是由于预处理器或后处理器基于安全原因拦截请求）则没有视图会被渲染，因为请求可能已经被完成了。</li>
</ul>
<p>处理器异常解析器被声明在<strong>WebApplicationContext</strong>中，它可以提取在处理请求的过程中抛出的异常。使用这些异常解析器使你可以定义自定义的行为来解决异常。</p>
<p>Spring <strong>DispatcherServlet</strong>同样支持由Servlet API指定的<em>last-modification-date</em> 的返回。对于指定请求确定最后修改日期的过程很简单：<strong>DispatcherServlet</strong>查找一个适当的处理器映射器，并检验发现的处理器是否实现了<strong>LastModified</strong>接口。如果是的话，<strong>LastModified</strong>接口**long getLastModified(request)**方法的值被返回给客户端。</p>
<p>你可以通过向<strong>web.xml</strong>文件中的Servlet声明添加Servlet初始化参数（<strong>init-param</strong>元素）来自定义单独的<strong>DispatcherServlet</strong>实例。有关支持的参数列表，请参见下表。</p>
<p><em>DispatcherServlet的初始化参数</em></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>contextClass</td>
<td>实现了<strong>WebApplicationContext</strong>的类，它实例化了这个Servlet使用的上下文。默认情况下，使用<strong>XmlWebApplicationContext</strong>。</td>
</tr>
<tr>
<td>contextConfigLocation</td>
<td>传递给上下文实例（由contextClass指定）的字符串，以指示那里可以找到上下文。该字符串可能包含多个字符串（使用逗号作为分隔符）来支持多个上下文。在多个上下文位置中定义了一个bean两次，那么最后位置定义的优先</td>
</tr>
<tr>
<td>namespace</td>
<td><strong>WebApplicationContext</strong>的命名空间。默认为**[servlet-name] -servlet**。</td>
</tr>
</tbody></table>
<hr>
<h1 id="实现控制器"><a href="#实现控制器" class="headerlink" title="实现控制器"></a>实现控制器</h1><hr>
<p>控制器提供对应用程序行为的访问，这些行为你通常通过一个service接口定义。控制器解释用户输入并将其转换为一个model，该model通过视图表现给用户。Spring以一个非常抽象的方式实现控制器，使你能够创建各种各样的控制器。</p>
<p>Spring 2.5为MVC控制器引入了基于注解的编程式模型，它使用诸如**@RequestMapping<strong>，</strong>@RequestParam<strong>，</strong>@ModelAttribute**等注解。此注解支持可用于Servlet MVC和Portlet MVC。以这种样式实现的控制器不必扩展特定的基类或实现特定的接口。此外，它们通常不直接依赖于Servlet或Portlet API，尽管你可以轻松配置对Servlet或Portlet设施的访问。</p>
<blockquote>
<p>在Github上的可用的<a href="https://github.com/spring-projects/">spring-projects Org</a>，许多Web应用程序利用本节中描述的注解支持，包括MvcShowcase，MvcAjax，MvcBasic，PetClinic，PetCare等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/helloWorld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，**@Contorller<strong>和</strong>@RequestMapping<strong>注解允许灵活的方法名称和签名。在这个特殊例子中，方法接收一个</strong>Model<strong>并且以</strong>String<strong>返回一个视图名称，但也可以使用其他各种方法参数和返回值，本节稍后会介绍。</strong>@Controller<strong>和</strong>@RequestMapping**以及一些其他注解构成了Spring MVC实现的基础。本节介绍这些注解以及它们在Servlet环境中最常用的方式。。</p>
<h2 id="使用-Controller定义一个控制器"><a href="#使用-Controller定义一个控制器" class="headerlink" title="使用@Controller定义一个控制器"></a>使用@Controller定义一个控制器</h2><hr>
<p><strong>@Controller</strong>注解表示这个特定类用于 <em>控制器</em> 角色。Spring不要求你继承任何控制器基类或引用Servlet API。但是，如果有需要，你仍然可以引用Servlet特定的功能。</p>
<p><strong>@Controller</strong>注解对于被注解的类作为模板，表明被注解类的角色。调度器扫描这些注解的类用于映射方法，并且自动探测**@RequestMapping**注解（请参阅下一节）。</p>
<p>你可以显式定义注解的控制器bean，通过在调度器的上下文中使用标准的Spring bean定义。然而，**@Controller**模型还允许自动检测，这与Spring对在类路径中探测组件类和从他们中自动注册bena定义的支持对齐。</p>
<p>要开启对这样的注解控制器自动探测的支持，你要向你的配置中添加组件扫描。如下面XML片段那样使用spring-context schema：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.springframework.samples.petclinic.web&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-RequestMapping映射请求"><a href="#使用-RequestMapping映射请求" class="headerlink" title="使用@RequestMapping映射请求"></a>使用@RequestMapping映射请求</h2><hr>
<p>你使用**@RequestMapping**注解将诸如&#x2F;appointments的URL映射到整个类或指定的处理器方法上。通常，类级注解将特定请求路径（或路径模式）映射到表单控制器上，并且使用另外的方法级注解缩小了对特定HTTP方法的请求方法（“GET”，“POST”等）或HTTP请求参数条件的主映射。</p>
<p>Petcare示例中的以下例子显式了使用此注解的Spring MVC应用程序中的控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/appointments&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppointmentsController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AppointmentBook appointmentBook;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppointmentsController</span><span class="params">(AppointmentBook appointmentBook)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appointmentBook = appointmentBook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Appointment&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appointmentBook.getAppointmentsForToday();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/&#123;day&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Appointment&gt; <span class="title function_">getForDay</span><span class="params">(<span class="meta">@PathVariable</span> <span class="meta">@DateTimeFormat(iso=ISO.DATE)</span> Date day, Model model)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appointmentBook.getAppointmentsForDay(day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/new&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> AppointmentForm <span class="title function_">getNewForm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppointmentForm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Valid</span> AppointmentForm appointment, BindingResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;appointments/new&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        appointmentBook.addAppointment(appointment);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/appointments&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，**@RequestMapping<strong>用在了很多地方。第一个用法是在类型（类）级别，它表示此控制器中的所有处理器方法都是相对于&#x2F;appointments路径。get()方法上还有一个更细化的</strong>@RequestMapping**：它只接收GET请求，这意味着对&#x2F;appointments的HTTP GET会调用此方法。add()有一个类似的细化注解，而getNewForm()将HTTP方法和路径的定义组合成一个，这样对于appointments&#x2F;new的GET请求将会由这个方法处理。</p>
<p>getForDay()方法显式了@RequestMapping的另一种用法：URI模板。（参见<a href="#URI%E6%A8%A1%E6%9D%BF">“URI模板”</a>一节）。</p>
<p>在类级别上的**@RequestMapping<strong>不是必须的。没有它，所有的路径都是绝对的，而不是相对。PetClinic示例应用程序的以下例子显式了使用</strong>@RequestMapping**的multi-action控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinicController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Clinic clinic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClinicController</span><span class="params">(Clinic clinic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clinic = clinic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">welcomeHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/vets&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelMap <span class="title function_">vetsHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelMap</span>(<span class="built_in">this</span>.clinic.getVets());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子没有指定GET与PUT，POST等等，因为**@RequestMapping<strong>默认映射所有的HTTP方法。使用</strong>@RequestMapping(method&#x3D;GET)<strong>或</strong>@GetMapping** 来缩小这个映射.</p>
<h3 id="组合-RequestMapping的变体"><a href="#组合-RequestMapping的变体" class="headerlink" title="组合@RequestMapping的变体"></a>组合@RequestMapping的变体</h3><p>Spring框架4.3引入了**@RequestMapping<strong>注解的以下方法级组合变体，这有助于简化常见HTTP方法的映射，并更好地表达注解处理器方法的语义。例如，</strong>@GetMapping<strong>可以被读取为一个</strong>GET** <strong>@RequestMapping</strong>。</p>
<ul>
<li><strong>@GetMapping</strong></li>
<li><strong>@PostMapping</strong></li>
<li><strong>@PutMapping</strong></li>
<li><strong>@DeleteMapping</strong></li>
<li><strong>@PatchMapping</strong></li>
</ul>
<p>以下示例通过组合的**@RequestMapping**注解进行简化，显式了上一节中的AppointmentsController的修改版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/appointments&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppointmentsController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AppointmentBook appointmentBook;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppointmentsController</span><span class="params">(AppointmentBook appointmentBook)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appointmentBook = appointmentBook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Appointment&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appointmentBook.getAppointmentsForToday();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;day&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Appointment&gt; <span class="title function_">getForDay</span><span class="params">(<span class="meta">@PathVariable</span> <span class="meta">@DateTimeFormat(iso=ISO.DATE)</span> Date day, Model model)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appointmentBook.getAppointmentsForDay(day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/new&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AppointmentForm <span class="title function_">getNewForm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppointmentForm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Valid</span> AppointmentForm appointment, BindingResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;appointments/new&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        appointmentBook.addAppointment(appointment);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/appointments&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller和AOP代理"><a href="#Controller和AOP代理" class="headerlink" title="@Controller和AOP代理"></a>@Controller和AOP代理</h3><p>在某些情况下，控制器可能需要在运行时期用AOP代理进行装饰。一个例子是如果你选择在控制器上直接使用**@Transactional<strong>注解。在这种情况下，对于控制器，我们建议使用基于类的代理。这通常是控制器的默认选择。但是，如果控制器必须实现一个不是Spring Context回调（例如</strong>InitializingBean<strong>，</strong>*Aware<strong>等）的接口，你可能需要显式配置基于类的代理。例如，使</strong>&lt;tx:annotation-driven&#x2F;&gt;<strong>，更改为</strong>&lt;tx:annotation-driven proxy-target-class &#x3D;”true”&#x2F;&gt;**。</p>
<h3 id="Spring-MVC-3-1中对-RequestMapping方法的新支持类"><a href="#Spring-MVC-3-1中对-RequestMapping方法的新支持类" class="headerlink" title="Spring MVC 3.1中对@RequestMapping方法的新支持类"></a>Spring MVC 3.1中对@RequestMapping方法的新支持类</h3><p>Spring 3.1为**@RequestMapping<strong>方法引入了一组新的支持类，分别叫做</strong>RequestMappingHandlerMapping<strong>和</strong>RequestMappingHandlerAdapter**。推荐使用它们，即使需要使用Spring MVC 3.1和之后版本的新功能。MVC命名空间和MVC Java配置默认启用这些新的支持类，但是如果你不使用，则必须显式配置。本节介绍旧支持类和新支持类之间的一些重要区别。</p>
<p>在Spring 3.1之前，类型和方法级请求映射是在两个不同的阶段进行了检查— 首先由<strong>DefaultAnnotationHandlerMapping</strong>选择一个控制器，然后通过<strong>AnnotationMethodHandlerAdapter</strong>缩小实际方法调用范围。</p>
<p>使用Spring 3.1中的新支持类，<strong>RequestMappingHandlerMapping</strong>是唯一可以决定哪个方法应该处理请求的地方。将这些控制器方法视为从类型和方法级**@RequestMapping**信息派生的每个方法的映射的唯一端点集合。</p>
<p>这开启了一些新的可能性。一旦<strong>HandlerInterceptor</strong>或<strong>HandlerExceptionResolver</strong>现在可以期望基于对象的处理器作为<strong>HandlerMethod</strong>，这就允许他们检查确切的方法，以及它的参数和相关注解。URL的处理就不再需要跨不同的控制器进行拆分。</p>
<p>还有几件事情已经不复存在了：</p>
<ul>
<li>首先使用<strong>SimpleUrlHandlerMapping</strong>或<strong>BeanNameUrlHandlerMapping</strong>选择控制器，然后基于**@RequestMapping**注解来缩小方法。</li>
<li>依靠方法名称作为一种回退机制，来消除两个没有映射URL路径的明确路径，但是其他方面匹配（例如HTTP方法）的@RequestMapping方法之间的歧义。在新的支持类中，**@RequestMapping**方法必须被唯一地映射。</li>
<li>如果没有其他控制器方法更具体地匹配话，使一个单独的默认方法（没有明确路径映射）来处理请求。在新的支持类中，如果一个匹配的方法都没有找到，就会产生一个404错误。</li>
</ul>
<p>上面这些功能依旧被现有支持类支持。不过要利用新的Spring MVC 3.1功能，你需要使用新的支持类。</p>
<h3 id="URI模板"><a href="#URI模板" class="headerlink" title="URI模板"></a>URI模板</h3><p>可以使用URI模板方便地访问**@RequestMapping**方法中URL的所选部分。</p>
<p>URI模板是一个类似URI的字符串，包含一个或多个变量名称。当你为这些变量替换值时，模板就变成了一个URI。URI模板的提议RFC定义了一个URI如何被参数化。例如，URI模板http://www.example.com/users/{userId}  包含变量userId。如果将fred值分配给变量会得到http://www.example.com/users/fred 。</p>
<p>在Spring MVC你可以在一个方法参数上使用**@PathVariable**注解，来绑定该参数到URI模板变量的值上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findOwner</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> ownerService.findOwner(ownerId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;owner&quot;</span>, owner);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;displayOwner&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URI模板 “&#x2F;owners&#x2F;{ownerId}”指定了变量名称为’owenerId’。当控制器处理这个请求时，会用在URI的适当部分中找到的值，来设置ownerId的值。例如，当进来一个 &#x2F;owner&#x2F;fred 请求时，ownerId的值为fred。</p>
<blockquote>
<p>要处理**@PathVariable**注解，Spring MVC需要按名称找到匹配的URI模板变量。你可以在注解中指定它。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findOwner</span><span class="params">(<span class="meta">@PathVariable(&quot;ownerId&quot;)</span> String theOwner, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者如果URI模板变量名称与方法参数名称匹配，则可以省略该详细信息。只要你的代码使用调试信息或Java 8上的-parameters编译器标记进行编译，Spring MVC会将方法参数与URI模板变量名称进行匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findOwner</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个方法可以有任意数量的@PathVariable注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, <span class="meta">@PathVariable</span> String petId, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> ownerService.findOwner(ownerId);</span><br><span class="line">    <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> owner.getPet(petId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;pet&quot;</span>, pet);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;displayPet&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在Map&lt;String，String&gt;参数上使用**@PathVariable**注解时，map会被填充上所有URI模板变量。</p>
<p>URI模板可以从类型和方法级**@RequestMapping**注解中进行组合。因此，可以使用&#x2F;owner&#x2F;42&#x2F;pets&#x2F;21等URL调用findPet()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelativePathUriTemplateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, <span class="meta">@PathVariable</span> String petId, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@PathVariable</strong>参数可以是任何简单的类型，如int，long，Date等。Spring会自动转换为适当的类型或抛出<strong>TypeMismatchException</strong>异常,如果Spring转换失败的话。你还可以注册解析其他数据类型的支持。请参见<a href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">“方法参数和类型转换”</a>一节以及<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89WebDataBinder%E5%88%9D%E5%A7%8B%E5%8C%96">“自定义WebDataBinder初始化”</a>一节。</p>
<h3 id="使用正则表达式的URI模板模式"><a href="#使用正则表达式的URI模板模式" class="headerlink" title="使用正则表达式的URI模板模式"></a>使用正则表达式的URI模板模式</h3><p>有时你需要更精确地定义URI模板变量。考虑URL“&#x2F;spring-web&#x2F;spring-web-3.0.5.jar”。你怎么把它分解成多个部分？</p>
<p><strong>@RequestMapping</strong>注解支持在URI模板变量中使用正则表达式。语法是**{varName:regex}**，其中第一部分定义了变量名，第二部分定义了正则表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;extension:\\.[a-z]+&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@PathVariable</span> String version, <span class="meta">@PathVariable</span> String extension)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径模式"><a href="#路径模式" class="headerlink" title="路径模式"></a>路径模式</h3><p>除了URI模板，**@RequestMapping<strong>注解和所有的</strong>@RequestMapping**变体还支持Ant风格的路径模式（例如&#x2F;myPath&#x2F;*.do）。还支持URI模板变量和Ant-style glob的组合（例如&#x2F;owners&#x2F; * &#x2F;pets&#x2F;{petId}）。</p>
<h3 id="路径模式比较"><a href="#路径模式比较" class="headerlink" title="路径模式比较"></a>路径模式比较</h3><p>当一个URL匹配多个模式时，使用排序来查找最具体的匹配。</p>
<p>具有较低数量的URI变量和通配符的模式被认为更具体。例如**&#x2F;hotels&#x2F;{hotel}&#x2F;*<strong>有一个URI变量和一个通配符，它被认为比有一个URI变量和两个通配符的</strong>&#x2F;hotels&#x2F;{hotel}&#x2F;****更具体。</p>
<p>如果两个模式有相同的数量，那么更长的那个被认为更具体。例如，**&#x2F;foo&#x2F;bar*<strong>比</strong>&#x2F;foo&#x2F;***更长，因此也被认为更具体。</p>
<p>当两个模式有相同的数量和长度，那么有更少通配符的会被认为更具体。例如&#x2F;hotels&#x2F;{hotel}比&#x2F;hotels&#x2F;*更具体。</p>
<p>还有一些额外的特殊规则：</p>
<ul>
<li><strong>默认的映射模式</strong>——&#x2F;** 比任何其他模式都更不具体。相比下&#x2F;api&#x2F;{a}&#x2F;{b}&#x2F;{c}更具体。</li>
<li><strong>前缀模式</strong>——例如&#x2F;public&#x2F;**比任何其他不包含双通配符的模式都更不具体。例如相比下&#x2F;public&#x2F;path3&#x2F;{a}&#x2F;{b}&#x2F;{c}更具体。</li>
</ul>
<p>有关详细信息，请参阅<strong>AntPathMatcher</strong>中的<strong>AntPatternComparator</strong>。注意，<strong>PathMatcher</strong>可以进行自定义（参见章节16.11“配置Spring MVC”中的<a href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D">第16.11节“路径匹配”</a>）。</p>
<h3 id="有占位符的路径模式"><a href="#有占位符的路径模式" class="headerlink" title="有占位符的路径模式"></a>有占位符的路径模式</h3><p><strong>@RequestMapping</strong>注解中的模式支持对本地属性和&#x2F;或系统属性和环境变量的**$ {…}<strong>占位符。在一个控制器需要映射的路径可能需要通过配置自定义的情况下，这很有用。关于占位符的更多信息，请参阅</strong>PropertyPlaceholderConfigurer**类的javadocs 。</p>
<h3 id="后缀模式匹配"><a href="#后缀模式匹配" class="headerlink" title="后缀模式匹配"></a>后缀模式匹配</h3><p>默认情况下，Spring MVC执行“**.*<strong>“后缀模式匹配，以便映射到</strong>&#x2F;person<strong>的控制器也隐式映射到</strong>&#x2F;person.***上。这使得通过URL路径可以轻松地请求资源的不同表示（例如&#x2F;person.pdf，&#x2F;person.xml）。</p>
<p>后缀模式匹配可以关闭或限制为一组明确注册用于内容协商的路径扩展。通常建议通过使用诸如**&#x2F;person&#x2F;{id}**之类的普通请求映射来减少歧义，这里其中的点可能不表示文件扩展名，例如&#x2F;person&#x2F;<a href="mailto:&#x6a;&#111;&#101;&#64;&#101;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#x6a;&#111;&#101;&#64;&#101;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a> vs &#x2F;person&#x2F;<a href="mailto:&#106;&#x6f;&#x65;&#x40;&#x65;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#46;&#x6a;&#115;&#111;&#110;">&#106;&#x6f;&#x65;&#x40;&#x65;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#46;&#x6a;&#115;&#111;&#110;</a>。此外，如下面的注释中所说明的，后缀模式匹配以及内容协商可能在某些情况下被用于尝试恶意攻击，因此有充分的理由有意义地限制它们。</p>
<p>对于后缀模式匹配请参见<a href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D">第16.11，“路径匹配”</a>,对于内容协商配置请参见<a href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">第16.6，“内容协商”</a>。</p>
<h3 id="后缀模式匹配和RFD"><a href="#后缀模式匹配和RFD" class="headerlink" title="后缀模式匹配和RFD"></a>后缀模式匹配和RFD</h3><p>Trustwave在2014年的论文中首次描述了反射文件下载 — Reflected file download（RFD）攻击。攻击类似于XSS，因为它依靠在响应中反映的输入（例如查询参数，URI变量）。然而，相比将JavaScript插入到HTML中，RFD攻击依赖浏览器切换为之行一个下载或者酱响应视为一个可执行脚本，如果如果根据文件扩展名双击（例如.bat，.cmd）的话。</p>
<p>在Spring MVC中@ResponseBody和ResponseEntity方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径拓展请求包含它们。但是请注意，禁用后缀模式匹配或禁用仅用于内容协商的路径扩展都可以有效地防止RFD攻击。</p>
<p>为了全面防范RFD，在渲染响应体之前，Spring MVC添加了一个Content-Disposition:inline;filename&#x3D;f.txt头来建议一个固定和安全的下载文件文件名。但只有当URL路径包含一个既不在白名单中，也不是用于内容协商的目的而注册的文件扩展名，才会这么做。然而，当URL直接输入浏览器时，这可能会产生一个副作用。</p>
<p>许多常见的路径扩展名默认为白名单。此外，REST API调用通常在浏览器中不是直接用作URL。然而，使用自定义HttpMessageConverter实现的应用程序可以明确地注册用于内容协商的文件扩展名，并且不会为此类扩展添加Content-Disposition头。见<a href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">第16.6节“内容协商”</a>。</p>
<blockquote>
<p>这是CVE-2015-5211工作的一部分。以下是报告中的其他建议：</p>
</blockquote>
<ul>
<li>编码而不是转义JSON响应。这也是OWASP XSS的建议。有关Spring的例子，请参阅<a href="#https://github.com/rwinch/spring-jackson-owasp">spring-jackson-owasp</a>。</li>
<li>将后缀模式匹配配置为关闭或仅限于明确注册的后缀。</li>
<li>使用将属性“useJaf”和“ignoreUnknownPathExtensions”设置为false来配置内容协商，这会对带有未知拓展名的URL响应一个406错误。如果URL自然希望在最后有一个点的话，这可能不是一个选择。</li>
<li>添加X-Content-Type-Options: nosniff头到响应。 Spring Security 4默认情况下执行此操作。</li>
</ul>
<h3 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h3><p>URI规范RFC 3986定义了在路径片段中包含name-value对的可能性。规范中没有使用特定的术语。一般的“URI路径参数”可能适用，尽管来自Tim Berners-Lee的旧帖子的更独特的“Matrix URI”也经常被使用并且是相当熟知的。在Spring MVC中，这些被称为矩阵变量（Matrix Variables）。</p>
<p>矩阵变量可以出现在任何路径段中，每个矩阵变量用“;”（分号）分隔。例如**:“&#x2F;cars;color&#x3D;red;year&#x3D;2012”<strong>。多个值可以是“,”（逗号）分隔</strong>“color&#x3D;red,green,blue”<strong>，或者变量名称可以重复</strong>“color&#x3D;red; color&#x3D;green; color&#x3D;blue”**。</p>
<p>如果URL期望包含矩阵变量，则请求映射模式必须使用URI模板来表示它们。这确保了请求可以正确匹配，无论矩阵变量是否存在，以及它们以什么顺序提供。</p>
<p>以下是提取矩阵变量“q”的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42;q=11;r=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId, <span class="meta">@MatrixVariable</span> <span class="type">int</span> q)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// petId == 42</span></span><br><span class="line">    <span class="comment">// q == 11</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有路径段都可能包含矩阵变量，因此在某些情况下，你需要更具体地确定变量预期位于何处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11/pets/21;q=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;)</span> <span class="type">int</span> q1,</span></span><br><span class="line"><span class="params">        <span class="meta">@MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;)</span> <span class="type">int</span> q2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q1 == 11</span></span><br><span class="line">    <span class="comment">// q2 == 22</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵变量可以定义为可选参数，并指定一个默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(<span class="meta">@MatrixVariable(required=false, defaultValue=&quot;1&quot;)</span> <span class="type">int</span> q)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q == 1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有矩阵变量可以在一个Map中获得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@MatrixVariable</span> MultiValueMap&lt;String, String&gt; matrixVars,</span></span><br><span class="line"><span class="params">        <span class="meta">@MatrixVariable(pathVar=&quot;petId&quot;)</span> MultiValueMap&lt;String, String&gt; petMatrixVars)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]</span></span><br><span class="line">    <span class="comment">// petMatrixVars: [&quot;q&quot; : 11, &quot;s&quot; : 23]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，为了使用矩阵变量，必须将<strong>RequestMappingHandlerMapping</strong>的<strong>removeSemicolonContent</strong>属性设置为<strong>false</strong>。默认设置为<strong>true</strong>。</p>
<blockquote>
<p>MVC Java配置和MVC命名空间都提供了使用矩阵变量的选项。<br>如果你使用Java配置，<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc-config-advanced-java">使用MVC Java Config进行高级自定义</a>部分将介绍如何自定义<strong>RequestMappingHandlerMapping</strong>。<br>在MVC命名空间中，**&lt;mvc:annotation-driven&gt;<strong>元素有</strong>enable-matrix-variables<strong>属性,它应该被设置为</strong>true<strong>。默认情况下它被设置为</strong>false**。 </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">enable-matrix-variables</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Consumable-Media-Types"><a href="#Consumable-Media-Types" class="headerlink" title="Consumable Media Types"></a>Consumable Media Types</h3><p>你可以通过指定Consumable Media Types的列表来缩小主要映射。只有当Content-Type请求头与指定的media type匹配时，才会匹配该请求。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPet</span><span class="params">(<span class="meta">@RequestBody</span> Pet pet, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumable Media Types表达式也可以以**!text&#x2F;plain<strong>否定，以匹配所有</strong>Content-Type<strong>不是</strong>text&#x2F;plain<strong>的请求。也可以考虑使用</strong>MediaType<strong>中提供的常量，例如</strong>APPLICATION_JSON_VALUE<strong>和</strong>APPLICATION_JSON_UTF8_VALUE**。</p>
<blockquote>
<p>在类型和方法级上支持consume条件。不像大多数其他条件，当用在类型级上时，方法级上的consumable类型覆盖而不是拓展类型级consumable类型。</p>
</blockquote>
<h3 id="Producible-Media-Types"><a href="#Producible-Media-Types" class="headerlink" title="Producible Media Types"></a>Producible Media Types</h3><p>你可以通过指定Producible Media Types列表来缩小主映射。只有当<strong>Accept</strong>请求头匹配这些值之一时，才会匹配该请求。此外，使用produce条件确保用于产生响应的实际内容类型与produce条件中指定的媒体类型相关。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Pet <span class="title function_">getPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 忽略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，在produce条件中指定的媒体类型还可以选择指定一个字符集。例如，在上面的代码片段中，我们指定与<strong>MappingJackson2HttpMessageConverter</strong>中配置的相同的媒体类型，包括UTF-8字符集。</p>
</blockquote>
<p>就像consumes一样，producible媒体类型表达式可以以!text&#x2F;plain否定，以匹配除为text&#x2F;plain的Accept之外的所有请求。还要考虑使用MediaType中提供的常量，例如APPLICATION_JSON_VALUE和APPLICATION_JSON_UTF8_VALUE。</p>
<blockquote>
<p>在类型和方法级上支持produces条件。不想大多数其他条件，当用在类型级上，方法级producible 类型覆盖而不是拓展类型级producible 类型。</p>
</blockquote>
<h3 id="请求参数和请求头值"><a href="#请求参数和请求头值" class="headerlink" title="请求参数和请求头值"></a>请求参数和请求头值</h3><p>你可以通过请求参数条件（如“myParam”，“!myParam”或​​“myParam&#x3D;myValue”）缩小请求匹配。前两个测试请求参数存在&#x2F;不存在，第三个为特定参数值。下面是一个请求参数值条件的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelativePathUriTemplateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, params = &quot;myParam=myValue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, <span class="meta">@PathVariable</span> String petId, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这同样也可用于对于测试请求头存在&#x2F;不存在或基于指定的请求头值来匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelativePathUriTemplateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String ownerId, <span class="meta">@PathVariable</span> String petId, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然可以使用媒体类型通配符匹配Content-Type和Accept标头值（例如“content-type&#x3D;text&#x2F;*“将匹配“text&#x2F;plain”和“text&#x2F;html”），但建议分别使用consumes和produces条件来代替。它们专门用于此目的。</p>
</blockquote>
<h3 id="HTTP-HEAD和HTTP-OPTIONS"><a href="#HTTP-HEAD和HTTP-OPTIONS" class="headerlink" title="HTTP HEAD和HTTP OPTIONS"></a>HTTP HEAD和HTTP OPTIONS</h3><p>映射到“GET”的**@RequestMapping**方法也隐式映射到“HEAD”，即不需要明确声明“HEAD”。处理一个HTTP HEAD请求就和处理HTTP GET一样，除了它仅统计响应体的字节数，并且设置在”Content-Length” 响应头中，而不写入响应体。</p>
<p><strong>@RequestMapping</strong>方法内置支持HTTP OPTIONS。默认情况下，HTTP OPTIONS请求通过在HTTP方法（明确声明在所有与URL模式匹配的@RequestMapping方法上的）上设置“Allow”响应头来处理。当没有HTTP方法被显式声明“Allow”，头被设置为”GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS”。理想地总是声明**@RequestMapping<strong>方法要处理的HTTP方法，或者使用专用的组合</strong>@RequestMapping**变体之一（请参阅<a href="#%E7%BB%84%E5%90%88@RequestMapping%E5%8F%98%E4%BD%93">“组合@RequestMapping变体”</a>一节）。</p>
<p>尽管不需要**@RequestMapping**方法可以映射到HTTP HEAD或HTTP OPTIONS，或同时两者。</p>
<h2 id="定义-RequestMapping处理器方法"><a href="#定义-RequestMapping处理器方法" class="headerlink" title="定义@RequestMapping处理器方法"></a>定义@RequestMapping处理器方法</h2><hr>
<p><strong>@RequestMapping</strong>处理器方法可以有非常灵活的签名。支持的方法参数和返回值将在以下部分中介绍。大多数参数可以按任意顺序使用，唯一的例外是BindingResult参数。这将在下一节中介绍。</p>
<blockquote>
<p>Spring 3.1分别为**@RequestMapping<strong>方法引入了一组新的支持类，分别叫做</strong>RequestMappingHandlerMapping<strong>和</strong>RequestMappingHandlerAdapter**推荐使用它们，即使需要使用Spring MVC 3.1和之后版本的新功能。MVC命名空间和MVC Java配置默认启用这些新的支持类，但是如果你不使用，则必须明确配置</p>
</blockquote>
<h3 id="支持的方法参数类型"><a href="#支持的方法参数类型" class="headerlink" title="支持的方法参数类型"></a>支持的方法参数类型</h3><p>以下是支持的方法参数类型：</p>
<ul>
<li><p><strong>Request</strong>或<strong>response</strong>对象（Servlet API）。选择任何具体的request或response类型，例如ServletRequest或HttpServletRequest。</p>
</li>
<li><p><strong>Session</strong>对象（Servlet API）：类型为<strong>HttpSession</strong>。这个类型的参数强制存在相应的session。因此，这样的参数从不为<strong>null</strong>。</p>
<blockquote>
<p><strong>Session</strong>访问可能不是线程安全的，特别在Servlet环境中。如果允许多个request同时访问session，请考虑将<strong>RequestMappingHandlerAdapter</strong>的“<strong>synchronizeOnSession</strong>“标志设置为“<strong>true</strong>“。</p>
</blockquote>
</li>
<li><p><strong>org.springframework.web.context.request.WebRequest</strong>或<strong>org.springframework.web.context.request.NativeWebRequest</strong>。允许通用请求参数访问以及request&#x2F;session属性访问，与本地Servlet&#x2F;Portlet API无关。</p>
</li>
<li><p><strong>java.util.Locale</strong>——当前的请求语言环境，由最具体的语言环境解析器确定，实际上是在MVC环境中配置的LocaleResolver&#x2F;LocaleContextResolver。</p>
</li>
<li><p><strong>java.util.TimeZone</strong>(Java 6+)&#x2F;<strong>java.time.ZoneId</strong>(Java 8)——当前请求相关联的时区，由LocaleContextResolver确定。</p>
</li>
<li><p><strong>java.io.InputStream&#x2F;java.io.Reader</strong>——访问请求的内容。该值是由Servlet API暴露的原生InputStream&#x2F;Reader。</p>
</li>
<li><p><strong>java.io.OutputStream&#x2F;java.io.Writer</strong>——用于生成响应的内容。该值是由Servlet API暴露的原生 OutputStream&#x2F;Writer。</p>
</li>
<li><p><strong>org.springframework.http.HttpMethod</strong>——HTTP请求方法。</p>
</li>
<li><p><strong>java.security.Principal</strong>——包含当前验证的用户</p>
</li>
<li><p><strong>@PathVariable</strong>注解参数——用于访问URI模板变量。请参阅<a href="#URI%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F">“URI模板模式”</a>一节。</p>
</li>
<li><p><strong>@MatrixVariable</strong>注解参数——用于访问位于URI路径段中的name-value对。请参阅<a href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E9%87%8F">“矩阵变量”</a>一节。</p>
</li>
<li><p><strong>@RequestParam</strong>注解参数——用于访问特定的Servlet请求参数。参数值将转换为声明的方法参数类型。请参阅<a href="#%E4%BD%BF%E7%94%A8@RequestParam%E7%BB%91%E5%AE%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%B0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0">“使用@RequestParam绑定请求参数到方法参数”</a>一节。</p>
</li>
<li><p><strong>@RequestHeader</strong>注解参数——用于访问特定的Servlet请求头。参数值将转换为声明的方法参数类型。请参阅<a href="#%E4%BD%BF%E7%94%A8@RequestHeader%E6%B3%A8%E8%A7%A3%E6%98%A0%E5%B0%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%B1%9E%E6%80%A7">“使用@RequestHeader注解映射请求头属性”</a>一节。</p>
</li>
<li><p><strong>@RequestBody</strong>注解参数——用于访问HTTP请求体。使用HttpMessageConverters将参数值转换为声明的方法参数类型。请参阅<a href="#%E4%BD%BF%E7%94%A8@RequestBody%E6%B3%A8%E8%A7%A3%E6%98%A0%E5%B0%84%E8%AF%B7%E6%B1%82%E4%BD%93">“使用@RequestBody注解映射请求体”</a>一节。</p>
</li>
<li><p><strong>@RequestPart</strong>注解参数——用于访问“multipart&#x2F;form-data”请求部分的内容。请参见<a href="#%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%AF%B7%E6%B1%82">第10.5节“从程序化客户端处理文件上传请求”</a>和<a href="#Spring%E7%9A%84%E5%A4%9A%E9%83%A8%E5%88%86%EF%BC%88%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%89%E6%94%AF%E6%8C%81">第10节“Spring的多部分（文件上传）支持”）</a>。</p>
</li>
<li><p><strong>@SessionAttribute</strong>注解参数——用于访问现有,永久的session属性（例如，用户认证对象），而不是访问作为控制器工作流程一部分通过@SessionAttributes临时存储在session中的model属性。</p>
</li>
<li><p><strong>@RequestAttribute</strong>注解参数——用于访问请求属性。</p>
</li>
<li><p>**HttpEntity&lt;?&gt;**参数——用于访问Servlet请求HTTP头和内容。请求流将使用HttpMessageConverters转换为实体。请参阅<a href="#%E4%BD%BF%E7%94%A8HttpEntity">“使用HttpEntity”</a>一节。</p>
</li>
<li><p><strong>java.util.Map</strong> &#x2F; <strong>org.springframework.ui.Model</strong> &#x2F; <strong>org.springframework.ui.ModelMap</strong>——用于富化暴露给Web视图的隐式model。</p>
</li>
<li><p><strong>org.springframework.web.servlet.mvc.support.RedirectAttributes</strong>在重定向情况下指定确切的属性集来使用，并且还添加flash属性（临时存储在服务器端的属性，使其在重定向之后可用于请求）。请参见(“将数据传递到重定向目标”](#将数据传递到重定向目标)一节和(第22.6节“使用flash属性”](#使用flash属性)一节。</p>
</li>
<li><p>根据**@InitBinder<strong>方法和&#x2F;或</strong>HandlerAdapter<strong>配置，使用自定义的类型转换，命令或表单对象将请求参数绑定到bean属性（通过setter）或直接转到字段上。请参阅</strong>RequestMappingHandlerAdapter<strong>上的</strong>webBindingInitializer<strong>属性。默认情况下，这些命令对象及其验证结果将作为model属性公开，使用命令类名称-例如。对于“some.package.OrderAddress”类型的命令对象的model属性“orderAddress”。</strong>ModelAttribute**注解可以用于方法参数来自定义所使用的model属性名称。</p>
</li>
<li><p><strong>org.springframework.validation.Errors&#x2F;org.springframework.validation.BindingResult</strong>验证前面的命令或表单对象的结果（即在前面的方法参数）。</p>
</li>
<li><p><strong>org.springframework.web.bind.support.SessionStatus</strong>用于标记表单处理完成的状态处理，这会触发在处理器类型级别上由@SessionAttributes注解指示的session属性的清理。</p>
</li>
<li><p><strong>org.springframework.web.util.UriComponentsBuilder</strong>——用于准备一个与当前请求的 host, port, scheme, context path以及servlet映射的文字部分相对的URL的构建器。</p>
</li>
</ul>
<p><strong>Errors</strong>或<strong>BindingResult</strong>参数必须跟在被绑定的模型对象后，因为方法签名可能有多个模型对象，Spring将为每个模型对象创建一个单独的BindingResult实例，因此以下示例将无法工作：</p>
<p><em>BindingResult和@ModelAttribute无效排序。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, Model model, BindingResult result)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注意，在Pet和BindingResult之间有一个Model参数。要使其工作，你必须将参数按如下重新排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result, Model model)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK 1.8的java.util.Optional也被支持作为带有注解的方法参数类型，该注解有一个required属性（例如**@RequestParam<strong>，</strong>@RequestHeader**等）在这些情况下使用java.util.Optional相当于有有一个属性required &#x3D; false。</p>
</blockquote>
<h3 id="支持的方法返回类型"><a href="#支持的方法返回类型" class="headerlink" title="支持的方法返回类型"></a>支持的方法返回类型</h3><p>以下是支持的方法返回类型：</p>
<ul>
<li>一个<strong>ModelAndView</strong>对象，带有使用命令对象和**@ModelAttribute**注解引用的数据访问器方法的结果隐式富化的model。</li>
<li>一个<strong>Model</strong>对象，视图名称通过<strong>RequestToViewNameTranslator</strong>隐式确定，model使用命令对象和@ModelAttribute注解引用的数据访问器方法的结果隐式富化。</li>
<li>用于暴露model的<strong>Map</strong>对象，视图名称通过<strong>RequestToViewNameTranslator</strong>隐式确定，model使用命令对象和@ModelAttribute注解引用的数据访问器方法的结果隐式富化。</li>
<li>一个<strong>View</strong>对象，model通过命令对象和**@ModelAttribute**注解引用数据访问器方法隐式确定。这个处理器方法也可以通过声明一个Model参数（见上文）以编程方式富化model。</li>
<li>一个<strong>String</strong>值，它被解释为逻辑视图名，model通过命令对象和**@ModelAttribute**注解引用数据访问器方法隐式确定。这个处理器方法也可以通过声明一个Model参数（见上文）以编程方式富化model。</li>
<li><strong>void</strong>，如果方法自己处理响应（通过直接写入响应内容，为此目的声明一个ServletResponse&#x2F;HttpServletResponse类型的参数）或者视图名称应该通过RequestToViewNameTranslator隐式确定（不在处理器方法签名中声明响应参数）。</li>
<li>如果方法被**@ResponseBody**注解，返回的类型被写入到响应HTTP体中。返回值将使用HttpMessageConverters转换为声明的方法参数类型。请参阅<a href="#%E4%BD%BF%E7%94%A8@ResponseBody%E6%B3%A8%E8%A7%A3%E6%98%A0%E5%B0%84%E5%93%8D%E5%BA%94%E4%BD%93">“使用@ResponseBody注解映射响应体”</a>一节。</li>
<li>一个**HttpEntity&lt;&gt;<strong>或</strong>ResponseEntity&lt;&gt;**对象,以提供对Servlet响应HTTP头和内容的访问。实体将使用HttpMessageConverters转换为响应流。请参阅<a href="#%E4%BD%BF%E7%94%A8HttpEntity">“使用HttpEntity”</a>一节。</li>
<li>一个<strong>HttpHeaders</strong>对象，它返回没有响应体的响应。</li>
<li>一个**Callable&lt;?&gt;**，当应用程序想要在由Spring MVC管理的线程中异步生成返回值时，可以返回它。</li>
<li>一个**DeferredResult&lt;?&gt;**，当应用程序想从自己选择​​的线程生成返回值时，可以返回它。</li>
<li>一个<strong>ListenableFuture&lt;?&gt;<strong>或</strong>CompletableFuture&lt;?&gt;</strong>&#x2F;**CompletionStage&lt;?&gt;**当应用程序想要从线程池提交中产生值时，可以返回它们</li>
<li>一个<strong>ResponseBodyEmitter</strong>，可以返回它以异步地将多个对象写入响应;也支持作为ResponseEntity内的主体。</li>
<li>一个<strong>SseEmitter</strong>，可以返回它以将异步的Server-Sent事件写入响应;也支持作为ResponseEntity内的主体。</li>
<li>一个<strong>StreamingResponseBody</strong>，可以返回它以异步写入响应OutputStream;;也支持作为ResponseEntity内的主体。</li>
<li>任何其他返回类型都被认为是要暴露给视图的单个model属性，使用在方法级通过@ModelAttribute指定的属性名称（或基于返回类型类名的默认属性名称）。model使用命令对象和@ModelAttribute注解引用的数据访问器方法的结果隐式富化。</li>
</ul>
<h3 id="使用-RequestParam将请求参数绑定到方法参数"><a href="#使用-RequestParam将请求参数绑定到方法参数" class="headerlink" title="使用@RequestParam将请求参数绑定到方法参数"></a>使用@RequestParam将请求参数绑定到方法参数</h3><p>在控制器中使用**@RequestParam**注解将请求参数绑定到方法参数</p>
<p>以下代码片段显式用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pets&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(<span class="meta">@RequestParam(&quot;petId&quot;)</span> <span class="type">int</span> petId, ModelMap model)</span> &#123;</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="built_in">this</span>.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;pet&quot;</span>, pet);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个注解的参数默认是必须的，但是你可以通过设置**@RequestParam<strong>的属性</strong>required<strong>为false来指定这个参数为可选（例如</strong>@RequestParam(name &#x3D;“id”，required &#x3D; false)**）</p>
<p>如果目标方法参数类型不是String，则会自动应用类型转换。请参阅<a href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">“方法参数和类型转换”</a>一节。</p>
<p>当在<strong>Map&lt;String,String&gt;<strong>或</strong>MultiValueMap&lt;String,String&gt;<strong>参数上使用</strong>@RequestParam</strong>注解时，map将被填充所有请求参数。</p>
<h3 id="使用-RequestBody注解映射请求体"><a href="#使用-RequestBody注解映射请求体" class="headerlink" title="使用@RequestBody注解映射请求体"></a>使用@RequestBody注解映射请求体</h3><p><strong>@RequestBody</strong>方法参数注解表示方法参数应绑定到HTTP请求体的值上。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/something&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestBody</span> String body, Writer writer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    writer.write(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你通过使用<strong>HttpMessageConverter</strong>将请求体转换为方法参数。<strong>HttpMessageConverter</strong>负责将HTTP请求消息转换为对象，并从对象转换为HTTP响应体。<strong>RequestMappingHandlerAdapter</strong>以以下默认<strong>HttpMessageConverters</strong>支持**@RequestBody**注解：</p>
<ul>
<li><strong>ByteArrayHttpMessageConverter</strong>转换字节数组。</li>
<li><strong>StringHttpMessageConverter</strong>转换字符串。</li>
<li><strong>FormHttpMessageConverter</strong>将表单数据从到 MultiValueMap&lt;String,String&gt;转换。</li>
<li><strong>SourceHttpMessageConverter</strong>与<strong>javax.xml.transform.Source</strong>互相转换。</li>
</ul>
<p>有关这些转换器的更多信息，请参阅<a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">“消息转换器”</a>。另请注意，如果使用MVC命名空间或MVC Java配置，默认情况下会注册更广泛的消息转换器。有关详细信息，请参见[第16.1节“启用MVC Java配置或MVC XML命名空间”](#启用MVC Java配置或MVC XML命名空间)。</p>
<p>如果你打算读写XML，则需要使用<strong>org.springframework.oxm</strong>包中的具体的<strong>Marshaller</strong>和<strong>Unmarshaller</strong>实现配置<strong>MarshallingHttpMessageConverter</strong>。下面的示例显式了如何直接在配置中执行此操作，但是如果你的应用程序通过MVC命名空间或MVC Java配置进行配置，请参阅[第16.1节“启用MVC Java配置或MVC XML命名空间”](#启用MVC Java配置或MVC XML命名空间)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;beanList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;stringHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;marshallingHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stringHttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;marshallingHttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;marshaller&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;castorMarshaller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;unmarshaller&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;castorMarshaller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;castorMarshaller&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.oxm.castor.CastorMarshaller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>@RequestBody</strong>方法参数可以使用**@Valid<strong>注解，在这种情况下，它将使用配置的</strong>Validator**实例进行验证。当使用MVC命名空间或MVC Java配置时，会自动配置一个JSR-303验证器，假设在类路径上有可用的JSR-303实现。</p>
<p>就像**@ModelAttribute<strong>参数一样，可以使用一个</strong>Errors<strong>参数来检查错误。如果未声明此类参数，则将引发</strong>MethodArgumentNotValidException<strong>异常。这个异常在</strong>DefaultHandlerExceptionResolver**中处理，它将向客户端发送一个400错误。</p>
<blockquote>
<p>有关通过MVC命名空间或MVC Java配置配置消息转换器和验证器的信息，请参见[第16.1节“启用MVC Java配置或MVC XML命名空间”](#启用MVC Java配置或MVC XML命名空间)。</p>
</blockquote>
<h3 id="使用-ResponseBody注解映射响应体"><a href="#使用-ResponseBody注解映射响应体" class="headerlink" title="使用@ResponseBody注解映射响应体"></a>使用@ResponseBody注解映射响应体</h3><p><strong>@ResponseBody</strong>注解类似于**@RequestBody**。这个注解可以被放置在方法上，并表示返回值类型应该被直接写入HTTP响应体中（而不是放在Model中，或者解释为视图名称）。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/something&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子会导致文本Hello World被写入HTTP响应流中。<br>与**@RequestBody<strong>一样，Spring通过使用</strong>HttpMessageConverter**将返回的对象转换为响应体。有关这些转换器的更多信息，请参阅上一部分和<a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">消息转换器</a>。</p>
<h3 id="使用-RestController注解创建REST控制器"><a href="#使用-RestController注解创建REST控制器" class="headerlink" title="使用@RestController注解创建REST控制器"></a>使用@RestController注解创建REST控制器</h3><p>控制器实现REST API是一个非常常见的用例，从而仅提供JSON，XML或自定义的MediaType内容。为了方便起见，相比使用**@ResponseBody<strong>注解你的所有的</strong>@RequestMapping<strong>方法，你可以使用</strong>@RestController**注解你的控制器类。</p>
<p><strong>@RestController</strong>是一个结合了**@ResponseBody<strong>和</strong>@Controller<strong>的模型注解。更重要的是，它给你的控制器提供了更多的意义，并且可能在将来的框架版本中携带额外的语义。<br>与常规的</strong>@Controller<strong>一样，</strong>@RestController<strong>可以由</strong>@ControllerAdvice**或@**RestControllerAdvice **beans协助。有关更多详细信息，请参阅<a href="#%E4%BD%BF%E7%94%A8@ControllerAdvice%E5%92%8C@RestControllerAdvice%E9%80%9A%E7%9F%A5%E6%8E%A7%E5%88%B6%E5%99%A8">“使用@ControllerAdvice和@RestControllerAdvice通知控制器”</a>一节。</p>
<h3 id="使用HttpEntity"><a href="#使用HttpEntity" class="headerlink" title="使用HttpEntity"></a>使用HttpEntity</h3><p><strong>HttpEntity</strong>类似于**@RequestBody<strong>和</strong>@ResponseBody<strong>。除了访问请求和响应体之外，</strong>HttpEntity<strong>（以及响应特定的子类</strong>ResponseEntity**）还允许访问请求和响应头，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/something&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(HttpEntity&lt;<span class="type">byte</span>[]&gt; requestEntity)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestHeader</span> <span class="operator">=</span> requestEntity.getHeaders().getFirst(<span class="string">&quot;MyRequestHeader&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] requestBody = requestEntity.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用请求头和请求体执行某些操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">responseHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    responseHeaders.set(<span class="string">&quot;MyResponseHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;String&gt;(<span class="string">&quot;Hello World&quot;</span>, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上示例获取<strong>MyRequestHeader</strong>请求头的值，并将字节数组读取形式读取请求体。在响应中添加了<strong>MyResponseHeader</strong>，将Hello World写入到响应流中，并且设置响应代码未201（Created）。</p>
<p>与**@RequestBody<strong>和</strong>@ResponseBody<strong>一样，Spring使用</strong>HttpMessageConverter**从请求和响应流转换。有关这些转换器的更多信息，请参阅上一部分和<a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">消息转换器</a>。</p>
<h3 id="在方法上使用-ModelAttribute"><a href="#在方法上使用-ModelAttribute" class="headerlink" title="在方法上使用@ModelAttribute"></a>在方法上使用@ModelAttribute</h3><p><strong>@ModelAttribute</strong>注解可以在方法和方法参数上使用。这节说明它的在方法上的用法，下一节说明它在方法参数上的用法。</p>
<p>在方法上的**@ModelAttribute<strong>表示该方法的目的是添加一个或多个</strong>Model<strong>属性。这样的方法支持与</strong>@RequestMapping<strong>方法相同的参数类型，但不能直接映射到请求上。在同一个控制器中，控制器中的</strong>@ModelAttribute<strong>方法在</strong>@RequestMapping**方法之前被调用。几个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个属性</span></span><br><span class="line"><span class="comment">// 方法的返回值类型会被在&quot;account“名称下添加到model中</span></span><br><span class="line"><span class="comment">// 你可以通过@ModelAttribute（“myAccount&quot;）自定义名称</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">addAccount</span><span class="params">(<span class="meta">@RequestParam</span> String number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accountManager.findAccount(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateModel</span><span class="params">(<span class="meta">@RequestParam</span> String number, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(accountManager.findAccount(number));</span><br><span class="line">    <span class="comment">// 添加更多 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@ModelAttribute</strong>方法用于在model中填充常用属性，例如使用state或pet类型填充下拉列表，或者检索诸如Account的命令对象，以便使用它来表示HTML表单上的数据。后一种情况在下一节进一步讨论。</p>
<p>注意两种样式的**@ModelAttribute<strong>方法。在第一个方法中，该方法通过返回隐式地添加一个属性。在第二个方法中，该方法接受一个</strong>Model**并向它添加任意数量的model属性。你可以根据在两种样式中选择。</p>
<p>控制器可以有任何数量的**@ModelAttribute<strong>方法。在同一控制器所有这些方法都在</strong>@RequestMapping**方法之前调用。</p>
<p><strong>@ModelAttribute</strong>方法也可以在**@ControllerAdvice**注解的类中定义，而这种方法也适用于许多控制器。有关更多详细信息，请参阅<a href="#%E4%BD%BF%E7%94%A8@ControllerAdvice%E5%92%8C@RestControllerAdvice%E9%80%9A%E7%9F%A5%E6%8E%A7%E5%88%B6%E5%99%A8">“使用@ControllerAdvice和@RestControllerAdvice通知控制器”</a>一节。</p>
<blockquote>
<p>当没有明确指定model属性名称时会发生什么？在这种情况下，根据其类型将默认名称分配给model属性。例如，如果该方法返回一个类型为Account的对象，使用的默认名称是”account”。你可以通过**@ModelAttribute<strong>注解的值来更改它。如果直接向model中添加属性，请使用合适的</strong>addAttribute(..)**重载方法，即带有或不带有属性名称。</p>
</blockquote>
<p><strong>@ModelAttribute</strong>注解也可以在**@RequestMapping<strong>方法中使用。在这种情况下，</strong>@RequestMapping**方法的返回值将被解释为model属性而不是视图名称。然后视图名称根据视图名称惯例推导出，这非常类似于返回void的方法 - 见第[13.3节“视图 - RequestToViewNameTranslator”](#视图 - RequestToViewNameTranslator)。</p>
<h3 id="在方法参数上使用-ModelAttribute"><a href="#在方法参数上使用-ModelAttribute" class="headerlink" title="在方法参数上使用@ModelAttribute"></a>在方法参数上使用@ModelAttribute</h3><p>如上一节所述，**@ModelAttribute**可以在方法或方法参数上使用。本节介绍了其在方法参数中的用法。</p>
<p>方法参数上的**@ModelAttribute**表示这个参数应该从model中检索。如果model中不存在，参数首先被实例化，然后添加到model中。一旦model中存在，这个参数的字段会从所有名称相匹配的请求参数中填充。这在Spring MVC中被称为的数据绑定，这是一个非常有用的机制，可以节省你逐个解析每个表单字段时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute</span> Pet pet)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>上面给定的示例中，Pet示例可以才能够哪里获得？这有几个选项：</p>
<ul>
<li>由于**@SessionAttributes**的使用，它可能已经在model中— 请参阅[“使用@SessionAttributes在请求之间的HTTP session中存储模型属性”](#使用@SessionAttributes在请求之间的HTTP session中存储模型属性)一节。</li>
<li>由于同一控制器中的**@ModelAttribute**方法，它可能已经在model中- 如前一节所述。</li>
<li>它可以基于URI模板变量和类型转换器（下面更详细地解释）来检索。</li>
<li>它可以使用其默认构造函数实例化。</li>
</ul>
<p><strong>@ModelAttribute</strong>方法是从数据库检索属性的常用方式，可以通过使用**@SessionAttributes**来选择性地存储在请求之间。在某些情况下，通过使用URI模板变量和类型转换器来检索属性可能很方便。下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/accounts/&#123;account&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@ModelAttribute(&quot;account&quot;)</span> Account account)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，model属性（即“account”）的名称与URI模板变量的名称相匹配。如果你注册可以将<strong>String</strong>类型的account值转换为<strong>Account</strong>实例的**Converter&lt;String,Account&gt;**，那么上面的例子不需要@ModelAttribute方法也可以工作。</p>
<p>下一步是数据绑定。<strong>WebDataBinder</strong>类按照名称将请求参数名称（包括查询字符串参数和表单字段）匹配到模型属性字段上。匹配的字段在必要的类型转换（从String到目标字段类型）应用后被填充。数据绑定和验证在第9章”验证，数据绑定，和类型转换“中一经介绍。自定义控制器级别的数据绑定过程将在<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89WebDataBinder%E5%88%9D%E5%A7%8B%E5%8C%96">“自定义WebDataBinder初始化”</a>一节中介绍。</p>
<p>数据绑定可能会出现错误，比如缺少必须字段或类型转换错误。要检查这样的错误，请在**@ModelAttribute<strong>参数之后立即添加</strong>BindingResult**参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>BindingResult</strong>可以检查是否发现错误，在通常呈现相同表单的情况吓,这里可以在Spring的&lt;errors&gt;表单标签的帮助下显式错误。</p>
<p>注意，在某些情况下，不使用数据绑定来获取访问modle中的属性可能是有用的。对于这种情况，你可以将<strong>Model</strong>注入控制器，或者作为选择的在注解上使用<strong>binding</strong>标志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> AccountForm <span class="title function_">setUpForm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccountForm</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">findAccount</span><span class="params">(<span class="meta">@PathVariable</span> String accountId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findOne(accountId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Valid</span> AccountUpdateForm form, BindingResult result,</span></span><br><span class="line"><span class="params">        <span class="meta">@ModelAttribute(binding=false)</span> Account account)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了数据绑定之外，你还可以使用你自己的自定义验证器传递相同的用于记录数据绑定错误的<strong>BindingResult</strong>来调用验证。这允许数据绑定和验证的错误在同一个地方累积，并随后向用户报告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PetValidator</span>().validate(pet, result);</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者你可以通过添加JSR-303 <strong>@Valid</strong>注解来自动调用验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关如何配置和使用验证的详细信息，请参见第9.8节<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#validation-beanvalidation">“Spring验证”</a>和<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#validation">第9章“验证，数据绑定和类型转换“</a>。</p>
<h3 id="使用-SessionAttributes在请求之间的HTTP-session中存储模型属性"><a href="#使用-SessionAttributes在请求之间的HTTP-session中存储模型属性" class="headerlink" title="使用@SessionAttributes在请求之间的HTTP session中存储模型属性"></a>使用@SessionAttributes在请求之间的HTTP session中存储模型属性</h3><p>类型级**@SessionAttributes**注解声明特定处理器使用的session属性。这通常将列出模型属性名称或模型属性的类型，这些模型属性或类型应该透明地存储在会话或某些会话存储中，作为后续请求之间的表单支持bean。</p>
<p>下面的代码片段展示了这个注解的用法，指定模型属性名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/editPet.do&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-SessionAttribute访问预先存在的全局session属性"><a href="#使用-SessionAttribute访问预先存在的全局session属性" class="headerlink" title="使用@SessionAttribute访问预先存在的全局session属性"></a>使用@SessionAttribute访问预先存在的全局session属性</h3><p>如果你需要访问全局管理的预先存在的session属性，即控制器之外的（如一个过滤器），并且它可能或不存在，则可以在方法参数上使用**@SessionAttribute**注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@SessionAttribute</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于需要添加或删除session属性的用例，请考虑将<strong>org.springframework.web.context.request.WebRequest</strong>或<strong>javax.servlet.http.HttpSession</strong>注入到控制器方法中。</p>
<p>对于作为控制器工作流程中的一部分，在session中的模型属性的临时存储，请考虑使用<strong>SessionAttributes</strong>，如上面“使用@SessionAttributes在请求之间的HTTP session中存储模型属性”一节中所述。</p>
<h3 id="使用-RequestAttribute来访问请求属性"><a href="#使用-RequestAttribute来访问请求属性" class="headerlink" title="使用@RequestAttribute来访问请求属性"></a>使用@RequestAttribute来访问请求属性</h3><p>与**@SessionAttribute<strong>类似，</strong>@RequestAttribute**注解可用于访问由过滤器或拦截器创建的预先存在的请求属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestAttribute</span> Client client)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用“application-x2F-x-www-form-urlencoded”数据"><a href="#使用“application-x2F-x-www-form-urlencoded”数据" class="headerlink" title="使用“application&#x2F;x-www-form-urlencoded”数据"></a>使用“application&#x2F;x-www-form-urlencoded”数据</h3><p>前面的部分介绍了使用**@ModelAttribute<strong>来支持来自浏览器客户端的表单提交请求。建议来自非浏览器客户端的请求使用同样的注解。然而，在使用HTTP PUT请求时，会有一个显着的区别。浏览器可以通过HTTP GET或HTTP POST提交表单数据。非浏览器客户端还可以通过HTTP PUT提交表单。这提出了一个挑战，因为Servlet规范要求</strong>ServletRequest.getParameter *()**系列方法仅支持HTTP POST的表单字段访问，而不支持HTTP PUT。</p>
<p>为了支持HTTP PUT和PATCH请求，<strong>spring-web</strong>模块提供了过滤器<strong>HttpPutFormContentFilter</strong>，它可以在<strong>web.xml</strong>中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpPutFormFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpPutFormFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述过滤器拦截内容类型为<strong>application&#x2F;x-www-form-urlencoded</strong>的HTTP PUT和PATCH请求，从请求的正文中读取表单数据，并包装成<strong>ServletRequest</strong>，以便可以通过**ServletRequest.getParameter *()**系列方法使用表单数据。</p>
<blockquote>
<p>由于<strong>HttpPutFormContentFilter</strong>消耗了请求的正文，所以不应该为PUT或PATCH URLs配置依赖其他的按<strong>application&#x2F;x-www-form-urlencoded</strong>的转换器。这包括**@RequestBody MultiValueMap&lt;String，String&gt;<strong>和</strong>HttpEntity&lt;MultiValueMap&lt;String，String &gt;&gt;**。</p>
</blockquote>
<h3 id="使用-CookieValue注解映射Cookie值"><a href="#使用-CookieValue注解映射Cookie值" class="headerlink" title="使用@CookieValue注解映射Cookie值"></a>使用@CookieValue注解映射Cookie值</h3><p><strong>@CookieValue</strong>注解允许将方法参数被绑定到HTTP cookie的值上。</p>
<p>让我们考虑下面从一个http请求中接收的cookie：<br><em>JSESSIONID&#x3D;415A4AC178C59DACE0B2C9CA727CDD84</em><br>以下代码示例演示如何获取JSESSIONID cookie的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayHeaderInfo</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果目标方法参数类型不是String，则会自动应用类型转换。请参阅<a href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">“方法参数和类型转换”</a>一节。</p>
<p>Servlet和Portlet环境中的注解处理器方法支持此注解。</p>
<h3 id="使用-RequestHeader注解映射请求头属性"><a href="#使用-RequestHeader注解映射请求头属性" class="headerlink" title="使用@RequestHeader注解映射请求头属性"></a>使用@RequestHeader注解映射请求头属性</h3><p><strong>@RequestHeader</strong>注解允许将一个方法参数绑定到一个请求头上。</p>
<p>以下是一个示例请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host                    localhost:8080</span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=0.9</span><br><span class="line">Accept-Language         fr,en-gb;q=0.7,en;q=0.3</span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Keep-Alive              300</span><br></pre></td></tr></table></figure>

<p>以下代码示例演示了如何获取<strong>Accept-Encoding</strong>和<strong>Keep-Alive</strong>头的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayHeaderInfo</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法参数类型不是String，则会自动应用类型转换。请参阅<a href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">“方法参数和类型转换”</a>一节。</p>
<p>当在<strong>Map&lt;String,String&gt;<strong>，</strong>MultiValueMap&lt;String,String&gt;<strong>或</strong>HttpHeaders</strong>参数上使用**@RequestHeader**注解时，map会被填充所有头值。</p>
<blockquote>
<p>内置支持可用于将一个逗号分割的字符串转换为一个字符串或类型转换系统已知的其他类型的数组&#x2F;集合。例如，使用@RequestHeader（“Accept”）注解的方法参数可以是String类型，但也可以是String []或List&lt;String&gt;。</p>
</blockquote>
<p>Servlet和Portlet环境中的注解处理器方法支持此注解。</p>
<h3 id="方法参数和类型转换"><a href="#方法参数和类型转换" class="headerlink" title="方法参数和类型转换"></a>方法参数和类型转换</h3><p>从请求中提取的基于字符串的值包括请求参数，路径变量，请求头和cookie值，它们可能需要转换为它们要绑定到的方法参数或字段的目标类型（例如，将请求参数绑定到@ModelAttribute参数中的字段）。如果目标类型不是String，则Spring将自动转换为适当的类型。所有简单的类型，如int，long，Date等都被支持。你可以通过<strong>WebDataBinder</strong>进一步自定义转换过程（请参阅“自定义WebDataBinder初始化”一节），或者使用<strong>FormattingConversionService</strong>注册<strong>Formatter</strong>（参见第9.6节“Spring字段格式化”）。</p>
<h3 id="自定义WebDataBinder初始化"><a href="#自定义WebDataBinder初始化" class="headerlink" title="自定义WebDataBinder初始化"></a>自定义WebDataBinder初始化</h3><p>要通过Spring的<strong>WebDataBinder</strong>定制使用<strong>PropertyEditors</strong>的请求参数绑定，你可以在你的控制器中使用**@InitBinder<strong>注解方法，在</strong>@ControllerAdvice<strong>类中使用</strong>@InitBinder<strong>方法，或提供自定义</strong>WebBindingInitializer**。有关更多详细信息，请参阅“使用@ControllerAdvice和@RestControllerAdvice的通知控制器”一节。</p>
<h3 id="使用-InitBinder自定义数据绑定"><a href="#使用-InitBinder自定义数据绑定" class="headerlink" title="使用@InitBinder自定义数据绑定"></a>使用@InitBinder自定义数据绑定</h3><p>使用**@InitBinder<strong>的注解方法允许你直接在你的控制器类中配置web数据绑定。</strong>@InitBinder<strong>标识初始化</strong>WebDataBinder<strong>的方法，</strong>WebDataBinder**将用于填充注解处理器方法的命令和表单对象参数。</p>
<p>这种init-binder方法支持@RequestMapping方法支持的所有参数，除了命令&#x2F;表单对象和相应的验证结果对象。Init-binder方法不能有返回值。因此，它们通常被声明为void。典型的参数包括WebDataBinder与WebRequest或java.util.Locale的组合，允许代码注册上下文特定的编辑器。</p>
<p>以下示例演示如何使用**@InitBinder<strong>为所有</strong>java.util.Date<strong>表单属性配置</strong>CustomDateEditor**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="literal">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">CustomDateEditor</span>(dateFormat, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，从Spring 4.2起，考虑使用<strong>addCustomFormatter</strong>来指定<strong>Formatter</strong>实现而不是<strong>PropertyEditor</strong>实例。如果你恰好在一个共享的<strong>FormattingConversionService</strong>中有一个基于<strong>Formatter</strong>的设置，这个会特别有用，用相同的方式重用控制器特定的绑定规则的调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置一个自定义的WebBindingInitializer"><a href="#配置一个自定义的WebBindingInitializer" class="headerlink" title="配置一个自定义的WebBindingInitializer"></a>配置一个自定义的WebBindingInitializer</h3><p>要在外部执行数据绑定初始化，你可以提供一个<strong>WebBindingInitializer</strong>接口的自定义实现，然后通过为<strong>AnnotationMethodHandlerAdapter</strong>提供自定义bean配置来启用它，从而覆盖默认配置。</p>
<p>PetClinic应用程序的以下示例显式了使用<strong>WebBindingInitializer</strong>接口（org.springframework.samples.petclinic.web.ClinicBindingInitializer）的自定义实现的配置，它配置了几个PetClinic控制器所需的PropertyEditor。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;webBindingInitializer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.petclinic.web.ClinicBindingInitializer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@InitBinder</strong>方法也可以在**@ControllerAdvice**注解的类中定义，在这种情况下，它们适用于匹配控制器。这提供了使用WebBindingInitializer的替代方法。有关更多详细信息，请参阅<a href="#%E4%BD%BF%E7%94%A8@ControllerAdvice%E5%92%8C@RestControllerAdvice%E9%80%9A%E7%9F%A5%E6%8E%A7%E5%88%B6%E5%99%A8">“使用@ControllerAdvice和@RestControllerAdvice通知控制器”</a>一节。</p>
<h3 id="使用-ControllerAdvice和-RestControllerAdvice通知控制器"><a href="#使用-ControllerAdvice和-RestControllerAdvice通知控制器" class="headerlink" title="使用@ControllerAdvice和@RestControllerAdvice通知控制器"></a>使用@ControllerAdvice和@RestControllerAdvice通知控制器</h3><p>@ControllerAdvice注解是组件注解，允许通过类路径扫描自动检测实现类。当使用MVC命名空间或MVC Java配置时，它将自动启用。</p>
<p>使用**@ControllerAdvice<strong>注解的类可以包含</strong>@ExceptionHandler<strong>，</strong>@InitBinder<strong>和</strong>@ModelAttribute<strong>注解方法，并且这些方法将应用于所有控制器层次结构中的</strong>@RequestMapping**方法，而不是声明它们的控制器层次结构。</p>
<p><strong>@RestControllerAdvice</strong>是默认使用**@ResponseBody<strong>语义的</strong>@ExceptionHandler**方法的替代方案。</p>
<p><strong>@ControllerAdvice</strong>和**@RestControllerAdvice**都可以针对控制器的一个子集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对所有使用@RestController注释的Controller</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAdvice</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对特定包中的所有Controller</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;org.example.controllers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasePackageAdvice</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对可分配给指定类的所有Controller</span></span><br><span class="line"><span class="meta">@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssignableTypesAdvice</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>查看@ControllerAdvice<a href="http://docs.spring.io/spring-framework/docs/4.3.10.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html">文档</a>了解更多详细信息。</p>
<h3 id="Jackson序列化视图支持"><a href="#Jackson序列化视图支持" class="headerlink" title="Jackson序列化视图支持"></a>Jackson序列化视图支持</h3><p>有时根据上下文过滤将被序列化到HTTP响应主体的对象是有用的。为了提供这样的功能，Spring MVC内置了对<strong>Jackson</strong>的Serialization Views进行渲染的支持。</p>
<p>要将它与使用**@ResponseBody<strong>控制器方法或返回</strong>ResponseEntity<strong>的控制器方法一起使用，只需使用指定要使用的视图类或接口的类参数添加</strong>@JsonView**注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@JsonView(User.WithoutPasswordView.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;eric&quot;</span>, <span class="string">&quot;7!jd#h23&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WithoutPasswordView</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WithPasswordView</span> <span class="keyword">extends</span> <span class="title class_">WithoutPasswordView</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView(WithoutPasswordView.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView(WithPasswordView.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，尽管**@JsonView**允许指定多个类，但用在控制器方法上只支持一个类参数。如果需要启用多个视图，请考虑使用复合接口。</p>
</blockquote>
<p>对于依赖于视图解析的控制器，只需将序列化视图类添加到model中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">extends</span> <span class="title class_">AbstractController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;eric&quot;</span>, <span class="string">&quot;7!jd#h23&quot;</span>));</span><br><span class="line">        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userView&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jackson-JSONP支持"><a href="#Jackson-JSONP支持" class="headerlink" title="Jackson JSONP支持"></a>Jackson JSONP支持</h3><p>为了启用对**@ResponseBody<strong>和</strong>ResponseEntity<strong>方法的JSONP支持，声明一个</strong>@ControllerAdvice** bean，它继承自<strong>AbstractJsonpResponseBodyAdvice</strong>，如下所示，这里构造函数参数表示JSONP查询参数的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonpAdvice</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsonpResponseBodyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonpAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;callback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于依赖于视图解析的控制器，当请求具有名为<strong>jsonp</strong>或<strong>callback</strong>的查询参数时，将自动启用JSONP。这些参数名称可以通过jsonpParameterNames属性自定义。</p>
<h2 id="异步请求处理"><a href="#异步请求处理" class="headerlink" title="异步请求处理"></a>异步请求处理</h2><hr>
<p>Spring MVC 3.2引入了基于Servlet 3的异步请求处理。相比往常返回一个值，控制器方法现在可以返回一个<strong>java.util.concurrent.Callable</strong>并从Spring MVC管理的线程生成返回值。与此同时，Servlet容器主线程被退出和释放并且允许处理其他请求。Spring MVC在TaskExecutor的帮助下在一个单独的线程中调用<strong>Callable</strong>，当<strong>Callable</strong>返回时，该请求将被分派回到Servlet容器，以使用这个<strong>Callable</strong>对象的返回值来恢复处理这个请求。这有一个这样一个控制器方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title function_">processUpload</span><span class="params">(<span class="keyword">final</span> MultipartFile file)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;someView&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个控制器方法也可以是返回一个<strong>DeferredResult</strong>的实例。在这种情况下，返回值也将从任何线程生成，即不由Spring MVC管理的线程。例如，结果可能是由于某些外部事件而产生的，例如JMS消息，计划任务等。这有一个这样一个控制器方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quotes&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">quotes</span><span class="params">()</span> &#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 将deferredResult保存在某个地方..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中...</span></span><br><span class="line">deferredResult.setResult(data);</span><br></pre></td></tr></table></figure>
<p>在不了解任何Servlet 3.0异步请求处理功能知识的情况下，这可能很难理解。阅读这些肯定会有帮助。以下是有关底层机制的几个基本事实：</p>
<ul>
<li>可以通过调用<strong>request.startAsync()<strong>将</strong>ServletRequest</strong>置于异步模式。这样做的主要作用是Servlet以及任何Filter都可以退出，但响应将保持开放状态，以便稍后完成处理。</li>
<li>对<strong>request.startAsync()<strong>的调用返回</strong>AsyncContext</strong>，它可用于进一步控制异步处理。例如，它提供了<strong>dispatch</strong>方法，除了允许应用程序在Servlet容器线程上恢复请求处理这点外，它类似于Servlet API的转发。</li>
<li><strong>ServletRequest</strong>提供对当前<strong>DispatcherType</strong>的访问，它可用于区分处理初始请求，异步调度，转发和其他调度器类型。</li>
</ul>
<p>考虑到上述情况，以下是使用<strong>Callable</strong>进行异步请求处理的事件序列：</p>
<ul>
<li>控制器返回一个<strong>Callable</strong>。</li>
<li>Spring MVC启动异步处理，并将<strong>Callable</strong>提交给<strong>TaskExecutor</strong>，以在单独的线程中进行处理。</li>
<li><strong>DispatcherServlet</strong>和所有<strong>Filter</strong>都退出Servlet容器线程，但响应保持打开状态。</li>
<li><strong>Callable</strong>产生一个结果，Spring MVC将请求返回给Servlet容器以恢复处理。</li>
<li><strong>DispatcherServlet</strong>再次被调用，并且从<strong>Callable</strong>异步生成的结果开始继续处理。</li>
</ul>
<p>这与<strong>DeferredResult</strong>的顺序非常相似，除了它可以在应用程序中任何线程生成异步结果：</p>
<ul>
<li>控制器返回一个<strong>DeferredResult</strong>并将其保存在某些可以访问的内存中的queue或list 中。</li>
<li>Spring MVC启动异步处理。</li>
<li><strong>DispatcherServlet</strong>和所有<strong>Filter</strong>都退出Servlet容器线程，但响应保持打开状态。</li>
<li>应用程序从一些线程设置DeferredResult，Spring MVC将请求发回到Servlet容器。</li>
<li><strong>DispatcherServlet</strong>再次被调用，并且从异步生成的结果开始继续处理。</li>
</ul>
<h3 id="异步请求的异常处理"><a href="#异步请求的异常处理" class="headerlink" title="异步请求的异常处理"></a>异步请求的异常处理</h3><p>如果从控制器方法返回的<strong>Callable</strong>在执行时引发异常，会发生什么？简答是这与控制器方法引发异常时发生的情况一样。它经历了常规异常处理机制。更长的解释是，当<strong>Callable</strong>引发一个异常，Spring MVC以这个<strong>Exception</strong>为结果调度回Servlet容器，并导致以异常而不是控制器方法返回值为开始恢复请求处理。当使用<strong>DeferredResult</strong>时，你可以选择是否使用<strong>Exception</strong>实例调用<strong>setResult</strong>或<strong>setErrorResult</strong>。</p>
<h3 id="拦截异步请求"><a href="#拦截异步请求" class="headerlink" title="拦截异步请求"></a>拦截异步请求</h3><p>一个<strong>HandlerInterceptor</strong>还可以实现<strong>AsyncHandlerInterceptor</strong>，是为了能够实现<strong>afterConcurrentHandlingStarted</strong>回调，，当异步处理开始时，该回调被调用，而不是<strong>postHandle</strong>和<strong>afterCompletion</strong>方法。</p>
<p><strong>HandlerInterceptor</strong>还可以注册<strong>CallableProcessingInterceptor</strong>或<strong>DeferredResultProcessingInterceptor</strong>，以便更深入地整合异步请求的生命周期，例如处理超时事件。有关更多详细信息，请参阅<strong>AsyncHandlerInterceptor</strong>的Javadoc。</p>
<p><strong>DeferredResult</strong>类型同样提供了诸如**onTimeout(Runnable)<strong>和</strong>onCompletion(Runnable)**等方法。有关详细信息，请参阅DeferredResult的Javadoc。</p>
<p>当使用<strong>Callable</strong>时，你可以使用<strong>WebAsyncTask</strong>的实例来包装它，该实例还提供了timeout和completion的注册方法。</p>
<h3 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h3><p>控制器方法可以使用<strong>DeferredResult</strong>和<strong>Callable</strong>异步生成其返回值，并且可以用于实现诸如<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">long polling</a>的技术，这里服务器可以尽快将事件推送到客户端。</p>
<p>如果你想在单个HTTP响应中推送多个事件怎么办？这是一个与“Long Polling”相关的技术，也被称为“HTTP Streaming”。Spring MVC可以通过<strong>ResponseBodyEmitter</strong>返回值类型来实现，该类型可以用于发送多个对象，而不是像**@ResponseBody<strong>的一样，发送的每个对象都使用</strong>HttpMessageConverter**写入响应。</p>
<p>这有一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/events&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseBodyEmitter <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResponseBodyEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseBodyEmitter</span>();</span><br><span class="line">    <span class="comment">// 将emitter保存在某处..</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他一些线程</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello once&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且之后再一次</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello again&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并在某些时候完成</span></span><br><span class="line">emitter.complete();</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>ResponseBodyEmitter</strong>也可以用作<strong>ResponseEntity</strong>中的正文，以便自定义响应的状态和响应头</p>
<h3 id="HTTP-Streaming与Server-Sent-Events"><a href="#HTTP-Streaming与Server-Sent-Events" class="headerlink" title="HTTP Streaming与Server-Sent Events"></a>HTTP Streaming与Server-Sent Events</h3><p><strong>SseEmitter</strong>是<strong>ResponseBodyEmitter</strong>的子类，提供对<a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a>的支持。Server-sent event只是同一个“HTTP Streaming”技术的另一个变体，除了从服务器推送的事件根据 W3C Server-Sent Events规范进行格式化的。</p>
<p>Server-Sent Events可用于预期的用途，即将事件从服务器推送到客户端。在Spring MVC中这很容易做到，只需返回一个SseEmitter类型的值。</p>
<p>请注意，Internet Explorer不支持Server-Sent Events，而对于更高级的Web应用程序消息传递场景（如在线游戏，协作，财务应用程序和其他），最好考虑Spring的WebSocket支持，它包括SockJS风格的WebSocket模拟，能够广泛地支持各种浏览器（包括Internet Explorer），同时支持在以消息作为核心的应用架构中，使用发布-订阅模型来在客户端间进行交互的更高层次的消息模式。如需了解更多，请参阅<a href="http://blog.pivotal.io/pivotal/products/websocket-architecture-in-spring-4-0">这个博客的文章</a>。</p>
<h3 id="HTTP-Streaming直接写到OutputStream中"><a href="#HTTP-Streaming直接写到OutputStream中" class="headerlink" title="HTTP Streaming直接写到OutputStream中"></a>HTTP Streaming直接写到OutputStream中</h3><p> <strong>ResponseBodyEmitter</strong>可以使用<strong>HttpMessageConverter</strong>来把对象写入到响应中，并发送这个事件。比如:写入JSON数据这种较为普遍的情况。然而，有些时候，比如像文件下载这种，分流消息的转换和直接写到相应的OutputStream中是很有用的。可以通过<strong>StreamingResponseBody</strong>返回的值类型来实现。</p>
<p>下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> StreamingResponseBody <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamingResponseBody</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTo</span><span class="params">(OutputStream outputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// write...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>ResponseBodyEmitter</strong>也同样能作为<strong>ResponseEntity</strong>的主体，来自定义响应的status（状态）和报头。</p>
<h3 id="配置异步的请求处理"><a href="#配置异步的请求处理" class="headerlink" title="配置异步的请求处理"></a>配置异步的请求处理</h3><h4 id="Servlet容器配置"><a href="#Servlet容器配置" class="headerlink" title="Servlet容器配置"></a>Servlet容器配置</h4><p>对于使用web.xml配置的应用程序，请确保升级到了3.0，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">http:</span>//<span class="attr">java.sun.com</span>/<span class="attr">xml</span>/<span class="attr">ns</span>/<span class="attr">javaee</span></span></span><br><span class="line"><span class="tag">            <span class="attr">http:</span>//<span class="attr">java.sun.com</span>/<span class="attr">xml</span>/<span class="attr">ns</span>/<span class="attr">javaee</span>/<span class="attr">web-app_3_0.xsd</span>&quot;</span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<strong>web.xml</strong>中异步支持必须在<strong>DispatcherServlet</strong>上开启,通过它的的**&lt;async-supported&gt;true&lt;&#x2F;async-supported&gt;<strong>子元素。另外，任何参与异步请求处理的</strong>Filter<strong>都必须配置为支持ASYNC dispatcher类型。为Spring Framework提供的所有过滤器启用ASYNC dispatcher类型应该是安全的，因为它们通常继承自</strong>OncePerRequestFilter**，并且具有关于过滤器是否需要参与异步调度的运行时期检查。</p>
<p>以下是一些web.xml配置示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Spring OpenEntityManagerInViewFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.~.OpenEntityManagerInViewFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Spring OpenEntityManagerInViewFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ASYNC<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用Servlet 3，基于Java的配置，例如通过<strong>WebApplicationInitializer</strong>，你同样需要像<strong>web.xml</strong>一样设置“asyncSupported”标志以及ASYNC dispatcher 类型。为了简化所有这些配置，请考虑继承<strong>AbstractDispatcherServletInitializer</strong>或更好的<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>，它会自动设置这些选项，并使其注册<strong>Filter</strong>实例变得非常简单。</p>
<h4 id="Spring-MVC配置"><a href="#Spring-MVC配置" class="headerlink" title="Spring MVC配置"></a>Spring MVC配置</h4><p>MVC Java配置和MVC命名空间提供了配置异步请求处理的选项。<strong>WebMvcConfigurer</strong>有<strong>configureAsyncSupport</strong>方法，而**&lt;mvc:annotation-driven&gt;<strong>有一个</strong>&lt;async-support&gt;**子元素。</p>
<p>这些允许你配置用于异步请求的默认超时值，如果未设置，则取决于底层的Servlet容器（例如Tomcat上为10秒）。你还可以配置一个AsyncTaskExecutor用于执行从控制器方法返回的Callable实例。强烈建议配置此属性，因为默认情况下，Spring MVC使用<strong>SimpleAsyncTaskExecutor</strong>。MVC的Java配置和MVC命名空间还允许你注册<strong>CallableProcessingInterceptor</strong>和<strong>DeferredResultProcessingInterceptor</strong>实例。</p>
<p>如果需要覆盖特定<strong>DeferredResult</strong>的默认超时值，可以使用适当的类构造函数。类似地，对于<strong>Callable</strong>，你可以将其包装在<strong>WebAsyncTask</strong>中，并使用适当的类构造函数自定义超时值。<strong>WebAsyncTask</strong>的类构造函数也允许提供一个<strong>AsyncTaskExecutor</strong>。</p>
<h2 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h2><p>spring-test模块对于测试带注解的控制器提供一流的支持。请参见<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#spring-mvc-test-framework">第15.6节“Spring MVC测试框架”</a>。</p>
<hr>
<h1 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h1><hr>
<p>在以前的Spring版本中，用户需要在Web应用程序上下文中定义一个或多个<strong>HandlerMapping</strong> bean，以将传入的Web请求映射到适当的处理器。随着注解控制器的引入，你一般不需要再这样做，因为<strong>RequestMappingHandlerMapping</strong>会自动在所有的**@Controller** bean上查找**@RequestMapping<strong>注解。但是，请记住，从</strong>AbstractHandlerMapping<strong>扩展的所有</strong>HandlerMapping**类都具有以下可用于自定义其行为的属性：</p>
<ul>
<li><strong>interceptors</strong>：要使用的拦截器列表。HandlerInterceptors在第4.1节“使用HandlerInterceptor拦截请求”中讨论。</li>
<li><strong>defaultHandler</strong>：当映射器处理器在一次映射处理器时没有映射结果，默认使用的处理器，</li>
<li><strong>order</strong>：基于order属性的值（请参阅org.springframework.core.Ordered接口），Spring会排序上下文中可用的所有处理器映射器，并应用第一个匹配的处理器。</li>
<li><strong>alwaysUseFullPath</strong>：如果为true，Spring将使用当前Servlet上下文中的完整路径来查找适当的handler。如果为false（默认值），则使用当前Servlet映射中的路径。例如，如果一个Servlet使用&#x2F;testing&#x2F;*映射，并且将alwaysUseFullPath属性设置为true，则使用&#x2F;testing&#x2F;viewPage.html，而如果属性设置为false，则使用&#x2F;viewPage.html。</li>
<li><strong>urlDecode</strong>：默认为true，从Spring 2.5开始。如果你喜欢比较编码路径，请将此标志设置为false。但是，HttpServletRequest始终以解码形式公开Servlet路径。请注意，当与编码路径比较时，Servlet路径将不匹配。</li>
</ul>
<p>以下示例说明如何配置拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用HandlerInterceptor拦截请求"><a href="#用HandlerInterceptor拦截请求" class="headerlink" title="用HandlerInterceptor拦截请求"></a>用HandlerInterceptor拦截请求</h2><hr>
<p>Spring的处理器映射机制包括处理器拦截器，当你希望将特定功能应用于某些请求时很有用，例如，检查请求体。</p>
<p>位于处理器映射器中的拦截器必须实现<strong>org.springframework.web.servlet</strong>包中<strong>HandlerInterceptor</strong>。这个接口定义了三个方法：**preHandle(..)**在处理器实际执行之前调用;**postHandle(..)**在处理器执行后调用;**afterCompletion(..)**在完整的请求完成后调用。这三种方法应提供足够的灵活性进行各种预处理和后处理。</p>
<p><strong>preHandle(..)<strong>方法返回一个布尔值。你可以使用此方法来中断或继续处理执行链。当此方法返回</strong>true</strong>时，处理器执行链将继续;当它返回<strong>false</strong>时，<strong>DispatcherServlet</strong>假定拦截器本身已经处理了请求（例如渲染了适当的视图），并且不会继续执行其他拦截器和执行链中的实际处理器。</p>
<p>拦截器可以使用<strong>interceptors</strong>属性进行配置，该属性存在继承<strong>AbstractHandlerMapping</strong>的所有<strong>HandlerMapping</strong>类上。这在下面的示例中显式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handlerMapping&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;officeHoursInterceptor&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;officeHoursInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;samples.TimeBasedAccessInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;openingTime&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;closingTime&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeBasedAccessInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> openingTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> closingTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOpeningTime</span><span class="params">(<span class="type">int</span> openingTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openingTime = openingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClosingTime</span><span class="params">(<span class="type">int</span> closingTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.closingTime = closingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">            Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> cal.get(HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">if</span> (openingTime &lt;= hour &amp;&amp; hour &lt; closingTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;http://host.com/outsideOfficeHours.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此映射器处理的任何请求都将被<strong>TimeBasedAccessInterceptor</strong>拦截。如果当前时间在办公时间之外，用户将被重定向到静态HTML文件，例如，你只能在办公时间内访问该网站。</p>
<blockquote>
<p>当使用<strong>RequestMappingHandlerMapping</strong>时，实际的处理器是<strong>HandlerMethod</strong>的一个实例，它标识将被调用的特定控制器方法。</p>
</blockquote>
<p>你可以看到，Spring适配器类<strong>HandlerInterceptorAdapter</strong>使得更容易扩展<strong>HandlerInterceptor</strong>接口。</p>
<blockquote>
<p>在上面的示例中，配置的拦截器将应用于使用注解控制器方法处理的所有请求。如果要缩小拦截器应用的URL路径，你可以使用MVC命名空间或MVC Java配置，或声明类型为MappedInterceptor的bean实例来执行此操作。请参见第<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc-config-enable">16.1节“启用MVC Java配置或MVC XML命名空间”</a>。</p>
</blockquote>
<p>请注意，<strong>HandlerInterceptor</strong>的<strong>postHandle</strong>方法并不总是适用于**@ResponseBody<strong>和</strong>ResponseEntity<strong>方法。在这种情况下，</strong>HttpMessageConverter<strong>在调用</strong>postHandle<strong>之前写入并提交响应，这使得不可能再更改响应，例如添加一个响应头。相反，应用程序可以实现</strong>ResponseBodyAdvice<strong>，并将其声明为</strong>@ControllerAdvice** bean或直接在<strong>RequestMappingHandlerAdapter</strong>上进行配置。</p>
<hr>
<h1 id="解析视图"><a href="#解析视图" class="headerlink" title="解析视图"></a>解析视图</h1><hr>
<p>用于Web应用程序的所有MVC框架提供了一种定址视图的方法。Spring提供视图解析器，它使你可以在浏览器中渲染模型，而不需要将你和特定的视图技术绑定起来起来。开箱即用，例如，Spring可以使用JSP，Velocity模板和XSLT视图。有关如何集成和使用多种不同视图技术的讨论，请参阅第<a href="">“视图技术”</a>。</p>
<p>对于Spring处理视图的方式来说，两个重要的接口是<strong>ViewResolver</strong>和<strong>View</strong>。<strong>ViewResolver</strong>提供了视图名称和实际视图之间的映射。<strong>View</strong>接口预备好指定request请求的地址，并将请求转交给其中一种视图技术。</p>
<h2 id="使用ViewResolver接口解析视图"><a href="#使用ViewResolver接口解析视图" class="headerlink" title="使用ViewResolver接口解析视图"></a>使用ViewResolver接口解析视图</h2><hr>
<p>如<a href="#%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%99%A8">第3节“实现控制器”</a>中所述，Spring Web MVC控制器中的所有处理器方法必须解析为逻辑视图名称,要么显式指出（例如，通过返回<strong>String</strong>，<strong>View</strong>或<strong>ModelAndView</strong>）要么隐式地（即基于惯例来处理）。Spring中的视图由逻辑视图名称编址，并由视图解析器解析。Spring自带几个视图解析器。这张表列出了大部分;以下几个例子。</p>
<table>
<thead>
<tr>
<th>ViewResolver</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AbstractCachingViewResolver</strong></td>
<td>缓存视图的抽象视图解析器。通常，视图在它能使用前需要准备;扩展此视图解析器提供缓存。</td>
</tr>
<tr>
<td><strong>XmlViewResolver</strong></td>
<td>ViewResolver的实现，它接受用XML编写的配置文件，与Spring的XML bean工厂具有相同的DTD。。默认配置文件为&#x2F;WEB-INF&#x2F;views.xml。</td>
</tr>
<tr>
<td><strong>ResourceBundleViewResolver</strong></td>
<td>ViewResolver的实现，它使用ResourceBundle中的bean定义，由bundle基本名称指定。通常你在属性文件中定义bundle，该属性文件位于类路径中。默认文件名为views.properties。</td>
</tr>
<tr>
<td><strong>UrlBasedViewResolver</strong></td>
<td>ViewResolver接口的简单实现，它直接解析逻辑视图名称到URL，而不需要定义显式的映射。这比较适合在逻辑视图名与你的视图资源名相匹配的情况下使用，这样就不用显式地指定映射了。</td>
</tr>
<tr>
<td><strong>InternalResourceViewResolver</strong></td>
<td>UrlBasedViewResolver的便利子类，支持InternalResourceView（实际上是Servlets和JSP）和子类，如JstlView和TilesView。你可以使用setViewClass(..)为此解析器生成的所有视图指定视图类。有关详细信息，请参阅UrlBasedViewResolver的javadocs。</td>
</tr>
<tr>
<td><strong>VelocityViewResolver</strong>&#x2F;<strong>FreeMarkerViewResolver</strong></td>
<td>UrlBasedViewResolver的便利子类，分别支持VelocityView（实际上是Velocity模板）或FreeMarkerView，以及它们的自定义子类。</td>
</tr>
<tr>
<td><strong>ContentNegotiatingViewResolver</strong></td>
<td>ViewResolver接口的实现，它根据请求文件名或Accept头来解析视图。参见<a href="#ContentNegotiatingViewResolver">第5.4节， “ContentNegotiatingViewResolver”</a>。</td>
</tr>
</tbody></table>
<p>例如，使用JSP作为视图技术，你可以使用UrlBasedViewResolver。此视图解析器将视图名称转换为URL，并将请求转交给RequestDispatcher以渲染视图。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当返回test作为逻辑视图名称时，此视图解析器将请求转发到<strong>RequestDispatcher</strong>，它会发送请求到&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp。</p>
<p>当你在Web应用程序中组合不同的视图技术时，可以使用ResourceBundleViewResolver：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;views&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultParentView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parentView&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>ResourceBundleViewResolver</strong>检查由basename标识的<strong>ResourceBundle</strong>，对于每个应该解析的视图，它使用属性**[viewname].(class)<strong>的值作为视图类，并且属性</strong>[viewname] .url**的值为视图url。示例可以在涵盖视图技术的下一章中找到。如你看到的，你可以识别一个父视图，它时这个属性文件中所有视图”拓展”自的。这样，你可以指定默认视图类。</p>
<blockquote>
<p><strong>AbstractCachingViewResolver</strong>的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。可以通过将cache属性设置为false来关闭缓存。此外，如果你必须在运行时刷新某个视图（例如，当Velocity模板被修改时），可以使用**removeFromCache(String viewName，Locale loc)**方法。</p>
</blockquote>
<h2 id="视图解析器链"><a href="#视图解析器链" class="headerlink" title="视图解析器链"></a>视图解析器链</h2><hr>
<p>Spring支持多个视图解析器。因此，你可以链接解析器，例如，并且在某些情况下覆盖特定视图。</p>
<p>你可以通过在应用程序上下文中添加多个解析器来链接视图解析器，如有必要，可以通过设置order属性来指定顺序。记住，order属性越高，视图解析器在链中的位置越靠后。</p>
<p>在以下示例中，视图解析器链由两个解析器组成，一个InternalResourceViewResolver，它始终自动定位为链中的最后一个解析器，另一个是XmlViewResolver用于指定Excel视图。InternalResourceViewResolver不支持Excel视图。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jspViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;excelViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- in views.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;report&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.example.ReportExcelView&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果一个指定的视图解析器不会产生视图，Spring会检查其他视图解析器的上下文。如果存在另外的视图解析器，Spring会继续检查它们，直到视图被解析。如果没有视图解析器返回一个视图，Spring会抛出一个<strong>ServletException</strong>异常。</p>
<p>视图解析器的合同指定视图解析器可以返回null以指示无法找到视图。然而，并不是所有的视图解析器都这样做，因为在某些情况下，解析器根本无法检测视图是否存在。例如，<strong>InternalResourceViewResolver</strong>在内部使用<strong>RequestDispatcher</strong>，并且调度是确定JSP是否存在的唯一方法，但此操作只能执行一次。这同样适用于<strong>VelocityViewResolver</strong>和其他一些解析器。检查特定视图解析器的javadoc以查看它们是否报告不存在的视图。因此，没有将<strong>InternalResourceViewResolver</strong>放在最后，会导致该链没有被完全检查，因为<strong>InternalResourceViewResolver</strong>总会返回一个视图（包括空视图）。</p>
<h2 id="重定向到视图"><a href="#重定向到视图" class="headerlink" title="重定向到视图"></a>重定向到视图</h2><hr>
<p>如前面提到的，一个控制器通常返回一个逻辑视图名，视角解析器将其解析为特定视图技术。对于诸如JSP的视图技术，它们通过 Servlet或JSP 引擎进行处理，这种解析通常通过<strong>InternalResourceViewResolver</strong>和<strong>InternalResourceView</strong>的组合来处理，它通过Servlet API的**RequestDispatcher.forward(..)<strong>方法或</strong>RequestDispatcher.include()**方法发出内部转发或包含。对于其他视图技术，例如Velocity,XSLT等等，视图本身将内容直接写入响应流。</p>
<p>有时需要视图在被渲染完成之前，将HTTP重定向先发送回客户端。例如，当一个控制器已经被POST数据调用，并且响应实际上委托给另一个控制器（例如，成功的表单提交）。在这种情况下，普通的内部转发将意味着另一个控制器也会看到相同的POST数据，如果它与其他预期数据混在一起的话，就会造成潜在的问题。在显式结果之前执行重定向的另一个原因是消除用户多次提交表单数据的可能性。在这种情况下，浏览器将首先发送初始<strong>POST</strong>;然后它会收到重定向到其他URL的响应;最后浏览器将为重定向响应中命名的URL执行后续的<strong>GET</strong>。因此，从浏览器的角度来看，当前页面不反映<strong>POST</strong>的结果，而是一个<strong>GET</strong>。最终的效果是用户无法通过执行刷新来意外重复<strong>POST</strong>到相同的数据。刷新会在那个结果页面强制GET，而不是重新发送初始<strong>POST</strong>数据。</p>
<h3 id="RedirectView"><a href="#RedirectView" class="headerlink" title="RedirectView"></a>RedirectView</h3><p>强迫重定向作为控制器响应结果的一个方式是控制器创建并返回一个Spring的<strong>RedirectView</strong>实例。在这种情况下，<strong>DispatcherServlet</strong>不使用通常的视图解析机制。而是因为该实例已经给出了（重定向）视图，<strong>DispatcherServlet</strong>只是指示视图来完成它的工作。反过来<strong>RedirectView</strong>的调用**HttpServletResponse.sendRedirect()**将HTTP重定向发送到客户端浏览器。</p>
<p>如果你使用RedirectView并且该视图是由控制器本身创建的，建议你将重定向URL配置为要注入到控制器中，这样的话，就不会与这个controller耦合太大，而只是在context的配置文件中配置了这个视图名。“‘redirect:’前缀”这节有助于此解耦。</p>
<h3 id="传递数据到重定向目标"><a href="#传递数据到重定向目标" class="headerlink" title="传递数据到重定向目标"></a>传递数据到重定向目标</h3><p>默认情况下，所有模型属性都被认为是重定向URL中的URI模板变量。其余的原始类型或原始类型的collections&#x2F;arrays都被自动添加为一个查询参数。</p>
<p>如果一个模型实例是专门为这次重定向行为而准备的，这种情况下，把基本类型的属性作为查询参数追加到URL上是期望的。然而，在注解控制器中，模型可能包含为渲染目的添加的额外属性（例如下拉列表的字节值）。为了避免在URL中出现这样的属性的可能性，**@RequestMapping<strong>方法可以声明一个类型为</strong>RedirectAttributes<strong>的参数，并使用它来指定可用于</strong>RedirectView<strong>的确切属性。如果方法重定向，则使用</strong>RedirectAttributes**的内容。否则使用模型的内容。</p>
<p><strong>RequestMappingHandlerAdapter</strong>提供了一个名为“<strong>ignoreDefaultModelOnRedirect</strong>”的标志，可以用于指示如果控制器方法重定向，默认Model中的内容不会被使用。作为替代，控制器方法应该声明一个<strong>RedirectAttributes</strong>类型属性，或者没有任何属性被传递到<strong>RedirectView</strong>中。MVC命名空间和MVC Java配置都将此标志设置为false，以保持兼容之前的spring版本。但是，对于新的应用程序，我们建议将其设置为true。</p>
<p>请注意，当扩展重定向URL时，当前请求中的URI模板变量可以自动使用，并不需要通过<strong>Model</strong>和<strong>RedirectAttributes</strong>来显式添加。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/files/&#123;path&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:files/&#123;path&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种传递数据到重定向目标的方式是通过Flash Attributes。不像其他的重定向属性，flash属性被保存在HTTP session中（因此不会出现在URL中）。有关详细信息，请参见<a href="#%E4%BD%BF%E7%94%A8Flash%E5%B1%9E%E6%80%A7">第6节“使用Flash属性”</a>。</p>
<h3 id="“redirect-”前缀"><a href="#“redirect-”前缀" class="headerlink" title="“redirect: ”前缀"></a>“redirect: ”前缀</h3><p>虽然<strong>RedirectView</strong>的使用工作良好，但如果控制器本身创建了<strong>RedirectView</strong>，则无法避免控制器意识到重定向发生。这并不是最佳的做法，因为这样耦合的太紧密。控制器不应该真正关心响应如何处理。一般来说，它应该只在视图名被注入到其中时才进行处理。</p>
<p>特殊的<strong>redirect:<strong>前缀允许你完成这个。如果返回的视图名称带有</strong>redirect:<strong>前缀，</strong>UrlBasedViewResolver</strong>（和所有子类）将会将其识别为需要重定向的特殊指示。视图名称的其余部分将被视为重定向URL。</p>
<p>净效果与控制器返回的<strong>RedirectView</strong>相同，但现在控制器本身可以只需要简单地按照逻辑视图名称进行操作。一个逻辑视图名称如<strong>redirect:&#x2F;myapp&#x2F;some&#x2F;resource</strong>将相对于当前的Servlet上下文进行重定向，而如**redirect://http://myhost.com/some/arbitrary/path**这样的名称将重定向到一个绝对URL。</p>
<p> 请注意，如果控制器的处理器被**@ResponseStatus<strong>所注解，注解的值是优先于被</strong>RedirectView**设置的response status(响应状态)。</p>
<h3 id="“forward-”前缀"><a href="#“forward-”前缀" class="headerlink" title="“forward: ”前缀"></a>“forward: ”前缀</h3><p>对于最终由<strong>UrlBasedViewResolver</strong>和它的子类解析的视图名称，也可能使用一个特殊的前缀**forward: **。这会为除前缀外的其余视图名创建一个InternalResourceView（它最终会执行一个RequestDispatcher.forward()）,其余视图名也被视为一个URL。因此，这个前缀与InternalResourceViewResolver和InternalResourceView（对于JSP）一起使用时就没有了。但是当你主要使用的是(除JSP外)其他的视图技术时，这个前缀就很有用，但是它还是会强制使用Servlet&#x2F;JSP引擎来处理对资源的forward操作（请注意，你也可以链接多个视图解析器。）。</p>
<p>如“redirect: ”前缀一样，如果带有“forward: ”前缀的视图名被注入到控制器中，控制器在处理响应方面不会检测到有什么特别的事情发生。</p>
<h2 id="ContentNegotiatingViewResolver"><a href="#ContentNegotiatingViewResolver" class="headerlink" title="ContentNegotiatingViewResolver"></a>ContentNegotiatingViewResolver</h2><hr>
<p><strong>ContentNegotiatingViewResolver</strong>自己不解析视图，而是委托给其他视图解析器，选择类似于客户端请求的表示的视图。对于客户端从服务器端请求表现形式，有以下两种策略:</p>
<ul>
<li>对每个资源使用不同的URI，通常通过在URI中使用不同的文件扩展名来实现。例如，URI http://www.example.com/users/fred.pdf请求用户fred的PDF展示，并且http://www.example.com/users/fred.xml请求XML展示。</li>
<li>使用相同的URI来为客户端定位资源，但设置<strong>Accept</strong> HTTP请求头来给出客户端能够理解的media types（媒体类型）。例如，一个对http://www.example.com/users/fredHTTP请求带有<strong>Accept</strong>请求头值为<strong>application&#x2F;pdf</strong>，这请求用户fred的PDF表示，而http://www.example.com/users/fred的请求带有被设置为<strong>text&#x2F;xml</strong>的请求头**Accept **，请求一个XML展示。这种策略就是内容协商（content negotiation）。</li>
</ul>
<blockquote>
<p>Accept请求头的一个问题是，不能使用HTML的Web浏览器中设置它。例如，在Firefox中，它被固定为：<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,<em>&#x2F;</em>;q&#x3D;0.8<br>因为这个原因，当开发基于浏览器的Web应用程序，为不同的表现形式使用不同的URI是很常见的。</p>
</blockquote>
<p>为了支持资源的多种表示，Spring提供<strong>ContentNegotiatingViewResolver</strong>，以根据HTTP请求的Accept头或文件拓展名来解析视图。<strong>ContentNegotiatingViewResolver</strong>自身不执行视图解析，而是委托给你通过bean属性<strong>ViewResolvers</strong>指定的视图解析器列表。</p>
<p><strong>ContentNegotiatingViewResolver</strong>通过将请求媒体类型与与其每个<strong>ViewResolver</strong>相关联的<strong>View</strong>支持的媒体类型（也称为<strong>Content-Type</strong>）进行比较，来选择适当的<strong>View</strong>来处理请求。第一个匹配到<strong>Content-Type</strong>的<strong>View</strong>对象将会被返回到客户端。如果<strong>ViewResolver</strong>链不能提供兼容的视图，则会查看通过<strong>DefaultViews</strong>属性（property）指定的视图列表。默认的视图适用于单例<strong>View</strong>，该单例View可以渲染当前资源的适当表示，而不管逻辑视图名。<strong>Accept</strong>请求头可以包括通配符，例如<em>*text&#x2F;<em><strong>，在这种情况下，其</strong>Content-Type</em>*为</em>*text&#x2F;xml<strong>的</strong>View**是兼容的匹配项。</p>
<p>要支持基于文件扩展名的视图的自定义解析，请使用ContentNegotiationManager：请参见<a href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">第16.6节“内容协商”</a>。</p>
<p>以下是ContentNegotiatingViewResolver配置的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewResolvers&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultViews&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.samples.rest.SampleContentAtomView&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>InternalResourceViewResolver</strong>处理视图名称和JSP页面名称的翻译，而<strong>BeanNameViewResolver</strong>会根据bean的名称返回一个视图。（有关Spring如何查看和实例化视图的详细信息，请参阅<a href="#%E4%BD%BF%E7%94%A8ViewResolver%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90%E8%A7%86%E5%9B%BE">“使用ViewResolver接口解析视图”</a>。）在此示例中，<strong>content</strong> bean是继承自<strong>AbstractAtomFeedView</strong>的类，它返回Atom RSS提要。有关创建Atom Feed表示的更多信息，请参阅Atom视图。</p>
<p>在上述配置中，如果使用**.html<strong>扩展名进行请求，则视图解析器将查找与</strong>text&#x2F;html<strong>媒体类型匹配的视图。</strong>InternalResourceViewResolver<strong>提供匹配</strong>text&#x2F;html<strong>的视图。如果请求是使用文件扩展名</strong>.atom<strong>，视图解析器将查找与</strong>application&#x2F;atom+xml<strong>媒体类型匹配的视图。如果返回的视图名称是</strong>content<strong>，则此视图由</strong>BeanNameViewResolver<strong>提供，将其映射到</strong>SampleContentAtomView<strong>上。如果请求是使用文件扩展名</strong>.json<strong>，则</strong>DefaultViews<strong>列表中的</strong>MappingJackson2JsonView<strong>实例将被选中，而不管视图名称如何。另外，客户端请求可以不带文件扩展名，而是带有被设置为首选媒体类型的</strong>Accept**请求头，请求的解析过程跟前一种方式是一样的。</p>
<blockquote>
<p>如果“ContentNegotiatingViewResolver”的ViewResolver列表未被显式配置，它会自动使用应用程序上下文中定义的任何ViewResolvers。</p>
</blockquote>
<p>下面显式了相应的控制器代码，它对于URI形式为http://localhost/content.atom或http://localhost/content,且Accept请求头值为application&#x2F;atom+xml 的，返回一个Atom RSS提要。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SampleContent&gt; contentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SampleContent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/content&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.setViewName(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;sampleContentList&quot;</span>, contentList);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用Flash属性"><a href="#使用Flash属性" class="headerlink" title="使用Flash属性"></a>使用Flash属性</h1><hr>
<p>Flash属性为一个请求存储属性提供了一种方式，这些存储的属性是为了能在其他请求中使用。这是重定向时最常用的 - 例如Post&#x2F;Redirect&#x2F;Get模式。Flash属性在重定向之前临时保存（之前通常是在session中），以便在重定向后可以提供给请求使用，并立即删除。</p>
<p>Spring MVC有两个主要的抽象支持Flash属性。FlashMap用于保存Flash属性，FlashMapManager用于存储，检索和管理FlashMap实例。</p>
<p>Flash属性支持始终是“开启”的，不需要显式启用，即使不使用它也一样，它不会导致HTTP session创建。对于每一个请求，会一个“输入”FlashMap，它带有前一个请求（如果有的话）传递进的属性，并且有一个“输出”FlashMap，带有储存起来用于后续请求的属性。这两个FlashMap实例都可以通过SpringContextMtils中的静态方法在Spring MVC中任何地方访问。</p>
<p>注解的控制器通常不需要直接使用<strong>FlashMap</strong>。相代替的，**@RequestMapping<strong>方法可以接受</strong>RedirectAttributes<strong>类型的参数，并使用它来对重定向场景添加的Flash属性。通过</strong>RedirectAttributes<strong>添加的Flash属性将自动传播到“输出”</strong>FlashMap**。类似地，在重定向之后，来自“输入”FlashMap的属性将自动添加到为目标URL提供服务的控制器中的Model中。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">“匹配请求到Flash属性
Flash属性的概念存在于许多其他Web框架中，并且已被证明在有些并发情况下会暴露出一些问题。这是因为根据定义，flash属性将被存储直到下一个请求。然而，有可能下一个请求并不是这个请求的接收者，而是另一个异步的请求(比如轮询，或资源的请求)，在这种情况下，flash属性就会被过早地被移除。

<p>为了减少这种问题的可能性，RedirectView会自动使用目标重定向URL的路径和查询参数”戳记”Flash实例。反过来，当查找“输入”FlashMap时，默认的FlashMapManager会将该信息与传入请求进行匹配。</p>
<p>这不能完全消除并发问题的可能性，但是通过重定向URL中已经提供的信息已经大大减少了它。因此，使用Flash属性主要用于重定向场景。</p>
</div> 


<hr>
<h1 id="组建URI"><a href="#组建URI" class="headerlink" title="组建URI"></a>组建URI</h1><hr>
<p>Spring MVC提供了使用<strong>UriComponentsBuilder</strong>和<strong>UriComponents</strong>构建和编码URI的机制。</p>
<p>例如，你可以扩展并且编码URI模板字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> UriComponentsBuilder.fromUriString(</span><br><span class="line">        <span class="string">&quot;http://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.expand(<span class="string">&quot;42&quot;</span>, <span class="string">&quot;21&quot;</span>).encode().toUri();</span><br></pre></td></tr></table></figure>
<p>请注意，UriComponent是不可变的，expand()和encode()操作如果必要的话，会返回新的实例。</p>
<p>你还可以使用单项URI组件进行扩展和编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> UriComponentsBuilder.newInstance()</span><br><span class="line">        .scheme(<span class="string">&quot;http&quot;</span>).host(<span class="string">&quot;example.com&quot;</span>).path(<span class="string">&quot;/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;&quot;</span>).build()</span><br><span class="line">        .expand(<span class="string">&quot;42&quot;</span>, <span class="string">&quot;21&quot;</span>)</span><br><span class="line">        .encode();</span><br></pre></td></tr></table></figure>
<p>在Servlet环境中，ServletUriComponentsBuilder子类提供了静态工厂方法，来从Servlet请求中复制可用的URL信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重用原request中的host，scheme格式，端口，路径和查询参数的字符串  </span></span><br><span class="line"><span class="comment">// 替换掉&quot;accountId&quot; 的查询参数值  </span></span><br><span class="line"></span><br><span class="line"><span class="type">ServletUriComponentsBuilder</span> <span class="variable">ucb</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromRequest(request)</span><br><span class="line">        .replaceQueryParam(<span class="string">&quot;accountId&quot;</span>, <span class="string">&quot;&#123;id&#125;&quot;</span>).build()</span><br><span class="line">        .expand(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .encode();</span><br></pre></td></tr></table></figure>
<p>或者，你可以选择复制可用信息的一部分，范围一直到并包括上下文路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重用host,port(端口)和context路径  </span></span><br><span class="line"><span class="comment">// 把&quot;/accounts&quot;追加到路径后面  </span></span><br><span class="line"></span><br><span class="line"><span class="type">ServletUriComponentsBuilder</span> <span class="variable">ucb</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromContextPath(request)</span><br><span class="line">        .path(<span class="string">&quot;/accounts&quot;</span>).build()</span><br></pre></td></tr></table></figure>
<p>或者在DispatcherServlet按名称（例如&#x2F;main&#x2F;*）映射的情况下，还可以包含servlet映射的文字部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重用 host, port,context path  </span></span><br><span class="line"><span class="comment">// 追加servlet的映射的文字部分到路径中 </span></span><br><span class="line"><span class="comment">// 追加&quot;/accounts&quot; 到路径上  </span></span><br><span class="line"></span><br><span class="line"><span class="type">ServletUriComponentsBuilder</span> <span class="variable">ucb</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromServletMapping(request)</span><br><span class="line">        .path(<span class="string">&quot;/accounts&quot;</span>).build()</span><br></pre></td></tr></table></figure>

<h2 id="组建控制器和方法的URI"><a href="#组建控制器和方法的URI" class="headerlink" title="组建控制器和方法的URI"></a>组建控制器和方法的URI</h2><hr>
<p>Spring MVC还提供了一种用于组建链接到控制器方法上的机制。例如，给出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hotels/&#123;hotel&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/bookings/&#123;booking&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBooking</span><span class="params">(<span class="meta">@PathVariable</span> Long booking)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以按照名称引用方法来准备一个链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> MvcUriComponentsBuilder</span><br><span class="line">    .fromMethodName(BookingController.class, <span class="string">&quot;getBooking&quot;</span>, <span class="number">21</span>).buildAndExpand(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们提供了实际的方法参数值，在这种情况下，long值21被用作路径变量并插入到URL中。此外，我们提供了值42，以填充任何剩余的URI变量，例如从类型级请求映射继承的“hotel”变量。如果该方法有更多的参数，你可以为URL不需要的参数提供null。一般来说，只有**@PathVariable<strong>和</strong>@RequestParam**参数与构造URL相关。</p>
<p>还有其他方式使用MvcUriComponentsBuilder。例如，你可以使用某种类似mock测试的技术，，以避免通过名称引用控制器方法（该示例假定静态导入MvcUriComponentsBuilder.on）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> MvcUriComponentsBuilder</span><br><span class="line">    .fromMethodCall(on(BookingController.class).getBooking(<span class="number">21</span>)).buildAndExpand(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>
<p>以上示例在MvcUriComponentsBuilder中使用静态方法。在内部，他们依靠ServletUriComponentsBuilder从当前请求的scheme, host, port, context path和servlet path中准备一个基本URL。这在大多数情况下运行良好，但有时可能还不够。例如，你可能不在请求的上下文中（比如:链接准备时的批量处理过程），或者你可能需要插入路径前缀（例如: 本地前缀从请求路径中被移除了，并且需要重新添加到链接中）。</p>
<p>对于这种情况，你可以使用接受UriComponentsBuilder的静态“fromXxx”重载方法来使用基本URL。或者你可以使用基本URL创建一个MvcUriComponentsBuilder的实例，然后使用基于实例的“withXxx”方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponentsBuilder</span> <span class="variable">base</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromCurrentContextPath().path(<span class="string">&quot;/en&quot;</span>);</span><br><span class="line"><span class="type">MvcUriComponentsBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> MvcUriComponentsBuilder.relativeTo(base);</span><br><span class="line">builder.withMethodCall(on(BookingController.class).getBooking(<span class="number">21</span>)).buildAndExpand(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>

<h2 id="使用“Forwarded”和“X-Forwarded-”头"><a href="#使用“Forwarded”和“X-Forwarded-”头" class="headerlink" title="使用“Forwarded”和“X-Forwarded- *”头"></a>使用“Forwarded”和“X-Forwarded- *”头</h2><hr>
<h2 id="从视图组建URI到控制器和方法"><a href="#从视图组建URI到控制器和方法" class="headerlink" title="从视图组建URI到控制器和方法"></a>从视图组建URI到控制器和方法</h2><hr>
<hr>
<h1 id="使用locale"><a href="#使用locale" class="headerlink" title="使用locale"></a>使用locale</h1><hr>
<hr>
<h1 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h1><hr>
<h2 id="主题概述"><a href="#主题概述" class="headerlink" title="主题概述"></a>主题概述</h2><hr>
<p>你可以应用Spring Web MVC框架主题来设置你的应用程序的整体外观，从而增强用户体验。主题是影响应用程序的视觉风格的静态资源（通常是样式表和图像）的集合。</p>
<h2 id="定义主题"><a href="#定义主题" class="headerlink" title="定义主题"></a>定义主题</h2><hr>
<p>要在Web应用程序中使用主题，你必须设置<strong>org.springframework.ui.context.ThemeSource</strong>接口的实现。<strong>WebApplicationContext</strong>接口继承自<strong>ThemeSource</strong>，但将其职责委托给专用实现。默认情况下，委托会是一个<strong>org.springframework.ui.context.support.ResourceBundleThemeSource</strong>实现，它从类路径根下加载属性文件。要使用自定义<strong>ThemeSource</strong>实现或配置<strong>ResourceBundleThemeSource</strong>的基本名称前缀，你可以在应用程序上下文中注册一个bean，并使用保留名称<strong>themeSource</strong>。Web应用程序上下文将自动检测具有该名称的bean并使用它。</p>
<p>当使用<strong>ResourceBundleThemeSource</strong>时，主体被定义在一个简单的属性文件中。属性文件列出构成主题的资源。这有一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">styleSheet=/themes/cool/style.css</span><br><span class="line">background=/themes/cool/img/coolBg.jpg</span><br></pre></td></tr></table></figure>
<p>属性的键是从视图代码引用主题元素的名称。对于JSP，你通常使用<strong>spring:theme</strong>自定义标签来执行此操作，它与<strong>spring:message</strong>标签非常相似。以下JSP片段使用上一个示例中定义的主题来自定义外观：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;spring:theme code=&#x27;styleSheet&#x27;/&gt;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background=&lt;spring:theme code=&#x27;background&#x27;/&gt;&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，ResourceBundleThemeSource使用空的基本名称前缀。因此，属性文件从类路径的根目录加载。因此，你可以将cool.properties主题定义放在类路径的根目录中，例如&#x2F;WEB-INF&#x2F;classes中。ResourceBundleThemeSource使用标准的Java资源束加载机制，允许完全国际化的主题。例如，我们可以使用一个&#x2F;WEB-INF&#x2F;classes&#x2F;cool_nl.properties来引用一个包含荷兰文本的特殊的背景图像。</p>
<h2 id="主题解析器"><a href="#主题解析器" class="headerlink" title="主题解析器"></a>主题解析器</h2><hr>
<p>如上一节所述在定义主题后，你决定使用哪个主题。<strong>DispatcherServlet</strong>将寻找一个名为<strong>themeResolver</strong>的bean来找出要使用的<strong>ThemeResolver</strong>实现。主题解析器与<strong>LocaleResolver</strong>的工作方式大致相同。它检测到用于特定请求的主题，还可以更改请求的主题。下面是Spring提供的主题解析器：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FixedThemeResolver</strong></td>
<td>选择一个固定的主题，使用defaultThemeName属性进行设置。</td>
</tr>
<tr>
<td><strong>SessionThemeResolver</strong></td>
<td>在用户的HTTP session中维持的主题。它只需在每个session中设置一次。但是并不在session间保留。</td>
</tr>
<tr>
<td><strong>CookieThemeResolver</strong></td>
<td>所选主题存储在客户端的cookie中。</td>
</tr>
</tbody></table>
<p>Spring还提供了一个<strong>ThemeChangeInterceptor</strong>，允许使用简单的请求参数对每个请求进行主题更改。</p>
<hr>
<h1 id="Spring的多部件（文件上传）支持"><a href="#Spring的多部件（文件上传）支持" class="headerlink" title="Spring的多部件（文件上传）支持"></a>Spring的多部件（文件上传）支持</h1><hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr>
<p>Spring的内置多部件支持处理Web应用程序中的文件上传。你可以使用可插拔<strong>MultipartResolver</strong>对象来启用这个多部件支持，它定义在org.springframework.web.multipart包中。Spring提供了基于<strong>Commons FileUpload</strong>的<strong>MultipartResolver</strong>的实现，也提供了基于Servlet3.0 multipart请求解析的<strong>MultipartResolver</strong>的实现。</p>
<p>默认情况下，Spring没有多部件处理，因为一些开发人员想要自己处理多部件。你通过向web应用程序上下文中添加一个多部件解析器来弃用多部分处理。每个请求都被检查以查看是否包含一个多部件。如果没有发现多部件，请求按预期继续进行。如果在请求中发现多部件，在你的上下文中声明的<strong>MultipartResolver</strong>被使用。之后，你的请求中的multipart属性被视为任何其他属性。</p>
<h2 id="使用基于Commons-FileUpload的MultipartResolver"><a href="#使用基于Commons-FileUpload的MultipartResolver" class="headerlink" title="使用基于Commons FileUpload的MultipartResolver"></a>使用基于Commons FileUpload的MultipartResolver</h2><hr>
<p>以下示例显式如何使用<strong>CommonsMultipartResolver</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其中一个可用属性; 以字节为单位的最大文件体积 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，你还需要将适当的jar放在你的类路径中，以使多部件解析器工作。在使用<strong>CommonsMultipartResolver</strong>的情况下，你需要使用<strong>commons-fileupload.jar</strong>。</p>
<p>当Spring <strong>DispatcherServlet</strong>检测到multi-part请求时，它激活已经声明在你的上下文中的解析器，并且将请求交给它。然后解析器包装当前的<strong>HttpServletRequest</strong>到<strong>MultipartHttpServletRequest</strong>中，后者支持多部件文件上传。使用<strong>MultipartHttpServletRequest</strong>，你可以获取关于该请求包含的多部件的信息，并且在你的控制器中实际访问多部件文件。</p>
<h2 id="使用基于Servlet-3-0的MultipartResolver"><a href="#使用基于Servlet-3-0的MultipartResolver" class="headerlink" title="使用基于Servlet 3.0的MultipartResolver"></a>使用基于Servlet 3.0的MultipartResolver</h2><hr>
<p>为了使用基于Servlet 3.0的多部件解析鹅，你需要在<strong>web.xml</strong>中使用“multipart-config”部分标记<strong>DispatcherServlet</strong>，或者在编程式的Servlet注册中使用<strong>javax.servlet.MultipartConfigElement</strong>，或者在自定义Servlet类的情况下，可能在你的Servlet类上使用<strong>javax.servlet.annotation.MultipartConfig</strong>注解。配置设置，例如最大大小或存储位置需要在Servlet注册级别上应用，因为Servlet 3.0不允许从MultipartResolver完成这些设置。</p>
<p>一旦使用上述方法启用了Servlet 3.0多部分解析，你可以将<strong>StandardServletMultipartResolver</strong>添加到你的Spring配置中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="以表单处理文件上传"><a href="#以表单处理文件上传" class="headerlink" title="以表单处理文件上传"></a>以表单处理文件上传</h2><hr>
<p>MultipartResolver完成其作业后，请求的处理和其他的一样。首先，创建一个带有文件输入的表单，允许用户上传表单。编码属性（enctype &#x3D;“multipart &#x2F; form-data”）让浏览器知道如何将表单编码为multipart请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Upload a file please<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please upload a file<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/form&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下一步是创建一个处理文件上传的控制器。这个控制器非常类似于通常的注解@Controller，除了我们在方法参数中使用<strong>MultipartHttpServletRequest</strong>或<strong>MultipartFile</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/form&quot;)</span><br><span class="line">    public String handleFormUpload(@RequestParam(&quot;name&quot;) String name,</span><br><span class="line">            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line"></span><br><span class="line">        if (!file.isEmpty()) &#123;</span><br><span class="line">            byte[] bytes = file.getBytes();</span><br><span class="line">            // 将字节存储在某处</span><br><span class="line">            return &quot;redirect:uploadSuccess&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;redirect:uploadFailure&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意@RequestParam方法参数如何映射到表单中声明的input元素。在这个例子中，byte []没有做任何事情，但实际上你可以将它保存在数据库中，存储在文件系统上，等等。</p>
<p>当使用Servlet 3.0多部件解析时，你还可以使用javax.servlet.http.Part作为方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFormUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;file&quot;)</span> Part file)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">        <span class="comment">// 存储上传文件中的字节到某处</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:uploadSuccess&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理来自编程客户端的文件上传请求"><a href="#处理来自编程客户端的文件上传请求" class="headerlink" title="处理来自编程客户端的文件上传请求"></a>处理来自编程客户端的文件上传请求</h2><hr>
<p>在RESTful服务方案中多部件请求也可以从非浏览器客户端提交。所有上述示例和配置在这里也适用。然而，不像浏览器通常提交文件和简单的表单字段，编程式客户端还可以发送特定内容类型的更复杂的数据 —例如一个带有文件，并在第二部分是JSON格式化的数据的多部件请求，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;meta-data&quot;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>
<p>你可以使用**@RequestParam(“meta-data”) String metadata<strong>控制器方法参数访问名为“meta-data”的部分。但是，你可能更希望接受一个强类型对象，它是从请求部分的正文中的JSON格式的数据初始化而来，这非常类似于</strong>@RequestBody**，借助于一个HttpMessageConverter将非多部件请求的正文转换为目标对象的方式。</p>
<p>为此，你可以使用@RequestPart注解来代替@RequestParam注解。它允许你拥有特定多部件的内容，并通过HttpMessageConverter来转换成”Content-Type”报头里理想的多部件对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/someUrl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">onSubmit</span><span class="params">(<span class="meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestPart(&quot;file-data&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意如何使用**@RequestParam<strong>或使用</strong>@RequestPart<strong>互换访问MultipartFile方法参数。但是，在这种情况下，</strong>@RequestPart(“meta-data”) MetaData<strong>方法参数将根据其</strong>“Content-Type”<strong>头读取为JSON内容，并在</strong>MappingJackson2HttpMessageConverter**的帮助下进行转换。</p>
<hr>
<h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><hr>
<h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><hr>
<p>Spring <strong>HandlerExceptionResolver</strong>实现处理在控制器执行期间发生的意外异常。<strong>HandlerExceptionResolver</strong>有点类似于可以在Web应用程序描述符web.xml中定义的异常映射。但是，它提供了一种更灵活的方法。例如，它提供有关在抛出异常时正在执行哪个处理器的信息。此外，编程式的异常处理可以在请求转发到另一个URL之前提供更多的响应选项（与使用Servlet特定的异常映射有相同的最终结果）。</p>
<p>除了实现<strong>HandlerExceptionResolver</strong>接口，实现该接口只需要重写<strong>resolveException(Exception,Handler)<strong>方法并返回一个</strong>ModelAndView</strong>，你还可以使用提供的<strong>SimpleMappingExceptionResolver</strong>或者创建**@ExceptionHandler<strong>方法。</strong>SimpleMappingExceptionResolver<strong>使你能够获取可能抛出的任何异常的类名，并将其映射到视图名上。这在功能上等同于Servlet API的异常映射功能，但是，它在不同的处理器中，可以更精细地实现异常的映射。另一方面，</strong>@ExceptionHandler<strong>注解可以用于应该被调用来处理异常的方法。这样的方法可以在</strong>@Controller<strong>中本地定义，也可以在</strong>@ControllerAdvice<strong>类中定义，这时将应用于许多</strong>@Controller**类。以下部分将对此进行更详细的解释。</p>
<h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h2><hr>
<p><strong>HandlerExceptionResolver</strong>接口和<strong>SimpleMappingExceptionResolver</strong>实现允许你将异常映射到指定的视图上，并且可以在转发到这些视图前，声明地附带一些可选Java逻辑。然而，在某些情况下，特别是当依赖于**@ResponseBody**方法而不是视图解析器时，直接设置响应状态并且选择性将错误内容写入响应体中可能更加方便。</p>
<p>你可以用**@ExceptionHandler<strong>方法来做到这一点。当在控制器内声明时，这样的方法将适用这个控制器（或任何它的子类）内</strong>@RequestMapping<strong>方法产生的异常。你可以在</strong>@ControllerAdvice<strong>类中声明一个</strong>@ExceptionHandler<strong>方法，在这种情况下，它处理来自许多控制器的</strong>@RequestMapping<strong>方法的异常。以下是一个控制器本地的</strong>@ExceptionHandler**方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @RequestMapping方法忽略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleIOException</span><span class="params">(IOException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备responseEntity  </span></span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@ExceptionHandler</strong>的值可以设置为异常类型的数组。如果一个异常被抛出，并且该异常与列表中的类型之一相匹配，那么使用相匹配**@ExceptionHandler**注解的方法就会被调用。如果没有设置注解值，则使用列为方法参数的异常类型。</p>
<p>很像使用**@RequestMapping<strong>注解注解的标准控制器方法，</strong>@ExceptionHandler<strong>方法的方法参数和返回值也是很灵活的。例如，可以在Servlet环境中访问</strong>HttpServletRequest<strong>，并在Portlet环境中访问PortletRequest。返回类型可以是一个</strong>String<strong>，它会被解释为一个视图名称，也可以是一个</strong>ModelAndView<strong>对象，一个</strong>ResponseEntity<strong>，或者你也可以添加</strong>@ResponseBody**，使方法返回值被消息转换器转换并写入到响应流。</p>
<h2 id="处理标准的Spring-MVC异常"><a href="#处理标准的Spring-MVC异常" class="headerlink" title="处理标准的Spring MVC异常"></a>处理标准的Spring MVC异常</h2><hr>
<p>Spring MVC可能会在处理请求时引发许多异常。<strong>SimpleMappingExceptionResolver</strong>可以根据需要轻松将任何异常映射到默认的错误视图。然而，当需要运行于一些自动解析响应的客户端的时候，你可能会想要在响应里设置特定的状态码。根据异常产生的状态码来代表客户端的4xx错误和服务器的5xx错误。</p>
<p><strong>DefaultHandlerExceptionResolver</strong>将Spring MVC异常转换为特定的错误状态代码。它默认被MVC命名空间、MVC Java配置以及<strong>DispatcherServlet</strong>注册（即不使用MVC命名空间或Java配置时）注册。下面列出了这个解析器处理的一些异常和相应的状态代码：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>HTTP状态码</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BindException</strong></td>
<td>400 (Bad Request)</td>
</tr>
<tr>
<td><strong>ConversionNotSupportedException</strong></td>
<td>500 (Internal Server Error)</td>
</tr>
<tr>
<td><strong>HttpMediaTypeNotAcceptableException</strong></td>
<td>406 (Not Acceptable)</td>
</tr>
<tr>
<td><strong>HttpMediaTypeNotSupportedException</strong></td>
<td>415 (Unsupported Media Type)</td>
</tr>
<tr>
<td><strong>HttpMessageNotReadableException</strong></td>
<td>400 (Bad Request)</td>
</tr>
<tr>
<td><strong>HttpMessageNotWritableException</strong></td>
<td>500 (Internal Server Error)</td>
</tr>
<tr>
<td><strong>HttpRequestMethodNotSupportedException</strong></td>
<td>405 (Method Not Allowed)</td>
</tr>
<tr>
<td><strong>MethodArgumentNotValidException</strong></td>
<td>400 (Bad Request)</td>
</tr>
<tr>
<td><strong>MissingPathVariableException</strong></td>
<td>500 (Internal Server Error)</td>
</tr>
<tr>
<td><strong>MissingServletRequestParameterException</strong></td>
<td>400 (Bad Request)</td>
</tr>
<tr>
<td><strong>MissingServletRequestPartException</strong></td>
<td>400 (Bad Request)</td>
</tr>
<tr>
<td><strong>NoHandlerFoundException</strong></td>
<td>404 (Not Found)</td>
</tr>
<tr>
<td><strong>NoSuchRequestHandlingMethodException</strong></td>
<td>404 (Not Found)</td>
</tr>
<tr>
<td><strong>TypeMismatchException</strong></td>
<td>400 (Bad Request)</td>
</tr>
</tbody></table>
<p><strong>DefaultHandlerExceptionResolver</strong>通过设置响应的状态来透明地工作。然而，当你的应用程序可能需要添加开发者友好内容到每个错误响应时（比如，提供REST API时），它会由于响应的主体中缺少错误内容而停止。你可以准备一个<strong>ModelAndView</strong>并且通过视图解析器 —  也就是通过配置一个<strong>ContentNegotiatingViewResolver</strong>,<strong>MappingJackson2JsonView</strong>等等，来渲染错误内容。但是，你可能更喜欢使用**@ExceptionHandler**方法。</p>
<p>如果你喜欢通过**@ExceptionHandler<strong>方法编写错误内容，你可以可以扩展</strong>ResponseEntityExceptionHandler<strong>来代替。这是</strong>@ControllerAdvice<strong>类的方便的基础，它提供一个</strong>@ExceptionHandler<strong>方法来处理标准的Spring MVC异常并返回</strong>ResponseEntity**。这允许你自定义响应并使用消息转换器写入错误内容。有关更多详细信息，请参阅ResponseEntityExceptionHandler javadocs。</p>
<h2 id="用-ResponseStatus注解业务异常"><a href="#用-ResponseStatus注解业务异常" class="headerlink" title="用@ResponseStatus注解业务异常"></a>用@ResponseStatus注解业务异常</h2><hr>
<p>可以使用**@ResponseStatus<strong>注解业务异常。当产生异常时，</strong>ResponseStatusExceptionResolver<strong>通过设置相应地响应的状态来处理它。默认情况下，</strong>DispatcherServlet<strong>注册</strong>ResponseStatusExceptionResolver**，它可以使用。</p>
<h2 id="自定义默认Servlet容器错误页面"><a href="#自定义默认Servlet容器错误页面" class="headerlink" title="自定义默认Servlet容器错误页面"></a>自定义默认Servlet容器错误页面</h2><hr>
<p>当响应的状态被设置错误状态码并且响应的正文为空时，Servlet容器通常会呈现一个HTML格式的错误页面。要自定义容器的默认错误页面，可以在<strong>web.xml</strong>中声明一个**&lt;error-page&gt;**元素。在Servlet 3之前，该元素必须映射到特定的状态码或异常类型。从Servlet 3开始，不需要映射错误页面，这表示默认的Servlet容器错误页面可以被自定义为特定的地址了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，错误页面的实际位置可以是JSP页面或容器中的一些其他URL，包括通过**@Controller**方法处理的一个URL：</p>
<p>编写错误信息时，<strong>HttpServletResponse</strong>上设置的状态码和错误消息可以通过控制器中的请求属性访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/error&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;reason&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或在JSP中：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;application/json&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&#123;</span><br><span class="line">    status:&lt;%=request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>) %&gt;,</span><br><span class="line">    reason:&lt;%=request.getAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>) %&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><hr>
<p><a href="http://projects.spring.io/spring-security/">Spring Security</a>项目提供了保护Web应用程序免受恶意攻击的功能。请参阅“<a href="">CSRF保护</a>”，“<a href="">安全响应头</a>”以及“<a href="">Spring MVC集成</a>”部分中的参考文档。请注意，使用Spring Security来保护应用程序并不一定需要它的所有功能。例如CSRF保护可以只需添加CsrfFilter 和CsrfRequestDataValueProcessor到你的配置中。参见<a href="https://github.com/spring-projects/spring-mvc-showcase/commit/361adc124c05a8187b84f25e8a57550bb7d9f8e4">Spring MVC演示示例</a>。</p>
<p>另一个选择是使用专门用于Web Security的框架。HDIV就是一个这样的框架，并且可以与Spring MVC集成。</p>
<hr>
<h1 id="“约定优先于配置“的支持"><a href="#“约定优先于配置“的支持" class="headerlink" title="“约定优先于配置“的支持"></a>“约定优先于配置“的支持</h1><hr>
<p> 对于很多项目，坚持既定的约定并且有合力的默认值是它们（项目）所需的。SpringWeb MVC现在明确支持”约定优先于配置”。这意味着如果你建立了一套命名约定等等，你可以大幅度减少设置处理器映射，视图解析，<strong>ModelAndView</strong>实例等所需的配置量。这对于快速成型是一个伟大的福音，并且这也可以在代码库中提供一定程度的（总是很好的）一致性，你应该选择把它推进生产环境。</p>
<p> 约定优先于配置的支持解决了MVC的三个核心领域：模型，视图和控制器。</p>
<h2 id="ControllerClassNameHandlerMapping控制器"><a href="#ControllerClassNameHandlerMapping控制器" class="headerlink" title="ControllerClassNameHandlerMapping控制器"></a>ControllerClassNameHandlerMapping控制器</h2><hr>
<p><strong>ControllerClassNameHandlerMapping</strong>类是一个<strong>HandlerMapping</strong>实现，它使用约定来确定请求URL和要处理这些请求的Controller实例之间的映射。</p>
<p>考虑以下简单的Controller实现。请特别注意类的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewShoppingCartController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于这个例子，实现并不重要...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是相应的Spring Web MVC配置文件的片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewShoppingCart&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.z.ViewShoppingCartController&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入需要的依赖... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>ControllerClassNameHandlerMapping</strong>在其应用程序上下文中找到所有定义的各种处理器（或<strong>Controller</strong>）bean，并且用<strong>Controller</strong>实例的名字来定义它的处理器映射。因此，<strong>ViewShoppingCartController</strong>映射到**&#x2F;viewshoppingcart***请求URL。</p>
<p>我们再来看一些更多的例子，熟悉这个核心思想。（注意URL中的全部小写，与驼峰式Controller类名称形成对比）。</p>
<ul>
<li><strong>WelcomeController</strong>映射到**&#x2F;welcome***请求URL</li>
<li><strong>HomeController</strong>映射到**&#x2F;home***请求URL</li>
<li><strong>IndexController</strong>映射到**&#x2F;index***请求URL</li>
<li><strong>RegisterController</strong>映射到**&#x2F;register***请求URL</li>
</ul>
<p>在<strong>MultiActionController</strong>处理器类的情况下，生成的映射稍微复杂一点。以下示例中的Controller名称假定为MultiActionController实现：</p>
<ul>
<li><strong>AdminController</strong>映射到**&#x2F;admin&#x2F;***请求URL</li>
<li><strong>CatalogController</strong>映射到**&#x2F;catalog&#x2F;***请求URL</li>
</ul>
<p>如果你遵循将Controller实现命名为xxxController的惯例，<strong>ControllerClassNameHandlerMapping</strong>会将你从定义和维护一个潜在的无聊<strong>SimpleUrlHandlerMapping</strong>（或类似的）中解救出来。</p>
<h2 id="ModelMap模型（ModelAndView）"><a href="#ModelMap模型（ModelAndView）" class="headerlink" title="ModelMap模型（ModelAndView）"></a>ModelMap模型（ModelAndView）</h2><hr>
<p><strong>ModelMap</strong>类本质上是一个更强大的<strong>Map</strong>，它可以使需要添加并在（或）<strong>View</strong>中显式的对象遵循常见的命名约定。考虑下面的<strong>Controller</strong>实现;注意，要被添加到<strong>ModelAndView</strong>中的对象并没有指定任何关联的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayShoppingCartController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">cartItems</span> <span class="operator">=</span> <span class="comment">// 获取一个CartItem对象列表</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="comment">// 获取正在购物的User对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;displayShoppingCart&quot;</span>); &lt;-- 逻辑视图名</span><br><span class="line"></span><br><span class="line">        mav.addObject(cartItems); &lt;--看，没有名称，只有对象</span><br><span class="line">        mav.addObject(user); &lt;-- 再一次这样</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ModelAndView</strong>类使用一个<strong>ModelMap</strong>类，ModelMap是一个自定义的<strong>Map</strong>实现，当对象被添加到它时，它为对象自动生成一个键。对于决定添加对象的名称的策略是，在诸如User之类的标量对象的情况下，使用对象类的短类名。下面示例是为标量对象生成并放入到<strong>ModelMap</strong>实例中的名称。</p>
<ul>
<li><strong>x.y.User</strong>实例，添加时会生成一个<strong>user</strong>名称。</li>
<li><strong>x.y.Registration</strong>实例，添加时会生成一个<strong>registration</strong>名称。</li>
<li><strong>x.y.Foo</strong>实例，添加时会生成一个<strong>foo</strong>名称。</li>
<li><strong>java.util.HashMap</strong>，添加时实例会生成一个<strong>hashMap</strong>名称。在这种情况下，你可能想要明确指定名称，因为<strong>hashMap</strong>不太直观。</li>
<li>添加null会导致一个<strong>IllegalArgumentException</strong>被抛出。如果要添加的对象可以为null，你也需要显式地指定其名。</li>
</ul>
<div class="quote">什么？居然没有自动多元？
Spring Web MVC的 约定优先于配置的支持并不支持自动多元化。也就是，你添加一个Person对象的List到ModelAndView中时，不会生成一个people名称。

<p>这个决定是经过一番辩论，最后还是“风险最小原则（Principle of Least Surprise）”获胜。</p>
</div>

<p>在添加一个Set或List之后名称生成策略是：窥视（peek）集合，取在集合中第一个对象的短类名，并使用List附加到名称后。这同样适用于数组，尽管数组不需要窥视数组内容。下面几个例子会使集合的名称生成语义更加清晰。</p>
<ul>
<li>一个<strong>x.y.User[]<strong>数组，有零个或更多</strong>x.y.User</strong>元素，添加时会生成<strong>userList</strong>名称。</li>
<li>一个<strong>x.y.Foo[]<strong>数组，有零个或更多</strong>x.y.Foo</strong>元素，添加时会生成<strong>fooList</strong>名称。</li>
<li>一个<strong>java.util.ArrayList</strong>，有零个或更多<strong>x.y.Use</strong>r元素，添加时会生成<strong>userList</strong>名称。</li>
<li>一个<strong>java.util.HashSet</strong>，有零个或更多<strong>x.y.Foo</strong>元素，添加时会生成<strong>fooList</strong>名称。</li>
<li>一个<strong>空的java.util.ArrayList</strong>不会被添加（实际上，**addObject(..)**调用本质上是一个no-op）。</li>
</ul>
<h2 id="关于RequestToViewNameTranslator视图"><a href="#关于RequestToViewNameTranslator视图" class="headerlink" title="关于RequestToViewNameTranslator视图"></a>关于RequestToViewNameTranslator视图</h2><hr>
<p>当没有显式提供逻辑视图名时，<strong>RequestToViewNameTranslator</strong>接口会决定这样一个逻辑<strong>View</strong>名称。它只有一个实现，<strong>DefaultRequestToViewNameTranslator</strong>类。</p>
<p>DefaultRequestToViewNameTranslator将请求URL映射到逻辑视图名上，就如此示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistrationController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求...</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">// 根据需要添加数据到model中...</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">        <span class="comment">// 注意，这里没有设置View或逻辑视图名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这就是那个众所周知的，用来生成视图名的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewNameTranslator&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;x.y.RegistrationController&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 根据需要注入依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 映射请求URL到Controller名上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意在<strong>handleRequest(..)<strong>方法实现中，没有在返回的</strong>ModelAndView</strong>上设置任何<strong>View</strong>或逻辑视图名。<strong>DefaultRequestToViewNameTranslator</strong>负责从请求的URL生成逻辑视图名。上面例子中，<strong>RegistrationController</strong>与<strong>ControllerClassNameHandlerMapping</strong>结合使用，一个请求URLhttp://localhost/registration.html导致一个逻辑视图名<strong>registration</strong>被<strong>DefaultRequestToViewNameTranslator</strong>生成。然后，该逻辑视图名称由<strong>InternalResourceViewResolver</strong> bean解析为**&#x2F;WEB-INF&#x2F;jsp&#x2F;registration.jsp**视图。</p>
<blockquote>
<p>你不需要显式定义一个<strong>DefaultRequestToViewNameTranslator</strong> bean。如果你喜欢<strong>DefaultRequestToViewNameTranslator</strong>的默认设置，则可以依靠Spring Web MVC <strong>DispatcherServlet</strong>来实例化此类的实例，如果未明确配置该实例的话。</p>
</blockquote>
<p>当然，如果你需要更改默认设置，那么你需要显式配置自己的<strong>DefaultRequestToViewNameTranslator</strong> bean。有关可配置的各种属性的详细信息，请参阅综合的<strong>DefaultRequestToViewNameTranslator</strong> javadocs。</p>
<hr>
<h1 id="HTTP缓存支持"><a href="#HTTP缓存支持" class="headerlink" title="HTTP缓存支持"></a>HTTP缓存支持</h1><hr>
<p>一个好的HTTP缓存策略可以显着提高Web应用程序的性能和客户段体验。**’Cache-Control’** HTTP响应头主要负责这一点，还有诸如<strong>“Last-Modified”</strong>和<strong>“ETag”</strong>之类的条件报头。</p>
<p><strong>‘Cache-Control’</strong> HTTP响应头建议私有缓存（例如浏览器）和公共缓存（例如代理）它们如何缓存HTTP响应以进一步重用。</p>
<p><a href="https://en.wikipedia.org/wiki/HTTP_ETag">ETag</a>（实体标签）是由HTTP&#x2F;1.1兼容的Web服务器返回的HTTP响应头，用于确定给定URL中的内容更改。它可以被认为是<strong>Last-Modified</strong>头的更复杂的继承者。当服务器返回带有ETag响应头的表示时，客户端可以在随后含有<strong>If-None-Match</strong>报头的GET请求中使用这个报头。如果内容没有改变，服务器返回<strong>304: Not Modified</strong>。</p>
<p>本节介绍在Spring Web MVC应用程序中配置HTTP缓存的不同可用选择。</p>
<h2 id="Cache-Control-HTTP响应头"><a href="#Cache-Control-HTTP响应头" class="headerlink" title="Cache-Control HTTP响应头"></a>Cache-Control HTTP响应头</h2><hr>
<p>Spring Web MVC支持许多用例和方式为应用程序配置<strong>“Cache-Control”</strong>报头。虽然RFC 7234第5.2.2节完全描述了这个报头及其可能的指令，但是有几种方法可以解决最常见的情况。</p>
<p>Spring Web MVC在几个它的API中使用一个配置约定：setCachePeriod(int seconds)：</p>
<ul>
<li><strong>-1</strong>值不会生成**’Cache-Control’**响应头。</li>
<li><strong>0</strong>值会使用**’Cache-Control: no-store’**指令阻止缓存。</li>
<li><strong>n&gt; 0</strong>值将使用**’Cache-Control: max-age&#x3D;n’**指令在响应n秒内缓存给出的响应。</li>
</ul>
<p>CacheControl构建器类简单描述了可用的“Cache-Control”指令，并使得构建你自己的HTTP缓存策略更加容易。一旦构建，就可以在几个Spring Web MVC API中接受CacheControl实例作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存1小时- &quot;Cache-Control: max-age=3600&quot;</span></span><br><span class="line"><span class="type">CacheControl</span> <span class="variable">ccCacheOneHour</span> <span class="operator">=</span> CacheControl.maxAge(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止缓存 - &quot;Cache-Control: no-store&quot;</span></span><br><span class="line"><span class="type">CacheControl</span> <span class="variable">ccNoStore</span> <span class="operator">=</span> CacheControl.noStore();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在公有和私有缓存中缓存10天,</span></span><br><span class="line"><span class="comment">// 公有缓存不能转为响应  </span></span><br><span class="line"><span class="comment">// &quot;Cache-Control: max-age=864000, public, no-transform&quot;</span></span><br><span class="line"><span class="type">CacheControl</span> <span class="variable">ccCustom</span> <span class="operator">=</span> CacheControl.maxAge(<span class="number">10</span>, TimeUnit.DAYS)</span><br><span class="line">                                    .noTransform().cachePublic();</span><br></pre></td></tr></table></figure>

<h2 id="静态资源的HTTP缓存支持"><a href="#静态资源的HTTP缓存支持" class="headerlink" title="静态资源的HTTP缓存支持"></a>静态资源的HTTP缓存支持</h2><hr>
<p>应使用适当的**’Cache-Control’<strong>和条件报头来提供静态资源以实现最佳性能。配置一个</strong>ResourceHttpRequestHandler<strong>来处理静态资源，不仅可以在本地通过读取文件的元数据来写入</strong>‘Last-Modified’<strong>头，，而且可以在属性被配置的情况下写入</strong>‘Cache-Control’**报头。</p>
<p>你可以在<strong>ResourceHttpRequestHandler</strong>上设置<strong>cachePeriod</strong>属性，也可以使用<strong>CacheControl</strong>实例，它支持更具体的指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/public-resources/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">1</span>, TimeUnit.HOURS).cachePublic());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在XML中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:cache-control</span> <span class="attr">max-age</span>=<span class="string">&quot;3600&quot;</span> <span class="attr">cache-public</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在控制器中支持的Cache-Control，ETag和Last-Modified响应头"><a href="#在控制器中支持的Cache-Control，ETag和Last-Modified响应头" class="headerlink" title="在控制器中支持的Cache-Control，ETag和Last-Modified响应头"></a>在控制器中支持的Cache-Control，ETag和Last-Modified响应头</h2><hr>
<p>控制器可以支持**’Cache-Control’<strong>, <strong>‘ETag’<strong>和&#x2F;或</strong>‘If-Modified-Since’<strong>HTTP请求;如果要在响应上设置’Cache-Control’报头，强烈建议使用这类支持。这涉及到为指定的请求计算</strong>lastModified</strong>参数的</strong>long<strong>型值，和&#x2F;或一个Etag的值，然后与请求中的’If-Modified-Since’报头值进行对比，并有可能返回一个状态代码为</strong>304 (Not Modified)**的响应。</p>
<p>如<a href="#%E4%BD%BF%E7%94%A8HttpEntity">“使用HttpEntity”</a>一节所述，控制器可以使用<strong>HttpEntity</strong>类型与请求&#x2F;响应进行交互。控制器返回<strong>ResponseEntity</strong>可以在响应中包含HTTP缓存信息，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/book/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Book&gt; <span class="title function_">showBook</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> findBook(id);</span><br><span class="line">    <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> book.getVersion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity</span><br><span class="line">                .ok()</span><br><span class="line">                .cacheControl(CacheControl.maxAge(<span class="number">30</span>, TimeUnit.DAYS))</span><br><span class="line">                .eTag(version) <span class="comment">// lastModified同样可用</span></span><br><span class="line">                .body(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做不仅会在响应中包含**’ETag’<strong>和</strong>‘Cache-Control’<strong>报头，如果客户端发送的条件报头与控制器设置的缓存信息集相匹配，它还会将响应转换为带有空白正文的</strong>HTTP 304 Not Modified**响应。</p>
<p><strong>@RequestMapping</strong>方法也可能希望支持相同的行为。这可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">myHandleMethod</span><span class="params">(WebRequest webRequest, Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> <span class="comment">// 1. 应用程序特定的计算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.checkNotModified(lastModified)) &#123;</span><br><span class="line">        <span class="comment">// 2. 快捷退出 - 无需进一步处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 或者进一步请求处理，实际准备内容</span></span><br><span class="line">    model.addAttribute(...);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;myViewName&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个关键元素：调用<strong>request.checkNotModified(lastModified)<strong>并返回</strong>null</strong>。前者在返回true之前设置适当的响应状态和响应头。后者与前者相结合使用，使Spring MVC不再进一步处理请求。</p>
<p>请注意，对这种有3种变体处理：</p>
<ul>
<li>**request.checkNotModified(lastModified)<strong>将lastModified与</strong>‘If-Modified-Since’<strong>或</strong>‘If-Unmodified-Since’**请求头进行比较</li>
<li>**request.checkNotModified(eTag)<strong>将eTag与</strong>‘If-None-Match’**请求头进行比较</li>
<li>**request.checkNotModified(eTag,lastModified)**同时执行上面两个，意味着两个条件都应该是有效。</li>
</ul>
<p>当接收到有条件的**’GET’&#x2F;‘HEAD’<strong>请求时，</strong>checkNotModified<strong>将检查资源是否尚未被修改，如果是，则会产生</strong>HTTP 304 Not Modified<strong>响应。在有条件的</strong>‘POST’&#x2F;‘PUT’&#x2F;‘DELETE’<strong>请求的情况下，</strong>checkNotModified<strong>将检查资源是否尚未被修改，如果已经被修改，将导致</strong>HTTP 409 Precondition Failed**响应以防止并发修改。</p>
<h2 id="Shallow-ETag支持"><a href="#Shallow-ETag支持" class="headerlink" title="Shallow ETag支持"></a>Shallow ETag支持</h2><hr>
<p>ETags的支持是由Servlet过滤器<strong>ShallowEtagHeaderFilter</strong>提供。它是一个简单的Servlet过滤器，因此可以与任何Web框架结合使用。<strong>ShallowEtagHeaderFilter</strong>过滤器创建了所谓的浅层ETag（而不是深层的ETag，关于深层ETag稍后介绍更多）。过滤器缓存渲染的JSP（或其他内容）的内容，生成一个MD5哈希，并将其作为响应中的一个ETag头返回。下一次客户端发送对同一资源的请求时，它将使用这个哈希值作为<strong>If-None-Match</strong>值。过滤器会探测到这一点，再次渲染视图，并比较两个哈希值。如果它们相等，则返回<strong>304</strong>。</p>
<p>请注意，此策略可节省网络带宽但不节省CPU，因为必须为每个请求计算完整的响应。在控制器级别的其他策略（如上所述）可以节省网络带宽并避免计算。</p>
<p>该过滤器有一个<strong>writeWeakETag</strong>参数，它配置过滤器写入Weak ETags，如这个所示：**W&#x2F;“02a2d595e6ed9a0b24f027f2b63b134d6”**，如RFC 7232第2.3节中所定义。</p>
<p>你在web.xml中配置ShallowEtagHeaderFilter：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>etagFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.ShallowEtagHeaderFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可选参数，用来配置过滤器写入weak ETags</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;writeWeakETag&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;true&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>etagFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>petclinic<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者在Servlet 3.0+环境中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123; <span class="keyword">new</span> <span class="title class_">ShallowEtagHeaderFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="基于代码的Servlet容器初始化"><a href="#基于代码的Servlet容器初始化" class="headerlink" title="基于代码的Servlet容器初始化"></a>基于代码的Servlet容器初始化</h1><hr>
<p>在Servlet 3.0+环境中，你可以选择以编程式配置Servlet容器作为替代方案，或与<strong>web.xml</strong>文件组合使用。以下是注册<strong>DispatcherServlet</strong>的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WebApplicationInitializer</strong>是由Spring MVC提供的接口，可确保你的实现被检测并自动用于初始化任何Servlet 3容器。<strong>WebApplicationInitializer</strong>的一个名为<strong>AbstractDispatcherServletInitializer</strong>的抽象基类实现使注册<strong>DispatcherServlet</strong>更容易，只需要简单的重写方法以指定Servlet映射和<strong>DispatcherServlet</strong>配置的位置。</p>
<p>对于应用程序推荐使用基于Java的Spring配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用基于XML的Spring配置，你应该直接从<strong>AbstractDispatcherServletInitializer</strong>扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">cxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AbstractDispatcherServletInitializer</strong>还提供了一种方便的方法来添加<strong>Filter</strong>实例，并将它们自动映射到<strong>DispatcherServlet</strong>上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123; <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>(), <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个过滤器根据基于具体类型的默认名称被添加，并自动映射到<strong>DispatcherServlet</strong>。</p>
<p><strong>AbstractDispatcherServletInitializer</strong>的<strong>isAsyncSupported <strong>protected方法提供了一个单独的位置来启用</strong>DispatcherServlet</strong>上的异步支持并且所有的过滤器映射到它。默认情况下，该标志设置为true。</p>
<p>最后，如果需要进一步自定义<strong>DispatcherServlet</strong>本身，可以覆盖<strong>createDispatcherServlet</strong>方法。</p>
<hr>
<h1 id="配置Spring-MVC"><a href="#配置Spring-MVC" class="headerlink" title="配置Spring MVC"></a>配置Spring MVC</h1><hr>
<p><a href="#WebApplicationContext%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8ABean%E7%B1%BB%E5%9E%8B">第2.1节“WebApplicationContext中的特殊Bean类型”</a>和<a href="#%E9%BB%98%E8%AE%A4DispatcherServlet%E9%85%8D%E7%BD%AE">第2.2节“默认DispatcherServlet配置”</a>介绍了Spring MVC的特殊bean以及<strong>DispatcherServlet</strong>使用的默认实现。在本节中，你将了解配置Spring MVC的两种额外方法。即MVC Java配置和MVC XML命名空间。</p>
<p>MVC Java配置和MVC命名空间提供了类似的默认配置，它覆盖<strong>DispatcherServlet</strong>的默认值。这样做的目的是，让大多数应用不得不有一致的配置，并且可从较高级别的架构来配置Spring MVC，这个架构可以作为简单易用的配置起始点，并且基本不需这些配置背后所需的知识。</p>
<p>你可以根据自己的喜好选择MVC Java配置或MVC命名空间。另外，你将在下面进一步看到，使用MVC Java配置，可以更容易地查看底层配置，以及直接对创建的Spring MVC bean进行细粒度的自定义。但是让我们从起点就开始。</p>
<h2 id="启用MVC-Java-Config或MVC-XML命名空间"><a href="#启用MVC-Java-Config或MVC-XML命名空间" class="headerlink" title="启用MVC Java Config或MVC XML命名空间"></a>启用MVC Java Config或MVC XML命名空间</h2><hr>
<p>要启用MVC Java配置，将@EnableWebMvc注解添加到你的一个@Configuration类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在XML中实现相同的操作，请使用<strong>DispatcherServlet</strong>上下文中的<strong>mvc:annotation-driven</strong>元素（如果你没有定义<strong>DispatcherServlet</strong>上下文，则在根上下文中）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上注册了一个<strong>RequestMappingHandlerMapping</strong>，一个<strong>RequestMappingHandlerAdapter</strong>和一个<strong>ExceptionHandlerExceptionResolver</strong>（以及其他的），以支持使用注解（如**@RequestMapping<strong>，</strong>@ExceptionHandler**等）的注解控制器方法处理请求。</p>
<p>同时，以下行为也会启用:</p>
<ol>
<li>除了用于数据绑定的JavaBeans PropertyEditor之外，还可以通过ConversionService实例进行Spring 3样式类型转换。</li>
<li>通过<strong>ConversionService</strong>使用**@NumberFormat**注解支持Number字段格式化。</li>
<li>使用**@DateTimeFormat<strong>注解支持</strong>Date** ,<strong>Calendar</strong>, <strong>Long</strong>以及Joda Time字段格式化。</li>
<li>支持使用**@Valid<strong>验证</strong>@Controller**输入，如果类路径中存在JSR-303 Provider 的话。</li>
<li><strong>HttpMessageConverter</strong>支持**@RequestBody<strong>方法参数和</strong>@ResponseBody<strong>方法从</strong>@RequestMapping<strong>或</strong>@ExceptionHandler**方法返回值。<br>下面是通过mvc:annotation-driven设置的完整HttpMessageConverters列表<ol>
<li><strong>ByteArrayHttpMessageConverter</strong> 转换字节数组。</li>
</ol>
<ul>
<li><strong>StringHttpMessageConverter</strong> 转换字符串。</li>
<li><strong>ResourceHttpMessageConverter</strong> 为所有媒体类型转换为&#x2F;从<strong>org.springframework.core.io.Resource</strong>。</li>
<li><strong>SourceHttpMessageConverter</strong> 转换为&#x2F;从<strong>javax.xml.transform.Source</strong>.</li>
<li><strong>FormHttpMessageConverter</strong> 将表单数据转换为&#x2F;从**MultiValueMap&lt;String，String&gt;**。</li>
<li><strong>Jaxb2RootElementHttpMessageConverter</strong> 将Java对象转换为&#x2F;从XML<br> — 如果JAXB2存在，并且类别路径中不存在Jackson 2 XML extension ，则会添加。</li>
<li><strong>MappingJackson2HttpMessageConverter</strong> 转换为&#x2F;从JSON— 如果类路径上存在Jackson 2，则添加。</li>
<li><strong>MappingJackson2XmlHttpMessageConverter</strong> 转换为&#x2F;从XML — 如果类路径上存在Jackson 2 XML extension，则添加。</li>
<li><strong>AtomFeedHttpMessageConverter</strong> 转换Atom feeds  — 如果类路径上存在Rome ，则添加。</li>
<li><strong>RssChannelHttpMessageConverter</strong> 转换RSS feeds — 如果类路径上存在Rome ，则添加。</li>
</ul>
</li>
</ol>
<p>有关如何自定义这些默认转换器的更多信息，请参见<a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">第16.12节“消息转换器”</a>。</p>
<blockquote>
<p>Jackson JSON和XML转换器使用由<strong>Jackson2ObjectMapperBuilder</strong>创建的<strong>ObjectMapper</strong>实例创建，以提供更好的默认配置。<br>此构建器使用以下命令自定义Jackson的默认属性：</p>
</blockquote>
<ol>
<li><strong>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</strong>被禁用。</li>
<li><strong>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</strong>被禁用。<br>如果在类路径中检测到它们，它也会自动注册以下众所周知的模块：</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>: 支持Java 7类型，如java.nio.file.Path。</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>: 支持Joda-Time类型。</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>: 支持Java 8 Date＆Time API类型。</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>: 支持其他Java 8类型，如<strong>Optional</strong>。</li>
</ol>
<h2 id="自定义已提供的配置"><a href="#自定义已提供的配置" class="headerlink" title="自定义已提供的配置"></a>自定义已提供的配置</h2><hr>
<p>要在Java中自定义默认配置，你只需实现<strong>WebMvcConfigurer</strong>接口，或者更有可能继承<strong>WebMvcConfigurerAdapter</strong>类，并覆盖所需的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override configuration methods...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要自定义**&lt;mvc:annotation-driven&#x2F;&gt;**的默认配置，请检查它支持哪些属性和子元素。你可以查看<a href="http://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema </a>模式或使用IDE的代码完成功能来发现哪些属性和子元素可用。</p>
<h2 id="转换和格式化"><a href="#转换和格式化" class="headerlink" title="转换和格式化"></a>转换和格式化</h2><hr>
<p>默认情况下，已安装了针对Number和Date类型的格式化器，包括对**@NumberFormat<strong>和</strong>@DateTimeFormat<strong>注解的支持。如果类路径上存在Joda Time，还安装了对Joda Time格式化库的完全支持。要注册自定义格式化器和转换器，请覆盖</strong>addFormatters**方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// Add formatters and/or converters</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MVC命名空间中，当添加**&lt;mvc:annotation-driven&#x2F;&gt;**时，同样应用相同的默认设置。要想注册自定义格式化器和转换器，只需提供一个ConversionService：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyFormatter&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyAnnotationFormatterFactory&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatterRegistrars&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyFormatterRegistrar&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关何时使用FormatterRegistrars的更多信息，请参见<a href="/2017/08/05/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%89%EF%BC%89%E9%AA%8C%E8%AF%81%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="FormatterRegistrar SPI">FormatterRegistrar SPI</a>和FormattingConversionServiceFactoryBean。</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><hr>
<p>Spring提供了一个<strong>Validator</strong>接口，可用于在应用程序的所有层中进行验证。在Spring MVC中，你可以将其配置为用作全局<strong>Validator</strong>实例，和&#x2F;或通过**@InitBinder<strong>方法作为控制器中的本地Validator，以便在哪遇到</strong>@Valid<strong>或</strong>@Validated**控制器方法参数都可以使用。可以将全局和本地验证器实例组合使用以提供复合验证。</p>
<p>Spring还通过<strong>LocalValidatorFactoryBean</strong>支持JSR-303 &#x2F; JSR-349 Bean验证，它将Spring <strong>org.springframework.validation.Validator</strong>接口适配为Bean Validation <strong>javax.validation.Validator</strong>规范。这个类可以插入Spring MVC作为下面描述的全局验证器。</p>
<p>默认情况下，当在类路径中检测到一个Bean Validation provider （如Hibernate Validator）时，使用**@EnableWebMvc<strong>或</strong>&lt;mvc:annotation-driven&#x2F;&gt;<strong>会在Spring MVC中通过</strong>LocalValidatorFactoryBean**自动注册Bean Validation支持。</p>
<blockquote>
<p>有时，将LocalValidatorFactoryBean注入到控制器或其他类中带来很多便利。最简单的方法是声明自己的@Bean，并使用@Primary标记它，以避免与MVC Java配置提供的冲突。<br>如果你喜欢使用MVC Java配置中的一个，则需要从WebMvcConfigurationSupport重写mvcValidator方法，并声明该方法以显式返回LocalValidatorFactory而不是Validator。有关如何切换扩展提供的配置的信息，请参见第[16.13节“使用MVC Java Config进行高级自定义”](#使用MVC Java Config进行高级自定义)。</p>
</blockquote>
<p>或者，你可以配置自己的全局Validator实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Validator <span class="title function_">getValidator</span><span class="params">()</span>; &#123;</span><br><span class="line">        <span class="comment">// 返回&quot;全局&quot; validator</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在XML中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">&quot;globalValidator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要将全局和本地验证结合起来，只需添加一个或多个本地验证器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        binder.addValidators(<span class="keyword">new</span> <span class="title class_">FooValidator</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种最小配置，每当遇到**@Valid<strong>或@<strong>Validated</strong>方法参数时，它将被配置的验证器验证。任何验证违规将自动暴露为</strong>BindingResult**中的错误，作为方法参数可访问，并且可在Spring MVC HTML视图中呈现。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><hr>
<p>你可以将<strong>HandlerInterceptors</strong>或<strong>WebRequestInterceptors</strong>配置为适用于所有传入请求或限制在指定的URL路径模式。</p>
<p>在Java中注册拦截器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LocaleInterceptor</span>());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">ThemeInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SecurityInterceptor</span>()).addPathPatterns(<span class="string">&quot;/secure/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在XML中使用&lt;mvc:interceptors&gt;元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/admin/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.theme.ThemeChangeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/secure/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.SecurityInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><hr>
<p>你可以配置Spring MVC如何根据请求确定所请求的媒体类型（media types）。可用的选项是检查URL路径查找文件扩展名，检查“Accept”请求头，特定查询参数，或者在没有请求中没有时回退到一个默认的内容类型。默认情况下，首先检查请求URI中的路径扩展名，其次检查“Accept”请求头。</p>
<p>MVC Java配置和MVC命名空间默认注册<strong>json</strong>，<strong>xml</strong>，<strong>rss</strong>，<strong>atom</strong>，如果有相应的依赖在类路径上的话。额外的路径extension-to-media type映射也可以显式地注册，并且还有将它们列为安全拓展名白名单的效果，用于探测RFD攻击的意图。（有关详细信息，请参阅“后缀模式匹配和RFD”部分）。</p>
<p>以下是通过MVC Java配置自定义内容协商选项的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.mediaType(<span class="string">&quot;json&quot;</span>, MediaType.APPLICATION_JSON);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MVC命名空间中，**&lt;mvc:annotation-driven&gt;<strong>元素有一个</strong>content-negotiation-manager<strong>属性，该属性需要</strong>ContentNegotiationManager<strong>，而</strong>ContentNegotiationManager<strong>又可以通过</strong>ContentNegotiationManagerFactoryBean**创建：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">content-negotiation-manager</span>=<span class="string">&quot;contentNegotiationManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;contentNegotiationManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mediaTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            json=application/json</span><br><span class="line">            xml=application/xml</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不使用MVC Java配置或MVC命名空间，则需要创建一个<strong>ContentNegotiationManager</strong>的实例，并使用它来配置<strong>RequestMappingHandlerMapping</strong>以进行请求映射，以及<strong>RequestMappingHandlerAdapter</strong>和<strong>ExceptionHandlerExceptionResolver</strong>进行内容协商。</p>
<p>请注意，<strong>ContentNegotiatingViewResolver</strong>现在也可以使用<strong>ContentNegotiationManager</strong>配置，因此你可以在Spring MVC中使用一个共享实例。</p>
<p>在更高级的情况下，配置多个<strong>ContentNegotiationManager</strong>实例可能有用，而这些实例又可能包含自定义的<strong>ContentNegotiationStrategy</strong>实现。例如，你可以使用<strong>ContentNegotiationManager</strong>配置一个<strong>ExceptionHandlerExceptionResolver</strong>，它始终将请求的媒体类型解析为“application&#x2F;json”。或者，如果请求中没有内容类型的化，你可能希望插入具有某种逻辑的自定义策略来选择一种默认内容类型（例如XML或JSON）。</p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><hr>
<p>这有一个定义<strong>ParameterizableViewController</strong>的快捷方式，这个视图控制器会在被调用时立即转发到视图。在静态资源中使用该控制器，当视图生成响应之前没有Java控制器逻辑需要执行时。</p>
<p>下面是一个在java中将“&#x2F;”的请求转发到一个名为“home”上的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的在XML中使用**&lt;mvc:view-controller&gt;**元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;home&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><hr>
<p>MVC配置简化了视图解析器的注册。</p>
<p>下面使一个Java配置示例，它使用FreeMarker HTML模板配置内容协商视图解析器，并将Jackson作为JSON渲染的默认View：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        registry.enableContentNegotiation(<span class="keyword">new</span> <span class="title class_">MappingJackson2JsonView</span>());</span><br><span class="line">        registry.jsp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在XML中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-resolvers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:content-negotiation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:default-views</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:default-views</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:content-negotiation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:jsp</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:view-resolvers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过请注意，FreeMarker，Velocity，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。</p>
<p>MVC命名空间提供专用元素。例如与FreeMarker：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-resolvers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:content-negotiation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:default-views</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:default-views</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:content-negotiation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:freemarker</span> <span class="attr">cache</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:view-resolvers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:freemarker-configurer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:template-loader-path</span> <span class="attr">location</span>=<span class="string">&quot;/freemarker&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:freemarker-configurer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Java配置中，只需添加相应的“Configurer”bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        registry.enableContentNegotiation(<span class="keyword">new</span> <span class="title class_">MappingJackson2JsonView</span>());</span><br><span class="line">        registry.freeMarker().cache(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FreeMarkerConfigurer <span class="title function_">freeMarkerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FreeMarkerConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerConfigurer</span>();</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;/WEB-INF/&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资源服务"><a href="#资源服务" class="headerlink" title="资源服务"></a>资源服务</h2><hr>
<p>这个选项运行遵循一个特定URL模式的静态资源请求由<strong>ResourceHttpRequestHandler</strong>从任何Resource位置的列表中服务。这提供了一种方便的方式来从除Web应用程序根路径以外的位置（包括类路径上的位置）提供静态资源。<strong>cache-period</strong>属性可用于设置久远到期报头（1年是一些如Page Speed和YSlow的优化工具的推荐值），以便客户端更有效地利用它们。处理器还可以正确地评估<strong>Last-Modified</strong>报头（如果存在），以便适当地返回304状态代码，从而避免对客户端已缓存资源的不必要开销。例如，要从Web应用程序根目录中的<strong>public-resources</strong>目录中提供具有**&#x2F;resources &#x2F;****的URL模式的资源请求，你将使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>).addResourceLocations(<span class="string">&quot;/public-resources/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在XMl中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了在未来1年的时间内为这些资源提供服务，以确保最大限度地利用浏览器缓存并减少浏览器发出的HTTP请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>).addResourceLocations(<span class="string">&quot;/public-resources/&quot;</span>).setCachePeriod(<span class="number">31556926</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在XML中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;31556926&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>有关详细信息，请参阅<a href="#HTTP%E7%BC%93%E5%AD%98%E6%94%AF%E6%8C%81">静态资源的HTTP缓存支持</a>。</p>
<p><strong>mapping</strong>属性必须是可以由<strong>SimpleUrlHandlerMapping</strong>使用的Ant模式，<strong>location</strong>属性必须指定一个或多个有效的资源目录位置。多个资源位置可以使用一个逗号分隔的值列表来指定。指定的位置将按照指定的顺序检查是否存在任何给定请求的资源。如，要从web应用程序根目录和一个在类路径中任何jar中的已知的路径&#x2F;META-INF&#x2F;public-web-resources&#x2F;开启资源服务，请使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;classpath:/META-INF/public-web-resources/&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样在XML中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/, classpath:/META-INF/public-web-resources/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当部署新版本的应用程序时可能会更改的资源时，建议你将版本字符串合并到用于请求资源的映射模式中，以便你可以强制客户端请求新部署的应用程序资源版本。版本化URL的支持内置在框架中，可以通过在资源处理器上配置资源链来启用。该链包含一个<strong>ResourceResolver</strong>实例，后跟一个或多个<strong>ResourceTransformer</strong>实例。他们一起可以提供资源的任意解析和转换。</p>
<p>内置的<strong>VersionResourceResolver</strong>可以配置不同的策略。例如，<strong>FixedVersionStrategy</strong>可以使用属性，日期或其他作为版本。<strong>ContentVersionStrategy</strong>使用从资源内容计算的MD5哈希值（称为“指纹识别”URL）。注意，当提供资源服务时，<strong>VersionResourceResolver</strong>会自动使用这个解析的version字符串作为HTTP ETag头</p>
<p>ContentVersionStrategy是一个很好的默认选择，除非不能使用（例如使用JavaScript模块加载器）。你可以针对不同的模式配置不同的版本策略，如下所示。请记住，计算基于内容的版本是昂贵的，因此在生产中应该启用资源链缓存。</p>
<p>Java配置示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/public-resources/&quot;</span>)</span><br><span class="line">                .resourceChain(<span class="literal">true</span>).addResolver(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">VersionResourceResolver</span>().addContentVersionStrategy(<span class="string">&quot;/**&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/public-resources/&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resource-chain</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:resource-cache</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:resolvers</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:version-resolver</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">mvc:content-version-strategy</span> <span class="attr">patterns</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">mvc:version-resolver</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:resolvers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:resource-chain</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了使上述工作，应用程序还必须使用版本来呈现URL。最简单的方法是配置<strong>ResourceUrlEncodingFilter</strong>，它包装响应并重写其<strong>encodeURL</strong>方法。这将在JSP，FreeMarker，Velocity以及调用响应<strong>encodeURL</strong>方法的任何其他视图技术中起作用。或者，应用程序还可以直接注入并使用<strong>ResourceUrlProvider</strong> bean，该bean通过MVC Java配置和MVC命名空间自动声明。</p>
<p><strong>WebJarsResourceResolver</strong>也支持Webjars，当**”org.webjars:webjars-locator”<strong>库在类路径中时，它会自动注册。此解析器允许资源链从HTTP GET请求中解析版本不可知库</strong>“GET &#x2F;jquery&#x2F;jquery.min.js”<strong>将返回资源</strong>“&#x2F;jquery&#x2F;1.2.0&#x2F;jquery.min.js”<strong>。它也可以通过在模板</strong>&lt;script src&#x3D;”&#x2F;jquery&#x2F;jquery.min.js”&#x2F;&gt; →&lt;script src&#x3D;”&#x2F;jquery&#x2F;1.2.0&#x2F;jquery.min.js”&#x2F;&gt;**中重写资源URL。</p>
<h2 id="在”默认“Servlet上回退到资源服务"><a href="#在”默认“Servlet上回退到资源服务" class="headerlink" title="在”默认“Servlet上回退到资源服务"></a>在”默认“Servlet上回退到资源服务</h2><hr>
<p>这允许将DispatcherServlet映射到“&#x2F;”（从而覆盖容器的默认Servlet的映射），同时仍然允许静态资源请求由容器的默认Servlet处理。它配置一个<strong>DefaultServletHttpRequestHandler</strong>，其URL映射为“&#x2F; **”，相对于其他URL映射为最低优先级。</p>
<p>这个处理器会将所有的请求装发到默认的Servlet上。因此将其保持在其他所有URL HandlerMappings顺序的最后位置很重要。如果你使用&lt;mvc:annotation-driven&gt;会是这样，或者你可以设置你的自定义HandlerMapping实例，确保它的order属性比DefaultServletHttpRequestHandler的值（它的是Integer.MAX_VALUE）低。</p>
<p>要使用默认设置启用该功能，请使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者在XML中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>覆盖“&#x2F;”Servlet映射的注意事项是，默认Servlet的RequestDispatcher必须以名称而不是路径检索。DefaultServletHttpRequestHandler会尝试在启动时自动检测容器的默认Servlet，使用大多数主要Servlet容器（包括Tomcat，Jetty，GlassFish，JBoss，Resin，WebLogic和WebSphere）的已知名称列表。如果默认的Servlet已经使用不同的名称自定义配置，或者如果使用其他Servlet容器而它的默认Servlet名称未知，那么必须显式地提供默认的Servlet名称，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable(<span class="string">&quot;myCustomDefaultServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者在XML中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> <span class="attr">default-servlet-name</span>=<span class="string">&quot;myCustomDefaultServlet&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><hr>
<p>这允许自定义与URL映射和路径匹配相关的各种设置。有关各个选项的详细信息，请查看<a href="http://docs.spring.io/spring-framework/docs/4.3.10.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html">PathMatchConfigurer API</a>。</p>
<p>下面时在Java配置中的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseSuffixPatternMatch(<span class="literal">true</span>)</span><br><span class="line">            .setUseTrailingSlashMatch(<span class="literal">false</span>)</span><br><span class="line">            .setUseRegisteredSuffixPatternMatch(<span class="literal">true</span>)</span><br><span class="line">            .setPathMatcher(antPathMatcher())</span><br><span class="line">            .setUrlPathHelper(urlPathHelper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UrlPathHelper <span class="title function_">urlPathHelper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PathMatcher <span class="title function_">antPathMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在XML，使用&lt;mvc:path-matching&gt;元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;mvc:path-matching</span><br><span class="line">        suffix-pattern=<span class="string">&quot;true&quot;</span></span><br><span class="line">        trailing-slash=<span class="string">&quot;false&quot;</span></span><br><span class="line">        registered-suffixes-only=<span class="string">&quot;true&quot;</span></span><br><span class="line">        path-helper=<span class="string">&quot;pathHelper&quot;</span></span><br><span class="line">        path-matcher=<span class="string">&quot;pathMatcher&quot;</span>/&gt;</span><br><span class="line">&lt;/mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;pathHelper&quot;</span> class=<span class="string">&quot;org.example.app.MyPathHelper&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;pathMatcher&quot;</span> class=<span class="string">&quot;org.example.app.MyPathMatcher&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><hr>
<p>可以通过重写configureMessageConverters()来实现Java配置中的HttpMessageConverter的自定义，如果你想替换由Spring MVC创建的默认转换器的话，或者重写extendMessageConverters()方法，你只想自定义它们或添加额外的转换器到默认的转换器中，</p>
<p>以下是使用自定义的ObjectMapper而不是默认值添加Jackson JSON和XML转换器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2ObjectMapperBuilder</span>()</span><br><span class="line">                .indentOutput(<span class="literal">true</span>)</span><br><span class="line">                .dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>))</span><br><span class="line">                .modulesToInstall(<span class="keyword">new</span> <span class="title class_">ParameterNamesModule</span>());</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(builder.build()));</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(builder.xml().build()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<strong>Jackson2ObjectMapperBuilder</strong>用于为<strong>MappingJackson2HttpMessageConverter</strong>和<strong>MappingJackson2XmlHttpMessageConverter</strong>创建一个通用配置，并带有缩进功能，自定义日期格式以及jackson-module-parameter-names的注册，这些参数添加了对访问参数名称的支持（在Java 8中添加的功能） 。</p>
<blockquote>
<p>使用Jackson XML支持实现缩进，除了jackson-dataformat-xml之外，还需要woodstox-core-asl依赖。</p>
</blockquote>
<p>其他可用的有趣的Jackson模块：</p>
<ol>
<li><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a>：支持javax.money类型（非官方模块）</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a>：支持Hibernate的特定类型和属性（包括延迟加载方面）</li>
</ol>
<p>也可以在XML中执行相同的操作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;objectMapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;xmlMapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;objectMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:indentOutput</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:simpleDateFormat</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:modulesToInstall</span>=<span class="string">&quot;com.fasterxml.jackson.module.paramnames.ParameterNamesModule&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xmlMapper&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;objectMapper&quot;</span> <span class="attr">p:createXmlMapper</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用MVC-Java-Config进行高级自定义"><a href="#使用MVC-Java-Config进行高级自定义" class="headerlink" title="使用MVC Java Config进行高级自定义"></a>使用MVC Java Config进行高级自定义</h2><hr>
<p>从上面的例子中可以看出，MVC Java配置和MVC命名空间提供了高级别构造，它不需要深入了解为你创建的底层bean。相反，它可以帮助你专注于你的应用程序需求。但是，在某些时候，你可能需要更细致的控制，或者你可能只想了解底层配置。</p>
<p>更精细控制的第一步是查看为你创建的底层bean。在MVC Java配置中，你可以在WebMvcConfigurationSupport中看到javadocs和@Bean方法。这个类中的配置是通过@EnableWebMvc注解自动导入。事实上，如果你打开@EnableWebMvc你可以看到@Import语句。</p>
<p>更精细控制的下一步是在WebMvcConfigurationSupport中创建的一个bean上自定义一个属性，或者提供自己的实例。这需要两件事情 - 移除@EnableWebMvc注解，以防止导入，然后从DelegateWebMvcConfiguration（WebMvcConfigurationSupport的子类）扩展。。这有一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建或者用&quot;super&quot; 创建适配器</span></span><br><span class="line">        <span class="comment">// 然后自定义它的属性之一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用程序应该只有一个配置继承<strong>DelegatingWebMvcConfiguration</strong>或一个**@EnableWebMvc<strong>注解类，因为它们都注册了相同的底层bean。以这种方式修改bean不会阻止你使用本节之前显式的任何更高级别的构造。 <strong>WebMvcConfigurerAdapter</strong>子类和</strong>WebMvcConfigurer**实现仍在使用中。</p>
</blockquote>
<h2 id="使用MVC命名空间进行高级自定义"><a href="#使用MVC命名空间进行高级自定义" class="headerlink" title="使用MVC命名空间进行高级自定义"></a>使用MVC命名空间进行高级自定义</h2><hr>
<p>使用MVC命名空间对于为你创建的配置进行更细粒度的控制有一点困难。</p>
<p>如果你确实需要这样做，而不是复制它提供的配置，请考虑配置一个<strong>BeanPostProcessor</strong>，以探测你要按类型自定义的bean，然后根据需要修改其属性。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> RequestMappingHandlerAdapter) &#123;</span><br><span class="line">            <span class="comment">// 修改适配器属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>MyPostProcessor</strong>需要包含在**&lt;component scan &#x2F;&gt;**中才能被检测到，或者你喜欢可以使用XML bean声明显式声明。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 核心技术（一）IoC容器</title>
    <url>/2017/07/25/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89IoC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}
</style>

<p><a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#beans">原文链接</a></p>
<hr>
<h1 id="Spring-IoC容器和bean介绍"><a href="#Spring-IoC容器和bean介绍" class="headerlink" title="Spring IoC容器和bean介绍"></a>Spring IoC容器和bean介绍</h1><hr>
<p>本章涵盖了控制反转-<em>Inversion of Control</em>  （IoC）原理的Spring框架实现。IoC也被称为依赖注入-<em>dependency injection</em> （DI）。它是一个通过对象定义它们的依赖项（也就是它们使用的其他对象）的过程，这些依赖只能通过构造方法参数、工厂方法的参数，或者已经被构建或由工厂方法返回的对象实例上设置的属性这些形式。然后，容器在创建bean时注入这些依赖项。这个过程从根本上反转了bean本身通过直接构造类，或者使用一个如Service Locator模式的机制对依赖实例化或定位的控制，因此命名控制反转（IoC）。</p>
<span id="more"></span>
<p><strong>org.springframework.beans</strong>和<strong>org.springframework.context</strong>包是Spring框架IoC容器的基础。<strong>BeanFactory</strong>接口提供了一个能够管理任何类型对象的高级配置机制。<strong>ApplicationContext</strong>是<strong>BeanFactory</strong>的一个子接口。它添加与Spring AOP功能的简单集成；消息资源处理（在国际化中使用），事件发布；以及应用层特定的上下文，例如用于Web应用程序的<strong>WebApplicationContext</strong>。</p>
<p>简而言之，<strong>BeanFactory</strong>提供配置框架和基本功能，<strong>ApplicationContext</strong>添加了更多的企业特定功能。<strong>ApplicationContext</strong>是<strong>BeanFactory</strong>的完整超集,本章仅用于Spring的IoC容器的描述。有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅第7.16节“BeanFactory”。</p>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean简单只是应用程序中的许多对象之一。Bean以及bean之间的依赖关系反映在容器使用的配置元数据中。</p>
<hr>
<h1 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h1><hr>
<p><strong>org.springframework.context.ApplicationContext</strong>接口表示Spring IoC容器，并且负责实例化，配置和组装上述的bean。容器通过读取配置元数据获取有关实例化，配置和组装的对象的说明。配置元数据用XML，Java注解或Java代码表示。它允许你表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring还提供了<strong>ApplicationContext</strong>接口的几个实现。在独立应用程序中，通常创建一个<strong>ClassPathXmlApplicationContext</strong>或<strong>FileSystemXmlApplicationContext</strong>的实例。虽然XML已经成为定义配置元数据的惯用格式，但你还可以指示容器使用Java注解或代码作为元数据格式，只需要通过提供少量的XML配置来声明开启对这些额外元数据格式的支持。</p>
<p>在大多数应用程序场景中，实例化一个或多个Spring IoC容器的实例不需要显式的用户代码。比如，在一个web应用程序情景中，在应用程序的web.xml文件中的一个简单的八行（或更多）的样板web描述XML通常就足够了（查看“Web应用程序的便捷ApplicationContext实例化”）。如果你使用Spring Tool Suite Eclipse-powered开发环境，则可以通过鼠标点击或击键轻松创建该样板设置。</p>
<p>下图是Spring如何工作的高级视图。你的应用程序类与配置元数据相结合，以便在创建和初始化<strong>ApplicationContext</strong>之后，有一个完全配置和可执行的系统或应用程序。<br><img src="/images/spring/container-magic.png.pagespeed.ce.-0JjaOG5As.png" alt="Spring IoC容器"></p>
<h2 id="配置元数据"><a href="#配置元数据" class="headerlink" title="配置元数据"></a>配置元数据</h2><hr>
<p>如前面的图标所展示，Spring IoC容器消耗一种形式的配置元数据；这个配置元数据表示作为应用程序开发者如何告诉Spring容器去实例化，配置并且组装你程序中的对象。</p>
<p>配置元数据传统上由一个简单且直观的XML格式提供，这是本章用来传达Spring IoC容器的关键概念和特性大多数使用的方式。</p>
<blockquote>
<p>基于XML的元数据不是唯一允许的配置元数据形式。Spring IoC容器本身与实际写入此配置元数据的格式完全分离。近来，很多开发人员为他们的Spring应用程序选择基于Java的配置。</p>
</blockquote>
<p>有关使用Spring容器的其他形式的元数据的信息，请参阅：</p>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">基于注解的配置</a>：Spring 2.5引入了基于注解的配置元数据的支持。</li>
<li><a href="#%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">基于Java的配置</a>：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring框架的一部分。因此，你可以使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新功能，请参阅@Configuration，@Bean，@Import和@DependsOn注解。</li>
</ul>
<p>Spring配置由必须是容器管理的一个但通常是多个bean定义组成。基于XML的配置元数据在顶级元素**&lt;beans&#x2F;&gt;<strong>内展示这些配置为</strong>&lt;bean&#x2F;&gt;<strong>元素的bean。基于Java配置通常在</strong>@Configuration<strong>类中使用</strong>@Bean**注解。</p>
<p>这些bean定义对应于构成应用程序的实际对象。通常，你定义服务层对象，数据访问对象（DAO），表示对象（如Struts Action实例），基础架构对象（如Hibernate SessionFactories，JMS Queues等）。通常，在容器中不配置细粒度的域对象，因为通常由DAO和业务逻辑来负责创建和加载这些域对象。但是，你可以使用Spring与AspectJ的集成来配置在IoC容器的控制之外创建的对象。请参阅<a href="">使用AspectJ对Spring进行依赖注入域对象</a>。</p>
<p>以下示例显示了基于XML的配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更多的bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>id</strong>属性是用于标识单个bean定义的字符串。<strong>class</strong>属性定义bean的类型，并使用完全限定的类名。id属性的值指的是相互协作的对象。引用协作对象的XML在此示例中没有展示;有关详细信息，请参阅<a href="#%E4%BE%9D%E8%B5%96">依赖</a>。</p>
<h2 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h2><hr>
<p>实例化一个Spring IoC容器是直观的。提供给<strong>ApplicationContext</strong>构造方法的本地路径或路径上是实际资源字符串，这允许容器从各种外部资源（如本地文件系统），或从从Java <strong>CLASSPATH</strong>等中加载配置元数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在了解Spring的IoC容器之后，你可能想要了解更多有关Spring Resource抽象的信息，如“<a href="">资源</a>“中所述，它提供了一种从URI语法中定义的位置读取InputStream的便捷机制。特别地，Resource路径用于构建应用程序上下文，如第8.7节“<a href="">应用程序上下文和资源路径</a>“中所述。</p>
</blockquote>
<p>下面示例展示了服务层对象（<strong>services.xml</strong>）配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;petStore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service的更多bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面示例展示了数据访问对象<strong>dao.xml</strong>文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的额外协作者和配置到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的额外协作者和配置到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据访问对象的更多bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，服务层由类PetStoreServiceImpl和两个数据访问对象类型为JpaAccountDao和JpaItemDao（基于JPA对象&#x2F;关系映射标准）组成。<strong>property name</strong>元素是指JavaBean属性（property）的名称，而<strong>ref</strong>元素是指另一个bean定义的名称。<strong>id</strong>和<strong>ref</strong>元素之间的这种链接表示协作对象之间的依赖关系。有关配置对象的依赖关系的详细信息，请参阅<a href="">依赖</a>。</p>
<h3 id="编写基于XML的配置元数据"><a href="#编写基于XML的配置元数据" class="headerlink" title="编写基于XML的配置元数据"></a>编写基于XML的配置元数据</h3><p>让bean定义分布在多个XML文件中是有意义的。每个单独的XML配置文件通常表示你的体系结构中的逻辑层或模块。</p>
<p>你可以使用<strong>ApplicationContext</strong>构造方法从所有这些XML片段中加载bean定义。如上一节所示那样，构造方法接收多个<strong>Resource</strong>位置。或者，使用一个或多个**&lt;import &#x2F;&gt;**元素从其他文件加载bean定义。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，外部定义的bean从三个文件中加载：<strong>services.xml</strong>，<strong>messageSource.xml</strong>和<strong>themeSource.xml</strong>。所有的位置路径是相对于执行导入操作的定义文件路径，所以<strong>services.xml</strong>必须与执行导入文件在相同的目录或类路径位置下，而<strong>messageSource.xml</strong>和<strong>themeSource.xml</strong>必须位于执行导入文件位置下的resources位置中。<font color= "#1469b3">如你所见，前置的斜杠被忽略，但是鉴于这些路径都是相对的，所以最好不要使用斜杠</font>。被导入文件的内容包括顶级**&lt;beans&#x2F;&gt;**元素,它必须是依据Spring Schema的有效XML bean定义文件。</p>
<blockquote>
<p>这是可行，但是不推荐使用一个相对”..&#x2F;“路径引用上级目录的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，这个引用不推荐用于“classpath：”URL（例如“classpath：..&#x2F; services.xml”），运行时解析过程选择“最近”根类路径，然后再查看其父目录。Classpath配置的更改可能会导致选择一个不同的，不正确的目录。<br>你可以一直使用完全限定的资源位置而不是相对路径：比如， “file:C:&#x2F;config&#x2F;services.xml” 或 “classpath:&#x2F;config&#x2F;services.xml”。然而，请注意，你将应用程序的配置与特定的绝对位置相耦合在一起。通常最好与这些绝对路径保持一个间接关联，比如，通过 “${…}” 占位符在运行时期解析JVM系统属性</p>
</blockquote>
<p>import指令是由<strong>beans</strong>命名空间本身提供的一个功能。Spring提供的一些XML命名空间中可以使用除纯bean定义之外的更多配置功能，例如。 **“context”<strong>和</strong>“util”**命名空间。</p>
<h3 id="Groovy-Bean定义DSL"><a href="#Groovy-Bean定义DSL" class="headerlink" title="Groovy Bean定义DSL"></a>Groovy Bean定义DSL</h3><p>作为外部配置元数据的另一个例子，bean定义也可以在Spring的Groovy Bean Definition DSL中表示，如Grails框架所知。通常，这种配置将存在一个“.groovy”文件中，结构如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName = <span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span></span><br><span class="line">        url = <span class="string">&quot;jdbc:hsqldb:mem:grailsDB&quot;</span></span><br><span class="line">        username = <span class="string">&quot;sa&quot;</span></span><br><span class="line">        password = <span class="string">&quot;&quot;</span></span><br><span class="line">        settings = [<span class="attr">mynew:</span><span class="string">&quot;setting&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource = dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种配置风格在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。它还允许通过“importBeans”指令导入XML bean定义文件。</p>
<h2 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h2><hr>
<p><strong>ApplicationContext</strong>是能够维护不同bean和它们的依赖关系的注册表的高级工厂的接口。使用**T getBean(String name, Class&lt;T&gt; requiredType)**方法你可以检索你的bean实例。</p>
<p><strong>ApplicationContext</strong>使你能够读取bean定义并访问它们，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并配置bean</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置实例</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置实例</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>
<p>使用Groovy配置，引导看起来非常相似，只是一个不同的上下文实现类，它是Groovy感知的（但也可以理解XML bean定义）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericGroovyApplicationContext</span>(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>最灵活的变体是<strong>GenericApplicationContext</strong>与<strong>reader</strong>委托组合，例如与XML文件的<strong>XmlBeanDefinitionReader</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>或者为Groovy文件使用<strong>GroovyBeanDefinitionReader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>这样的reader委托可以在相同的<strong>ApplicationContext</strong>中进行混合和匹配，从不同的配置源读取bean定义，如果需要的话。</p>
<p>然后你可以使用<strong>getBean</strong>来获取你的bean实例。<strong>ApplicationContext</strong>接口还有其他一些获取bean的方法，但理想情况下你的应用程序代码应该从不会使用到它们。实际上，你的应用程序代码根本不应该调用**getBean()**方法，因此根本不需要依赖Spring API。例如，Spring与Web框架的集成为各种Web框架组件（如controller和JSF-managed bean）提供依赖注入，允许你在指定bean上通过元数据声明一个依赖（例如自动装配注解）</p>
<hr>
<h1 id="Bean概述"><a href="#Bean概述" class="headerlink" title="Bean概述"></a>Bean概述</h1><hr>
<p>Spring IoC容器管理一个或多个bean。这些bean是使用你提供给容器的配置元数据创建的，例如，以XML **&lt;bean &#x2F;&gt;**定义的形式。</p>
<p>在容器本身内，这些bean定义以<strong>BeanDefinition</strong>对象表示，它包含了以下元数据（以及其他信息）：</p>
<ul>
<li>一个包完全限定类名称：通常是要定义的bean的实际实现类。</li>
<li>Bean行为配置元素，它说明bean应该在容器（作用域，生命周期回调等）中的行为。</li>
<li>这个bean工作所需引用的其他bean；这些引用也被称为协作者或依赖。</li>
<li>在新创建的对象中设置其他配置设置，例如，在管理连接池的bean中使用的连接数，或池的大小限制。</li>
</ul>
<p>该元数据转换为组成每个bean定义的一组属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释…</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>3.2<a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96bean">“实例化bean”</a></td>
</tr>
<tr>
<td>name</td>
<td>3.1<a href="#%E5%91%BD%E5%90%8Dbean">“命名bean”</a></td>
</tr>
<tr>
<td>scope</td>
<td>5 <a href="#Bean%E5%9F%9F">“Bean域”</a></td>
</tr>
<tr>
<td>constructor arguments</td>
<td>4.1<a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“依赖注入”</a></td>
</tr>
<tr>
<td>properties</td>
<td>4.1<a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“依赖注入”</a></td>
</tr>
<tr>
<td>autowiring mode</td>
<td>4.5<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">“自动装配协作者”</a></td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>4.4<a href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96bean">“延迟初始化bean”</a></td>
</tr>
<tr>
<td>initialization method</td>
<td>6.11<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83">“初始化回调”</a></td>
</tr>
<tr>
<td>destruction method</td>
<td>6.12 <a href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83">“销毁回调”</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定bean的信息的bean定义之外，<strong>ApplicationContext</strong>的实现还允许用户注册在容器外创建的现有对象。这是通过访问ApplicationContext的<strong>getBeanFactory()<strong>方法获取BeanFatory，这个方法返回BeanFactory的实现</strong>DefaultListableBeanFactory</strong>。<strong>DefaultListableBeanFactory</strong>通过**registerSingleton(..)**和 **registerBeanDefinition(..)**方法支持这种注册。然而，通常应用程序仅使用通过元数据bean定义定义的bean。</p>
<blockquote>
<p>Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他内省步骤期间正确地推断它们。然而在某种程度上也支持覆盖已有的元数据和单例实例，在运行时期新的bean注册（同时实时访问工厂）是不被正式支持的，并且可能导致bean容器中的并发访问异常和&#x2F;或不一致的状态。</p>
</blockquote>
<h2 id="命名bean"><a href="#命名bean" class="headerlink" title="命名bean"></a>命名bean</h2><hr>
<p>每个bean都有一个或多个标识符。这些标识符在托管该bean的容器中必须是唯一的。一个bean通常只有一个标识符，但是如果它需要不止一个的话，额外的可以被认为是别名。</p>
<p>在基于XML配置元数据，你使用<strong>id</strong>和&#x2F;或<strong>name</strong>属性来指定bean的标识符。<strong>id</strong>属性允许你指定一个id。通常这些名称是字母数字（’myBean’，’fooService’等），但也可能包含特殊的字符。如果你想要向bean引入其他别名，你可以在<strong>name</strong>属性中指定它们，并用逗号（**,<strong>），分号（</strong>;<strong>）或</strong>空白<strong>来分隔。作为一个历史说明，在Spring 3.1之前的版本中，</strong>id<strong>属性被定义为一个</strong>xsd:ID<strong>类型，它限制了可能的字符。从3.1开始，它被定义为一个</strong>xsd:string**类型。注意容器依然强制bean id的唯一性，尽管不再通过XML解析。</p>
<p>你不需要为bean提供name或id。如果没有明确提供name或id，容器将为该bean生成唯一的名称。但是，如果要通过名称引用该bean，通过使用<strong>ref</strong>元素或 Service Locator样式查找，你必须提供一个名称。如果不提供名称，则可能与使用 <a href="#%E5%86%85%E9%83%A8bean">内部bean</a>和<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">自动装配协作者</a>有关。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**bean命名惯例**   
命名bean时的惯例是使用标准Java用于实例字段命名的惯例。也就是，bean名称以一个小写字母开始，后面是是驼峰式命名。这样命名的示例是（不带引号）"accountManager"，"accountService"，"userDao"等等。      
一致的bean命名使你的配置更容易阅读和理解，并且如果你使用Spring AOP ，在通过名称将advice应用到到一组bean时，这会非常有帮助。
</div> 

<blockquote>
<p>在类路径中通过组件扫描，Spring会按照上述规则为未命名组件生成bean名称：实质上是采用简单类名称，并将它的第一个字母转换为小写。然而，在（异常）特殊情况下，如果有多个字符，并且第一个和第二个字符都是大写字母，则原始大写将被保留。这些与<strong>java.beans.Introspector.decapitalize</strong>（也是这里Spring使用的）定义的规则相同。</p>
</blockquote>
<h3 id="在bean定义外为bean起别名"><a href="#在bean定义外为bean起别名" class="headerlink" title="在bean定义外为bean起别名"></a>在bean定义外为bean起别名</h3><p>在bean定义本身中，你可以通过使用由<strong>id</strong>属性指定的最多一个名称和在<strong>name</strong>属性中任意数量的其他名称，组合来为bean提供多个名称。这些名称可以是同一个bean的等价别名，并且在一些情况下有用，例如允许一个应用程序中的每个组件通过使用指定给该组件本身的bean名称来引用一个公共依赖。</p>
<p>但是在实际定义bean的地方指定它的所有别名并不总是足够的。有时需要为一个在其他地方定义的bean引入一个别名。这在大型系统中通常会遇到，因为这样的系统的配置被分隔在每个子系统中，每一个子系统都有它自己的一系列对象定义。在基于XML的配置元数据中，你可以使用**&lt;alias&gt;**元素来完成此操作。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，在相同容器中一个名称为fromName的bean，也可能在使用这种别名定义后，以toName引用。</p>
<p>例如，子系统A的配置元数据可能通过名称<strong>subsystemA-dataSource</strong>引用一个DateSource。子系统B的配置元数据可能通过名称<strong>subsystemB-dataSource</strong>引用一个DateSource。当使用这两个子系统构成主程序，主程序通过名称<strong>myApp-dataSource</strong>引用这个<strong>DataSource</strong>。要使所有三个名称都引用相同的对象，你向MyApp配置元数据中添加以下别名定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;myApp-dataSource&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，每个组件和主应用程序可以通过唯一的名称来引用dataSource，并保证不会与任何其他定义（有效创建命名空间）冲突，但它们引用同一个bean。</p>
<blockquote>
<p>如果使用Java配置，可以使用**@Bean**注解来提供别名，详见第12.3节<a href="#%E4%BD%BF%E7%94%A8@Bean%E6%B3%A8%E8%A7%A3">“使用@Bean注解”</a>。</p>
</blockquote>
<h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><hr>
<p>bean定义本质上是创建一个或多个对象的配方。当询问时，容器会查看命名bean的配方，并使用由该bean定义封装的配置元数据创建（或获取）实际对象。</p>
<p>如果使用基于XML的配置元数据，则可以在**&lt;bean&#x2F;&gt;<strong>元素的</strong>class<strong>属性中指定要实例化的对象的类型（或类）。</strong>class<strong>属性（attribute），在内部是</strong>BeanDefinition<strong>实例上的</strong>Class<strong>属性（property），通常是强制必须的。你可以通过以下两种方式之一使用</strong>Class**属性：</p>
<ul>
<li>通常，在容器本身通过反射调用它的构造器直接创建bean的情况下，指定被构建的bean类，这与Java代码使用new操作符有些等同。</li>
<li>指定一个实际的类，它包含了会被调用来创建对象的静态工厂方法，在这种不常见的情况下，容器会在一个类上调用静态工厂方法来创建一个bean。从调用静态工厂方法返回的对象类型可能完全是同一个类或另一个类。</li>
</ul>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**内部类名称** 如果要为静态嵌套类配置bean定义，则必须使用嵌套类的二进制名称。    
比如，如果你在com.example包有一个类叫Foo，并且这个Foo类有一个静态嵌套类叫Bar，那么在bean定义上'class'的值会是...    
**com.example.Foo$Bar**
注意，在名称中使用**$**字符将外部类名称与嵌套类名称分隔开。
</div>

<h3 id="使用构造方法实例化"><a href="#使用构造方法实例化" class="headerlink" title="使用构造方法实例化"></a>使用构造方法实例化</h3><p>当通过构造方法方法创建一个bean时，所有普通类都可以使用并与Spring兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定方式编码。只需指定bean类即可。然而，根据为这个指定bean所使用的IoC类型，你可能需要一个默认（空）的构造方法。</p>
<p>Spring IoC容器几乎可以管理你想要管理的任何类;它不限于只管理真正的JavaBeans。大多数Spring用户喜欢实际的JavaBeans，它只有一个默认（无参）构造方法和容器中的属性（properties）之后建立适当的setter和getter。。你还可以在容器中有更多别样情调的非Bean风格的类。例如，如果你需要使用完全不遵守JavaBean规范的旧版连接池，那么Spring也可以管理它。</p>
<p>使用基于XML配置元数据，你可以如下指定你的bean类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于为构造方法提供参数（如果需要的话）和在对象构建后设置对象实例属性的机制更多的信息，参阅<a href="#%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96">“注入依赖”</a></p>
<h3 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h3><p>当你使用一个静态工厂方法创建一个bean定义，你使用<strong>class</strong>属性来指定包含这个静态工厂方法的类，并且使用一个名为<strong>factory-method</strong>的属性指定这个工厂方法本身。你应该可以调用此方法（随后可以使用可选参数），并返回一个活动对象，随后将其视为通过构造方法创建的对象。这种bean定义的一个用途是在旧代码中调用静态工厂。</p>
<p>下面的bean定义指定这个bean会被通过调用一个工厂方法来创建。这个定义没有指定返回对象的类型（类），只指定了包含此工厂方法的类。在这个例子中，**createInstance()**方法必须是静态方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关为工厂方法提供（可选）参数和从工厂返回对象后，设置对象实例属性机制的更多信息，参阅<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82">“依赖和配置细节”</a></p>
<h3 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h3><p>类似于通过静态工厂方法实例化，也可以使用一个实例工厂方法，调用容器中现有的bean的非静态方法来创建一个新的bean。要使用这种机制，使<strong>class</strong>属性为空，并且在 <strong>factory-bean</strong> 属性中指定当前（或父&#x2F;祖）容器中包含了要用来调用用于创建对象的实例方法的bean名称。使用 <strong>factory-method</strong> 属性设置工厂方法本身名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 工厂bean，其中包含一个名为createInstance()的方法， --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此定位器bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要通过工厂bean创建的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DefaultServiceLocator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个工厂类也可以有多个工厂方法，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此定位器bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DefaultServiceLocator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountService <span class="title function_">createAccountServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法表明，factory bean本身可以通过依赖注入（DI）进行管理和配置。详细信息请参见<a href="">“依赖和配置细节”</a>。</p>
<blockquote>
<p>在Spring文档中，factory bean是指在Spring容器中配置的bean，通过它的实例或静态工厂方法来创建对象。相比之下，<strong>FactoryBean</strong>（注意大写）是指一个Spring特定的<strong>FactoryBean</strong>。</p>
</blockquote>
<hr>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><hr>
<p>一个典型的企业应用程序不是由单个对象（或在Spring说法中是bean）组成的。即使是最简单的应用程序，也有几个对象共同合作，来展示最终用户看到的整体的应用程序。下节解释你如何定义一系列独立于一个完全实现的应用程序的bean定义，这样的应用程序对象互相协作完成一个目标。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><hr>
<p>依赖注入（DI）是一个通过对象定义它们依赖的过程，也就是它们使用的其他对象，这些依赖只能通过构造方法参数、工厂方法的参数，或者已经被构建或由工厂方法返回的对象实例上设置的属性这些形式。然后，容器在创建bean时注入这些依赖项。这个过程从根本上反转了bean本身通过直接构造类，或者使用一个如Service Locator模式的机制对依赖实例化或定位的控制，因此命名控制反转（IoC）。</p>
<p>使用DI原理，代码更加清晰，并且当提给供对象依赖项的时候，解耦更加有效。对象不查找其依赖关系，并且不知道依赖项的位置或类。因此，你的类变得更容易测试，特别是当依赖接口或抽象基类上时，它允许在单元测试中使用存根（实现接口，但方法体为空）或模拟实现。</p>
<p>DI存在两种主要的变体：<a href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">基于构造方法的依赖注入</a> 和 <a href="#%E5%9F%BA%E4%BA%8ESetter%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">基于Setter的依赖注入</a>。</p>
<h3 id="基于构造方法的依赖注入"><a href="#基于构造方法的依赖注入" class="headerlink" title="基于构造方法的依赖注入"></a>基于构造方法的依赖注入</h3><p>基于构造方法的DI通过容器调用有多个参数的构造方法完成，每个参数表示一个依赖项。这与调用一个有特定参数的静态工厂方法来构造bean几乎相当，并且这个讨论将传参给一个构造方法与传参给一个静态工厂方法视为类似的。以下示例显示一个只能使用构造器注入进行依赖注入的类。请注意，这个类没有什么特别之处，它是一个POJO，它不依赖于容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleMovieLister对MovieFinder有依赖关系</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个构造方法，使Spring容器可以注入一个MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略实际使用注入的MovieFinder的业务逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法参数解析"><a href="#构造方法参数解析" class="headerlink" title="构造方法参数解析"></a>构造方法参数解析</h4><p>使用参数的类型进行构造方法参数解析匹配。如果在bean定义的构造方法参数中不存在潜在的歧义，那么构造方法参数在bean定义中定义的顺序就是在bean被实例化时将这些参数提供给适当的构造方法的顺序。考虑以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foo</span><span class="params">(Bar bar, Baz baz)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有潜在的歧义存在，假设<strong>Bar</strong>和<strong>Baz</strong>类没有继承关系。因此，以下配置工作正常，你不需要在**<constructor-arg />**元素中显式指定构造方法参数索引和&#x2F;或类型。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Baz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当引用另一个bean时，其类型是已知的，那么匹配正常（如前面的例子所示）。当使用一个简单类型，例如**&lt;value&gt;true&lt;&#x2F;value&gt;**时，在没有帮助的情况下Spring无法确定值的类型，因此无法通过类型匹配。考虑以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算终极答案的年数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命，宇宙及一切的答案（银河漫游指南的梗）</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述情况下，如果使用<strong>type</strong>属性显式指定构造方法参数的类型，那么容器可以用简单类型执行类型匹配。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>index</strong>属性来明确指定构造方法参数的索引。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了解决多个简单值的歧义之外，指定索引可以解决构造方法具有两个相同类型参数的歧义。注意，索引从0开始。</p>
<p>你还可以使用构造方法参数名称为值消除歧义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请记住，为了使这种操作开箱即用，你的代码必须在启用调试标志的情况下进行编译，以便Spring可以从构造方法中查找参数名称。如果你无法使用调试标志（或不想）编译代码，则可以使用**@ConstructorProperties** JDK注解来明确命名构造方法参数。示例类必须如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于Setter的依赖注入"><a href="#基于Setter的依赖注入" class="headerlink" title="基于Setter的依赖注入"></a>基于Setter的依赖注入</h3><p>基于Setter的DI通过在调用无参数构造方法或无参数静态工厂方法来实例化bean之后，通过容器调用bean的setter方法来实现。</p>
<p>以下示例展示了一个类，它只能使用纯setter注入进行依赖注入。这个类是常规Java。它是一个POJO，它不依赖容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleMovieLister依赖MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个setter方法，使Spring容器可以注入一个MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略实际使用注入的MovieFinder的业务逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ApplicationContext</strong> 对于它管理的bean支持基于构造方法和基于setter的DI。在一些依赖已经通过构造方法方式注入后，它也支持基于setter的DI。你可以以<strong>BeanDefinition</strong>的形式配置依赖，它与<strong>PropertyEditor</strong>实例结合使用，以将属性从一种格式转换为另一种格式。然而，大多数Spring用户不直接使用这些类（即以编程方式），而是使用XML bean定义，注解组件（即，使用**@Component<strong>，</strong>@Controller<strong>等注解类）或者在基于Java <strong>@Configuration</strong>类中的</strong>@Bean<strong>方法。然后将这些源内部地转换到</strong>BeanDefinition**的实例中，并用于加载整个Spring IoC容器实例。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">*基于构造还是基于setter DI*      
由于可以混合使用基于构造方法和基于setter的DI，这有一个很好的经验法则，就是为强制性依赖项使用构造方法注入，为可选依赖项使用setter方法或配置方法注入。请注意，可以在setter方法上使用@Required注解，使属性成为必需的依赖项。<br> 
Spring团队通常主张构造方法注入，因为它可以实现应用程序组件为不可变对象，并确保所需的依赖关系不为null。此外，构造方法注入的组件总是以完全初始化的状态返回给客户端（调用）代码。作为一个附注，大量的构造方法参数是一个不好的代码气息，这意味着该类可能有太多的责任，应该重构以更好地解决问题的正确分离。<br>
Setter注入应主要用于可选依赖，可以在类中分配合理的默认值。否则，必须在代码任何使用依赖的地方执行非空检查。setter注入的一个好处是setter方法使得该类的对象可以在以后重新配置或重新注入。因此对于setter注入，通过 JMX MBeans管理是一个引人注目的用例。<br> 
使用对特定类最有意义的DI风格。有时候，当你处理没有来源的第三方类时，你来做选择。例如，如果第三方类不暴露任何setter方法，那么构造方法注入可能是DI的唯一可用形式。     
</div>

<h3 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h3><p>容器如下执行bean依赖解析：</p>
<ul>
<li><strong>ApplicationContext</strong>使用配置元数据（它描述了所有的bean）来创建和初始化。配置元数据可以通过XML，Java代码或注解指定。</li>
<li>对于每一个bean，它的依赖以属性，构造方法参数或静态工厂方法参数（如果你使用它来替代一个正常的构造方法）形式表现。当bean实际创建时，这些依赖被提供给bean。</li>
<li>每个属性或构造方法参数是要设置的值的实际定义，或对容器中另一个bean的引用。</li>
<li>作为值的每个属性或构造方法参数都将从其指定的格式转换为该属性或构造方法参数的实际类型。默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，如<strong>int</strong>，<strong>long</strong>，<strong>String</strong>，<strong>boolean</strong>等。</li>
</ul>
<p>Spring容器会在容器创建时验证每个bean的配置。但是，在bean实际被创建之前，不会设置bean的属性。在容器创建时，被设置为预实例化（默认设置）的单例域bean会被创建。域在<a href="#Bean%E5%9F%9F">“Bean域”</a>这一章定义。否则的话，bean只在被需要的时候才会创建。bean的创建可能会导致一个bean树被创建，因为bean的依赖和它依赖的依赖（等等）被创建和分配。请注意，这些依赖关系中的解决方案不匹配可能会显示较晚，也就是在受影响的bean首次创建的时候。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">*循环依赖*： 如果你主要使用构造方法注入，可能会创建一个无法解决的循环依赖场景。<br> <br> 例如：类A通过构造方法依赖需要一个类B的实例，而类B通过构造方法注入又需要类A的实例。如果你为类A和B配置bean为互相注入，Spring IoC容器在运行时期探测到这个循环引用，就会抛出一个BeanCurrentlyInCreationException。<br> <br> 一个可能的解决方案是编辑这些类的源码，将其通过setter而不是构造方法配置。或者，避免构造方法注入而只使用setter注入。换而言之，你可以使用setter注入配置循环依赖，尽管这是不被推荐的。<br> <br>不像通常的情况（没有循环依赖），bean A和bean B之间的循环依赖关系强制其中一个bean在被完全初始化之前被注入到另一个bean中（一个经典的鸡/鸡蛋场景）。
</div>

<p>你一般可以信任Spring执行正确操作。它在容器加载时检测到配置问题，例如对不存在的bean的引用和循环依赖。当bean被创建后，Spring尽可能晚的设置属性和解析依赖。这意味着Spring容器被正确加载，但稍后你请求一个对象，如果在创建对象或者创建一个它的依赖上存在问题，容器会抛出一个异常。例如，bean由于缺少或无效的属性而抛出一个异常。这可能延迟了一些配置问题的发现，这也是为什么ApplicationContext的实现默认预实例化单例bean。以一些前期的时间和内存为代价，在bean实际需要前就创建它们，这样你可以在ApplicationContext创建时就发现配置的问题，而不是之后。你依旧可以重写这个默认行为，使单例bean懒加载，而不是预实例化。</p>
<p>如果没有循环依赖存在，当一个或多个协作bean被注入到一个需要该依赖的bean中时，每个协作bean在被注入到需要该依赖的bean之前都会被完全配置。这意味着如果beana A依赖bean B，Spring IoC容器在调用bean A的setter方法之前已经完全配置了bean B。换而言之，bean被实例化（如果不是一个预实例化单例），它的依赖被设置完成，并且相应的生命周期方法（比如 <a href="">配置的init方法</a> 或 <a href="">初始化bean回调方法</a>  ）已被调用。</p>
<h3 id="依赖注入示例"><a href="#依赖注入示例" class="headerlink" title="依赖注入示例"></a>依赖注入示例</h3><p>以下示例为基于setter的DI使用基于XML的配置元数据。Spring XML配置文件的一小部分指定了一些bean定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用了嵌套ref元素的setter注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用更加整洁的ref属性的setter注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntegerProperty</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，setter被声明与XML文件中指定的属性相匹配。以下示例使用基于构造方法的DI：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用嵌套的ref元素的构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用更加整洁的ref属性的构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = anotherBean;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = yetAnotherBean;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在bean定义中指定的构造方法参数将被用作ExampleBean的构造方法的参数。</p>
<p>现在考虑这个例子的一种变体，不再使用构造方法，而是告诉Spring调用一个静态方法来返回这个对象的一个实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ExampleBean</span><span class="params">(...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个静态工厂方法; 这个方法的参数可以是该方法返回bean</span></span><br><span class="line">    <span class="comment">//的依赖，不管这些参数是否实际被使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title function_">createInstance</span> <span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExampleBean</span> <span class="variable">eb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleBean</span> (...);</span><br><span class="line">        <span class="comment">//一些其他操作...</span></span><br><span class="line">        <span class="keyword">return</span> eb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态工厂方法的参数通过**&lt;constructor-arg&#x2F;&gt;<strong>元素提供，与实际构造方法使用的完全相同。这个工厂方法返回的类的类型不必和包含该静态工厂方法的类的类型一样，尽管在这个实例中是一样的。一个实例（非静态）工厂方法将以基本相同的方式使用（除了使用</strong>factory-bean<strong>属性而不是</strong>class**属性），所以这里不再赘述。</p>
<h2 id="依赖和配置细节"><a href="#依赖和配置细节" class="headerlink" title="依赖和配置细节"></a>依赖和配置细节</h2><hr>
<p>如在前面章节中提到的，你可以将bean属性和构造方法参数定义为对其他被管理的bean（协作者）的引用，或行内定义的值。为这个目的，Spring基于XML配置元数据在它的**&lt;property&#x2F;&gt;<strong>和</strong>&lt;constructor-arg&#x2F;&gt;**元素中支持子元素类型。</p>
<h3 id="直接值（原始类型，String等等）"><a href="#直接值（原始类型，String等等）" class="headerlink" title="直接值（原始类型，String等等）"></a>直接值（原始类型，String等等）</h3><p>**&lt;property&#x2F;&gt;**元素的value属性将一个属性或者构造方法参数指定为人类可读的字符串表示形式。Spring的 <a href="">转换服务</a> 用于将这些值从String转换为实际的属性或参数类型。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致一个setDriverClassName(String)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下示例使用 <a href="#%E4%BD%BF%E7%94%A8p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F">p命名空间</a> 进行更简洁的XML配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:driverClassName</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:username</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:password</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的XML更简洁;然而，拼写错误将在运行时而不是设计时被发现，除非你在创建bean定义时使用支持自动属性完成的IDE（如IntelliJ IDEA或Spring Tool Suite（STS））。</p>
<p>你也可以如下配置一个<strong>java.util.Properties</strong>实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mappings&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以java.util.Properties类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用JavaBeans <strong>PropertyEditor</strong>机制将**&lt;value&#x2F;&gt;<strong>元素内的文本转换为</strong>java.util.Properties<strong>实例。这是一个很好的捷径，而且是Spring团队赞成在value属性样式中使用嵌套的</strong>&lt;value&#x2F;&gt;**元素的几个地方之一。</p>
<h4 id="idref元素"><a href="#idref元素" class="headerlink" title="idref元素"></a>idref元素</h4><p><strong>idref</strong>元素只是将容器中另一个bean的id（字符串值 - 不是引用）传递给**&lt;constructor-arg&#x2F;&gt;<strong>或</strong>&lt;property&#x2F;&gt;**元素的防错方式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theClientBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述bean定义片段与以下代码片段完全相同（在运行时）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一种形式优于第二种形式，因为使用<strong>idref</strong>标签允许容器在部署时验证所引用的，命名的bean实际存在。在第二个变体中，不会对传递给client bean的targetName属性的值执行验证。只有当client bean被实际实例化的时候，错误拼写才会被发现（最可能是致命的结果）。如果client bean是一个 <a href="#Bean%E5%9F%9F">原型</a> bean,这种错字和它产生的异常只能在容器部署后很久才能被发现。</p>
<blockquote>
<p>在4.0 beans xsd中，<strong>idref</strong>元素上的<strong>local</strong>属性不再受支持，因为它不再提供超过常规bean引用的值。在升级到4.0 schema时，只需将你现有的<strong>idref local</strong>引用更改为<strong>idref bean</strong>。</p>
</blockquote>
<p><strong>&lt;idref&#x2F;&gt;<strong>元素带来值一个常用的地方是在</strong>ProxyFactoryBean</strong> bean定义中AOP拦截器的配置中（至少早在Spring 2.0版本）。指定拦截器名称时使用**&lt;idref&#x2F;&gt;**元素可防止拼写错误。</p>
<h3 id="引用其他bean（协作者）"><a href="#引用其他bean（协作者）" class="headerlink" title="引用其他bean（协作者）"></a>引用其他bean（协作者）</h3><p><strong>ref</strong>元素是**&lt;constructor-arg&#x2F;&gt;<strong>或</strong>&lt;property&#x2F;&gt;<strong>定义元素中的最后一个元素。在这里，你可以将bean的指定属性的值设置为对由容器管理的另一个bean（协作者）的引用。这个被引用的bean是进行属性设置bean的依赖项，并且它在进行属性设置前被引用bean一经请求就进行初始化（如果协作者是单例bean，它可能已经被容器初始化）。所有引用最终都是对另一个对象的引用。作用域和验证取决于你是否通过 <strong>bean</strong>, <strong>local</strong>,或</strong>parent**属性指定其他对象的id&#x2F;name。</p>
<p>通过**&lt;ref&#x2F;&gt;<strong>标签的bean属性指定目标bean是最常用的形式，并允许创建对在同一容器或父容器中任何bean的引用，而不管它是否在同一个XML文件中。bean属性的值可能与目标bean的</strong>id<strong>属性相同，或者与目标bean的</strong>name**属性中的一个值相同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;someBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<strong>parent</strong>属性指定目标bean是创建对在当前容器的父容器中bean的引用。<strong>parent</strong>属性的值可能与目标bean的id属性或目标bean的name属性中的值之一相同，并且目标bean必须在当前容器的父容器中。你使用这种引用形式变体，主要是在当你有层次结构的容器，并且你想要使用代理包装一个在父容器中已有的bean，这样会与父bean具有相同的名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父上下文中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.SimpleAccountService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据需要插入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在子（后代）上下文中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><span class="comment">&lt;!-- bean名称与父bean相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">&quot;accountService&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 注意我们如何引用父bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里按需要插入其他配置和依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在4.0 beans xsd中，<strong>idref</strong>元素上的<strong>local</strong>属性不再受支持，因为它不再提供超过常规bean引用的值。在升级到4.0 schema时，只需将你现有的<strong>idref local</strong>引用更改为<strong>idref bean</strong>。</p>
</blockquote>
<h3 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h3><p>一个在**&lt;property&#x2F;&gt;<strong>或</strong>&lt;constructor-arg&#x2F;&gt;<strong>元素内部的</strong>&lt;bean&#x2F;&gt;**元素定义了一个所谓的内部bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 相比使用一个目标bean的引用，可以只是内联定义这个目标bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是一个内部bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Fiona Apple&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个内部bean定义不需要定义的id或name;如果指定的话，容器也不使用这样的值作为标识符。容器也会忽略创建的<strong>scope</strong>标志：内部bean总是匿名的，并且它们总是外部bean而创建。不可能将注入内部bean到除闭包bean外的其他协作bean中，也不可能独立访问它们。</p>
<p>作为一个个别案例，有可能从一个自定义域中接收销毁回调，例如，对一个包含在单例bean中的request-scoped内部bean：内部Bean实例的创建将绑定到其包含的bean上但是销毁回调允许它参与到request scope的生命周期。这不是常见场景；内部bean通常只是分享在它们的包含bean的域内。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>在**&lt;list&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>和</strong>&lt;props&#x2F;&gt;**元素中，你可以分别设置Java Collection类型List，Set,Map和Properties的属性和参数。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;moreComplexObject&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setAdminEmails(java.util.Properties)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;development&quot;</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导致setSomeList(java.util.List)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setSomeMap(java.util.Map)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;an entry&quot;</span> <span class="attr">value</span>=<span class="string">&quot;just some string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;a ref&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;myDataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setSomeSet(java.util.Set)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someSet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>Map的 key 和 value 的值，或 set 的值，也可以是以下任意一元素</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>
<h4 id="集合合并"><a href="#集合合并" class="headerlink" title="集合合并"></a>集合合并</h4><p>Spring容器还支持集合的合并。应用程序开发人员可以定义父样式的**&lt;list&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>或</strong>&lt;props&#x2F;&gt;<strong>元素，并且有子样式的</strong>&lt;list&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>或</strong>&lt;props&#x2F;&gt;**元素继承并重写父集合中的值。也就是说，子集合的值是合并父和子集合的元素的结果，子集合元素重写在父集合中指定的值。</p>
<p><em>关于合并的这个部分讨论了父子bean的机制。读者不熟悉父和子bean定义的可能需要在继续前阅读 <a href="#Bean%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF">相关章节</a></em></p>
<p>以下示例演示集合合并：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 合并在子集合定义上指定 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sales&quot;</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，在子bean定义的adminEmails属性的&lt;props&#x2F;&gt;元素上使用merge&#x3D;true属性。当子bean被容器解析并实例化的时候，生成的实例具有一个adminEmails Properties集合，该集合包含将子级的adminEmails集合与父级的adminEmails集合合并的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">administrator=administrator@example.com</span><br><span class="line">sales=sales@example.com</span><br><span class="line">support=support@example.co.uk</span><br></pre></td></tr></table></figure>
<p>子Properties集合的值集继承父项&lt;props&#x2F;&gt;中的所有属性元素，并且子级support的值覆盖父集合中的值。</p>
<p>此合并行为与&lt;list&#x2F;&gt;，&lt;map&#x2F;&gt;和&lt;set&#x2F;&gt;集合类型类似。在具体&lt;list&#x2F;&gt;元素的情况下，与List集合类型相关联的语义，也就是说，有序集合概念的值会被维持;父项的值先于所有子列表的值。在Map，Set和Properties集合类型的情况下，不存在排序。因此，对于容器在内部使用的在相关的Map，Set和Properties实现类型的基础之上实现的集合类型，没有有效的有序语义。</p>
<p><strong>集合合并的限制</strong><br>你不能合并不同的集合类型（如一个Map和一个List），如果你尝试这样做，则会抛出合适的异常。merge 属性必须在较低的，继承的子定义上指定;在父集合定义上指定合并属性是多余的，不会导致期望的合并。<br><strong>强类型集合</strong><br>随着在Java 5中引入泛型类型，你可以使用强类型集合。也就是说，可以声明一个Collection类型，使它只能包含String元素（举例）。如果你使用Spring来依赖注入一个强类型的Collection到一个bean中，你可以利用Spring的类型转换支持，以便将强类型的Collection实例的元素转换为适当的类型，然后才能添加到Collection中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accounts&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9.99&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.75&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;six&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.99&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当foo bean的accounts属性准备注入时，有关强类型Map&lt;String，Float&gt;的元素类型的泛型信息可通过反射获得。因此，Spring的类型转换基础框架将各种值元素识别为Float类型，并将字符串值9.99,2.75和3.99转换为实际的Float类型。</p>
<h3 id="null和空字符串值"><a href="#null和空字符串值" class="headerlink" title="null和空字符串值"></a>null和空字符串值</h3><p>Spring将属性的空参数作为空字符串处理。以下基于XML的配置元数据片段将电子邮件属性设置为空字符串值（“”）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面实例等效与下面的Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&lt;null&#x2F;&gt;元素处理null值。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述配置相当于以下Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用p命名空间的XML快捷方式"><a href="#使用p命名空间的XML快捷方式" class="headerlink" title="使用p命名空间的XML快捷方式"></a>使用p命名空间的XML快捷方式</h3><p>p命名空间使你能够用bean元素的属性（attributes）而不是嵌套的**&lt;property&#x2F;&gt;**元素来描述属性值和&#x2F;或协作bean。</p>
<p>Spring使用命名空间支持可扩展的配置格式，这是基于XML Schema 定义。本章讨论的beans配置格式在XML Schema文档中定义。但是，p命名空间没有在XSD文件中定义，只存在于Spring的内核。</p>
<p>以下示例显式了解决相同结果的两个XML片段：第一个使用标准XML格式，第二个使用p命名空间。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;p-namespace&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:email</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该示例显示了在bean定义中名为email的p命名空间中属性。这告诉Spring包含一个属性声明。如前所述，p命名空间没有schema定义，因此你可以将属性（attribute）的名称设置为属性（property ）名称。</p>
<p>下一个示例包括两个对另一个bean的引用的bean定义：：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John Doe&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spouse&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-modern&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:name</span>=<span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:spouse-ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;jane&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jane Doe&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，此示例不仅包括使用p命名空间的属性值，还使用特殊格式来声明属性引用。第一个bean定义使用**&lt;property name &#x3D;”spouse” ref &#x3D;”jane”&#x2F;&gt;<strong>来创建从bean john到bean jane的引用，第二个bean定义使用</strong>p:spouse-ref &#x3D;”jane”**作为属性来完成相同的事情。在这种情况下，spouse是属性名称，而-ref部分表示这不是一个直接的值，而是引用另一个bean。</p>
<blockquote>
<p>p命名空间不如标准XML格式那么灵活。例如，这种声明属性引用的格式与以Ref结尾的属性冲突，而标准XML格式则不会。我们建议你仔细选择你的方法，并将其传达给你的团队成员，以避免同时使用所有三种方法生成XML文档</p>
</blockquote>
<h3 id="使用c命名空间的XML快捷方式"><a href="#使用c命名空间的XML快捷方式" class="headerlink" title="使用c命名空间的XML快捷方式"></a>使用c命名空间的XML快捷方式</h3><p>类似于称为“使用p命名空间的XML快捷方式”，Spring 3.1中新引入的c命名空间允许使用内联属性来配置构造方法参数，而不是使用嵌套的<strong>constructor-arg</strong>元素。</p>
<p>我们来回顾一下名为<a href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“基于构造方法的依赖注入”</a>一节中使用c:namespace的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Baz&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 传统的声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用c命名空间的声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span> <span class="attr">c:bar-ref</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">c:baz-ref</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">c:email</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于通过参数名来设置构造方法参数，**c:<strong>命名空间与</strong>p:**的使用相同的惯例（对bean引用的尾接-ref）。同样，它也需要声明，即使它没有在XSD schema 中定义（但它存在于Spring内核中）。</p>
<p>对于构造方法参数名称不可用的罕见情况（通常如果字节码在没有调试信息的情况下编译），可以对参数索引使用回退：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c命名空间索引声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span> <span class="attr">c:_0-ref</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于XML语法，索引符号需要前置_的存在，因为XML属性名称不能以数字开头（即使某些IDE允许）。</p>
</blockquote>
<p>在实践中，构造方法解析机制在匹配参数方面非常有效，除非真的需要，我们建议你在你的配置中始终使用名称符号。</p>
<h3 id="复合属性名称"><a href="#复合属性名称" class="headerlink" title="复合属性名称"></a>复合属性名称</h3><p>当你设置bean属性时，可以使用复合或嵌套属性名称，只要除了最后属性名称之外的路径的所有组件都不为null。 考虑下面的bean定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foo.Bar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fred.bob.sammy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>foo</strong> bean有一个<strong>fred</strong>属性，<strong>fred</strong>属性又有一个<strong>bob</strong>属性，bob属性又有一个<strong>sammy</strong>属性，最后的<strong>sammy</strong>属性被设置值为123。为了这个工作，在bean被构建之后，<strong>foo</strong>的<strong>fred</strong>属性，<strong>fred</strong>的<strong>bob</strong>属性必须不是null，否则抛出一个<strong>NullPointerException</strong> 。</p>
<h2 id="使用depends-on"><a href="#使用depends-on" class="headerlink" title="使用depends-on"></a>使用depends-on</h2><hr>
<p>如果一个bean是另一个的依赖，通常意味着一个bean被设置为另一个bean的属性。通常，你可以使用基于XML的配置元数据中的**&lt;ref &#x2F;&gt;<strong>元素来完成此任务。但是，有时bean之间的依赖关系较不直接;比如，在一个类中的静态初始化器需要被触发，例如数据库驱动注册。</strong>depends-on**属性可以明确强制一个或多个bean在使用此元素的bean被初始化前先初始化。下面示例使用depends-on熟悉来表示一个单例bean上的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了表达对多个bean的依赖，提供bean名称列表作为<strong>depends-on</strong>属性的值，使用<strong>逗号</strong>，<strong>空白</strong>或者<strong>分号</strong>作为有效分隔符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bean定义中的<strong>depends-on</strong>属性可以同时指定初始化时依赖，而在单例Bean的情况下，可以指定相应的销毁时依赖。一个需要依赖项的bean与一个给定的bean定义的<strong>depends-on</strong>关系，则需要依赖项bean在依赖项销毁之前销毁。因此<strong>depends-on</strong>也可以控制关机顺序。</p>
</blockquote>
<h2 id="延迟初始化bean"><a href="#延迟初始化bean" class="headerlink" title="延迟初始化bean"></a>延迟初始化bean</h2><hr>
<p>默认情况下，<strong>ApplicationContext</strong>实现在初始化过程中急切创建和配置所有单例bean。一般来说，这种预实例化是可取的，因为配置或周围环境中的错误会被立即发现，而不是在几个小时甚至几天之后。当不希望这种行为的时候，你通过可以标记bean定义为lazy-initialized（延迟初始化）来阻止单例bean的预实例化。一个延迟初始化的bean告诉IoC容器当它被第一次请求的时候才创建bean实例，而不是在启动时就实例化。</p>
<p>在XML中，这种行为由在**&lt;bean&#x2F;&gt;<strong>元素上的</strong>lazy-init**属性控制；例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当上述配置被<strong>ApplicationContext</strong>使用时，<strong>ApplicationContext</strong>启动时，名为<strong>lazy</strong>的bean不会立即被预实例化，而<strong>not.lazy</strong> bean会被立即预实例化。</p>
<p>然而，当一个延迟初始化的bean是一个单例bean的依赖项的时候，它不是延迟初始化的，<strong>ApplicationContext</strong>在启动时就创建该延迟初始化bean，因为它必须满足该单例的依赖。延迟初始化bean被注入到其他不是延迟初始化的单例bean中。</p>
<p>你也可以通过使用**&lt;beans&#x2F;&gt;<strong>元素上的</strong>default-lazy-init**属性在容器级别上控制懒加载；例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 没有beans会被预实例化... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自动装配协作者"><a href="#自动装配协作者" class="headerlink" title="自动装配协作者"></a>自动装配协作者</h2><hr>
<p>Spring容器可以自动装配协作bean之间的关系。你可以通过检查（inspect）<strong>ApplicationContext</strong>的内容来允许Spring为你的bean自动解析协作者（其他bean）。自动装配有以下的优点：</p>
<ul>
<li>自动装配可以显著减少指定属性或构造方法参数的需要。（其他机制，如本章其他地方讨论的bean模板在这方面也很有价值。）</li>
<li>随着对象的发展，自动装配可以更新配置。例如，如果你需要给一个类添加一个依赖项，则可以无需修改配置，自动满足该依赖关系。因此，自动装配在开发过程中特别有用，在代码库变得更加稳定时，无需切换到显式装配。</li>
</ul>
<p>当使用基于XML的配置元数据时，可以使用**&lt;bean&#x2F;&gt;<strong>元素上的</strong>autowire**属性为bean定义指定自动装配模式。自动装配功能有四种模式。你可以指定每一个需要自动装配的bean并且因此可以选择哪一个来自动装配。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>(默认)不自动装配。必须通过ref元素定义bean引用。对于大规模的部署不推荐改变此默认设置，因为明确指定协作者将给予更大的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td>byName</td>
<td>通过属性名自动装配。Spring会找到一个与需要自动装配的属性名称相同的bean。例如，如果bean定义被设置为通过名称自动装配，并且它包含一个master属性（也就是，它有一个setMaster(..)方法），Spring会查找一个名称为master的bean定义，并且使用它来设置属性</td>
</tr>
<tr>
<td>byType</td>
<td>如果确实容器中存在该属性类型的一个bean，则允许该属性被自动装配。如果有超过一个的bean存在，会抛出一个致命异常，这表示你可能不会为该bean使用<em>byType</em>自动装配。如果这里没有匹配的bean存在，则什么也不会发生；属性没有被设置。</td>
</tr>
<tr>
<td>constructor</td>
<td>类似与<em>byType</em>，但是只适用于构造方法参数。如果在容器中没有一个构造方法参数类型的bean，则会引起一个致命错误。</td>
</tr>
</tbody></table>
<p>在 <em>byType</em> 或 <em>constructor</em> 模式下，你可以装配数组和类型集合。在这种情况下，容器中所有在匹配预期类型的自动装配候选者，都被提供来满足依赖。如果期望的key类型是String，你可以自动装配强类型的Map。一个自动装配Map值会由匹配预期类型的所有bean实例组成，并且Map的key会包含相应的bean名称。</p>
<p>你可以将autowire行为与依赖检查相结合，检查会在自动装配完成后执行。</p>
<h3 id="自动装配的限制和缺点"><a href="#自动装配的限制和缺点" class="headerlink" title="自动装配的限制和缺点"></a>自动装配的限制和缺点</h3><p>在项目中贯穿始终的使用自动装配是效果最好的。如果自动装配没有被一贯使用，只是自动装配一两个bean定义可能会迷惑开发者。</p>
<p>考虑下面自动装配的限制和缺点：</p>
<ul>
<li>在<strong>property</strong>和<strong>constructor-arg</strong>中显式设置的依赖总是覆盖自动装配。你不能自动装配所谓的简单属性，例如原始类型，String和Class（以及这些简单属性的数组）。这种限制是设计的。</li>
<li>自动装配不如显式写明精确。尽管，如上表所示，Spring小心避免在歧义的情况下猜测，这可能会有一个意想不到的结果，你的Spring管理对象之间的关系不再被明确记录。</li>
<li>对于可能从Spring容器生成文档的工具可能无法使用装配信息。</li>
<li>容器中的多个bean定义可能与由setter方法或构造方法参数指定的类型相匹配，从而进行自动装配。对于数组，集合或Map，这不一定是问题。然而，对于期望单个值的依赖，这种歧义不是任意解决的。如果没有唯一的bean定义可用，则抛出异常。</li>
</ul>
<p>在后一种情况下，你有几个选项：</p>
<ul>
<li>放弃自动装配，明确写明依赖。</li>
<li>通过设置一个bean的<strong>autowire-candidate</strong>属性为false（如下一节描述），避免该bean被自动装配。</li>
<li>通过将其**&lt;bean&#x2F;&gt;<strong>元素的</strong>primary**属性设置为true，将单个bean定义指定为主要候选。</li>
<li>使用基于注解的配置实现更细粒度的控制，如<a href="#%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">“基于注解的容器配置”</a>中所描述的。</li>
</ul>
<h3 id="从自动装配中排除一个bean"><a href="#从自动装配中排除一个bean" class="headerlink" title="从自动装配中排除一个bean"></a>从自动装配中排除一个bean</h3><p>在每个bean的基础上，你可以将bean从自动装配中排除。在Spring的XML格式中，将**&lt;bean&#x2F;&gt;<strong>元素上的</strong>autowire-candidate<strong>属性设置为false;容器使这个指定的bean定义不可用于自动装配基础架构（包括注解样式配置，例如</strong>@Autowired**）。</p>
<blockquote>
<p><strong>autowire-candidate</strong>属性被设计为仅影响基于类型的自动装配。它不会影响通过名称的明确引用，即使指定的bean没有被标记为一个自动装配候选，它也会被解析。因此，如果名称匹配的话，通过名称的自动装配依旧会注入这个bean。</p>
</blockquote>
<p>你也可以基于模式匹配而不是bean名称来限制自动装配的候选者。顶级**&lt;beans&#x2F;&gt;<strong>元素的</strong>default-autowire-candidates<strong>属性接收一个或多个模式。例如，要将自动装配候选者状态限制为任何名称以Repository结尾的bean，提供一个 *Repository的值。要提供多个模式，在一个以逗号分割的列表中定义它们。对一个bean明确定义</strong>autowire-candidate**属性的值为true或false的，这种设置始终优先，对于这样的bean，模式匹配将不再适用。</p>
<p>这些技术对于你不想通过自动装配注入其他bean的bean很有用。这并不意味着被排除的bean本身不能使用自动装配来配置。而是，这个bean它本身不是其他bean自动装配的候选者。</p>
<h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><hr>
<p>在大多数应用程序场景中，在容器中大多数的bean都是 <a href="">单例</a> 的。当一个单例bean需要和其他单例bean相协作时，或者一个非单例bean需要和其他非单例bean相协作时，你通常通过定义一个bean作为其他bean的属性来处理依赖关系。当bean的生命周期不同的时候，会发生一个问题。假设单例bean A需要使用非单例（原型）bean B，也许每个方法在A上调用。容器只会创建单例bean A一次，因此只有一次设置属性的机会。容器不能在每次需要时，向bean A提供一个新的bean B实例。</p>
<p>解决方案是放弃一些控制反转。你可以通过实现<strong>ApplicationContextAware</strong>接口使bean A对容器敏感，并且在每次bean A需要bean B的时候通过对容器调用**getBean(“B”)**来获取（通常是新的）bean B实例。以下是这种方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个使用状态命令行样式类的类执行一些处理</span></span><br><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring-API导入</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Map commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 抓取相应Command的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 注意Spring API依赖!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applicationContext.getBean(<span class="string">&quot;command&quot;</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述是不可取的，因为业务代码接触并耦合到Spring框架上。方法注入，一个Spring IoC容器的先进的功能，可以以干净的方式处理这种用例。</p>
<blockquote>
<p>你可以在此 <a href="https://spring.io/blog/2004/08/06/method-injection/">博客条目</a> 中阅读更多关于方法注入的动机。</p>
</blockquote>
<h3 id="Lookup方法注入"><a href="#Lookup方法注入" class="headerlink" title="Lookup方法注入"></a>Lookup方法注入</h3><p>Lookup方法注入是容器重写容器所管理的bean上的方法的能力，用来返回容器中另一个命名bean的lookup结果。lookup通常涉及前一部分中描述的场景中的原型bean。Spring框架通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类来实现此方法注入。</p>
<blockquote>
<ul>
<li>为了使这个动态子类工作起来，Spring将子类化的类不能是<strong>final</strong>，并且被重写的方法也不能是<strong>final</strong>。</li>
</ul>
</blockquote>
<ul>
<li>单元测试具有抽象方法的类需要你自己对类进行子类化，并提供抽象方法的存根实现。</li>
<li>组件扫描也需要具体的方法，这需要具体的类来进行。</li>
<li>另一个关键的限制是，lookup方法不能和工厂方法一起使用，并且特别是不能和配置类中的带有@Bean方法一起使用，因为在该情况下容器不负责创建实例，因此无法动态创建一个运行时生成的子类。</li>
</ul>
<p>看前面的代码片段中的<strong>CommandManager</strong>类，你会看到Spring容器将动态地覆盖<strong>createCommand()<strong>方法的实现。你的</strong>CommandManager</strong>类将不会对Spring有任何依赖关系，在重做示例中可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再有Spring导包!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 抓取相应Command接口的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧...但是这个方法的实现在哪里？</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端类包含要被注入的方法（在这个例子中是<strong>CommandManager</strong>），要注入的方法需要以下形式的签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>
<p>如果这个方法是<strong>abstranct</strong>的，动态生成子类实现了这个方法。否则，动态生成子类覆盖这个定义在原始类中的具体方法。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 被部署为一个原型（非单例）的有状态的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myCommand&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按需在这里注入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor 使用statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;commandManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createCommand&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标识为commandManager的bean无论什么时候需要myCommand bean的一个新实例，就调用自己的<strong>creatCommond()<strong>方法。你必须小心以原型部署</strong>myCommand</strong> bean，如果它实际需要。如果它是以单例部署，则每次myCommand bean返回的是同一个实例。</p>
<p>或者，在基于注解的组件模型中，你可以通过@Lookup注释声明一个lookup 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup(&quot;myCommand&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，更为惯用的是，你可能依赖针对lookup方法声明返回类型的解析来获取目标bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，你通常会使用具体的存根实现来声明这种带注解的lookup方法，为了使它们与Spring的组件扫描规则兼容，默认情况下抽象类被忽略。此限制不适用于明确注册或明确导入的bean类的情况。</p>
<blockquote>
<p>另一种访问不同域的目标bean的方法是<strong>ObjectFactory</strong>&#x2F;<strong>Provider</strong>注入点。查看<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96">“作用域bean作为依赖”</a>一节。<br>感兴趣的读者还可以找到<strong>ServiceLocatorFactoryBean</strong>（在org.springframework.beans.factory.config包中）来使用。</p>
</blockquote>
<h3 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h3><p>比lookup方法注入更少用的一种方法注入形式是可以使用另一个方法实现来替换被管理bean中的任意方法。用户可以安全地跳过本节的剩余部分，直到实际需要该功能。</p>
<p>使用基于XML的配置元数据，对于已部署的bean你可以使用replacement-method元素将现有的方法实现替换为另一个。考虑下面的类，使用一个我们要重写的方法computeValue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValueCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">computeValue</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">// 一些真实代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些其他方法...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现org.springframework.beans.factory.support.MethodReplacer接口的类提供了新的方法定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 意在用于重写在MyValueCalculator</span></span><br><span class="line"><span class="comment"> * 中现有的computeValue(String)实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title class_">MethodReplacer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取输入值，使用它，并返回一个计算结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署原始类并指定方法重写的bean定义如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myValueCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 任意方法替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">&quot;computeValue&quot;</span> <span class="attr">replacer</span>=<span class="string">&quot;replacementComputeValue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;replacementComputeValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以在&lt;replaced-method&#x2F;&gt;元素中使用一个或多个包含的&lt;arg-type&#x2F;&gt;元素来指示被重写的方法的方法签名。只有当方法重载并且类中存在多个变体时，参数的签名才是必需的。为方便起见，参数的类型字符串可能是完全限定类型名称的子字符串。例如，以下全部匹配java.lang.String：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">String</span><br><span class="line">Str</span><br></pre></td></tr></table></figure>
<p>由于参数的数量通常足以区分每个可能的选择，所以此快捷方式可以节省大量的打字，只需键入与参数类型匹配的最短字符串即可。</p>
<hr>
<h1 id="Bean域"><a href="#Bean域" class="headerlink" title="Bean域"></a>Bean域</h1><hr>
<p>当你创建一个bean定义的时候，你创建了一个用于创建了由bean定义所定义的类的实际实例配方。bean定义是一个配方的概念很重要，因为这意味着，与类一样，你可以从单个配方创建许多对象实例。</p>
<p>你不仅可以控制要插入到由一个特殊bean定义创建的对象中的各种依赖和配置值，也可以控制这个对象的域。这种方法是强大和灵活的，你可以通过配置来选择你创建的对象的域，而不必在Java类级别上设置对象的域。bean可以被定义为部署在多个域之一中：Spring框架支持七个开箱即用的域，其中五个域只在你使用Web感知的<strong>ApplicationContext</strong>时可用。</p>
<p>以下域支持开箱即用。你还可以创建自定义域。</p>
<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#singleton%E5%9F%9F">singleton</a></td>
<td>（默认）每个Spring IoC容器将单个bean定义作为单个对象实例。</td>
</tr>
<tr>
<td><a href="#prototype%E5%9F%9F">prototype</a></td>
<td>将单个bean定义范围适用于任何数量的对象实例。</td>
</tr>
<tr>
<td><a href="#request%E5%9F%9F">request</a></td>
<td>将单个bean定义范围适用于单个HTTP请求的生命周期;也就是，每个HTTP请求都有一个它自己的bean实例，该实例是由背后的单个bean定义创建的。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#session%E5%9F%9F">session</a></td>
<td>将单个bean定义范围适用于一个HTTP Session生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#globalSession%E5%9F%9F">globalSession</a></td>
<td>将单个bean定义范围适用于一个HTTP Session生命周期中。通常仅在Portlet上下文中使用时才有效。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#application%E5%9F%9F">application</a></td>
<td>将单个bean定义范围适用于一个ServletContext生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#websocket%E5%9F%9F">websocket</a></td>
<td>将单个bean定义范围适用于一个WebSocket生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
</tbody></table>
<blockquote>
<p>从Spring 3.0开始，一个thread域是可用的，但默认情况下未注册。有关更多信息，请参阅SimpleThreadScope的文档。有关如何注册此或任何其他自定义域的说明，请参阅<a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4">“使用自定义范围”</a>一节。</p>
</blockquote>
<h2 id="singleton域"><a href="#singleton域" class="headerlink" title="singleton域"></a>singleton域</h2><hr>
<p>单例bean只有一个共享实例被管理，并且所有对具有该id的bean或匹配到id的bean的请求都会使Spring容器返回一个指定的bean实例。</p>
<p>换句话说，当你定义一个bean定义以及它的域为singleton时，Spring IoC容器只会创建一个由该bean定义定义的对象的实例。这个单例实例被储存在一个这样的单例bean的缓存中，并且所有对这个命名bean的后续请求和引用都会返回缓存对象。<br><img src="/images/spring/singleton.png.pagespeed.ce.U0lSEQUK39.png" alt="单例bean"><br>Spring的单例bean概念不同于定义在Gang of Four (GoF)模式书中的单例模式（Singleton pattern）. GoF单例硬编码了对象的域范围，使得每个ClassLoader只会创建一个且只有一个特定类的实例。Spring单例域是描述为一个容器一个bean。这意味着如果在单个Spring容器为一个特殊类定义了一个bean，那么Spring容器只会创建一个且只有一个由该bean定义的类的实例。单例域是Spring默认的域。在XML中要定义一个bean为单例，你应该这么写，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面是等效的，尽管有些多余（单例域是默认设置）) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="prototype域"><a href="#prototype域" class="headerlink" title="prototype域"></a>prototype域</h2><hr>
<p>部署非单例，原型域的bean使每次对该特定bean进行请求时创建一个新的bean实例。也就是在容器中这个bean被注入到其他bean，或者你通过getBean()方法调用请求它。一般来说，为有状态的bean使用原型域，为无状态的bean使用单例域。</p>
<p>下面图表说明了Spring原型域。一个数据访问对象（DAO）通常不被配置为原型，因为一个典型DAO不保持任何会话状态；这只是作者简单的重用单例域的图。<br><img src="/images/spring/prototype.png" alt="原型bean"><br>下面示例在XML中定义一个bean为原型：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>与其他域相反，Spring不管理原型bean的完整生命周期：容器实例化，配置或以其他方式组装原型对象，并将其交给客户端，并不再记录该原型实例。因此，尽管不管是什么域，初始化生命周期回调方法在所有的对象上被调用，但是在原型的情况下，配置的销毁生命周期不被调用。客户端代码必须清理原型域对象并且是释放这个原型bean持有的昂贵资源。要使Spring容器释放原型bean持有的资源，尝试使用一个自定义的bean <a href="">post-processor</a>, 它涉及需要清理的bean。</p>
<p>在某些方面，Spring容器对原型域bean的作用是Java new操作符的替代。所有这之后的生命周期管理都必须由客户端处理。（有关Spring容器中bean的生命周期的详细信息，请参见第6.1节<a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83">“生命周期回调”</a>。）</p>
<h2 id="依赖原型bean的单例bean"><a href="#依赖原型bean的单例bean" class="headerlink" title="依赖原型bean的单例bean"></a>依赖原型bean的单例bean</h2><hr>
<p>当你使用依赖原型bean的单例bean的时候，要意识到依赖关系是在实例化时解析的。因此，如果你依赖注入一个原型域bean到一个单例域的bean，一个新的原型bean被实例化，然后被依赖注入到这个单例bean中。这个原型实例是曾经提供给单例域实例的唯一实例。</p>
<p>然而，假设你想要这个单例域bean在运行时期，重复去获得这个原型bean的新实例。你不能依赖注入一个原型域bean到你的单例域bean中，因为这个注入只发生一次，在Spring容器实例化这个单例bean并且解析和注入它的依赖时。如果在运行时多次需要一个原型bean的新实例，请参见第4.6节 <a href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">“方法注入”</a></p>
<h2 id="Request-session-global-session-application和-WebSocket域"><a href="#Request-session-global-session-application和-WebSocket域" class="headerlink" title="Request, session, global session, application和 WebSocket域"></a>Request, session, global session, application和 WebSocket域</h2><hr>
<p>只有使用Web感知的Spring <strong>ApplicationContext</strong>实现（如XmlWebApplicationContext），<strong>request</strong>, <strong>session</strong>, <strong>globalSession</strong>, <strong>application</strong>和 <strong>webSocket</strong>域才可用。如果你在常规Spring Ioc容器，如<strong>ClassPathXmlApplicationContext</strong>中见到这些域，那么会抛出一个<strong>IllegalStateException</strong>异常来抱怨一个未知的bean范围。</p>
<h3 id="初始web配置"><a href="#初始web配置" class="headerlink" title="初始web配置"></a>初始web配置</h3><p>要支持在<strong>request</strong>, <strong>session</strong>, <strong>globalSession</strong>, <strong>application</strong>和 <strong>webSocket</strong>级别（web域bean）bean的域，在你定义你的bean之前，需要一些次要的初始配置。（对于标准域，单例和原型不需要这些初始设置。）</p>
<p>如何完成此初始设置取决于你的特定Servlet环境。</p>
<p>如果在Spring Web MVC中访问作用域bean，实际上，其中请求由Spring的 <strong>DispatcherServlet</strong>或<strong>DispatcherPortlet</strong>来处理，这样不需要特殊的设置：DispatcherServlet和DispatcherPortlet已经显式所有相关状态。</p>
<p>如果你使用Servlet 2.5 web容器，请求在Spring的DispatcherServlet之外处理（例如，当使用JSF或Struts），你需要注册<strong>org.springframework.web.context.request.RequestContextListener</strong> <strong>ServletRequestListener</strong>。对于Servlet 3.0+,可以通过WebApplicationInitializer接口以编程方式完成。或者，对于较旧的容器，请将以下声明添加到Web应用程序的web.xml文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.request.RequestContextListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果你的监听器设置有问题，请考虑使用Spring的RequestContextFilter。过滤器映射取决于周围的Web应用程序配置，因此必须根据需要进行更改。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>DispatcherServlet</strong>，<strong>RequestContextListener</strong>和<strong>RequestContextFilter</strong>都完成相同的事情，即将HTTP请求对象绑定到为该请求提供服务的线程上。这使得request-和session域的bean在调用链上进一步可用。</p>
<h3 id="Request域"><a href="#Request域" class="headerlink" title="Request域"></a>Request域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.LoginAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用loginAction 的bean定义为每个HTTP请求创建一个新的LoginAction bean实例。也就是说，loginAction bean的作用域在HTTP request级别上。你可以根据需要更改创建的实例的内部状态，因为从同一个loginAction bean定义创建的其他实例将不会在状态中看到这些更改;它们是特定于单独请求的。当请求完成处理时，作用于该请求的bean将被丢弃。</p>
<p>使用注解驱动组件或Java Config时，可以使用@RequestScope注解指定组件为request域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAction</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Session域"><a href="#Session域" class="headerlink" title="Session域"></a>Session域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用UserPreferences的bean定义为每个HTTP会话的生命周期创建一个新的UserPreferences bean实例。换而言之，userPreferences bean的作用域在HTTP Session级别上有效。和request域的bean一样，你可以根据需要更改创建的实例的内部状态，其他HTTP Session实例使用从相同userPreferences bean定义创建的实例看不到这些状态修改，因为它们是特定于单个HTTP会话的。当HTTP Session最终被丢弃时，范围限定于该特定HTTP Session的bean也被丢弃。</p>
<p>使用注解驱动组件或Java Config时，可以使用@SessionScope注解指定组件为session域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPreferences</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="globalSession域"><a href="#globalSession域" class="headerlink" title="globalSession域"></a>globalSession域</h3><p>考虑以下bean定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;globalSession&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>globalSession域类似于标准的HTTP Session域（如上描述），并且仅适用于基于Portlet的Web应用程序的上下文。portlet规范定义了构成单个Portlet Web应用程序的所有portlet之间共享的全局会话的概念。定义在globalSession域上的Bean被限定（或绑定）到全局portlet Session的生命周期上。</p>
<p>如果你编写一个标准的基于Servlet的web应用程序，并且你定义一个或多个bean具有gloablSession域，那么使用的是标准HTTP Session域，并且不会发生错误。</p>
<h3 id="Application域"><a href="#Application域" class="headerlink" title="Application域"></a>Application域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AppPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用AppPreferences的bean定义为整个web程序创建一个新的AppPreferences bean实例。换而言之，appPreferences bean的作用域在HTTP ServletContext级别上有效，作为一个常规的ServletContext属性存储。这有些类似域Spring单例bean，但是在两个重要方式上不同：它是每一个ServletContext一个单例，而不是每一个Springd的’ApplicationContext’（在任何给定的Web应用程序中可能有几个），并且它实际上是暴露的，因此可视为ServletContext属性。<br>使用注解驱动组件或Java Config时，可以使用@ApplicationScope注解指定组件为application域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppPreferences</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域bean作为依赖"><a href="#作用域bean作为依赖" class="headerlink" title="作用域bean作为依赖"></a>作用域bean作为依赖</h3><p>Spring IoC容器不仅管理对象（bean）的实例化，还管理协作者（或依赖）的装配。如果要将HTTP request域的bean（比如）注入到另一个更长生命域的bean中，你可以选择注入AOP代理来代替作用域bean。也就是说，你需要注入一个代理对象，该对象暴露与作用域对象相同的公共接口，但也可以从相关域（例如HTTP请求）中检索真实目标对象，并将方法调用委托给真实对象。</p>
<blockquote>
<p>你还可以在作用域为<strong>singleton</strong>的bean之间使用**&lt;aop:scoped-proxy&#x2F;&gt;<strong>，然后该引用经过可序列化的中间代理，因此能够在反序列化上重新获得目标单例bean。当针对</strong>prototype<strong>域的bean声明</strong>&lt;aop:scoped-proxy&#x2F;&gt;**，共享代理上的每个方法调用将导致创建一个新的目标实例，然后调用被转发到该目标实例。<br>此外，域代理不是以生命周期安全方式从较较小域访问bean的唯一方法。你也可以简单只声明你的注入点（即构造器&#x2F;setter参数或者自动装配字段）为ObjectFactory&lt;MyTargetBean&gt;,允许getObject()调用在每次需要时根据需要检索当前实例，而不必保留实例或分别存储它。JSR-330变体称为Provider，与Provider&lt;MyTargetBean&gt;声明一起使用，并为每次检索尝试使用相应的get()调用。有关JSR-330的更多详细信息，请参阅此处。</p>
</blockquote>
<p>以下示例中的配置只有一行，但是了解“为什么”以及它背后的“如何”是很重要的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个HTTP Session域bean以一个代理暴露出来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指示容器代理包围的bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个使用上述代理注入到的单例域bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.SimpleUserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对代理的userPreferences bean的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要创建这样一个代理，你将一个子**&lt;aop:scoped-proxy&#x2F;&gt;<strong>元素插入作用域bean定义中(请参阅 <a href="">“选择要创建的代理类型”</a> 一节和第41章 <a href="">基于XML架构的配置</a>)。为什么作用域在request, session, globalSession和自定义域级别上bean定义需要</strong>&lt;aop:scoped-proxy&#x2F;&gt;**元素？让我们来检查下下面的单例bean定义并且与上述域所需要的定义的进行对比（注意下面userPreferences bean定义是不完整的）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，这个HTTP-Session域bean <strong>userPreferences</strong>的引用被注入到单例bean <strong>userManager</strong>中。这里的重点是<strong>userManager</strong> bean是单例：它只会被每个容器实例化一次，并且它的依赖（这里只有一个，userPreferences bean）同样只会被注入进一次。这意味着<strong>userManager</strong> bean将只对完全相同的<strong>userPreferences</strong>对象进行操作，也就是最初注入的那个。</p>
<p>当将一个短生存域bean注入到一个长生存域bean的时候，这不是你想要的行为，比如将一个HTTP Session域的协作bean作为依赖注入到一个单例bean中。相反，你需要一个userManager对象，并且在HTTP Session的整个生命周期中，你需要一个特定于所述HTTP Session的userPreferences对象。因此，容器创建一个对象，该对象暴露与UserPreferences类（理想情况下是UserPreferences实例的对象）完全相同的公共接口，该对象可从域机制（HTTP request，Session等）中获取真实的UserPreferences对象。这个容器将这个代理对象注入到userManager bean中，该bean不会意识到这个UserPreferences引用是一个代理。在这个例子中，当UserManager实例调用一个依赖注入的UserPreferences对象的方法时，它实际是调用代理上的方法。然后这个代理从（这个例子中）HTTP Session中获取真实UserPreferences对象，并且将方法调用委托给这个获取的真实UserPreferences对象上。</p>
<p>因此当将request-，session-和globalSession-域的bean注入到协作bean上时，你需要下面正确并且完整的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="选择要创建的代理类型"><a href="#选择要创建的代理类型" class="headerlink" title="选择要创建的代理类型"></a>选择要创建的代理类型</h4><p>默认情况下，当Spring容器为使用**&lt;aop:scoped-proxy&#x2F;&gt;**元素标记的bean创建代理时，将创建一个基于CGLIB的类代理。</p>
<blockquote>
<p>CGLIB代理只拦截公共方法调用！不要在这样的代理上调用非公开方法;它们不会被委派给实际的作用域目标对象。</p>
</blockquote>
<p>或者，你可以通过为**&lt;aop:scoped-proxy&#x2F;&gt;<strong>元素的</strong>proxy-target-class**属性的值指定为false，来配置Spring容器为这些作用域bean创建基于标准的JDK基于接口的代理。使用JDK基于接口的代理意味着你的应用程序类路径不需要额外的库来实现这种代理。然而，这也意味着作用域bean的类必须实现至少一个接口，并且所有被注入协作者的作用域bean必须通过它的一个接口引用该bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DefaultUserPreferences实现了 the UserPreferences接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultUserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有关选择基于类或基于接口的代理的更多详细信息，请参见第11.6节<a href="">“代理机制”</a>。</p>
<h2 id="自定义域"><a href="#自定义域" class="headerlink" title="自定义域"></a>自定义域</h2><hr>
<p>bean域机制是可以拓展的；你可以定义你自己的域，或者甚至可以重定义现有的bean，虽然后者被认为是不好的做法，你不能覆盖内置的单例和原型域。</p>
<h3 id="创建自定义域"><a href="#创建自定义域" class="headerlink" title="创建自定义域"></a>创建自定义域</h3><p>要将自定义域集成到Spring容器中，需要实现<strong>org.springframework.beans.factory.config.Scope</strong>接口，它将在本节讲述。有关如何实现自己的范围的想法，请参阅随Spring框架本身提供的Scope实现和Scope javadocs，它更详细地解释了需要实现的方法。</p>
<p><strong>Scope</strong>接口有四个从域中获取，移除，并且销毁对象的方法。</p>
<p>以下方法从底层域返回对象。例如，session域实现返回会话域中的bean（如果不存在，则该方法返回一个新bean实例，并将其绑定到会话以供将来引用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span><br></pre></td></tr></table></figure>
<p>以下方法从底层域中删除该对象。例如，session域实现从底层会话中移除该会话域bean。应该返回对象，但如果没有找到指定名称的对象，则可以返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">remove</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>
<p>以下方法注册域应当执行的回调，当它被销毁或者当这个域中指定的对象被销毁的时候。关销毁回调的更多信息，请参阅javadocs或Spring scope实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerDestructionCallback</span><span class="params">(String name, Runnable destructionCallback)</span></span><br></pre></td></tr></table></figure>
<p>以下方法获取底层域的对话标识符。该标识符对于每个域是不同的。对于会话域的实现，该标识符可以是session标识符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConversationId</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="使用自定义域"><a href="#使用自定义域" class="headerlink" title="使用自定义域"></a>使用自定义域</h3><p>在编写和测试一个或多个自定义Scope实现之后，你需要使Spring容器了解你的新作用域。以下方法是使用Spring容器注册新的Scope的中心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerScope</span><span class="params">(String scopeName, Scope scope)</span>;</span><br></pre></td></tr></table></figure>
<p>此方法在<strong>ConfigurableBeanFactory</strong>接口上声明，它通过<strong>BeanFactory</strong>属性与Spring配合在大多数的<strong>ApplicationContext</strong>具体实现可用。</p>
<p><strong>registerScope(..)<strong>方法的第一个参数是与域关联的唯一名称;Spring容器中这样的名字的例子就是</strong>singleton</strong>和<strong>prototype</strong>。**registerScope(..)**方法的第二个参数是你希望注册使用的自定义Scope实现的实际实例。</p>
<p>假设你编写了自定义的Scope实现，然后像下面一样将它注册。</p>
<blockquote>
<p>下面的例子使用Spring中包含的<strong>SimpleThreadScope</strong>，但它默认情况下未注册。对于你自己的自定义Scope实现，示例将是一样的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scope</span> <span class="variable">threadScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThreadScope</span>();</span><br><span class="line">beanFactory.registerScope(<span class="string">&quot;thread&quot;</span>, threadScope);</span><br></pre></td></tr></table></figure>
<p>然后，你创建遵循自定义域域规则的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过自定义域实现，你不限于只使用域的编程式注册。你还可以声明地使用<strong>CustomScopeConfigurer</strong>类来执行Scope注册：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;scopes&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.SimpleThreadScope&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Rick&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<strong>FactoryBean</strong>实现中放置**&lt;aop:scoped-proxy&#x2F;&gt;<strong>时，它是工厂bean本身作用域，而不是从</strong>getObject()**返回的对象。</p>
</blockquote>
<hr>
<h1 id="定制bean性质"><a href="#定制bean性质" class="headerlink" title="定制bean性质"></a>定制bean性质</h1><hr>
<h2 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h2><hr>
<p>要与容器的bean生命周期管理进行交互，可以实现Spring <strong>InitializingBean</strong>和<strong>DisposableBean</strong>接口。容器为前者调用**afterPropertiesSet()<strong>，并为后者调用</strong>destroy()**，以允许bean在初始化和销毁bean时执行某些操作。</p>
<blockquote>
<p>JSR-250 <strong>@PostConstruct</strong>和**@PreDestroy<strong>注解通常被认为是在现代Spring应用程序中接收生命周期回调的最佳做法。使用这些注解意味着你的bean没有和Spring特定接口耦合。有关详细信息，请参见第7.9.8节<a href="#@PostConstruct%E5%92%8C@PreDestroy">“@PostConstruct和@PreDestroy”</a>。如果你不想使用JSR-250注解，但你仍然希望移除耦合，请考虑使用</strong>init-method<strong>和</strong>destroy-method**对象定义元数据。</p>
</blockquote>
<p>在内部，Spring 框架使用<strong>BeanPostProcessor</strong>实现来处理它可以找到的任何回调接口，并调用适当的方法。如果你需要自定义功能或者其他生命周期行为这些Spring没有提供开箱即用的，你可以实现一个自己的<strong>BeanPostProcessor</strong>。更多信息，请参阅[容器扩展点](# 容器扩展点)。</p>
<p>除了初始化和销毁回调之外，Spring管理的对象可能还实现<strong>Lifecycle</strong>接口，这样这些对象可以参与由容器自己的生命周期驱动的启动和关闭过程。</p>
<p>在本节描述生命周期回调接口。</p>
<h3 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h3><p><strong>org.springframework.beans.factory.InitializingBean</strong>接口允许在bean上所有必须属性已经被容器设置好后，执行初始化工作。<strong>InitializingBean</strong>接口指定了一个单一方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>建议你不要使用<strong>InitializingBean</strong>接口，因为它不必要地将代码耦合到Spring上。作为选择，使用**@PostConstruct<strong>注解或指定一个POJO初始化方法。在基于XML配置元数据中，你使用</strong>init-method<strong>属性来指定具有void no-argument签名的方法的名称。在Java Config中，你可以使用</strong>@Bean<strong>的</strong>initMethod**属性，请参阅<a href="">“接收生命周期回调”</a>一节。例如，以下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与下面完全一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前一种没有将代码与Spring耦合在一起。</p>
<h3 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h3><p>实现<strong>org.springframework.beans.factory.DisposableBean</strong>接口允许bean在包含它的容器销毁时获取一个回调。<strong>DisposableBean</strong>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>建议你不要使用<strong>DisposableBean</strong>接口，因为它不必要地将代码耦合到Spring上。作为选择，使用**@PreDestroy<strong>注解或指定一个由bean定义支持的通用方法。在基于XML配置元数据中，你使用&lt;bean&#x2F;&gt;上的</strong>destroy-method<strong>属性。在Java Config中，你可以使用</strong>@Bean<strong>的</strong>destroyMethod**属性，请参阅<a href="">“接收生命周期回调”</a>一节。例如，以下定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些销毁工作(比如释放池连接)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与下面完成一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些销毁工作(比如释放池连接)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前一种没有将代码与Spring耦合在一起。</p>
<blockquote>
<p>一个**&lt;bean&gt;<strong>元素的</strong>destroy-method<strong>属性可以被赋予一个特殊的(<strong>inferred</strong>)值，该值指示Spring在特定的bean类上自动检测公共的</strong>close<strong>或</strong>shutdown<strong>方法。（任何实现</strong>java.lang.AutoCloseable<strong>或</strong>java.io.Closeable<strong>的类会因此匹配）。这个特殊的（推测的）值也可以在</strong>&lt;beans&gt;<strong>元素的</strong>default-destroy-method**属性上设置，以将此行为应用于一整套bean（请参阅<a href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95">“默认初始化和销毁方法”</a>一节）。注意这是Java cofig的默认行为。</p>
</blockquote>
<h3 id="默认初始化和销毁方法"><a href="#默认初始化和销毁方法" class="headerlink" title="默认初始化和销毁方法"></a>默认初始化和销毁方法</h3><p>当你编写不使用Spring指定的<strong>InitializingBean</strong>和<strong>DisposableBean</strong>回调接口的初始化和销毁​​方法回调时，你通常用<strong>init()</strong>,<strong>initialize()</strong>,**dispose()**等这些名称。理想情况下，这些生命周期回调方法的名称贯穿整个项目，以便所有的开发者使用相同的方法名称和确保一致性。</p>
<p>你可以配置Spring容器去查找在每个bean上的命名初始化和销毁回调方法名称。这意味着你作为一个程序开发者，可以编写你的应用程序类，并且使用一个名为**init()<strong>的初始化回调，而不用必在每个bean定义上配置</strong>init-method&#x3D;“init”**属性。Spring IoC容器在bean被创建的时候调用这个方法（并按照前面描述的标准生命周期回调契约）。这个功能同样为初始化和销毁方法回调执行一致的命名约定。</p>
<p>假设你的初始化回调方法名为**init()<strong>并且销毁回调方法名为</strong>destory()**。你的类将类似于下面例子中的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title class_">BlogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlogDao blogDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlogDao</span><span class="params">(BlogDao blogDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blogDao = blogDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是（不出意料的）初始化回调方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.blogDao == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The [blogDao] property must be set.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blogService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultBlogService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于顶级**&lt;beans &#x2F;&gt;<strong>元素属性中</strong>default-init-method<strong>属性的存在，导致Spring IoC容器将bean上名为</strong>init**的方法识别为初始化方法回调。当bean被创建和组装，如果这个bean类上有这样一个方法，它会在合适的时间被调用。</p>
<p>你通过使用顶级**&lt;beans &#x2F;&gt;<strong>元素上</strong>default-init-method**属性类似的配置销毁方法回调（在XML上是这样）。</p>
<p>如果已有的bean类已经有回调方法，并且命名与约定不符的，你可以通过使用**&lt;bean&#x2F;&gt;<strong>的</strong>init-method<strong>和</strong>destroy-method**属性来指定（在XML中，是这样）方法名称来覆盖默认值。</p>
<p>Spring容器保证在bean所有的依赖被提供后，立即调用配置的初始化回调。因此这个初始化回调是在原始bean上被调用，这意味着AOP拦截器等尚未应用于该bean。目标bean首先被完全创建，然后才应用AOP代理（例如）和它的拦截器链。如果目标bean和代理被分开定义，你的代码甚至可以绕过代理，与原始目标bean进行交互。因此，将拦截器应用到init方法将会变得不一致，因为这样做会将目标bean的生命周期和它的代理&#x2F;拦截器耦合在一起，并在代码直接与原始目标bean进行交互时留下奇怪的语义。</p>
<h3 id="组合生命周期机制"><a href="#组合生命周期机制" class="headerlink" title="组合生命周期机制"></a>组合生命周期机制</h3><p>从Spring 2.5开始，你有三种控制bean生命周期行为的选项：<strong>InitializingBean</strong>和<strong>DisposableBean</strong>回调接口;自定义<strong>init()<strong>和</strong>destroy()<strong>方法;和</strong>@PostConstruct</strong>和**@PreDestroy**注解。你可以组合这些机制来控制给定的bean。</p>
<blockquote>
<p>如果为一个bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，那么每个配置的方法都按照下面列出的顺序执行。但是，如果为超过一个这些生命周期机制配置了相同的方法名称，例如初始化方法init() ，该方法将如上一节所述的只执行一次。</p>
</blockquote>
<p>使用了不同的初始化方法，为同一个bean配置的多个生命周期机制，如下被调用：</p>
<ul>
<li>被**@PostConstruct**注解的方法</li>
<li>由<strong>InitializingBean</strong>回调接口定义的<strong>afterPropertiesSet()</strong></li>
<li>自定义配置的**init()**方法</li>
</ul>
<p>销毁方法以相同的顺序被调用</p>
<ul>
<li>被**@PreDestroy**注解的方法</li>
<li>由<strong>DisposableBean</strong>回调接口定义的<strong>destroy()</strong></li>
<li>自定义配置的**destroy()**方法</li>
</ul>
<h3 id="启动和关闭回调"><a href="#启动和关闭回调" class="headerlink" title="启动和关闭回调"></a>启动和关闭回调</h3><p><strong>Lifecycle</strong>接口为任何具有自身生命周期需求的对象定义了必需方法（例如启动和停止一些后台进程）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何Spring管理的对象都可以实现这个接口。然后，当<strong>ApplicationContext</strong>本身接收到启动和停止信号时，例如，对于运行时的停止&#x2F;重新启动情况，它会将这些调用级联到在该上下文中定义的所有<strong>Lifecycle</strong>实现。它通过委托给<strong>LifecycleProcessor</strong>来执行此操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>LifecycleProcessor</strong>本身是<strong>Lifecycle</strong>接口的扩展。它还增加了另外两种方法来对正在刷新和关闭的上下文进行反应。</p>
<blockquote>
<p>请注意，常规的<strong>org.springframework.context.Lifecycle</strong>接口只是对明确的启动&#x2F;停止通知的简单合同，并不意味着在上下文刷新时自动启动。考虑实现<strong>org.springframework.context.SmartLifecycle</strong>来代替，以便对特定bean的自动启动（包括启动阶段）进行细粒度的控制。此外，请注意，停止通知不能保证在销毁之前发生：在常规关机时，所有Lifecycle bean将在广泛的销毁回调传播之前首先收到停止通知;然而，在上下文生命周期的热刷新或中止刷新尝试时，只会调用destroy方法。</p>
</blockquote>
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“depends-on”关系，则依赖方将在其依赖之后启动，并在其依赖之前停止。然而，有时直接依赖是未知的。你可能只知道某种类型的对象应该在另一种类型的对象之前开始。在这些情况下，<strong>SmartLifecycle</strong>接口定义了另一个选项，即在其父接口<strong>Phased</strong>上定义的getPhase()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phased</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span>, Phased &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAutoStartup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Runnable callback)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启动时，相位最低的对象首先启动，停止时则按照相反的顺序进行。因此，实现SmartLifecycle的对象，并且它的getPhase()方法返回值为Integer.MIN_VALUE的，将是第一个启动和最后停止的对象（可能是因为它依赖于其他进程运行）。当考虑相位值时，知道任何没有实现**SmartLifecycle **的“正常”<strong>Lifecycle</strong>对象的相位值为0是很重要的。因此，任何负相位值都表示一个对象应该在这些标准组件之前开始（并在它们之后停止），反之亦然。</p>
<p>你可以看到<strong>SmartLifecycle</strong>定义的stop方法接受回调。任何实现必须在该实现的关闭过程完成后调用该回调的run（）方法。这可以在必要时进行异步关闭，因为<strong>LifecycleProcessor</strong>接口的默认<strong>DefaultLifecycleProcessor</strong>，会对每个阶段中的对象组等待它们的超时值，以此来调用这个回调。每个相位默认超时值是30秒。你可以通过在上下文中定义名为“lifecycleProcessor”的bean来覆盖默认的生命周期处理器实例。如果你只想修改超时值，则定义以下内容就足够了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以毫秒为单位的超时值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeoutPerShutdownPhase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如前所述，LifecycleProcessor接口定义了用于刷新和关闭上下文的回调方法。后者将简单地驱动关闭过程，就像已经明确调用了stop()一样，但是它是在上下文关闭时发生。另一方面，“refresh”回调启用了SmartLifecycle bean的另一个功能。当上下文被刷新（在所有对象被实例化和初始化之后）时，该回调将被调用，并且在这个点上，默认生命周期处理器将检查每个SmartLifecycle对象的isAutoStartup()方法返回的布尔值。如果为“true”，则该对象将在该点启动，而不是等待上下文或它自己的start()方法的显式调用（与上下文刷新不同，对于标准的上下文实现上下文启动不会自动发生）。“phase”值以及任何“depends-on”关系将以与上述相同的方式决定来启动顺序。</p>
<h3 id="在非Web应用程序中正常关闭Spring-IoC容器"><a href="#在非Web应用程序中正常关闭Spring-IoC容器" class="headerlink" title="在非Web应用程序中正常关闭Spring IoC容器"></a>在非Web应用程序中正常关闭Spring IoC容器</h3><blockquote>
<p>本节仅适用于非Web应用程序。 Spring的基于Web的ApplicationContext实现已经有代码在关闭相关Web应用程序时，正常关闭Spring IoC容器。</p>
</blockquote>
<p>如果在非Web应用程序环境中使用Spring的IoC容器;例如，在富客户端桌面环境中;你为JVM注册一个关闭钩子。这样做可以确保正常关机，并在单例Bean上调用相关的destroy方法，以便释放所有资源。当然，你仍然必须正确配置和实现这些销毁回调。</p>
<p>要注册一个关闭钩子，你调用ConfigurableApplicationContext接口上声明的registerShutdownHook()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span> []&#123;<span class="string">&quot;beans.xml&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为上述上下文添加一个关闭钩子...</span></span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// app在这里运行...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要方法退出，钩子在应用程序关闭之前被调用......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationContextAware和BeanNameAware"><a href="#ApplicationContextAware和BeanNameAware" class="headerlink" title="ApplicationContextAware和BeanNameAware"></a>ApplicationContextAware和BeanNameAware</h2><hr>
<p>当<strong>ApplicationContext</strong>创建一个实现<strong>org.springframework.context.ApplicationContextAware</strong>接口的对象实例时，会提供给实例该<strong>ApplicationContext</strong>的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此bean可以编程式操作创建它们的<strong>ApplicationContext</strong>，通过<strong>ApplicationContext</strong>接口或者将个引用转换为这个接口的一个已知子类，例如<strong>ConfigurableApplicationContext</strong>，它暴露了一些额外功能。这样做的一个用途是可以编程式检索其他的bean。有时这种能力是有用的;然而，一般你应该避免这样做，因为它将代码和Spring耦合在一起，并且没有遵循将协作者作为属性提供给bean的控制反转风格。<strong>ApplicationContext</strong>的其他方法提供对文件资源的访问，发布应用程序事件和访问<strong>MessageSource</strong>。这些附加功能在第7.15节<a href="">“ApplicationContext的附加功能”</a>中描述。</p>
<p>从Spring2.5开始，自动装配是另一种获取<strong>ApplicationContext</strong>引用的可选方法。“传统”的<strong>constructor</strong>和<strong>byType</strong>自动装配模式（如第4.5节<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">“自动装配协作者”</a>中所述）可以分别为构造方法参数或setter方法参数提供<strong>ApplicationContext</strong>类型的依赖。为了更多的灵活性，包括自动装配字段和多参数方法的能力，请使用新的基于注解的自动装配功能。如果你这样做，<strong>ApplicationContext</strong>被自动装配到一个字段，构造方法参数或者方法参数上，如果相关期望<strong>ApplicationContext</strong>类型的字段，构造方法或方法带有**@Autowired**注解的话。更多信息，请参阅第9.2节<a href="#@Autowired">“@Autowired”</a>。</p>
<p>当<strong>ApplicationContext</strong>创建一个实现<strong>org.springframework.beans.factory.BeanNameAware</strong>接口的类时，该类将被提供一个对其关联对象定义中定义名称的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个回调在普通bean属性被填充后，但是在一个初始化回调（如InitializingBean的afterPropertiesSet 或一个自定义init方法）前调用。</p>
<h2 id="其他Aware接口"><a href="#其他Aware接口" class="headerlink" title="其他Aware接口"></a>其他Aware接口</h2><p>除了上面讨论的<strong>ApplicationContextAware</strong>和<strong>BeanNameAware</strong>之外，Spring还提供了一系列Aware接口，允许bean指示容器他们需要某个基础框架依赖。最重要的Aware接口总结如下-作为通用规则，它们的名称很好的指示了依赖类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>注入的依赖</th>
<th>在…解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ApplicationContextAware</strong></td>
<td>声明ApplicationContext</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>ApplicationEventPublisherAware</strong></td>
<td>封闭的ApplicationContext事件发布&#96;器</td>
<td><a href="#ApplicationContext%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">7.15节“ApplicationContext的附加功能”</a></td>
</tr>
<tr>
<td><strong>BeanClassLoaderAware</strong></td>
<td>用于加载bean类的类加载器。</td>
<td><a href="#">第3.2节“实例化bean”</a></td>
</tr>
<tr>
<td><strong>BeanFactoryAware</strong></td>
<td>声明的BeanFactory</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>BeanNameAware</strong></td>
<td>声明bean的名称</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>BootstrapContextAware</strong></td>
<td>容器运行的资源适配器BootstrapContext。通常仅在JCA感知的ApplicationContexts中可用</td>
<td><a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#cci">第32章，JCA CCI</a></td>
</tr>
<tr>
<td><strong>LoadTimeWeaverAware</strong></td>
<td>定义了加载时处理类定义的weaver</td>
<td><a href="#"></a></td>
</tr>
<tr>
<td><strong>MessageSourceAware</strong></td>
<td>解析消息的配置策略（支持参数化和国际化）</td>
<td><a href="#"></a></td>
</tr>
<tr>
<td><strong>NotificationPublisherAware</strong></td>
<td>Spring JMX通知发布器</td>
<td><a href="#">第31.7节“通知”</a></td>
</tr>
<tr>
<td><strong>PortletConfigAware</strong></td>
<td>当前容器运行的PortletConfig。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第25章Portlet MVC框架</a></td>
</tr>
<tr>
<td><strong>PortletContextAware</strong></td>
<td>当前容器运行的PortletContext。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第25章Portlet MVC框架</a></td>
</tr>
<tr>
<td><strong>ResourceLoaderAware</strong></td>
<td>用于低级别访问资源配置的loader</td>
<td><a href="#">第8章 资源</a></td>
</tr>
<tr>
<td><strong>ServletConfigAware</strong></td>
<td>当前容器运行的ServletConfig。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第22章，Web MVC框架</a></td>
</tr>
<tr>
<td><strong>ServletContextAware</strong></td>
<td>当前容器运行的ServletContext。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第22章，Web MVC框架</a></td>
</tr>
</tbody></table>
<hr>
<h1 id="Bean定义继承"><a href="#Bean定义继承" class="headerlink" title="Bean定义继承"></a>Bean定义继承</h1><hr>
<p>一个bean定义可以包含很多配置信息，包括构造方法参数，属性值和容器特定信息，如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以根据需要覆盖某些值，或者添加其他值。使用父和子bean定义可以节省大量的输入。实际上，这是模板的一种形式。</p>
<p>如果以编程方式使用<strong>ApplicationContext</strong>接口，子Bean定义由<strong>ChildBeanDefinition</strong>类表示。大多数用户不能在这个级别上使用它们，而是以类似于<strong>ClassPathXmlApplicationContext</strong>的方式声明地配置bean定义。当你使用基于XML的配置元数据时，你通过使用<strong>parent</strong>属性指定一个子bean的定义，指定父bean作为此属性的值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 值为1的age属性会从父级继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个子bean定义如果没有指定bean类的话则使用父级的定义，但也可以覆盖父级定义。在后一种情况，这个子bean必须兼容父级，也就是，它必须接受父级的属性值。</p>
<p>子bean继承父级的域，构造方法参数值，属性值，和方法重写，并可以添加新值。你指定的任何域，初始化方法，销毁方法，和&#x2F;或静态工厂方法会覆盖父级中相应的设置。</p>
<p>其余设置始终采用自子定义：depends on，自动装配模式，依赖关系检查，单例，延迟初始化。</p>
<p>上面的例子使用<strong>abstract</strong>属性明确标示父bean定义是抽象的。如果父定义没有指定一个类，则需要将父bean定义明确标识为抽象，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age会从父bean定义中继承值为1--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父bean不能自己实例化，因为它是不完整的，它也被明确标记为<strong>abstract</strong>。当一个定义像这样是“<strong>abstract</strong>“的，它只能用作纯模板bean定义，作为子定义的父定义。尝试使用这样一个抽象的父bean，当通过引用它作为另一个bean的<strong>ref</strong>属性或使用父bean <strong>id</strong>进行显式的<strong>getBean()<strong>调用，会返回一个错误。类似地，容器的内部</strong>preInstantiateSingletons()<strong>方法忽略被定义为</strong>abstract</strong>的bean定义。</p>
<blockquote>
<p><strong>ApplicationContext</strong>默认预实例化所有的单例。因此，重要的是（至少对于单例bean），如果你有一个（父）bean定义，你打算仅作为模板使用，并且这个定义指定了一个类，则必须确保将<strong>abstract</strong>属性设置为<strong>true</strong>，否则应用程序上下文将实际（尝试）预实例化这个抽象bean。</p>
</blockquote>
<hr>
<h1 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h1><hr>
<p>通常，应用程序开发人员不需要对<strong>ApplicationContext</strong>实现类进行子类化。相反，Spring IoC容器可以通过插入特殊集成接口的实现来扩展。接下来的几节将介绍这些集成接口。</p>
<h2 id="使用BeanPostProcessor自定义bean"><a href="#使用BeanPostProcessor自定义bean" class="headerlink" title="使用BeanPostProcessor自定义bean"></a>使用BeanPostProcessor自定义bean</h2><hr>
<p><strong>BeanPostProcessor</strong>接口定义了你可以实现的回调方法，以提供自己的（或覆盖容器的默认）实例化逻辑，依赖解析逻辑等。如果要在Spring容器完成实例化，配置和初始化bean之后实现一些自定义逻辑，则可以插入一个或多个<strong>BeanPostProcessor</strong>实现。</p>
<p>你可以配置多个<strong>BeanPostProcessor</strong>实例，并且可以通过设置<strong>order</strong>属性来控制这些BeanPostProcessors执行的顺序。只有当<strong>BeanPostProcessor</strong>实现了<strong>Ordered</strong>接口时，才能设置此属性;如果你编写自己的<strong>BeanPostProcessor</strong>，你也应该考虑实现<strong>Ordered</strong>接口。有关更多详细信息，请参阅<strong>BeanPostProcessor</strong>和<strong>Ordered</strong>接口的javadocs。另请参阅下面的关于编程式注册<strong>BeanPostProcessors</strong>的注释。</p>
<blockquote>
<p><strong>BeanPostProcessor</strong>操作bean（或对象）实例；也就是说，Spring Ioc容器实例化一个bean示例，然后<strong>BeanPostProcessor</strong>执行它的工作。<br><strong>BeanPostProcessor</strong>作用域在每个容器范围。这只有在使用容器层次结构时才有用。如果你在一个容器中定义了一个BeanPostProcessor，那么它只会对该容器中的bean进行post-process。换句话说，在一个容器中定义的bean不会被另一个容器中定义的BeanPostProcessor进行post-process，即使这两个容器都是同一层次结构的一部分。<br>要更改实际的bean定义（即定义bean的蓝图），你需要使用<strong>BeanFactoryPostProcessor</strong>，如第7.8.2节<a href="#%E4%BD%BF%E7%94%A8BeanFactoryPostProcessor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE">“使用BeanFactoryPostProcessor自定义配置元数据”</a>所述。</p>
</blockquote>
<p><strong>org.springframework.beans.factory.config.BeanPostProcessor</strong>接口只由两个回调方法组成。当这样的类在容器中被注册为post-processor时，对于由容器创建的每个bean实例，post-processor在容器初始化方法（诸如InitializingBean的afterPropertiesSet()和任何声明的init方法）被调用之前以及任何bean初始化回调之后，从容器中获取回调。post-processor可以对bean实例执行任何操作，包括完全忽略回调。bean post-processor通常检查回调接口，或者可能使用一个代理来包装bean。一些Spring AOP基础框架类被实现为bean post-processor，以提供代理包装逻辑。</p>
<p><strong>ApplicationContext</strong>会自动探测任何定义在配置元数据中实现了<strong>BeanPostProcessor</strong>接口的bean。<strong>ApplicationContext</strong>注册这些bean作为post-processor，以便稍后在创建bean时可以调用它们。Bean post-processor可以像任何其他bean一样部署在容器中。</p>
<p>注意，当在配置类上使用**@Bean<strong>工厂方法声明一个</strong>BeanPostProcessor<strong>时，工厂方法的返回类型应该是实现类本身或至少是</strong>org.springframework.beans.factory.config.BeanPostProcessor<strong>接口，清楚地表明该bean的post-processor性质。否则，</strong>ApplicationContext<strong>将无法在完全创建它之前按类型自动检测到它。由于为了在上下文中应用于其他bean的初始化，所以</strong>BeanPostProcessor**需要更早的实例化，这种早期类型检测至关重要。</p>
<ul>
<li><blockquote>
<p>虽然<strong>BeanPostProcessor</strong>注册的推荐方式是通过<strong>ApplicationContext</strong>自动检测（如上所述），但也可以使用<strong>addBeanPostProcessor</strong>方法对<strong>ConfigurableBeanFactory</strong>进行编程式注册。当需要在注册之前评估条件逻辑，或者甚至在层次结构中的背景上复制bean post-processor时，这可能是有用的。但是请注意，以编程方式添加的<strong>BeanPostProcessors</strong>不遵循<strong>Ordered</strong>接口。这里注册的顺序决定执行的顺序。还要注意，以编程方式注册的<strong>BeanPostProcessors</strong>始终在通过自动检测注册的那些之前进行处理，而不管是否有明确的排序。          </p>
</blockquote>
</li>
<li><blockquote>
<p>实现<strong>BeanPostProcessor</strong>接口的类是特殊的，并且被容器不同对待。作为<strong>ApplicationContext</strong>的特殊启动阶段的一部分，它们直接引用的所有<strong>BeanPostProcessors</strong>和Bean都将在启动时实例化。接下来，所有<strong>BeanPostProcessors</strong>都以排序的方式进行注册，并应用于容器中的所有其他bean。因为AOP自动代理以<strong>BeanPostProcessor</strong>本身实现，所以<strong>BeanPostProcessors</strong>和它们直接引用的bean都不具有自动代理的资格，因此没有组织它们的方面。<br>对于任何这样的bean，你应该看到一个信息日志消息：“Bean foo不符合所有BeanPostProcessor接口处理（例如：不符合自动代理资格）”的资格。<br>注意，如果你让bean使用自动装配或者**@Resource<strong>（它可能回退进行自动装配）装配到你的</strong>BeanPostProcessor<strong>，则Spring可能会在搜索类型匹配的候选对象时访问非预期的bean，从而使该</strong>BeanPostProcessor<strong>不符合自动代理或其他类型的bean  post-processing。例如，如果你使用</strong>@Resource**注解的的依赖，其中字段&#x2F; setter名称与bean的已声明名称不直接对应，并且注解没有使用name属性，那么Spring将访问其他bean以按类型进行匹配。</p>
</blockquote>
</li>
</ul>
<p>以下示例说明如何在<strong>ApplicationContext</strong>中编写，注册和使用<strong>BeanPostProcessors</strong>。</p>
<h3 id="示例：Hello-World，BeanPostProcessor-style"><a href="#示例：Hello-World，BeanPostProcessor-style" class="headerlink" title="示例：Hello World，BeanPostProcessor-style"></a>示例：Hello World，BeanPostProcessor-style</h3><hr>
<p>第一个例子说明了基本用法。该示例展示了一个自定义<strong>BeanPostProcessor</strong>实现，它调用每个由容器创建的bean的**toString()**方法，并将生成的字符串打印到系统控制台。</p>
<p>查找下面的自定义BeanPostProcessor实现类定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单地返回实例化的bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean,</span></span><br><span class="line"><span class="params">            String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// 我们可能会在这里返回任何对象引用...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean,</span></span><br><span class="line"><span class="params">            String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; created : &quot;</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:lang</span>=<span class="string">&quot;http://www.springframework.org/schema/lang&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/lang</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/lang/spring-lang.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">&quot;messenger&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">script-source</span>=<span class="string">&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Fiona Apple Is Just So Dreamy.&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当上面的bean（messenger）被实例化，这个自定义BeanPostProcessor实现将事实输出到系统控制台</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;scripting.InstantiationTracingBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意InstantiationTracingBeanPostProcessor怎么被简单的定义。它甚至没有一个名字，因为它是一个bean，它可以像任何其他bean一样被依赖注入。（上述配置还定义了一个由Groovy脚本支持的bean，Spring动态语言支持在<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#dynamic-language">第35章“动态语言支持”</a>一章中详细介绍。</p>
<p>以下简单的Java应用程序执行上述代码和配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;scripting/beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">Messenger</span> <span class="variable">messenger</span> <span class="operator">=</span> (Messenger) ctx.getBean(<span class="string">&quot;messenger&quot;</span>);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述应用程序的输出类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bean &#x27;messenger&#x27; created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>

<h3 id="示例：-RequiredAnnotationBeanPostProcessor"><a href="#示例：-RequiredAnnotationBeanPostProcessor" class="headerlink" title="示例： RequiredAnnotationBeanPostProcessor"></a>示例： RequiredAnnotationBeanPostProcessor</h3><p>将回调接口或注解与自定义BeanPostProcessor结合使用是扩展Spring IoC容器的常用手段。一个例子是Spring的RequiredAnnotationBeanPostProcessor - 一个Spring分发版附带的BeanPostProcessor实现，它确保被（任意）注解标记的bean上的JavaBean属性被实际（配置为）依赖注入一个值。</p>
<h2 id="使用BeanFactoryPostProcessor自定义配置元数据"><a href="#使用BeanFactoryPostProcessor自定义配置元数据" class="headerlink" title="使用BeanFactoryPostProcessor自定义配置元数据"></a>使用BeanFactoryPostProcessor自定义配置元数据</h2><hr>
<p>我们将看到的下一个扩展点是<strong>org.springframework.beans.factory.config.BeanFactoryPostProcessor</strong>。该接口的语义与<strong>BeanPostProcessor</strong>类似，主要区别在于：<strong>BeanFactoryPostProcessor</strong>对bean配置元数据进行操作;也就是说，Spring IoC容器允许<strong>BeanFactoryPostProcessor</strong>读取配置元数据，并可能在容器实例化除<strong>BeanFactoryPostProcessors</strong>之外的任何Bean之前,会更改它。</p>
<p>你可以配置多个<strong>BeanFactoryPostProcessors</strong>，并且可以通过设置order属性来控制这些BeanFactoryPostProcessors执行的顺序。但是，你只能在BeanFactoryPostProcessor实现了Ordered接口，才能设置此属性。如果你编写自己的BeanFactoryPostProcessor，你也应该考虑实现Ordered接口。有关更多详细信息，请参阅BeanFactoryPostProcessor和Ordered接口的javadocs。</p>
<blockquote>
<p>如果要更改实际的bean实例（即从配置元数据创建的对象），则需要使用BeanPostProcessor（如第8.1节“使用BeanPostProcessor自定义bean”中所述）。尽管在技术上可以在BeanFactoryPostProcessor中使用bean实例（例如，使用BeanFactory.getBean()），但这样做会导致过早的bean实例化，违反了标准容器生命周期。这可能会导致负面的副作用，如旁路bean后处理。此外，BeanFactoryPostProcessors作用域在每个容器范围。这只有在使用容器层次结构时才有用。如果在一个容器中定义了一个BeanFactoryPostProcessor，那么它只会应用于该容器中的bean定义。一个容器中的Bean定义不会被另一个容器中的BeanFactoryPostProcessors进行post-processed，即使这两个容器都是同一层次结构的一部分。</p>
</blockquote>
<p>当在<strong>ApplicationContext</strong>中声明一个<strong>BeanFactoryPostProcessor</strong>，它会被自动执行以便对定义容器的配置元数据进行更改。Spring包括一些预定义的BeanFactoryPostProcessor，如<strong>PropertyOverrideConfigurer</strong>和<strong>PropertyPlaceholderConfigurer</strong>。例如，也可以使用自定义BeanFactoryPostProcessor来注册自定义属性编辑器。</p>
<p><strong>ApplicationContext</strong>自动检测部署到其中的任何实现<strong>BeanFactoryPostProcessor</strong>接口的bean。它在适当的时候使用这些bean作为<strong>BeanFactoryPostProcessor</strong>。你可以像任何其他bean一样部署这些后处理器bean。</p>
<blockquote>
<p>与<strong>BeanPostProcessors</strong>一样，你通常不想将<strong>BeanFactoryPostProcessors</strong>配置为延迟初始化。如果没有其他bean引用一个Bean(Factory)PostProcessor，那么后处理器根本不会被实例化。因此，它的懒加载标记会被忽略，即使在**&lt;beans&#x2F;&gt;<strong>元素的声明中将</strong>default-lazy-init**属性设置为true，Bean(Factory)PostProcessor也会被立即实例化。</p>
</blockquote>
<h3 id="示例：类名替换PropertyPlaceholderConfigurer"><a href="#示例：类名替换PropertyPlaceholderConfigurer" class="headerlink" title="示例：类名替换PropertyPlaceholderConfigurer"></a>示例：类名替换PropertyPlaceholderConfigurer</h3><p>你可以使用**PropertyPlaceholderConfigurer **在使用了标准的Java Properties格式的单独的文件中从bean定义外部化属性值。这样做使得部署应用程序的人可以自定义环境特定的属性（如数据库URL和密码），避免修改容器的主要XML定义文件或文件的复杂性及风险。</p>
<p>考虑以下基于XML的配置元数据片段，其中定义了带有占位符值的<strong>DataSource</strong>。该示例显式从外部<strong>Properties</strong>文件配置的属性。在运行时，<strong>PropertyPlaceholderConfigurer</strong>应用于将替换<strong>DataSource</strong>的某些属性的元数据。被替换的值被指定为遵循Ant&#x2F;log4j&#x2F;JSP EL风格的**${property-name}**形式的占位符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/foo/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际值来自另一个文件，以标准Java Properties格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
<p>因此，字符串${jdbc.username}在运行时被替换为值“sa”，同样适用于与属性文件中的键匹配的其他占位符值。<strong>PropertyPlaceholderConfigurer</strong>在一个bean中多数properties和attributes中检查占位符。此外，可以定制占位符前缀和后缀。</p>
<p>使用Spring 2.5引入的<strong>context</strong>命名空间，可以使用专用配置元素配置属性占位符。一个或多个位置可以在<strong>location</strong>属性中以用逗号分隔列表提供。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/foo/jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>PropertyPlaceholderConfigurer</strong>不仅在你指定的Properties文件中查找属性。默认如果它没有在指定的属性文件中找到一个属性，它还将检查Java系统属性。你可以通过将<strong>configurer</strong>的<strong>systemPropertiesMode</strong>属性设置为以下三个支持的整数值之一来自定义此行为：</p>
<ul>
<li>从不（0）：从不检查系统属性</li>
<li>回退（1）：如果在指定的属性文件中没有可解析的，则检查系统属性。这个是默认设置</li>
<li>覆盖（2）：首先检查系统属性，然后再尝试指定的属性文件。这允许系统属性覆盖任何其他属性源。</li>
</ul>
<p>有关详细信息，请参阅PropertyPlaceholderConfigurer javadocs。</p>
<blockquote>
<p>你可以使用PropertyPlaceholderConfigurer来替换类名，这在运行时必须选择特定的实现类时有时很有用。例如：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;$&#123;custom.strategy.class&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果类不能在运行时解析为有效类，那么即将要创建的bean的解析失败，对于非延迟初始化的bean这发生在<strong>ApplicationContext</strong>的**preInstantiateSingletons()**阶段期间。</p>
<h3 id="示例：PropertyOverrideConfigurer"><a href="#示例：PropertyOverrideConfigurer" class="headerlink" title="示例：PropertyOverrideConfigurer"></a>示例：PropertyOverrideConfigurer</h3><p>另一个bean工厂后处理器的<strong>PropertyOverrideConfigurer</strong>与<strong>PropertyPlaceholderConfigurer</strong>类似，但是不像后者那样，原始bean定义可以具有默认值或根本没有任何值用于bean属性。如果一个用于覆盖的Properties文件没有某个bean属性的条目，则使用默认上下文定义。</p>
<p>请注意，bean定义感知不到被覆盖，所以从XML定义文件中不能立即显式覆盖configurer正在被使用。如果多个<strong>PropertyOverrideConfigurer</strong>实例为同一个bean属性定义不同的值，由于覆盖机制而获胜，最后一个覆盖值生效。</p>
<p>属性文件配置行采用以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beanName.property=value</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql:mydb</span><br></pre></td></tr></table></figure>
<p>此示例文件可以与包含称为dataSource的bean的容器定义一起使用，这个bean有一个driver和url属性。</p>
<p>还支持复合属性名称，只要除了要被覆盖的最终属性外，路径的每个组件都已经是非null（可能由构造方法初始化）。在这个例子中…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo.fred.bob.sammy=123</span><br></pre></td></tr></table></figure>
<p>foo bean的fred属性的bob属性的sammy属性设置为标量值123。</p>
<blockquote>
<p>指定的覆盖值始终为字面值;它们不会被转换为bean引用。当XML bean定义中的原始值指定一个bean引用时，此约定也适用。</p>
</blockquote>
<p>使用Spring 2.5引入的context命名空间时，可以使用专用配置元素配置属性覆盖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">&quot;classpath:override.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用FactoryBean自定义实例化逻辑"><a href="#使用FactoryBean自定义实例化逻辑" class="headerlink" title="使用FactoryBean自定义实例化逻辑"></a>使用FactoryBean自定义实例化逻辑</h2><hr>
<p>为自己的工厂的对象实现<strong>org.springframework.beans.factory.FactoryBean</strong>接口。</p>
<p><strong>FactoryBean</strong>接口是Spring IoC容器的实例化逻辑的可插入点。如果你有复杂的初始化代码，那么它可以在Java中更好的表达，而不是在一堆（可能）冗长的XML中，你可以创建自己的<strong>FactoryBean</strong>，在该类中编写复杂的初始化，然后将你的自定义<strong>FactoryBean</strong>插入容器。</p>
<p>FactoryBean接口提供三种方法：</p>
<ul>
<li><strong>Object getObject()</strong>: 返回此工厂创建的对象的实例。该实例可能是共享的，这取决于这个工厂是否返回单例或原型。</li>
<li><strong>boolean isSingleton()</strong>: 如果此FactoryBean返回单例则返回true，否则返回false。</li>
<li><strong>Class getObjectType()</strong>: 返回getObject()方法返回的对象类型，如果类型未提前知道，则返回null。</li>
</ul>
<p>FactoryBean的概念和接口在Spring Framework中的许多地方使用; FactoryBean接口的50多个实现与Spring本身一起运行。</p>
<p>当你需要向容器询问实际的<strong>FactoryBean</strong>实例本身而不是其生成的bean时，在调用<strong>ApplicationContext</strong>的<strong>getBean()<strong>方法时，使用</strong>＆</strong>符号（＆）来表示bean的id。所以对于给定的FactoryBean，其ID为myBean，在容器上调用**getBean(“myBean”)<strong>返回FactoryBean的产物;而调用</strong>getBean(“＆myBean”)**则返回FactoryBean实例本身。</p>
<hr>
<h1 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h1><hr>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**注解比XML更适合配置Spring吗？**      
基于注解配置的引入产生了这样一个问题，这种方式比XML更好吗？短的答案是看情况。长的答案是每种方式都有它自己的优缺点，并且通常由开发人员决定哪种策略更适合他们。由于它们被定义的方式，注解在它们的声明中提供了大量的上下文，从而使配置更短，更简洁。然而，XML非常适合在不接触源代码或重新编译组件的情况下组装组件。一些开发人员喜欢将装配就近源代码，而其他开发者认为注解类不再是POJO，此外，配置变得分散化，难以控制。      
无论怎么选择，Spring都可以容纳这两种风格，甚至将它们混合在一起。需要指出的是，通过其JavaConfig选项，Spring允许以非侵入式的方式使用注解，而不用触及目标组件源代码，并且而在工具方面，Spring Tool Suite支持所有配置样式。
</div> 
基于注解的配置提供了XML配置的替代方法，这种配置依赖于字节码元数据来装配组件，而不是角括号声明。相比使用XML来声明一个bean装配，开发者通过在相关类，方法，字段声明上使用注解，将配置移动到组件类本身。正如在“示例：RequiredAnnotationBeanPostProcessor"一节中所提到的，使用** BeanPostProcessor** 结合注解是扩展Spring IoC容器的常用手段。例如，Spring 2.0使用**@Required**注解强制执行注入所需的属性。Spring 2.5使得可以遵循相同的通用方式来驱动Spring的依赖注入。实质上，**@Autowired**注解提供了与第4.5节 [“自动装配协作者"](#自动装配协作者) 中所述相同的功能，但具有更细粒度的控制和更广泛的适用性。Spring 2.5还添加了对JSR-250注解的支持，如**@PostConstruct**和**@PreDestroy**。Spring 3.0增加了javax.inject包中包含的JSR-330（用于Java的依赖注入）注解，例如**@Inject**和**@Named**。有关这些注解的详细信息，请参见 [相关章节]()。

<blockquote>
<p>注解注入在XML注入之前执行，因此通过这两种方式进行注入时，后一种配置会覆盖前面的属性装配。</p>
</blockquote>
<p>和之前一样，你可以以单独的bean定义来注册，但也可以通过在基于XML的Spring配置中包含以下标签来隐式注册（注意包含的<strong>context</strong>命名空间）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（隐式注册的post-processors包括<strong>AutowiredAnnotationBeanPostProcessor</strong>，<strong>CommonAnnotationBeanPostProcessor</strong>，<strong>PersistenceAnnotationBeanPostProcessor</strong>以及前述的<strong>RequiredAnnotationBeanPostProcessor</strong>。）</p>
<blockquote>
<p> <strong>&lt;context:annotation-config&#x2F;&gt;<strong>只在和它在同一个应用程序上下文中的bean上查找注解。这意味着，如果在</strong>DispatcherServlet</strong>的<strong>WebApplicationContext</strong>中放置了**&lt;context:annotation-config&#x2F;&gt;<strong>，它只检查conroller中的</strong>@Autowired** bean，而不在service中。更多信息请查看第22.2节 <a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc-servlet">“The 于DispatcherServlet”</a>。</p>
</blockquote>
<h2 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h2><hr>
<p><strong>@Required</strong>注解应用于bean属性的setter方法，如下面示例所示&#96;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此注解只是表示受影响的bean属性必须在配置的时候通过bean定义中的显式属性值或通过自动装配来填充。如果受影响bean属性没有被填充，容器会抛出一个异常；这允许急切和明确的失败，在以后避免<strong>NullPointerExceptions</strong>等异常。它还建议你将断言放入bean类本身，例如，将其放入<strong>init</strong>方法中。这样做确保这些必须的引用和值，即使你在容器外使用这个类。</p>
<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><hr>
<blockquote>
<p>以下示例中可以使用JSR 330的**@Inject<strong>注解来代替Spring的</strong>@Autowired**注解。请参阅 <a href="">这里</a> 了解更多详情。</p>
</blockquote>
<p>你可以将**@Autowired**注解应用到构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从Spring Framework 4.3开始，如果目标bean只定义一个构造方法，则**@Autowired**构造方法不再需要。如果有几个构造方法可用，至少必须注解一个构造方法来指导容器必须使用哪个构造方法。</p>
</blockquote>
<p>如预期的那样，你还可以将**@Autowired**注解应用于“传统”setter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以将注解应用于具有任意名称和&#x2F;或多个参数的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以将**@Autowired**应用于字段，甚至将其与构造方法进行混合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过将注解添加到期望特定类型数组的字段或方法上，从ApplicationContext提供该类型的所有bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样适用于类型集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你希望将数组或列表中的项目按特定顺序排序话，你的bean可以实现<strong>org.springframework.core.Ordered</strong>接口，或者要么使用**@Order<strong>要么使用标准的</strong>@Priority**。</p>
</blockquote>
<p>只要预期的键的类型为String，即使类型Map也可以自动装配。 Map值将包含预期类型的​​所有bean，键将包含相应的bean名称：Map值将包含预期类型的​​所有bean，键将包含相应的bean名称：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，自动装配会在没有候选bean可用时失败；因为默认会将被注解的方法，构造方法和字段视为必须依赖。这可以通过如下来修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个类只有一个注解的构造方法可以被标记为必须的，但是可以注解多个构造方法为非必须。在这种情况下，每个被考虑在候选之中，并且Spring使用最贪婪（greediest）的构造方法，也就是有最多参数的构造方法，该构造方法的依赖将被满足。**@AutoWired的required属性建议使用@Required注解代替。<strong>required属性表示该属性对于自动装配目的不是必需的，如果不能被自动装配，那么该属性将被忽略。另一方面，</strong>@Required**更强大，它强迫属性必须被容器支持的任何bean设置，如果没有注入值，则会引发相应的异常。</p>
</blockquote>
<p>你还可以对于众所周知的可解析的依赖接口使用@Autowired：<strong>BeanFactory</strong>, <strong>ApplicationContext</strong>, <strong>Environment</strong>,** ResourceLoader**, <strong>ApplicationEventPublisher</strong>, 和 <strong>MessageSource</strong>。这些接口以及它们的拓展接口（比如<strong>ConfigurableApplicationContext</strong>或<strong>ResourcePatternResolver</strong>）是自动解析的，不需要特殊设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> **@Autowired **， **@Inject **， **@Resource **和 **@Value **注解由Spring  **BeanPostProcessor **实现处理，这又意味着你不能在自己的 **BeanPostProcessor **或 **BeanFactoryPostProcessor **类型（如果有的话）中应用这些注解。这些类型必须通过XML或使用Spring @Bean方法显式地“装配”。</p>
</blockquote>
<h2 id="使用限定符微调基于注解的自动装配"><a href="#使用限定符微调基于注解的自动装配" class="headerlink" title="使用限定符微调基于注解的自动装配"></a>使用限定符微调基于注解的自动装配</h2><hr>
<p>因为通过类型的自动装配可能导致多个候选者，它经常需要对选择的过程有更多的控制。完成这项工作的一个方式是使用Spring的**@Primary<strong>注解。</strong>@Primary**表示当多个bean是自动装配到一个单值依赖的候选者时，给定一个特定的bean优先权。如果候选人中只存在一个“主要”bean，那么它将是自动装配的值。</p>
<p>让我们假设我们下面的配置，它定义firstMovieCatalog作为主要的MovieCatalog。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的配置，以下MovieRecommender将会使用firstMovieCatalog自动注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的bean定义如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-Qualifier微调基于注解的自动装配"><a href="#使用-Qualifier微调基于注解的自动装配" class="headerlink" title="使用@Qualifier微调基于注解的自动装配"></a>使用@Qualifier微调基于注解的自动装配</h2><hr>
<p>当使用通过类型的注解，有多个实例匹配确定一个主要候选者时，**@Primary<strong>是一种有效方式。当对选择过程需要更多控制时，可以使用Spring的</strong>@Qualifier**注解。你可以将qualifier值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的bean。在最简单的情况下，这可以是一个简单的描述性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;main&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Qualifier</strong>注解也可以在各个构造方法参数或方法参数中指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="meta">@Qualifier(&quot;main&quot;)</span>MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的bean定义如下所示。具有qualifier值“main”的bean，使用具有相同值的qualifier的构造方法参数进行装配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;main&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;action&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于回退匹配，bean名称被认为是默认qualifier值。因此，你可以使用id“main”来定义bean，而不是嵌套的qualifier元素，这导致相同的匹配结果。但是，尽管你可以使用这个惯例通过名称引用特定的bean，但是@Autowired从根本上是关于使用可选语义qualifier的类型驱动的注入。这意味着即使使用bean名称回退，qualifier值在类型匹配集合中总是具有缩小的语义;他们没有在语义上表达对唯一bean ID的引用。良好的qualifier值是“main”或“EMEA”或“persistent”，表示独立于bean id的特定组件的特征，可以在上述示例中的匿名bean定义的情况下自动生成。</p>
<p>Qualifiers也适用于上面讨论的类型集合，例如Set&lt;MovieCatalog&gt;。在这个情况下，根据声明的qualifier所有匹配的bean作为集合被注入。这意味着qualifier不一定是唯一的;它们只是构成过滤的标准。例如，你可以使用相同的qualifier值“action”定义多个MovieCatalog bean，所有这些都将注入到使用@Qualifier(“action”)注解的Set&lt;MovieCatalog&gt;中。</p>
<blockquote>
<p>如果你打算使用按名称的注解驱动注入，那么不要主要使用@Autowired，即使在技术上能够通过@Qualifier值引用一个bean名称。而是使用JSR-250 @Resource注解，它通过它的唯一名称语义定义识别一个指定的目标组件，声明的类型和匹配过程无关。@Autowired有不同的语义：在按类型选择候选bean之后，指定的String限定符值只有在这些类型选择的候选者才会被考虑，例如，匹配一个“account”限定符与与标记有相同限定符标签的bean。对于被定义为collection&#x2F;map或数组类型的bean，@Resource是一个更好的解决方法，通过唯一名称来引用指定的集合或数组bean。也就是说，从4.3开始，只要元素类型信息保存在@Bean返回类型签名或集合继承层次结构中，就可以通过Spring的@Autowired类型匹配算法来匹配collection&#x2F;map和数组类型。在这种情况下，限定符值可用于在相同类型的集合中进行选择，如前一段所述。<br>从4.3开始，@Autowired还考虑注入自引用，即引用回目前注入的bean。注意自注入是一个回退；对其他组件的常规依赖性始终优先。在这个意义上，自我引用不参与正式的候选人选择，因此特别的从不会是primary;相反，他们总是作为最低的优先级。在实践中，仅使用自我引用只作为最后的手段。例如，通过bean的事务代理在同一个实例上调用其他方法：在这种情况下，考虑将受影响的方法分解为单独的委托bean。或者，使用@Resource，它可以通过其唯一的名称获取代理回到当前的bean。@Autowired适用于字段，构造方法和多参数方法，允许在参数级别缩小qualifier注解。相比之下，@Resource仅支持具有单个参数的字段和bean属性setter方法。因此，如果你的注入目标是构造方法或多参数方法，请坚持使用qualifier。</p>
</blockquote>
<p>你可以创建你自己的自定义qualifier注解。简单定一个一个注解，并且在你的定义中提供@Qualifier注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以在自动装配的字段和参数上提供这个自定义qualifier：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Genre(&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setComedyCatalog</span><span class="params">(<span class="meta">@Genre(&quot;Comedy&quot;)</span> MovieCatalog comedyCatalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，提供关于候选bean定义的信息。你可以添加&lt;qualifier&#x2F;&gt;标签作为&lt;bean&#x2F;&gt;标签的子元素，然后指定type和value来匹配你的自定义qualifier注解。type是匹配注解的完全限定类名。或者，如果没有名称冲突的风险存在，为了方便你也可以使用简短类名称。这两种方式都在下面的示例中演示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;Genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;example.Genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在10节<a href="">“类路径扫描和托管组件”</a>中，你将看到一个相比以XML格式提供qualifier元数据，基于注解的替代方法。具体来说，请参见第10.8节<a href="">“使用z注解提供qualifier元数据”</a>。</p>
<p>在某些情况下，使用没有value的注解可能就足够了。当注解提供更通用的目的并且可以跨几种不同类型的依赖被应用时，这可能是有用的。例如，当没有Internet连接可用时将被搜索，你可能会提供一个离线目录。首先定义这个简单的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加这个注解到需要自动装配的字段或属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Offline</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在bean定义仅需要一个qualifier type：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;Offline&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你也可以定义接收命名属性自定义qualifier注解，取代这个简单的value属性。如果要在被自动装配的一个字段或参数上指定多个属性值，则bean应以必须与所有这些属性值相匹配才会被视为自动装配候选者。作为示例，考虑下面的注解定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">genre</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Format <span class="title function_">format</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里Format是一个枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Format</span> &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要自动装配的字段被用自定义qualifier注解，并且包含这两个属性值：genre和format。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，bean定义应该包含匹配的限定符值。这个示例还说明了可以使用bean meta属性替代&lt;qualifier&#x2F;&gt;子元素。如果可用，则&lt;qualifier&#x2F;&gt;及其属性优先，但如果不存在这样的qualifier，则自动装配机制将回退在&lt;meta&#x2F;&gt;标记中提供的值上，如以下示例中的最后两个bean定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;MovieQualifier&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;VHS&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;MovieQualifier&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;VHS&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DVD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BLURAY&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用泛型作为自动装配限定符"><a href="#使用泛型作为自动装配限定符" class="headerlink" title="使用泛型作为自动装配限定符"></a>使用泛型作为自动装配限定符</h2><hr>
<p>除了@Qualifier注解之外，还可以使用Java泛型类型作为隐式形式的限定。例如，假设你有以下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StringStore <span class="title function_">stringStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringStore</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IntegerStore <span class="title function_">integerStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntegerStore</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设上面的bean实现了泛型接口，即Store&lt;String&gt;和Store&lt;Integer&gt;, 你可以@Autowired这个Store接口并且泛型会被用作限定符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier,注入stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier,注入integerStore bean</span></span><br></pre></td></tr></table></figure>
<p>当自动装配List，Map和Array时，泛型qualifier同样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要Store bean有一个 &lt;Integer&gt;泛型，就会注入所有的这样的Store bean</span></span><br><span class="line"><span class="comment">// Store&lt;String&gt; beans不会出现在这个list中</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h2 id="CustomAutowireConfigurer"><a href="#CustomAutowireConfigurer" class="headerlink" title="CustomAutowireConfigurer"></a>CustomAutowireConfigurer</h2><hr>
<p>CustomAutowireConfigurer是一个BeanFactoryPostProcessor，它可以使你注册你自己的自定义qualifier注解类型，即使它们没有使用Spring的@Qualifier注解进行注解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customAutowireConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customQualifierTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>AutowireCandidateResolver通过以下方式确定自动装配候选者：</p>
<ul>
<li>每个bean定义的autowire-candidate值</li>
<li>然后在&lt;beans&#x2F;&gt;可用的default-autowire-candidates模式</li>
<li>@Qualifier注解的存在以及使用CustomAutowireConfigurer注册的所有自定义注解。</li>
</ul>
<p>当多个bean符合自动装配候选者时，决定哪一个为“primary”方式如下：如果候选人中只有一个bean定义的primary 属性设置为true，它会被选择。</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><hr>
<p>Spring还支持使用JSR-250 <strong>@Resource</strong>注解对字段或bean属性的setter方法进行注入。这是Java EE 5和6中的常见模式，例如在JSF 1.2管理的bean或JAX-WS 2.0的端点中。Spring也对Spring管理的对象支持这种模式。</p>
<p><strong>@Resource</strong>接收一个<strong>name</strong>属性，并且默认情况下，Spring将该值作为要注入的bean名称进行解释。换而言之，它遵循按名称语义，如下示例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name=&quot;myMovieFinder&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有明确指定name，则默认name来自字段名称或setter方法。在一个字段的情景下，它接收一个字段名称；在一个setter方法的情景下，它接收这个bean属性名称。所以下面示例是将名为“movieFinder”的bean注入到其setter方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该注解提供的name通过<strong>CommonAnnotationBeanPostProcessor</strong>感知的<strong>ApplicationContext</strong>解析为一个bean名称。如果明确配置Spring的<strong>SimpleJndiBeanFactory</strong>，可以通过JNDI解析名称。但是，建议你依赖默认行为，只需使用Spring的JNDI查找功能来保留间接级别。</p>
</blockquote>
<p>在**@Resource<strong>使用没有指定明确的名称的情况下，类似于</strong>@Autowires<strong>，</strong>@Resource<strong>查找一个主类型匹配，而不是一个指定的命名bean，并解析众所周知的可解析依赖：</strong>BeanFactory<strong>，</strong>ApplicationContext<strong>，</strong>ResourceLoader<strong>，</strong>ApplicationEventPublisher<strong>和</strong>MessageSource**接口。</p>
<p>因此在下面的示例中，<strong>customerPreferenceDao</strong> 字段首先查找一个命名为<strong>customerPreferenceDao</strong>的bean，然后回退到类型为<strong>CustomerPreferenceDao</strong>的主类型匹配。“<strong>context</strong>“字段是基于已知的可解析依赖类型ApplicationContext来注入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><hr>
<p><strong>CommonAnnotationBeanPostProcessor</strong>不仅可以识别**@Resource<strong>注解，还可以识别JSR-250生命周期注解。在Spring 2.5中引入，对这些注解的支持提供了在 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83">初始化回调</a>和<a href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"> 销毁回调</a>中描述的另一种替代方法。只要</strong>CommonAnnotationBeanPostProcessor**在Spring <strong>ApplicationContext</strong>中注册，带有这些注解之一的方法，是在生命周期中与相应的Spring生命周期接口方法或明确声明的回调方法相同的时间点调用。在下面示例，缓存将在初始化时预先填充，并在销毁时清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateMovieCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在初始化时填充电影缓存...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMovieCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在销毁时清除电影缓存...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关组合各种生命周期机制的影响的详细信息，请参阅<a href="#%E7%BB%84%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6">“组合生命周期机制”</a>一节。</p>
</blockquote>
<hr>
<h1 id="类路径扫描和管理的组件"><a href="#类路径扫描和管理的组件" class="headerlink" title="类路径扫描和管理的组件"></a>类路径扫描和管理的组件</h1><hr>
<p>本章中的大多数示例使用XML指定在Spring容器内生成每个<strong>BeanDifinition</strong>的配置元数据。前一节（第9节“基于注释的容器配置”）演示了如何通过源代码级注解提供大量配置元数据。然而，即使在这些例子中，“基本”bean定义也是在XML文件中明确定义的，而注解只是用来驱动依赖注入。本节介绍通过扫描类路径隐式检测候选组件的选项。候选组件是与过滤器条件匹配并且在容器内有对应的bean定义注册。这消除了使用XML来执行bean注册的需要;作为代替，你可以使用注解（例如**@Component**），AspectJ类型表达式，或者你自己的自定义过滤条件来选择哪些类会有在容器里的bean定义注册。</p>
<blockquote>
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring框架的一部分。这允许你使用Java而不是传统的XML文件定义bean。有关如何使用这些新功能的示例，请查看@Configuration，@Bean，@Import和@DependsOn注释。</p>
</blockquote>
<h2 id="Component和更多模型注解"><a href="#Component和更多模型注解" class="headerlink" title="@Component和更多模型注解"></a>@Component和更多模型注解</h2><hr>
<p><strong>@Repository</strong>注解是任何满足存储库（也称为数据访问对象或DAO）角色或原型的类的标记。该标记的用途是自动翻译异常，如第20.2.2节<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#orm-exception-translation">“异常翻译”</a>所述。</p>
<p>Spring提供了更多的模型注解：**@Component<strong>，</strong>@Service<strong>和</strong>@Controller<strong>。</strong>@Component<strong>是对任何Spring管理的组件的通用模型。</strong>@Repository<strong>，</strong>@Service<strong>和</strong>@Controller<strong>是针对更具体使用场景的专用化</strong>@Component<strong>例如，分别用于持久化，服务和表示层中。因此，你可以使用</strong>@Component<strong>对组件类进行注解，但通过使用</strong>@Repository<strong>，</strong>@Service<strong>或</strong>@Controller**注解它们，你的类更适合于通过工具或相关方面进行处理。例如，这些模型注解是切面点的理想目标。还有可能@Repository，@Service和@Controller可能会在未来的Spring框架发布版中带来额外的语义。因此，如果你在你的服务层在@Component和@Service中选择，@Service显然是更好的选择。类似的，如上所述，@Repository已被支持作为持久层中自动异常转换的标记。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><hr>
<p>许多Spring提供的注解可以在你自己的代码中用作元注解。元注解只是可以应用于其他注解的注解。例如，上面提到的**@Service<strong>注解是使用</strong>@Component**进行元注解的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元注解也可以组合起来创建组合注解。例如，Spring MVC中的**@RestController<strong>注解由</strong>@Controller<strong>和</strong>@ResponseBody**组成。</p>
<p>此外，组合注解可以可选地从元注解重新声明属性以允许用户自定义。当你只想暴露这个元注解属性的子集的时候，这特别有用。例如，Spring的**@SessionScope**注解将域名称硬编码为session，但人允许定制proxyMode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SessionScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> Scope#proxyMode&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> ScopedProxyMode#TARGET_CLASS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Scope.class)</span></span><br><span class="line">    ScopedProxyMode <span class="title function_">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以使用**@SessionScope<strong>而不声明</strong>proxyMode**，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionScopedService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或对<strong>proxyMode</strong>使用一个覆盖值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionScopedUserService</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关更多详细信息，请参阅<a href="#http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#annotation-programming-model">Spring 注解编程模型</a>。</p>
<h2 id="自动检测类和注册bean定义"><a href="#自动检测类和注册bean定义" class="headerlink" title="自动检测类和注册bean定义"></a>自动检测类和注册bean定义</h2><hr>
<p>Spring可以自动探测模型类并且在<strong>ApplicationContext</strong>中注册相应的<strong>BeanDefinition</strong>。如下，以下两个类有资格进行这种自动检测：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要自动探测这些类并且注册相应的bean，你需要添加**@ComponentScan<strong>到你的</strong>@Configuration<strong>类，其中</strong>basePackages**属性是两个类的公共父包。（或者，你可以指定包含每个类的父包的逗号&#x2F;分号&#x2F;空格分隔列表。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了简洁，上述可能已经使用了注解的<strong>value</strong>属性，即**@ComponentScan(“org.example”)**</p>
</blockquote>
<p>以下是使用XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用**&lt;context:component-scan&gt;<strong>隐式启用</strong>&lt;context:annotation-config&gt;<strong>的功能。当使用</strong>&lt;context:component-scan&gt;<strong>时通常不需要包含</strong>&lt;context:annotation-config&gt;**元素。</p>
</blockquote>
<blockquote>
<p>classpath包的扫描需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请确保不激活JAR任务的仅文件切换。此外，classpath目录基于安全策略可能不会在某些环境中暴露出来，例如JDK 1.7.0_45及更高版本的独立app（这需要你的清单中的“受信任的库”设置;请参阅<a href="http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources%EF%BC%89%E3%80%82">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources）。</a></p>
</blockquote>
<p>此外，当你使用<strong>component-scan</strong>元素时，<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>都将被隐式包含。这意味着这两个组件是一起被自动检测和装配的，它们都没有在XML中提供的任何bean配置元数据。</p>
<blockquote>
<p>你可以通过包含值为<strong>false</strong>的<strong>annotation-config</strong>属性来禁用<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>的注册。</p>
</blockquote>
<h2 id="使用过滤器来自定义扫描"><a href="#使用过滤器来自定义扫描" class="headerlink" title="使用过滤器来自定义扫描"></a>使用过滤器来自定义扫描</h2><hr>
<p>默认情况下，使用**@Component<strong>，</strong>@Repository<strong>，</strong>@Service<strong>，</strong>@Controller<strong>，或其自身用</strong>@Component<strong>注解的自定义注解，注解的类是唯一被检测到的候选组件。然而，你只需要通过应用自定义过滤器就可以修改和拓展这个行为。将它们添加为</strong>@ComponentScan<strong>注解的</strong>includeFilters<strong>或</strong>excludeFilters<strong>参数（或者作为</strong>component-scan<strong>元素的</strong>include-filter<strong>或</strong>exclude-filter<strong>子元素）。每个过滤器元素需要</strong>type<strong>和</strong>expression**属性。下面表格描述了过滤选项。</p>
<table>
<thead>
<tr>
<th>过滤器type</th>
<th>expression示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>annotation(默认)</td>
<td>org.example.SomeAnnotation</td>
<td>存在于目标组件上的注解类型级别</td>
</tr>
<tr>
<td>assignable</td>
<td>org.example.SomeClass</td>
<td>目标组件被分配（拓展&#x2F;实现）的类（或接口）.</td>
</tr>
<tr>
<td>aspectj</td>
<td>org.example..*Service+</td>
<td>匹配目标组件的AspectJ类型表达式。</td>
</tr>
<tr>
<td>regex</td>
<td>org.example.Default.*</td>
<td>匹配目标组件类名称的正则表达式。</td>
</tr>
<tr>
<td>custom</td>
<td>org.example.MyTypeFilter</td>
<td>org.springframework.core.type.TypeFilter接口的自定义实现。</td>
</tr>
</tbody></table>
<p>以下示例显式忽略所有@Repository注解，而使用“stub”repositories的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span></span><br><span class="line"><span class="meta">        excludeFilters = @Filter(Repository.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于使用XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;.*Stub.*Repository&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你还可以通过在注解上设置<strong>useDefaultFilters&#x3D;false</strong>或将<strong>use-default-filters&#x3D;“false”<strong>作为</strong>&lt;component-scan&#x2F;&gt;<strong>元素的属性来禁用默认过滤器。这将实际上禁用使用</strong>@Component</strong>，**@Repository<strong>，</strong>@Service<strong>，</strong>@Controller<strong>或</strong>@Configuration**注解的类的自动检测。</p>
</blockquote>
<h2 id="在组件中定义bean元数据"><a href="#在组件中定义bean元数据" class="headerlink" title="在组件中定义bean元数据"></a>在组件中定义bean元数据</h2><hr>
<p>Spring组件还可以向容器提供bean定义元数据。你可以使用与**@Configuration<strong>注解类中定义bean元数据相同的</strong>@Bean**注解来执行此操作。这有一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">publicInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 组件方法实现忽略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是一个Spring组件，它的doWork()方法中包含特定于应用程序的代码。但是，它还提供了一个bean定义，它有一个工厂方法publicInstance()。这个@Bean注解标识工厂方法和其他bean定义属性，例如通过@Qualifier注解设置限定符值。可以指定的其他方法级注解是@Scope，@Lazy和自定义限定符注解。</p>
<blockquote>
<p>除了组件初始化的角色之外，@Lazy注解也可以放置在标有@Autowired或@Inject的注入点上。在这种情况下，它导致注入了一个懒解析代理。</p>
</blockquote>
<p>如前面讨论的也支持自动装配的字段和方法，它有对@Bean方法的自动装配的额外支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">publicInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义限定符和方法参数的自动装配</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> TestBean <span class="title function_">protectedInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;public&quot;)</span> TestBean spouse,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;#&#123;privateInstance.age&#125;&quot;)</span> String country)</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;protectedInstance&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">private</span> TestBean <span class="title function_">privateInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;privateInstance&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">requestScopedInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;requestScopedInstance&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例自动将String方法参数country装配为另一个名为privateInstance的bean的Age属性的值。Spring表达式语言元素通过符号#{&lt;expression&gt;}定义属性的值。对于@Value注解，一个表达式解析器在解析表达式文本的时候被预配置来查找bean名称。</p>
<p>从Spring框架4.3开始，你还可以声明InjectionPoint类型的工厂方法参数（或其更具体的子类DependencyDescriptor），以访问触发创建当前bean的请求注入点。请注意，这仅适用于实际bean实例的创建，而不适用于注入现有实例。因此，这个功能对于原型域bean最有意义。对于其他域，工厂方法只会看到在给定域内触发一个新的bean实例创建的注入点：例如，触发创建一个懒加载单例bean的依赖。在这种情况下，使用提供的注入点元数据进行语义关注。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">prototypeInstance</span><span class="params">(InjectionPoint injectionPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;prototypeInstance for &quot;</span> + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规Spring组件中的@Bean方法的处理方式和它们在Spring @Configuration类中的对应方法不同。不同之处在于，@Component类没有使用CGLIB来增强，以拦截方法和字段的调用。CGLIB代理是@​​Configuration类中的@Bean方法中调用方法或字段的方式，它们为协作对象创建bean元数据引用;这样的方法不是使用普通的Java语义来调用的，而是通过容器来调用，为了能够提供通常的生命周期管理和Spring bean代理，即使通过对@Bean方法编程调用来引用其他bean。相反，在普通的@Component类中调用@Bean方法中的方法或字段具有标准Java语义，没有特殊的CGLIB处理或其他限制。</p>
<blockquote>
<p>你可以将@Bean方法声明为static，允许调用它们，而无需创建它们包含的配置类作为实例。当定义后处理器时这尤其有意义，例如BeanFactoryPostProcessor和BeanPostProcessor类型，因为这样的bean将在容器生命周期早期初始化，并且应该避免在此时触发配置的其他部分。请注意，静态@Bean方法的调用永远不会被容器拦截，即使在@Configuration类中（见上文）。这是由于技术限制：CGLIB子类化只能覆盖非静态方法。因此，直接调用另一个@Bean方法将具有标准的Java语义，导致独立的实例直接从工厂方法返回。@Bean方法的Java语言可见性对Spring容器中生成的bean定义并没有立即的影响。你可以在非@Configuration类中以及任何地方的静态方法上自由声明你的工厂方法。但是，@Configuration类中的常规@Bean方法必须是可覆盖的，即不能将其声明为private或final。<br>@Bean方法也将在给定组件或配置类的基类上发现，以及由组件或配置类实现的接口中声明的Java 8 default 方法。这允许在组成复杂的配置布局上有很大的灵活性，甚至可以通过Java 8 default方法（从Spring 4.2起）实现多重继承。<br>最后，请注意，单个类可以为同一个bean持有多个@Bean方法，作为多个工厂方法的安排，以在运行根据可用依赖来使用。这与在其他配置方案中选择“greediest”构造方法或工厂方法的算法相同：具有最大数量的可满足依赖关系的变体将在构建时采用，类似于容器在多个@Autowired构造方法之间进行选择</p>
</blockquote>
<h2 id="命名自动检测的组件"><a href="#命名自动检测的组件" class="headerlink" title="命名自动检测的组件"></a>命名自动检测的组件</h2><hr>
<p>当组件作为扫描过程的一部分自动检测时，其bean名称由该扫描器已知的BeanNameGenerator策略生成。默认情况下，任何Spring模型注解（@Component，@Repository，@Service和@Controller）包含一个name value，从而将该名称提供给相应的bean定义。</p>
<p>如果一个不包含名称value的注解或任何其他检测到的组件（例如由自定义过滤器发现的组件），默认的bean名称生成器返回小写形式，非完全限定的类名称。例如，如果检测到以下两个组件，则名称将为myMovieLister和movieFinderImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;myMovieLister&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你不想依赖于默认的bean命名策略，你可以提供自定义bean命名策略。首先，实现BeanNameGenerator接口，并确保包含一个默认的无参构造方法。然后，在配置扫描器时提供完全限定的类名称：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">&quot;org.example.MyNameGenerator&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作为通用规则，只要当其他组件可能会明确引用时，考虑使用注解指定组件名称。另一方面，只要容器负责装配，自动生成的名称就足够了。</p>
<h2 id="为自动检测的组件提供域"><a href="#为自动检测的组件提供域" class="headerlink" title="为自动检测的组件提供域"></a>为自动检测的组件提供域</h2><hr>
<p>与Spring管理的组件一样，自动检测组件的默认和最常见的域是singleton。但是，有时你需要一个不同的域，这时你可以通过@Scope注解来制定。只要在注解重提供域名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关Web特定域的详细信息，请参见第5.4节[“Request, session, global session, application和 WebSocket域”](#Request, session, global session, application和 WebSocket域)。</p>
<blockquote>
<p>要为域解析提供自定义策略，而不是依赖基于注解的方式，请实现ScopeMetadataResolver接口，并确保包含一个默认的无参构造方法。然后，在配置扫描器时提供完全限定的类名称：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">scope-resolver</span>=<span class="string">&quot;org.example.MyScopeResolver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当使用某些非单例域时，可能需要为作用域对象生成代理。原因在<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96">“作用域bean作为依赖”</a>一节中已经描述。为此，scoped-proxy属性可以在component-scan元素中使用。三个可能的值是：no，interfaces和targetClass。例如，以下配置将导致标准的JDK动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, scopedProxy = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">scoped-proxy</span>=<span class="string">&quot;interfaces&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用注解提供限定符元数据"><a href="#使用注解提供限定符元数据" class="headerlink" title="使用注解提供限定符元数据"></a>使用注解提供限定符元数据</h2><hr>
<p>@Qualifier注解已经在第7.9.4节<a href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E5%BE%AE%E8%B0%83%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">“使用限定符微调基于注解的自动装配”</a>。该部分中的示例演示了@Qualifier注解的使用以及在你解析自动装配候选者时使用自定义限定符注解来提供更细粒度的控制。因为这些示例基于XML bean定义，所以使用XML中的bean元素的qualifier或meta子元素在候选bean定义上提供了限定符元数据。当依赖类路径扫描来自动检测组件时，你可以在候选类上使用那个类型级别注解来提供限定符元数据。以下三个例子说明了这种技术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;Action&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre(&quot;Action&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Offline</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与大多数基于注解的替代方案一样，，请注意，注解元数据绑定到类定义本身，而使用XML允许同一类型的多个bean提供他们限定符元数据的变体，因为元数据是为每个实例，而不是每个类提供的。</p>
</blockquote>
<hr>
<h1 id="使用JSR-330标准注解"><a href="#使用JSR-330标准注解" class="headerlink" title="使用JSR 330标准注解"></a>使用JSR 330标准注解</h1><hr>
<hr>
<h1 id="基于Java的容器配置"><a href="#基于Java的容器配置" class="headerlink" title="基于Java的容器配置"></a>基于Java的容器配置</h1><hr>
<h2 id="基本概念：-Bean-和-Configuration"><a href="#基本概念：-Bean-和-Configuration" class="headerlink" title="基本概念：@Bean 和@Configuration"></a>基本概念：@Bean 和@Configuration</h2><hr>
<p>Spring的新Java配置支持中的中心构件是**@Configuration<strong>注解的类和</strong>@Bean<strong>注解的方法。<br><strong>@Bean</strong>注解用于表示一个方法实例化，配置和初始化一个新的对象，以便由Spring IoC容器管理。对于那些熟悉Spring的</strong>&lt;beans &#x2F;&gt;** XML配置的人来说，**@Bean<strong>注解和</strong>&lt;beans &#x2F;&gt;<strong>元素具有相同的作用。你可以对任何Spring @Component使用</strong>@Bean<strong>注解方法，但是，它们通常与</strong>@Configuration** bean一起使用。<br>用**@Configuration<strong>注解一个类的主要目的是表明它是作为bean定义的来源。此外，</strong>@Configuration<strong>类允许通过简单地调用同一个类中的其他</strong>@Bean<strong>方法来定义bean之间依赖关系。可能最简单的</strong>@Configuration**类将如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的AppConfig类将等同于以下Spring <strong>&lt;beans &#x2F;&gt;</strong> XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">全@Configuration vs 'lite'@Bean模式<br/>当**@Bean**方法在没有使用@Configuration的类注解中声明时，它们被称为在'lite'模式下处理。例如，在**@Component**中甚至在普通的旧的类中声明的bean方法将被视为'lite'。<br/>与完整的**@Configuration**不同，lite @Bean方法不能轻松声明bean间依赖关系。在'lite'模式下运行时，通常一个@Bean方法不应该调用另一个@Bean方法。<br/>仅在**@Configuration**类中使用@Bean方法是确保始终使用“完整”模式的推荐方法。这将防止相同的**@Bean**方法被意外调用多次，并有助于减少在'精简'模式下操作时难以追踪的细微错误。</div>
**@Bean**和**@Configuration**注解将在下面的章节中深入讨论。首先，我们将介绍使用基于Java的配置创建Spring容器的各种方法。

<h2 id="使用AnnotationConfigApplicationContext实例化Spring容器"><a href="#使用AnnotationConfigApplicationContext实例化Spring容器" class="headerlink" title="使用AnnotationConfigApplicationContext实例化Spring容器"></a>使用AnnotationConfigApplicationContext实例化Spring容器</h2><hr>
<p>下面的章节介绍Spring的AnnotationConfigApplicationContext，这是Spring 3.0中的新功能。这个多功能的ApplicationContext实现不仅可以接受@Configuration类作为输入，还可以接受@Component类以及用JSR-330元数据注解的普通类。<br>当提供@Configuration类作为输入时，@Configuration类本身被注册为一个bean定义，并且该类中所有声明的@Bean方法也被注册为bean定义。<br>当提供@Component和JSR-330类时，它们被注册为bean定义，并且假定在必要时在这些类中使用DI元数据（例如@Autowired或@Inject）。</p>
<h2 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h2><p>与使用Spring XML文件作为实例化ClassPathXmlApplicationContext的输入的方式类似，@Configuration类可用作实例化AnnotationConfigApplicationContext的输入。这允许完全无XML地使用Spring容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所述，AnnotationConfigApplicationContext不仅限与@Configuration类一起使用。任何@Component或JSR-330注解类都可作为输入提供给构造函数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面假设MyServiceImpl，Dependency1和Dependency2使用Spring依赖注入注解，例如@Autowired。</p>
<h2 id="使用register-Class-lt-gt-…-编程式构建容器"><a href="#使用register-Class-lt-gt-…-编程式构建容器" class="headerlink" title="使用register(Class&lt;?&gt;…)编程式构建容器"></a>使用register(Class&lt;?&gt;…)编程式构建容器</h2><p>AnnotationConfigApplicationContext可以使用无参数构造函数实例化，然后使用register（）方法进行配置。以编程方式构建AnnotationConfigApplicationContext时，此方法特别有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用scan-String…​-启用组件扫描"><a href="#使用scan-String…​-启用组件扫描" class="headerlink" title="使用scan(String…​)启用组件扫描"></a>使用scan(String…​)启用组件扫描</h2><p>要启用组件扫描，只需注解您的@Configuration类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有经验的Spring用户会熟悉Spring的XML声明congtenx：namespace</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.acme&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将扫描com.acme包，查找任何@ Component注解的类，并且这些类将在容器中注册为Spring bean定义。AnnotationConfigApplicationContext公开scan(String …)方法以允许使用相同的组件扫描功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请记住@Configuration类是使用@Component进行元注解的，所以它们是组件扫描的候选对象！在上面的例子中，假设AppConfig是在com.acme包（或下面的任何包）中声明的，它将在调用scan())期间被拾取，并且在refresh())后，处理其所有的@Bean方法，在容器中注册为bean定义。</p>
</blockquote>
<h2 id="使用AnnotationConfigWebApplicationContext支持Web应用程序"><a href="#使用AnnotationConfigWebApplicationContext支持Web应用程序" class="headerlink" title="使用AnnotationConfigWebApplicationContext支持Web应用程序"></a>使用AnnotationConfigWebApplicationContext支持Web应用程序</h2><p>AnnotationConfigApplicationContext的WebApplicationContext变体可与AnnotationConfigWebApplicationContext一起使用。在配置Spring ContextLoaderListener servlet侦听器，Spring MVC DispatcherServlet等时，可以使用此实现。接下来是配置典型Spring MVC Web应用程序的web.xml片段。请注意contextClass context-param和init-param的使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置ContextLoaderListener以使用AnnotationConfigWebApplicationContext         </span></span><br><span class="line"><span class="comment">    而不是默认的XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置的位置必须包含一个或多个都好或空格分隔的</span></span><br><span class="line"><span class="comment">    完全限定的@Configuration类。完全限定包也可以指定为扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 像往常一样使用ContextLoaderListener引导根应用程序上下文 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 照常声明一个Spring MVC DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置DispatcherServlet以使用AnnotationConfigWebApplicationContext             </span></span><br><span class="line"><span class="comment">        而不是默认的XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--同样，配置位置必须包含一个或多个以逗号或空格分隔的位置            </span></span><br><span class="line"><span class="comment">         和完全限定的@Configuration类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将/ app / *的所有请求映射到调度servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-Bean注解"><a href="#使用-Bean注解" class="headerlink" title="使用@Bean注解"></a>使用@Bean注解</h2><hr>
<p>@Bean是一个方法级别的注解，并且等同XML &lt;bean &#x2F;&gt;元素的。注解支持&lt;bean &#x2F;&gt;提供的一些属性，例如：init-method，destroy-method，autowiring和name。<br>您可以在带有@ Configuration注解或带有@ Component注解的类中使用@Bean注解。</p>
<h3 id="声明一个bean"><a href="#声明一个bean" class="headerlink" title="声明一个bean"></a>声明一个bean</h3><p>要声明一个bean，只需使用@Bean注解来注解一个方法即可。您可以使用此方法在指定为方法返回值的类型的ApplicationContext中注册bean定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置完全等同于以下Spring XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个声明都在ApplicationContext中创建一个名为transferService的bean，绑定到TransferServiceImpl类型的对象实例：<br>transferService - &gt; com.acme.TransferServiceImpl</p>
<h3 id="Bean依赖"><a href="#Bean依赖" class="headerlink" title="Bean依赖"></a>Bean依赖</h3><p>@Bean注解的方法可以有任意数量的参数来描述构建bean所需的依赖项。例如，如果我们的TransferService需要一个AccountRepository，我们可以通过一个方法参数实现这个依赖关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析机制与基于构造函数的依赖注入非常相似，请参阅相关部分以获取更多详细信息。</p>
<h3 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h3><p>任何使用@Bean注解定义的类都支持常规生命周期回调，并且可以使用JSR-250中的@PostConstruct和@PreDestroy注解，请参阅JSR-250注释以获取更多详细信息。<br>常规的Spring生命周期回调也被完全支持。如果一个bean实现了InitializingBean，DisposableBean或Lifecycle，那么它们各自的方法由容器调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，Java配置定义的bean如果具有公共的close或shutdown方法，会被自动列入销毁回调。如果你有一个公共的close或shutdown方法，并且你不希望在容器关闭时调用它，只需在你的bean定义中添加@Bean(destroyMethod &#x3D;“”)来禁用默认（推断）模式。<br>您可能希望为通过JNDI获取的资源默认执行此操作，因为其生命周期在应用程序外部进行管理。特别是，确保始终为DataSource执行此操作，因为它已知在Java EE应用程序服务器上存在问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="string">&quot;MyDS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，使用@Bean方法，通常会选择使用编程式JNDI查找：使用Spring的JndiTemplate &#x2F; JndiLocatorDelegate帮助程序或直接使用JNDI InitialContext，但不使用JndiObjectFactoryBean变体，这会强制您将返回类型声明为FactoryBean类型，而不是实际的目标类型，使其更难用于其他@Bean方法中的交叉引用调用，这些方法打算引用所提供的资源</p>
<p>当然，就上面的Foo而言，在构造过程中直接调用init()方法同样有效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">        foo.init();</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当您直接使用Java进行工作时，您可以对您的对象执行任何您喜欢的操作，并且不总是需要依赖容器生命周期！</p>
</blockquote>
<h3 id="指定bean域"><a href="#指定bean域" class="headerlink" title="指定bean域"></a>指定bean域</h3><h4 id="使用-Scope注解"><a href="#使用-Scope注解" class="headerlink" title="使用@Scope注解"></a>使用@Scope注解</h4><p>您可以指定使用@Bean注解定义的bean应该具有特定的作用域。您可以使用Bean Scopes部分中指定的任何标准域。<br>默认域是singleton，但您可以使用@Scope注解覆盖它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Encryptor <span class="title function_">encryptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Scope和域代理"><a href="#Scope和域代理" class="headerlink" title="@Scope和域代理"></a>@Scope和域代理</h4><p>Spring提供了一种通过作用域代理来处理作用域依赖关系的便捷方式。使用XML配置时创建此类代理的最简单方法是&lt;aop:scoped-proxy &#x2F;&gt;元素。使用@Scope注解在Java中配置你的bean提供了与proxyMode属性等效的支持。默认值是无代理（ScopedProxyMode.NO），但您可以指定ScopedProxyMode.TARGET_CLASS或ScopedProxyMode.INTERFACES。<br>如果您使用Java将域代理示例从XML参考文档（请参阅前面的链接）移植到我们的@Bean，它将如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> UserPreferences <span class="title function_">userPreferences</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserPreferences</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Service <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUserService</span>();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义bean命名"><a href="#自定义bean命名" class="headerlink" title="自定义bean命名"></a>自定义bean命名</h3><p>默认情况下，配置类使用@Bean方法的名称作为结果bean的名称。但是，可以使用name属性覆盖此功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myFoo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bean别名"><a href="#bean别名" class="headerlink" title="bean别名"></a>bean别名</h3><p>正如第7.3.1节“命名bean”中所讨论的，有时需要给单个bean多个名称，称为bean别名。 @Bean注解的name属性为此接受一个String数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &#123; &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bean描述"><a href="#bean描述" class="headerlink" title="bean描述"></a>bean描述</h3><p>有时候提供一个更详细的bean的文本描述是有帮助的。当bean暴露（可能通过JMX）用于监视目的时，这可能特别有用。<br>要将描述添加到@Bean，可以使用@Description注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description(&quot;Provides a basic example of a bean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-configuration注解"><a href="#使用-configuration注解" class="headerlink" title="使用@configuration注解"></a>使用@configuration注解</h2><hr>
<p>@Configuration是一个类级注解，指示一个对象是一个bean定义的来源。 @Configuration类通过public @Bean注解方法声明bean。调用@Configuration类上的@Bean方法也可以用来定义bean间的依赖关系。</p>
<h3 id="注入bean间依赖关系"><a href="#注入bean间依赖关系" class="headerlink" title="注入bean间依赖关系"></a>注入bean间依赖关系</h3><p>当@Beans彼此依赖时，表达这种依赖就如同一个bean方法调用另一个一样简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，foo bean通过构造函数注入接收对bar的引用。</p>
<blockquote>
<p>这种声明bean间依赖关系的方法只有在@Configuration类中声明@Bean方法时才起作用。你不能用简单的@Component类来声明bean间的依赖关系。</p>
</blockquote>
<h3 id="lookup方法注入"><a href="#lookup方法注入" class="headerlink" title="lookup方法注入"></a>lookup方法注入</h3><p>如前所述，lookup方法注入是一种您很少使用的高级功能。在单例范围的bean对原型范围的bean具有依赖关系的情况下，它很有用。对这种类型的配置使用Java提供了实现这种模式的自然方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取适当的Command接口的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新的）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//好的...但这个方法的实现在哪里？</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Java配置支持，您可以创建CommandManager的子类，其中抽象的createCommand（）方法被重写，以便查找新的（原型）命令对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AsyncCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandManager <span class="title function_">commandManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span></span><br><span class="line">    <span class="comment">// to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandManager</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有关基于Java的配置如何在内部工作的更多信息"><a href="#有关基于Java的配置如何在内部工作的更多信息" class="headerlink" title="有关基于Java的配置如何在内部工作的更多信息"></a>有关基于Java的配置如何在内部工作的更多信息</h3><p>以下示例显示了一个被调用两次的@Bean注解方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">clientService1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClientServiceImpl</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">clientService2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClientServiceImpl</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientDao <span class="title function_">clientDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientDao（）在clientService1（）中被调用一次，在clientService2（）中被调用一次。由于此方法创建ClientDaoImpl的新实例并将其返回，因此通常期望拥有2个实例（每个服务一个实例）。这肯定会有问题：在Spring中，实例化的bean默认为<strong>singletion</strong>作用域。这就是神奇的地方：所有@Configuration类在启动时都使用CGLIB进行子类化。在子类中，child方法在调用父方法并创建新实例之前首先检查容器是否有缓存的（域）Bean。请注意，从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已在org.springframework.cglib下重新打包，并直接包含在Spring-Core JAR中。</p>
<blockquote>
<p>根据您的bean的域，行为可能会有所不同。我们在这里讨论singleton。</p>
</blockquote>
<blockquote>
<p>由于CGLIB在启动时动态添加功能，因此存在一些限制，特别是配置类不能是最终的。但是，从4.3开始，任何构造函数都可以在配置类上使用，包括对默认注入使用@Autowired或单个非默认构造函数声明。 如果您希望避免任何CGLIB限制，请考虑在非@配置类上声明您的@Bean方法，例如而是使用简单的@Component类。 @Bean方法之间的跨方法调用不会被拦截，因此您必须在构造方法或方法级别专门依赖依赖注入。</p>
</blockquote>
<h2 id="撰写基于Java的配置"><a href="#撰写基于Java的配置" class="headerlink" title="撰写基于Java的配置"></a>撰写基于Java的配置</h2><hr>
<h3 id="使用-Import注解"><a href="#使用-Import注解" class="headerlink" title="使用@Import注解"></a>使用@Import注解</h3><p>就像在Spring XML文件中使用&lt;import &#x2F;&gt;元素以帮助模块化配置一样，@Import注解允许从另一个配置类加载@Bean定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只需要显式提供ConfigB：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在beanA和B将可用...</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> ctx.getBean(A.class);</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法简化了容器实例化，因为只有一个类需要处理，而不需要开发人员在构建过程中记住大量的@Configuration类。</p>
<blockquote>
<p>从Spring Framework 4.2开始，@Import还支持对常规组件类的引用，类似于AnnotationConfigApplicationContext.register方法。如果您想要避免组件扫描，使用几个配置类作为明确定义所有组件的入口点，这特别有用。</p>
</blockquote>
<h3 id="注入对导入的-Bean定义的依赖关系"><a href="#注入对导入的-Bean定义的依赖关系" class="headerlink" title="注入对导入的@Bean定义的依赖关系"></a>注入对导入的@Bean定义的依赖关系</h3><p>上面的例子很简单。在大多数实际场景中，bean会存在跨配置类之间彼此的依赖。当使用XML时，这本身并不是一个问题，因为不涉及编译器，并且可以简单地声明ref &#x3D;”someBean”并相信Spring将在容器初始化期间解决它。当然，在使用@Configuration类时，Java编译器会对配置模型施加约束，因为对其他bean的引用必须是有效的Java语法。<br>幸运的是，解决这个问题很简单。正如我们已经讨论过的，@Bean方法可以有任意数量的描述bean依赖关系的参数。让我们考虑一个更现实的场景，其中有几个@Configuration类，每个类都依赖于其他类中声明的bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// 一切都通过配置类连接起来......</span></span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种方法可以实现相同的结果。请记住@Configuration类最终只是容器中的另一个bean：这意味着它们可以像任何其他bean一样利用@Autowired和@Value注入等等！</p>
<blockquote>
<p>确保以这种方式注入的依赖关系只有最简单的类型。 @Configuration类在上下文初始化期间处理得相当早，并强制依赖性以这种方式注入可能会导致意外的早期初始化。在可能的情况下，采用基于参数的注入，如上例所示。<br>此外，通过@Bean特别小心BeanPostProcessor和BeanFactoryPostProcessor定义。这些通常应该声明为静态的@Bean方法，而不是触发其包含的配置类的实例化。否则，@Autowired和@Value将不能在配置类本身上工作，因为它太早创建为bean实例。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RepositoryConfig</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Configuration类中的构造函数注入仅在Spring Framework 4.3中受支持。另请注意，如果目标bean只定义一个构造函数，则不需要指定@Autowired;在上面的例子中，RepositoryConfig构造函数不需要@Autowired。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
