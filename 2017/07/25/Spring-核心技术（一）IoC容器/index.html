<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="strong {     margin: 2px;     background-color: #f2f2f2;     border: 1px solid #ccc;     border-radius: 4px;     padding: 1px 3px 0;     text-shadow: none;     white-space: nowrap;     color: #6d180b">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 核心技术（一）IoC容器">
<meta property="og:url" content="http://yoursite.com/2017/07/25/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89IoC%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="अरण्य">
<meta property="og:description" content="strong {     margin: 2px;     background-color: #f2f2f2;     border: 1px solid #ccc;     border-radius: 4px;     padding: 1px 3px 0;     text-shadow: none;     white-space: nowrap;     color: #6d180b">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/spring/container-magic.png.pagespeed.ce.-0JjaOG5As.png">
<meta property="og:image" content="http://yoursite.com/images/spring/singleton.png.pagespeed.ce.U0lSEQUK39.png">
<meta property="og:image" content="http://yoursite.com/images/spring/prototype.png">
<meta property="article:published_time" content="2017-07-25T13:17:00.000Z">
<meta property="article:modified_time" content="2022-07-05T03:30:52.827Z">
<meta property="article:author" content="不识">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/spring/container-magic.png.pagespeed.ce.-0JjaOG5As.png">

<link rel="canonical" href="http://yoursite.com/2017/07/25/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89IoC%E5%AE%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring 核心技术（一）IoC容器 | अरण्य</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">अरण्य</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此曰无诤，又名空静</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/25/Spring-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89IoC%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="不识">
      <meta itemprop="description" content="初心未终，此道可成">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="अरण्य">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring 核心技术（一）IoC容器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-25 21:17:00" itemprop="dateCreated datePublished" datetime="2017-07-25T21:17:00+08:00">2017-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-05 11:30:52" itemprop="dateModified" datetime="2022-07-05T11:30:52+08:00">2022-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <style>
strong {
    margin: 2px;
    background-color: #f2f2f2;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 1px 3px 0;
    text-shadow: none;
    white-space: nowrap;
    color: #6d180b;
    font-weight: normal;
}
</style>

<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#beans">原文链接</a></p>
<hr>
<h1 id="Spring-IoC容器和bean介绍"><a href="#Spring-IoC容器和bean介绍" class="headerlink" title="Spring IoC容器和bean介绍"></a>Spring IoC容器和bean介绍</h1><hr>
<p>本章涵盖了控制反转-<em>Inversion of Control</em>  （IoC）原理的Spring框架实现。IoC也被称为依赖注入-<em>dependency injection</em> （DI）。它是一个通过对象定义它们的依赖项（也就是它们使用的其他对象）的过程，这些依赖只能通过构造方法参数、工厂方法的参数，或者已经被构建或由工厂方法返回的对象实例上设置的属性这些形式。然后，容器在创建bean时注入这些依赖项。这个过程从根本上反转了bean本身通过直接构造类，或者使用一个如Service Locator模式的机制对依赖实例化或定位的控制，因此命名控制反转（IoC）。</p>
<span id="more"></span>
<p><strong>org.springframework.beans</strong>和<strong>org.springframework.context</strong>包是Spring框架IoC容器的基础。<strong>BeanFactory</strong>接口提供了一个能够管理任何类型对象的高级配置机制。<strong>ApplicationContext</strong>是<strong>BeanFactory</strong>的一个子接口。它添加与Spring AOP功能的简单集成；消息资源处理（在国际化中使用），事件发布；以及应用层特定的上下文，例如用于Web应用程序的<strong>WebApplicationContext</strong>。</p>
<p>简而言之，<strong>BeanFactory</strong>提供配置框架和基本功能，<strong>ApplicationContext</strong>添加了更多的企业特定功能。<strong>ApplicationContext</strong>是<strong>BeanFactory</strong>的完整超集,本章仅用于Spring的IoC容器的描述。有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅第7.16节“BeanFactory”。</p>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean简单只是应用程序中的许多对象之一。Bean以及bean之间的依赖关系反映在容器使用的配置元数据中。</p>
<hr>
<h1 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h1><hr>
<p><strong>org.springframework.context.ApplicationContext</strong>接口表示Spring IoC容器，并且负责实例化，配置和组装上述的bean。容器通过读取配置元数据获取有关实例化，配置和组装的对象的说明。配置元数据用XML，Java注解或Java代码表示。它允许你表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring还提供了<strong>ApplicationContext</strong>接口的几个实现。在独立应用程序中，通常创建一个<strong>ClassPathXmlApplicationContext</strong>或<strong>FileSystemXmlApplicationContext</strong>的实例。虽然XML已经成为定义配置元数据的惯用格式，但你还可以指示容器使用Java注解或代码作为元数据格式，只需要通过提供少量的XML配置来声明开启对这些额外元数据格式的支持。</p>
<p>在大多数应用程序场景中，实例化一个或多个Spring IoC容器的实例不需要显式的用户代码。比如，在一个web应用程序情景中，在应用程序的web.xml文件中的一个简单的八行（或更多）的样板web描述XML通常就足够了（查看“Web应用程序的便捷ApplicationContext实例化”）。如果你使用Spring Tool Suite Eclipse-powered开发环境，则可以通过鼠标点击或击键轻松创建该样板设置。</p>
<p>下图是Spring如何工作的高级视图。你的应用程序类与配置元数据相结合，以便在创建和初始化<strong>ApplicationContext</strong>之后，有一个完全配置和可执行的系统或应用程序。<br><img src="/images/spring/container-magic.png.pagespeed.ce.-0JjaOG5As.png" alt="Spring IoC容器"></p>
<h2 id="配置元数据"><a href="#配置元数据" class="headerlink" title="配置元数据"></a>配置元数据</h2><hr>
<p>如前面的图标所展示，Spring IoC容器消耗一种形式的配置元数据；这个配置元数据表示作为应用程序开发者如何告诉Spring容器去实例化，配置并且组装你程序中的对象。</p>
<p>配置元数据传统上由一个简单且直观的XML格式提供，这是本章用来传达Spring IoC容器的关键概念和特性大多数使用的方式。</p>
<blockquote>
<p>基于XML的元数据不是唯一允许的配置元数据形式。Spring IoC容器本身与实际写入此配置元数据的格式完全分离。近来，很多开发人员为他们的Spring应用程序选择基于Java的配置。</p>
</blockquote>
<p>有关使用Spring容器的其他形式的元数据的信息，请参阅：</p>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">基于注解的配置</a>：Spring 2.5引入了基于注解的配置元数据的支持。</li>
<li><a href="#%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">基于Java的配置</a>：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring框架的一部分。因此，你可以使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新功能，请参阅@Configuration，@Bean，@Import和@DependsOn注解。</li>
</ul>
<p>Spring配置由必须是容器管理的一个但通常是多个bean定义组成。基于XML的配置元数据在顶级元素**&lt;beans&#x2F;&gt;<strong>内展示这些配置为</strong>&lt;bean&#x2F;&gt;<strong>元素的bean。基于Java配置通常在</strong>@Configuration<strong>类中使用</strong>@Bean**注解。</p>
<p>这些bean定义对应于构成应用程序的实际对象。通常，你定义服务层对象，数据访问对象（DAO），表示对象（如Struts Action实例），基础架构对象（如Hibernate SessionFactories，JMS Queues等）。通常，在容器中不配置细粒度的域对象，因为通常由DAO和业务逻辑来负责创建和加载这些域对象。但是，你可以使用Spring与AspectJ的集成来配置在IoC容器的控制之外创建的对象。请参阅<a href="">使用AspectJ对Spring进行依赖注入域对象</a>。</p>
<p>以下示例显示了基于XML的配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更多的bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>id</strong>属性是用于标识单个bean定义的字符串。<strong>class</strong>属性定义bean的类型，并使用完全限定的类名。id属性的值指的是相互协作的对象。引用协作对象的XML在此示例中没有展示;有关详细信息，请参阅<a href="#%E4%BE%9D%E8%B5%96">依赖</a>。</p>
<h2 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h2><hr>
<p>实例化一个Spring IoC容器是直观的。提供给<strong>ApplicationContext</strong>构造方法的本地路径或路径上是实际资源字符串，这允许容器从各种外部资源（如本地文件系统），或从从Java <strong>CLASSPATH</strong>等中加载配置元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在了解Spring的IoC容器之后，你可能想要了解更多有关Spring Resource抽象的信息，如“<a href="">资源</a>“中所述，它提供了一种从URI语法中定义的位置读取InputStream的便捷机制。特别地，Resource路径用于构建应用程序上下文，如第8.7节“<a href="">应用程序上下文和资源路径</a>“中所述。</p>
</blockquote>
<p>下面示例展示了服务层对象（<strong>services.xml</strong>）配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;petStore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service的更多bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面示例展示了数据访问对象<strong>dao.xml</strong>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的额外协作者和配置到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的额外协作者和配置到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据访问对象的更多bean定义到这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，服务层由类PetStoreServiceImpl和两个数据访问对象类型为JpaAccountDao和JpaItemDao（基于JPA对象&#x2F;关系映射标准）组成。<strong>property name</strong>元素是指JavaBean属性（property）的名称，而<strong>ref</strong>元素是指另一个bean定义的名称。<strong>id</strong>和<strong>ref</strong>元素之间的这种链接表示协作对象之间的依赖关系。有关配置对象的依赖关系的详细信息，请参阅<a href="">依赖</a>。</p>
<h3 id="编写基于XML的配置元数据"><a href="#编写基于XML的配置元数据" class="headerlink" title="编写基于XML的配置元数据"></a>编写基于XML的配置元数据</h3><p>让bean定义分布在多个XML文件中是有意义的。每个单独的XML配置文件通常表示你的体系结构中的逻辑层或模块。</p>
<p>你可以使用<strong>ApplicationContext</strong>构造方法从所有这些XML片段中加载bean定义。如上一节所示那样，构造方法接收多个<strong>Resource</strong>位置。或者，使用一个或多个**&lt;import &#x2F;&gt;**元素从其他文件加载bean定义。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，外部定义的bean从三个文件中加载：<strong>services.xml</strong>，<strong>messageSource.xml</strong>和<strong>themeSource.xml</strong>。所有的位置路径是相对于执行导入操作的定义文件路径，所以<strong>services.xml</strong>必须与执行导入文件在相同的目录或类路径位置下，而<strong>messageSource.xml</strong>和<strong>themeSource.xml</strong>必须位于执行导入文件位置下的resources位置中。<font color= "#1469b3">如你所见，前置的斜杠被忽略，但是鉴于这些路径都是相对的，所以最好不要使用斜杠</font>。被导入文件的内容包括顶级**&lt;beans&#x2F;&gt;**元素,它必须是依据Spring Schema的有效XML bean定义文件。</p>
<blockquote>
<p>这是可行，但是不推荐使用一个相对”..&#x2F;“路径引用上级目录的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，这个引用不推荐用于“classpath：”URL（例如“classpath：..&#x2F; services.xml”），运行时解析过程选择“最近”根类路径，然后再查看其父目录。Classpath配置的更改可能会导致选择一个不同的，不正确的目录。<br>你可以一直使用完全限定的资源位置而不是相对路径：比如， “file:C:&#x2F;config&#x2F;services.xml” 或 “classpath:&#x2F;config&#x2F;services.xml”。然而，请注意，你将应用程序的配置与特定的绝对位置相耦合在一起。通常最好与这些绝对路径保持一个间接关联，比如，通过 “${…}” 占位符在运行时期解析JVM系统属性</p>
</blockquote>
<p>import指令是由<strong>beans</strong>命名空间本身提供的一个功能。Spring提供的一些XML命名空间中可以使用除纯bean定义之外的更多配置功能，例如。 **“context”<strong>和</strong>“util”**命名空间。</p>
<h3 id="Groovy-Bean定义DSL"><a href="#Groovy-Bean定义DSL" class="headerlink" title="Groovy Bean定义DSL"></a>Groovy Bean定义DSL</h3><p>作为外部配置元数据的另一个例子，bean定义也可以在Spring的Groovy Bean Definition DSL中表示，如Grails框架所知。通常，这种配置将存在一个“.groovy”文件中，结构如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName = <span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span></span><br><span class="line">        url = <span class="string">&quot;jdbc:hsqldb:mem:grailsDB&quot;</span></span><br><span class="line">        username = <span class="string">&quot;sa&quot;</span></span><br><span class="line">        password = <span class="string">&quot;&quot;</span></span><br><span class="line">        settings = [<span class="attr">mynew:</span><span class="string">&quot;setting&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource = dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种配置风格在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。它还允许通过“importBeans”指令导入XML bean定义文件。</p>
<h2 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h2><hr>
<p><strong>ApplicationContext</strong>是能够维护不同bean和它们的依赖关系的注册表的高级工厂的接口。使用**T getBean(String name, Class&lt;T&gt; requiredType)**方法你可以检索你的bean实例。</p>
<p><strong>ApplicationContext</strong>使你能够读取bean定义并访问它们，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并配置bean</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置实例</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置实例</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>
<p>使用Groovy配置，引导看起来非常相似，只是一个不同的上下文实现类，它是Groovy感知的（但也可以理解XML bean定义）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericGroovyApplicationContext</span>(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>最灵活的变体是<strong>GenericApplicationContext</strong>与<strong>reader</strong>委托组合，例如与XML文件的<strong>XmlBeanDefinitionReader</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>或者为Groovy文件使用<strong>GroovyBeanDefinitionReader</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>这样的reader委托可以在相同的<strong>ApplicationContext</strong>中进行混合和匹配，从不同的配置源读取bean定义，如果需要的话。</p>
<p>然后你可以使用<strong>getBean</strong>来获取你的bean实例。<strong>ApplicationContext</strong>接口还有其他一些获取bean的方法，但理想情况下你的应用程序代码应该从不会使用到它们。实际上，你的应用程序代码根本不应该调用**getBean()**方法，因此根本不需要依赖Spring API。例如，Spring与Web框架的集成为各种Web框架组件（如controller和JSF-managed bean）提供依赖注入，允许你在指定bean上通过元数据声明一个依赖（例如自动装配注解）</p>
<hr>
<h1 id="Bean概述"><a href="#Bean概述" class="headerlink" title="Bean概述"></a>Bean概述</h1><hr>
<p>Spring IoC容器管理一个或多个bean。这些bean是使用你提供给容器的配置元数据创建的，例如，以XML **&lt;bean &#x2F;&gt;**定义的形式。</p>
<p>在容器本身内，这些bean定义以<strong>BeanDefinition</strong>对象表示，它包含了以下元数据（以及其他信息）：</p>
<ul>
<li>一个包完全限定类名称：通常是要定义的bean的实际实现类。</li>
<li>Bean行为配置元素，它说明bean应该在容器（作用域，生命周期回调等）中的行为。</li>
<li>这个bean工作所需引用的其他bean；这些引用也被称为协作者或依赖。</li>
<li>在新创建的对象中设置其他配置设置，例如，在管理连接池的bean中使用的连接数，或池的大小限制。</li>
</ul>
<p>该元数据转换为组成每个bean定义的一组属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释…</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>3.2<a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96bean">“实例化bean”</a></td>
</tr>
<tr>
<td>name</td>
<td>3.1<a href="#%E5%91%BD%E5%90%8Dbean">“命名bean”</a></td>
</tr>
<tr>
<td>scope</td>
<td>5 <a href="#Bean%E5%9F%9F">“Bean域”</a></td>
</tr>
<tr>
<td>constructor arguments</td>
<td>4.1<a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“依赖注入”</a></td>
</tr>
<tr>
<td>properties</td>
<td>4.1<a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“依赖注入”</a></td>
</tr>
<tr>
<td>autowiring mode</td>
<td>4.5<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">“自动装配协作者”</a></td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>4.4<a href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96bean">“延迟初始化bean”</a></td>
</tr>
<tr>
<td>initialization method</td>
<td>6.11<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83">“初始化回调”</a></td>
</tr>
<tr>
<td>destruction method</td>
<td>6.12 <a href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83">“销毁回调”</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定bean的信息的bean定义之外，<strong>ApplicationContext</strong>的实现还允许用户注册在容器外创建的现有对象。这是通过访问ApplicationContext的<strong>getBeanFactory()<strong>方法获取BeanFatory，这个方法返回BeanFactory的实现</strong>DefaultListableBeanFactory</strong>。<strong>DefaultListableBeanFactory</strong>通过**registerSingleton(..)**和 **registerBeanDefinition(..)**方法支持这种注册。然而，通常应用程序仅使用通过元数据bean定义定义的bean。</p>
<blockquote>
<p>Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他内省步骤期间正确地推断它们。然而在某种程度上也支持覆盖已有的元数据和单例实例，在运行时期新的bean注册（同时实时访问工厂）是不被正式支持的，并且可能导致bean容器中的并发访问异常和&#x2F;或不一致的状态。</p>
</blockquote>
<h2 id="命名bean"><a href="#命名bean" class="headerlink" title="命名bean"></a>命名bean</h2><hr>
<p>每个bean都有一个或多个标识符。这些标识符在托管该bean的容器中必须是唯一的。一个bean通常只有一个标识符，但是如果它需要不止一个的话，额外的可以被认为是别名。</p>
<p>在基于XML配置元数据，你使用<strong>id</strong>和&#x2F;或<strong>name</strong>属性来指定bean的标识符。<strong>id</strong>属性允许你指定一个id。通常这些名称是字母数字（’myBean’，’fooService’等），但也可能包含特殊的字符。如果你想要向bean引入其他别名，你可以在<strong>name</strong>属性中指定它们，并用逗号（**,<strong>），分号（</strong>;<strong>）或</strong>空白<strong>来分隔。作为一个历史说明，在Spring 3.1之前的版本中，</strong>id<strong>属性被定义为一个</strong>xsd:ID<strong>类型，它限制了可能的字符。从3.1开始，它被定义为一个</strong>xsd:string**类型。注意容器依然强制bean id的唯一性，尽管不再通过XML解析。</p>
<p>你不需要为bean提供name或id。如果没有明确提供name或id，容器将为该bean生成唯一的名称。但是，如果要通过名称引用该bean，通过使用<strong>ref</strong>元素或 Service Locator样式查找，你必须提供一个名称。如果不提供名称，则可能与使用 <a href="#%E5%86%85%E9%83%A8bean">内部bean</a>和<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">自动装配协作者</a>有关。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**bean命名惯例**   
命名bean时的惯例是使用标准Java用于实例字段命名的惯例。也就是，bean名称以一个小写字母开始，后面是是驼峰式命名。这样命名的示例是（不带引号）"accountManager"，"accountService"，"userDao"等等。      
一致的bean命名使你的配置更容易阅读和理解，并且如果你使用Spring AOP ，在通过名称将advice应用到到一组bean时，这会非常有帮助。
</div> 

<blockquote>
<p>在类路径中通过组件扫描，Spring会按照上述规则为未命名组件生成bean名称：实质上是采用简单类名称，并将它的第一个字母转换为小写。然而，在（异常）特殊情况下，如果有多个字符，并且第一个和第二个字符都是大写字母，则原始大写将被保留。这些与<strong>java.beans.Introspector.decapitalize</strong>（也是这里Spring使用的）定义的规则相同。</p>
</blockquote>
<h3 id="在bean定义外为bean起别名"><a href="#在bean定义外为bean起别名" class="headerlink" title="在bean定义外为bean起别名"></a>在bean定义外为bean起别名</h3><p>在bean定义本身中，你可以通过使用由<strong>id</strong>属性指定的最多一个名称和在<strong>name</strong>属性中任意数量的其他名称，组合来为bean提供多个名称。这些名称可以是同一个bean的等价别名，并且在一些情况下有用，例如允许一个应用程序中的每个组件通过使用指定给该组件本身的bean名称来引用一个公共依赖。</p>
<p>但是在实际定义bean的地方指定它的所有别名并不总是足够的。有时需要为一个在其他地方定义的bean引入一个别名。这在大型系统中通常会遇到，因为这样的系统的配置被分隔在每个子系统中，每一个子系统都有它自己的一系列对象定义。在基于XML的配置元数据中，你可以使用**&lt;alias&gt;**元素来完成此操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，在相同容器中一个名称为fromName的bean，也可能在使用这种别名定义后，以toName引用。</p>
<p>例如，子系统A的配置元数据可能通过名称<strong>subsystemA-dataSource</strong>引用一个DateSource。子系统B的配置元数据可能通过名称<strong>subsystemB-dataSource</strong>引用一个DateSource。当使用这两个子系统构成主程序，主程序通过名称<strong>myApp-dataSource</strong>引用这个<strong>DataSource</strong>。要使所有三个名称都引用相同的对象，你向MyApp配置元数据中添加以下别名定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;myApp-dataSource&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，每个组件和主应用程序可以通过唯一的名称来引用dataSource，并保证不会与任何其他定义（有效创建命名空间）冲突，但它们引用同一个bean。</p>
<blockquote>
<p>如果使用Java配置，可以使用**@Bean**注解来提供别名，详见第12.3节<a href="#%E4%BD%BF%E7%94%A8@Bean%E6%B3%A8%E8%A7%A3">“使用@Bean注解”</a>。</p>
</blockquote>
<h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><hr>
<p>bean定义本质上是创建一个或多个对象的配方。当询问时，容器会查看命名bean的配方，并使用由该bean定义封装的配置元数据创建（或获取）实际对象。</p>
<p>如果使用基于XML的配置元数据，则可以在**&lt;bean&#x2F;&gt;<strong>元素的</strong>class<strong>属性中指定要实例化的对象的类型（或类）。</strong>class<strong>属性（attribute），在内部是</strong>BeanDefinition<strong>实例上的</strong>Class<strong>属性（property），通常是强制必须的。你可以通过以下两种方式之一使用</strong>Class**属性：</p>
<ul>
<li>通常，在容器本身通过反射调用它的构造器直接创建bean的情况下，指定被构建的bean类，这与Java代码使用new操作符有些等同。</li>
<li>指定一个实际的类，它包含了会被调用来创建对象的静态工厂方法，在这种不常见的情况下，容器会在一个类上调用静态工厂方法来创建一个bean。从调用静态工厂方法返回的对象类型可能完全是同一个类或另一个类。</li>
</ul>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**内部类名称** 如果要为静态嵌套类配置bean定义，则必须使用嵌套类的二进制名称。    
比如，如果你在com.example包有一个类叫Foo，并且这个Foo类有一个静态嵌套类叫Bar，那么在bean定义上'class'的值会是...    
**com.example.Foo$Bar**
注意，在名称中使用**$**字符将外部类名称与嵌套类名称分隔开。
</div>

<h3 id="使用构造方法实例化"><a href="#使用构造方法实例化" class="headerlink" title="使用构造方法实例化"></a>使用构造方法实例化</h3><p>当通过构造方法方法创建一个bean时，所有普通类都可以使用并与Spring兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定方式编码。只需指定bean类即可。然而，根据为这个指定bean所使用的IoC类型，你可能需要一个默认（空）的构造方法。</p>
<p>Spring IoC容器几乎可以管理你想要管理的任何类;它不限于只管理真正的JavaBeans。大多数Spring用户喜欢实际的JavaBeans，它只有一个默认（无参）构造方法和容器中的属性（properties）之后建立适当的setter和getter。。你还可以在容器中有更多别样情调的非Bean风格的类。例如，如果你需要使用完全不遵守JavaBean规范的旧版连接池，那么Spring也可以管理它。</p>
<p>使用基于XML配置元数据，你可以如下指定你的bean类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于为构造方法提供参数（如果需要的话）和在对象构建后设置对象实例属性的机制更多的信息，参阅<a href="#%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96">“注入依赖”</a></p>
<h3 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h3><p>当你使用一个静态工厂方法创建一个bean定义，你使用<strong>class</strong>属性来指定包含这个静态工厂方法的类，并且使用一个名为<strong>factory-method</strong>的属性指定这个工厂方法本身。你应该可以调用此方法（随后可以使用可选参数），并返回一个活动对象，随后将其视为通过构造方法创建的对象。这种bean定义的一个用途是在旧代码中调用静态工厂。</p>
<p>下面的bean定义指定这个bean会被通过调用一个工厂方法来创建。这个定义没有指定返回对象的类型（类），只指定了包含此工厂方法的类。在这个例子中，**createInstance()**方法必须是静态方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关为工厂方法提供（可选）参数和从工厂返回对象后，设置对象实例属性机制的更多信息，参阅<a href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82">“依赖和配置细节”</a></p>
<h3 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h3><p>类似于通过静态工厂方法实例化，也可以使用一个实例工厂方法，调用容器中现有的bean的非静态方法来创建一个新的bean。要使用这种机制，使<strong>class</strong>属性为空，并且在 <strong>factory-bean</strong> 属性中指定当前（或父&#x2F;祖）容器中包含了要用来调用用于创建对象的实例方法的bean名称。使用 <strong>factory-method</strong> 属性设置工厂方法本身名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 工厂bean，其中包含一个名为createInstance()的方法， --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此定位器bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要通过工厂bean创建的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DefaultServiceLocator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个工厂类也可以有多个工厂方法，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此定位器bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DefaultServiceLocator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountService <span class="title function_">createAccountServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法表明，factory bean本身可以通过依赖注入（DI）进行管理和配置。详细信息请参见<a href="">“依赖和配置细节”</a>。</p>
<blockquote>
<p>在Spring文档中，factory bean是指在Spring容器中配置的bean，通过它的实例或静态工厂方法来创建对象。相比之下，<strong>FactoryBean</strong>（注意大写）是指一个Spring特定的<strong>FactoryBean</strong>。</p>
</blockquote>
<hr>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><hr>
<p>一个典型的企业应用程序不是由单个对象（或在Spring说法中是bean）组成的。即使是最简单的应用程序，也有几个对象共同合作，来展示最终用户看到的整体的应用程序。下节解释你如何定义一系列独立于一个完全实现的应用程序的bean定义，这样的应用程序对象互相协作完成一个目标。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><hr>
<p>依赖注入（DI）是一个通过对象定义它们依赖的过程，也就是它们使用的其他对象，这些依赖只能通过构造方法参数、工厂方法的参数，或者已经被构建或由工厂方法返回的对象实例上设置的属性这些形式。然后，容器在创建bean时注入这些依赖项。这个过程从根本上反转了bean本身通过直接构造类，或者使用一个如Service Locator模式的机制对依赖实例化或定位的控制，因此命名控制反转（IoC）。</p>
<p>使用DI原理，代码更加清晰，并且当提给供对象依赖项的时候，解耦更加有效。对象不查找其依赖关系，并且不知道依赖项的位置或类。因此，你的类变得更容易测试，特别是当依赖接口或抽象基类上时，它允许在单元测试中使用存根（实现接口，但方法体为空）或模拟实现。</p>
<p>DI存在两种主要的变体：<a href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">基于构造方法的依赖注入</a> 和 <a href="#%E5%9F%BA%E4%BA%8ESetter%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">基于Setter的依赖注入</a>。</p>
<h3 id="基于构造方法的依赖注入"><a href="#基于构造方法的依赖注入" class="headerlink" title="基于构造方法的依赖注入"></a>基于构造方法的依赖注入</h3><p>基于构造方法的DI通过容器调用有多个参数的构造方法完成，每个参数表示一个依赖项。这与调用一个有特定参数的静态工厂方法来构造bean几乎相当，并且这个讨论将传参给一个构造方法与传参给一个静态工厂方法视为类似的。以下示例显示一个只能使用构造器注入进行依赖注入的类。请注意，这个类没有什么特别之处，它是一个POJO，它不依赖于容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleMovieLister对MovieFinder有依赖关系</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个构造方法，使Spring容器可以注入一个MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略实际使用注入的MovieFinder的业务逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法参数解析"><a href="#构造方法参数解析" class="headerlink" title="构造方法参数解析"></a>构造方法参数解析</h4><p>使用参数的类型进行构造方法参数解析匹配。如果在bean定义的构造方法参数中不存在潜在的歧义，那么构造方法参数在bean定义中定义的顺序就是在bean被实例化时将这些参数提供给适当的构造方法的顺序。考虑以下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foo</span><span class="params">(Bar bar, Baz baz)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有潜在的歧义存在，假设<strong>Bar</strong>和<strong>Baz</strong>类没有继承关系。因此，以下配置工作正常，你不需要在**<constructor-arg />**元素中显式指定构造方法参数索引和&#x2F;或类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Baz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当引用另一个bean时，其类型是已知的，那么匹配正常（如前面的例子所示）。当使用一个简单类型，例如**&lt;value&gt;true&lt;&#x2F;value&gt;**时，在没有帮助的情况下Spring无法确定值的类型，因此无法通过类型匹配。考虑以下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算终极答案的年数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命，宇宙及一切的答案（银河漫游指南的梗）</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述情况下，如果使用<strong>type</strong>属性显式指定构造方法参数的类型，那么容器可以用简单类型执行类型匹配。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>index</strong>属性来明确指定构造方法参数的索引。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了解决多个简单值的歧义之外，指定索引可以解决构造方法具有两个相同类型参数的歧义。注意，索引从0开始。</p>
<p>你还可以使用构造方法参数名称为值消除歧义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请记住，为了使这种操作开箱即用，你的代码必须在启用调试标志的情况下进行编译，以便Spring可以从构造方法中查找参数名称。如果你无法使用调试标志（或不想）编译代码，则可以使用**@ConstructorProperties** JDK注解来明确命名构造方法参数。示例类必须如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于Setter的依赖注入"><a href="#基于Setter的依赖注入" class="headerlink" title="基于Setter的依赖注入"></a>基于Setter的依赖注入</h3><p>基于Setter的DI通过在调用无参数构造方法或无参数静态工厂方法来实例化bean之后，通过容器调用bean的setter方法来实现。</p>
<p>以下示例展示了一个类，它只能使用纯setter注入进行依赖注入。这个类是常规Java。它是一个POJO，它不依赖容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleMovieLister依赖MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个setter方法，使Spring容器可以注入一个MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略实际使用注入的MovieFinder的业务逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ApplicationContext</strong> 对于它管理的bean支持基于构造方法和基于setter的DI。在一些依赖已经通过构造方法方式注入后，它也支持基于setter的DI。你可以以<strong>BeanDefinition</strong>的形式配置依赖，它与<strong>PropertyEditor</strong>实例结合使用，以将属性从一种格式转换为另一种格式。然而，大多数Spring用户不直接使用这些类（即以编程方式），而是使用XML bean定义，注解组件（即，使用**@Component<strong>，</strong>@Controller<strong>等注解类）或者在基于Java <strong>@Configuration</strong>类中的</strong>@Bean<strong>方法。然后将这些源内部地转换到</strong>BeanDefinition**的实例中，并用于加载整个Spring IoC容器实例。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">*基于构造还是基于setter DI*      
由于可以混合使用基于构造方法和基于setter的DI，这有一个很好的经验法则，就是为强制性依赖项使用构造方法注入，为可选依赖项使用setter方法或配置方法注入。请注意，可以在setter方法上使用@Required注解，使属性成为必需的依赖项。<br> 
Spring团队通常主张构造方法注入，因为它可以实现应用程序组件为不可变对象，并确保所需的依赖关系不为null。此外，构造方法注入的组件总是以完全初始化的状态返回给客户端（调用）代码。作为一个附注，大量的构造方法参数是一个不好的代码气息，这意味着该类可能有太多的责任，应该重构以更好地解决问题的正确分离。<br>
Setter注入应主要用于可选依赖，可以在类中分配合理的默认值。否则，必须在代码任何使用依赖的地方执行非空检查。setter注入的一个好处是setter方法使得该类的对象可以在以后重新配置或重新注入。因此对于setter注入，通过 JMX MBeans管理是一个引人注目的用例。<br> 
使用对特定类最有意义的DI风格。有时候，当你处理没有来源的第三方类时，你来做选择。例如，如果第三方类不暴露任何setter方法，那么构造方法注入可能是DI的唯一可用形式。     
</div>

<h3 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h3><p>容器如下执行bean依赖解析：</p>
<ul>
<li><strong>ApplicationContext</strong>使用配置元数据（它描述了所有的bean）来创建和初始化。配置元数据可以通过XML，Java代码或注解指定。</li>
<li>对于每一个bean，它的依赖以属性，构造方法参数或静态工厂方法参数（如果你使用它来替代一个正常的构造方法）形式表现。当bean实际创建时，这些依赖被提供给bean。</li>
<li>每个属性或构造方法参数是要设置的值的实际定义，或对容器中另一个bean的引用。</li>
<li>作为值的每个属性或构造方法参数都将从其指定的格式转换为该属性或构造方法参数的实际类型。默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，如<strong>int</strong>，<strong>long</strong>，<strong>String</strong>，<strong>boolean</strong>等。</li>
</ul>
<p>Spring容器会在容器创建时验证每个bean的配置。但是，在bean实际被创建之前，不会设置bean的属性。在容器创建时，被设置为预实例化（默认设置）的单例域bean会被创建。域在<a href="#Bean%E5%9F%9F">“Bean域”</a>这一章定义。否则的话，bean只在被需要的时候才会创建。bean的创建可能会导致一个bean树被创建，因为bean的依赖和它依赖的依赖（等等）被创建和分配。请注意，这些依赖关系中的解决方案不匹配可能会显示较晚，也就是在受影响的bean首次创建的时候。</p>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">*循环依赖*： 如果你主要使用构造方法注入，可能会创建一个无法解决的循环依赖场景。<br> <br> 例如：类A通过构造方法依赖需要一个类B的实例，而类B通过构造方法注入又需要类A的实例。如果你为类A和B配置bean为互相注入，Spring IoC容器在运行时期探测到这个循环引用，就会抛出一个BeanCurrentlyInCreationException。<br> <br> 一个可能的解决方案是编辑这些类的源码，将其通过setter而不是构造方法配置。或者，避免构造方法注入而只使用setter注入。换而言之，你可以使用setter注入配置循环依赖，尽管这是不被推荐的。<br> <br>不像通常的情况（没有循环依赖），bean A和bean B之间的循环依赖关系强制其中一个bean在被完全初始化之前被注入到另一个bean中（一个经典的鸡/鸡蛋场景）。
</div>

<p>你一般可以信任Spring执行正确操作。它在容器加载时检测到配置问题，例如对不存在的bean的引用和循环依赖。当bean被创建后，Spring尽可能晚的设置属性和解析依赖。这意味着Spring容器被正确加载，但稍后你请求一个对象，如果在创建对象或者创建一个它的依赖上存在问题，容器会抛出一个异常。例如，bean由于缺少或无效的属性而抛出一个异常。这可能延迟了一些配置问题的发现，这也是为什么ApplicationContext的实现默认预实例化单例bean。以一些前期的时间和内存为代价，在bean实际需要前就创建它们，这样你可以在ApplicationContext创建时就发现配置的问题，而不是之后。你依旧可以重写这个默认行为，使单例bean懒加载，而不是预实例化。</p>
<p>如果没有循环依赖存在，当一个或多个协作bean被注入到一个需要该依赖的bean中时，每个协作bean在被注入到需要该依赖的bean之前都会被完全配置。这意味着如果beana A依赖bean B，Spring IoC容器在调用bean A的setter方法之前已经完全配置了bean B。换而言之，bean被实例化（如果不是一个预实例化单例），它的依赖被设置完成，并且相应的生命周期方法（比如 <a href="">配置的init方法</a> 或 <a href="">初始化bean回调方法</a>  ）已被调用。</p>
<h3 id="依赖注入示例"><a href="#依赖注入示例" class="headerlink" title="依赖注入示例"></a>依赖注入示例</h3><p>以下示例为基于setter的DI使用基于XML的配置元数据。Spring XML配置文件的一小部分指定了一些bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用了嵌套ref元素的setter注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用更加整洁的ref属性的setter注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntegerProperty</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，setter被声明与XML文件中指定的属性相匹配。以下示例使用基于构造方法的DI：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用嵌套的ref元素的构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用更加整洁的ref属性的构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanOne = anotherBean;</span><br><span class="line">        <span class="built_in">this</span>.beanTwo = yetAnotherBean;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在bean定义中指定的构造方法参数将被用作ExampleBean的构造方法的参数。</p>
<p>现在考虑这个例子的一种变体，不再使用构造方法，而是告诉Spring调用一个静态方法来返回这个对象的一个实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ExampleBean</span><span class="params">(...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个静态工厂方法; 这个方法的参数可以是该方法返回bean</span></span><br><span class="line">    <span class="comment">//的依赖，不管这些参数是否实际被使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title function_">createInstance</span> <span class="params">(</span></span><br><span class="line"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExampleBean</span> <span class="variable">eb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleBean</span> (...);</span><br><span class="line">        <span class="comment">//一些其他操作...</span></span><br><span class="line">        <span class="keyword">return</span> eb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态工厂方法的参数通过**&lt;constructor-arg&#x2F;&gt;<strong>元素提供，与实际构造方法使用的完全相同。这个工厂方法返回的类的类型不必和包含该静态工厂方法的类的类型一样，尽管在这个实例中是一样的。一个实例（非静态）工厂方法将以基本相同的方式使用（除了使用</strong>factory-bean<strong>属性而不是</strong>class**属性），所以这里不再赘述。</p>
<h2 id="依赖和配置细节"><a href="#依赖和配置细节" class="headerlink" title="依赖和配置细节"></a>依赖和配置细节</h2><hr>
<p>如在前面章节中提到的，你可以将bean属性和构造方法参数定义为对其他被管理的bean（协作者）的引用，或行内定义的值。为这个目的，Spring基于XML配置元数据在它的**&lt;property&#x2F;&gt;<strong>和</strong>&lt;constructor-arg&#x2F;&gt;**元素中支持子元素类型。</p>
<h3 id="直接值（原始类型，String等等）"><a href="#直接值（原始类型，String等等）" class="headerlink" title="直接值（原始类型，String等等）"></a>直接值（原始类型，String等等）</h3><p>**&lt;property&#x2F;&gt;**元素的value属性将一个属性或者构造方法参数指定为人类可读的字符串表示形式。Spring的 <a href="">转换服务</a> 用于将这些值从String转换为实际的属性或参数类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致一个setDriverClassName(String)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下示例使用 <a href="#%E4%BD%BF%E7%94%A8p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F">p命名空间</a> 进行更简洁的XML配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:driverClassName</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:username</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:password</span>=<span class="string">&quot;masterkaoli&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的XML更简洁;然而，拼写错误将在运行时而不是设计时被发现，除非你在创建bean定义时使用支持自动属性完成的IDE（如IntelliJ IDEA或Spring Tool Suite（STS））。</p>
<p>你也可以如下配置一个<strong>java.util.Properties</strong>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mappings&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以java.util.Properties类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用JavaBeans <strong>PropertyEditor</strong>机制将**&lt;value&#x2F;&gt;<strong>元素内的文本转换为</strong>java.util.Properties<strong>实例。这是一个很好的捷径，而且是Spring团队赞成在value属性样式中使用嵌套的</strong>&lt;value&#x2F;&gt;**元素的几个地方之一。</p>
<h4 id="idref元素"><a href="#idref元素" class="headerlink" title="idref元素"></a>idref元素</h4><p><strong>idref</strong>元素只是将容器中另一个bean的id（字符串值 - 不是引用）传递给**&lt;constructor-arg&#x2F;&gt;<strong>或</strong>&lt;property&#x2F;&gt;**元素的防错方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theClientBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述bean定义片段与以下代码片段完全相同（在运行时）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一种形式优于第二种形式，因为使用<strong>idref</strong>标签允许容器在部署时验证所引用的，命名的bean实际存在。在第二个变体中，不会对传递给client bean的targetName属性的值执行验证。只有当client bean被实际实例化的时候，错误拼写才会被发现（最可能是致命的结果）。如果client bean是一个 <a href="#Bean%E5%9F%9F">原型</a> bean,这种错字和它产生的异常只能在容器部署后很久才能被发现。</p>
<blockquote>
<p>在4.0 beans xsd中，<strong>idref</strong>元素上的<strong>local</strong>属性不再受支持，因为它不再提供超过常规bean引用的值。在升级到4.0 schema时，只需将你现有的<strong>idref local</strong>引用更改为<strong>idref bean</strong>。</p>
</blockquote>
<p><strong>&lt;idref&#x2F;&gt;<strong>元素带来值一个常用的地方是在</strong>ProxyFactoryBean</strong> bean定义中AOP拦截器的配置中（至少早在Spring 2.0版本）。指定拦截器名称时使用**&lt;idref&#x2F;&gt;**元素可防止拼写错误。</p>
<h3 id="引用其他bean（协作者）"><a href="#引用其他bean（协作者）" class="headerlink" title="引用其他bean（协作者）"></a>引用其他bean（协作者）</h3><p><strong>ref</strong>元素是**&lt;constructor-arg&#x2F;&gt;<strong>或</strong>&lt;property&#x2F;&gt;<strong>定义元素中的最后一个元素。在这里，你可以将bean的指定属性的值设置为对由容器管理的另一个bean（协作者）的引用。这个被引用的bean是进行属性设置bean的依赖项，并且它在进行属性设置前被引用bean一经请求就进行初始化（如果协作者是单例bean，它可能已经被容器初始化）。所有引用最终都是对另一个对象的引用。作用域和验证取决于你是否通过 <strong>bean</strong>, <strong>local</strong>,或</strong>parent**属性指定其他对象的id&#x2F;name。</p>
<p>通过**&lt;ref&#x2F;&gt;<strong>标签的bean属性指定目标bean是最常用的形式，并允许创建对在同一容器或父容器中任何bean的引用，而不管它是否在同一个XML文件中。bean属性的值可能与目标bean的</strong>id<strong>属性相同，或者与目标bean的</strong>name**属性中的一个值相同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;someBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<strong>parent</strong>属性指定目标bean是创建对在当前容器的父容器中bean的引用。<strong>parent</strong>属性的值可能与目标bean的id属性或目标bean的name属性中的值之一相同，并且目标bean必须在当前容器的父容器中。你使用这种引用形式变体，主要是在当你有层次结构的容器，并且你想要使用代理包装一个在父容器中已有的bean，这样会与父bean具有相同的名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父上下文中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.SimpleAccountService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据需要插入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在子（后代）上下文中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><span class="comment">&lt;!-- bean名称与父bean相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">&quot;accountService&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 注意我们如何引用父bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里按需要插入其他配置和依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在4.0 beans xsd中，<strong>idref</strong>元素上的<strong>local</strong>属性不再受支持，因为它不再提供超过常规bean引用的值。在升级到4.0 schema时，只需将你现有的<strong>idref local</strong>引用更改为<strong>idref bean</strong>。</p>
</blockquote>
<h3 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h3><p>一个在**&lt;property&#x2F;&gt;<strong>或</strong>&lt;constructor-arg&#x2F;&gt;<strong>元素内部的</strong>&lt;bean&#x2F;&gt;**元素定义了一个所谓的内部bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 相比使用一个目标bean的引用，可以只是内联定义这个目标bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是一个内部bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Fiona Apple&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个内部bean定义不需要定义的id或name;如果指定的话，容器也不使用这样的值作为标识符。容器也会忽略创建的<strong>scope</strong>标志：内部bean总是匿名的，并且它们总是外部bean而创建。不可能将注入内部bean到除闭包bean外的其他协作bean中，也不可能独立访问它们。</p>
<p>作为一个个别案例，有可能从一个自定义域中接收销毁回调，例如，对一个包含在单例bean中的request-scoped内部bean：内部Bean实例的创建将绑定到其包含的bean上但是销毁回调允许它参与到request scope的生命周期。这不是常见场景；内部bean通常只是分享在它们的包含bean的域内。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>在**&lt;list&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>和</strong>&lt;props&#x2F;&gt;**元素中，你可以分别设置Java Collection类型List，Set,Map和Properties的属性和参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;moreComplexObject&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setAdminEmails(java.util.Properties)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;development&quot;</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导致setSomeList(java.util.List)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setSomeMap(java.util.Map)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;an entry&quot;</span> <span class="attr">value</span>=<span class="string">&quot;just some string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;a ref&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;myDataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导致setSomeSet(java.util.Set)调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someSet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>Map的 key 和 value 的值，或 set 的值，也可以是以下任意一元素</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>
<h4 id="集合合并"><a href="#集合合并" class="headerlink" title="集合合并"></a>集合合并</h4><p>Spring容器还支持集合的合并。应用程序开发人员可以定义父样式的**&lt;list&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>或</strong>&lt;props&#x2F;&gt;<strong>元素，并且有子样式的</strong>&lt;list&#x2F;&gt;<strong>，</strong>&lt;map&#x2F;&gt;<strong>，</strong>&lt;set&#x2F;&gt;<strong>或</strong>&lt;props&#x2F;&gt;**元素继承并重写父集合中的值。也就是说，子集合的值是合并父和子集合的元素的结果，子集合元素重写在父集合中指定的值。</p>
<p><em>关于合并的这个部分讨论了父子bean的机制。读者不熟悉父和子bean定义的可能需要在继续前阅读 <a href="#Bean%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF">相关章节</a></em></p>
<p>以下示例演示集合合并：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 合并在子集合定义上指定 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sales&quot;</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，在子bean定义的adminEmails属性的&lt;props&#x2F;&gt;元素上使用merge&#x3D;true属性。当子bean被容器解析并实例化的时候，生成的实例具有一个adminEmails Properties集合，该集合包含将子级的adminEmails集合与父级的adminEmails集合合并的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">administrator=administrator@example.com</span><br><span class="line">sales=sales@example.com</span><br><span class="line">support=support@example.co.uk</span><br></pre></td></tr></table></figure>
<p>子Properties集合的值集继承父项&lt;props&#x2F;&gt;中的所有属性元素，并且子级support的值覆盖父集合中的值。</p>
<p>此合并行为与&lt;list&#x2F;&gt;，&lt;map&#x2F;&gt;和&lt;set&#x2F;&gt;集合类型类似。在具体&lt;list&#x2F;&gt;元素的情况下，与List集合类型相关联的语义，也就是说，有序集合概念的值会被维持;父项的值先于所有子列表的值。在Map，Set和Properties集合类型的情况下，不存在排序。因此，对于容器在内部使用的在相关的Map，Set和Properties实现类型的基础之上实现的集合类型，没有有效的有序语义。</p>
<p><strong>集合合并的限制</strong><br>你不能合并不同的集合类型（如一个Map和一个List），如果你尝试这样做，则会抛出合适的异常。merge 属性必须在较低的，继承的子定义上指定;在父集合定义上指定合并属性是多余的，不会导致期望的合并。<br><strong>强类型集合</strong><br>随着在Java 5中引入泛型类型，你可以使用强类型集合。也就是说，可以声明一个Collection类型，使它只能包含String元素（举例）。如果你使用Spring来依赖注入一个强类型的Collection到一个bean中，你可以利用Spring的类型转换支持，以便将强类型的Collection实例的元素转换为适当的类型，然后才能添加到Collection中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accounts&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9.99&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2.75&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;six&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.99&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当foo bean的accounts属性准备注入时，有关强类型Map&lt;String，Float&gt;的元素类型的泛型信息可通过反射获得。因此，Spring的类型转换基础框架将各种值元素识别为Float类型，并将字符串值9.99,2.75和3.99转换为实际的Float类型。</p>
<h3 id="null和空字符串值"><a href="#null和空字符串值" class="headerlink" title="null和空字符串值"></a>null和空字符串值</h3><p>Spring将属性的空参数作为空字符串处理。以下基于XML的配置元数据片段将电子邮件属性设置为空字符串值（“”）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面实例等效与下面的Java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&lt;null&#x2F;&gt;元素处理null值。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述配置相当于以下Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用p命名空间的XML快捷方式"><a href="#使用p命名空间的XML快捷方式" class="headerlink" title="使用p命名空间的XML快捷方式"></a>使用p命名空间的XML快捷方式</h3><p>p命名空间使你能够用bean元素的属性（attributes）而不是嵌套的**&lt;property&#x2F;&gt;**元素来描述属性值和&#x2F;或协作bean。</p>
<p>Spring使用命名空间支持可扩展的配置格式，这是基于XML Schema 定义。本章讨论的beans配置格式在XML Schema文档中定义。但是，p命名空间没有在XSD文件中定义，只存在于Spring的内核。</p>
<p>以下示例显式了解决相同结果的两个XML片段：第一个使用标准XML格式，第二个使用p命名空间。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;p-namespace&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:email</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该示例显示了在bean定义中名为email的p命名空间中属性。这告诉Spring包含一个属性声明。如前所述，p命名空间没有schema定义，因此你可以将属性（attribute）的名称设置为属性（property ）名称。</p>
<p>下一个示例包括两个对另一个bean的引用的bean定义：：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-classic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John Doe&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spouse&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;john-modern&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:name</span>=<span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:spouse-ref</span>=<span class="string">&quot;jane&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;jane&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jane Doe&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，此示例不仅包括使用p命名空间的属性值，还使用特殊格式来声明属性引用。第一个bean定义使用**&lt;property name &#x3D;”spouse” ref &#x3D;”jane”&#x2F;&gt;<strong>来创建从bean john到bean jane的引用，第二个bean定义使用</strong>p:spouse-ref &#x3D;”jane”**作为属性来完成相同的事情。在这种情况下，spouse是属性名称，而-ref部分表示这不是一个直接的值，而是引用另一个bean。</p>
<blockquote>
<p>p命名空间不如标准XML格式那么灵活。例如，这种声明属性引用的格式与以Ref结尾的属性冲突，而标准XML格式则不会。我们建议你仔细选择你的方法，并将其传达给你的团队成员，以避免同时使用所有三种方法生成XML文档</p>
</blockquote>
<h3 id="使用c命名空间的XML快捷方式"><a href="#使用c命名空间的XML快捷方式" class="headerlink" title="使用c命名空间的XML快捷方式"></a>使用c命名空间的XML快捷方式</h3><p>类似于称为“使用p命名空间的XML快捷方式”，Spring 3.1中新引入的c命名空间允许使用内联属性来配置构造方法参数，而不是使用嵌套的<strong>constructor-arg</strong>元素。</p>
<p>我们来回顾一下名为<a href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">“基于构造方法的依赖注入”</a>一节中使用c:namespace的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Baz&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 传统的声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用c命名空间的声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span> <span class="attr">c:bar-ref</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">c:baz-ref</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">c:email</span>=<span class="string">&quot;foo@bar.com&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于通过参数名来设置构造方法参数，**c:<strong>命名空间与</strong>p:**的使用相同的惯例（对bean引用的尾接-ref）。同样，它也需要声明，即使它没有在XSD schema 中定义（但它存在于Spring内核中）。</p>
<p>对于构造方法参数名称不可用的罕见情况（通常如果字节码在没有调试信息的情况下编译），可以对参数索引使用回退：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c命名空间索引声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span> <span class="attr">c:_0-ref</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;baz&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于XML语法，索引符号需要前置_的存在，因为XML属性名称不能以数字开头（即使某些IDE允许）。</p>
</blockquote>
<p>在实践中，构造方法解析机制在匹配参数方面非常有效，除非真的需要，我们建议你在你的配置中始终使用名称符号。</p>
<h3 id="复合属性名称"><a href="#复合属性名称" class="headerlink" title="复合属性名称"></a>复合属性名称</h3><p>当你设置bean属性时，可以使用复合或嵌套属性名称，只要除了最后属性名称之外的路径的所有组件都不为null。 考虑下面的bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foo.Bar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fred.bob.sammy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>foo</strong> bean有一个<strong>fred</strong>属性，<strong>fred</strong>属性又有一个<strong>bob</strong>属性，bob属性又有一个<strong>sammy</strong>属性，最后的<strong>sammy</strong>属性被设置值为123。为了这个工作，在bean被构建之后，<strong>foo</strong>的<strong>fred</strong>属性，<strong>fred</strong>的<strong>bob</strong>属性必须不是null，否则抛出一个<strong>NullPointerException</strong> 。</p>
<h2 id="使用depends-on"><a href="#使用depends-on" class="headerlink" title="使用depends-on"></a>使用depends-on</h2><hr>
<p>如果一个bean是另一个的依赖，通常意味着一个bean被设置为另一个bean的属性。通常，你可以使用基于XML的配置元数据中的**&lt;ref &#x2F;&gt;<strong>元素来完成此任务。但是，有时bean之间的依赖关系较不直接;比如，在一个类中的静态初始化器需要被触发，例如数据库驱动注册。</strong>depends-on**属性可以明确强制一个或多个bean在使用此元素的bean被初始化前先初始化。下面示例使用depends-on熟悉来表示一个单例bean上的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了表达对多个bean的依赖，提供bean名称列表作为<strong>depends-on</strong>属性的值，使用<strong>逗号</strong>，<strong>空白</strong>或者<strong>分号</strong>作为有效分隔符。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bean定义中的<strong>depends-on</strong>属性可以同时指定初始化时依赖，而在单例Bean的情况下，可以指定相应的销毁时依赖。一个需要依赖项的bean与一个给定的bean定义的<strong>depends-on</strong>关系，则需要依赖项bean在依赖项销毁之前销毁。因此<strong>depends-on</strong>也可以控制关机顺序。</p>
</blockquote>
<h2 id="延迟初始化bean"><a href="#延迟初始化bean" class="headerlink" title="延迟初始化bean"></a>延迟初始化bean</h2><hr>
<p>默认情况下，<strong>ApplicationContext</strong>实现在初始化过程中急切创建和配置所有单例bean。一般来说，这种预实例化是可取的，因为配置或周围环境中的错误会被立即发现，而不是在几个小时甚至几天之后。当不希望这种行为的时候，你通过可以标记bean定义为lazy-initialized（延迟初始化）来阻止单例bean的预实例化。一个延迟初始化的bean告诉IoC容器当它被第一次请求的时候才创建bean实例，而不是在启动时就实例化。</p>
<p>在XML中，这种行为由在**&lt;bean&#x2F;&gt;<strong>元素上的</strong>lazy-init**属性控制；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当上述配置被<strong>ApplicationContext</strong>使用时，<strong>ApplicationContext</strong>启动时，名为<strong>lazy</strong>的bean不会立即被预实例化，而<strong>not.lazy</strong> bean会被立即预实例化。</p>
<p>然而，当一个延迟初始化的bean是一个单例bean的依赖项的时候，它不是延迟初始化的，<strong>ApplicationContext</strong>在启动时就创建该延迟初始化bean，因为它必须满足该单例的依赖。延迟初始化bean被注入到其他不是延迟初始化的单例bean中。</p>
<p>你也可以通过使用**&lt;beans&#x2F;&gt;<strong>元素上的</strong>default-lazy-init**属性在容器级别上控制懒加载；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 没有beans会被预实例化... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自动装配协作者"><a href="#自动装配协作者" class="headerlink" title="自动装配协作者"></a>自动装配协作者</h2><hr>
<p>Spring容器可以自动装配协作bean之间的关系。你可以通过检查（inspect）<strong>ApplicationContext</strong>的内容来允许Spring为你的bean自动解析协作者（其他bean）。自动装配有以下的优点：</p>
<ul>
<li>自动装配可以显著减少指定属性或构造方法参数的需要。（其他机制，如本章其他地方讨论的bean模板在这方面也很有价值。）</li>
<li>随着对象的发展，自动装配可以更新配置。例如，如果你需要给一个类添加一个依赖项，则可以无需修改配置，自动满足该依赖关系。因此，自动装配在开发过程中特别有用，在代码库变得更加稳定时，无需切换到显式装配。</li>
</ul>
<p>当使用基于XML的配置元数据时，可以使用**&lt;bean&#x2F;&gt;<strong>元素上的</strong>autowire**属性为bean定义指定自动装配模式。自动装配功能有四种模式。你可以指定每一个需要自动装配的bean并且因此可以选择哪一个来自动装配。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>(默认)不自动装配。必须通过ref元素定义bean引用。对于大规模的部署不推荐改变此默认设置，因为明确指定协作者将给予更大的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td>byName</td>
<td>通过属性名自动装配。Spring会找到一个与需要自动装配的属性名称相同的bean。例如，如果bean定义被设置为通过名称自动装配，并且它包含一个master属性（也就是，它有一个setMaster(..)方法），Spring会查找一个名称为master的bean定义，并且使用它来设置属性</td>
</tr>
<tr>
<td>byType</td>
<td>如果确实容器中存在该属性类型的一个bean，则允许该属性被自动装配。如果有超过一个的bean存在，会抛出一个致命异常，这表示你可能不会为该bean使用<em>byType</em>自动装配。如果这里没有匹配的bean存在，则什么也不会发生；属性没有被设置。</td>
</tr>
<tr>
<td>constructor</td>
<td>类似与<em>byType</em>，但是只适用于构造方法参数。如果在容器中没有一个构造方法参数类型的bean，则会引起一个致命错误。</td>
</tr>
</tbody></table>
<p>在 <em>byType</em> 或 <em>constructor</em> 模式下，你可以装配数组和类型集合。在这种情况下，容器中所有在匹配预期类型的自动装配候选者，都被提供来满足依赖。如果期望的key类型是String，你可以自动装配强类型的Map。一个自动装配Map值会由匹配预期类型的所有bean实例组成，并且Map的key会包含相应的bean名称。</p>
<p>你可以将autowire行为与依赖检查相结合，检查会在自动装配完成后执行。</p>
<h3 id="自动装配的限制和缺点"><a href="#自动装配的限制和缺点" class="headerlink" title="自动装配的限制和缺点"></a>自动装配的限制和缺点</h3><p>在项目中贯穿始终的使用自动装配是效果最好的。如果自动装配没有被一贯使用，只是自动装配一两个bean定义可能会迷惑开发者。</p>
<p>考虑下面自动装配的限制和缺点：</p>
<ul>
<li>在<strong>property</strong>和<strong>constructor-arg</strong>中显式设置的依赖总是覆盖自动装配。你不能自动装配所谓的简单属性，例如原始类型，String和Class（以及这些简单属性的数组）。这种限制是设计的。</li>
<li>自动装配不如显式写明精确。尽管，如上表所示，Spring小心避免在歧义的情况下猜测，这可能会有一个意想不到的结果，你的Spring管理对象之间的关系不再被明确记录。</li>
<li>对于可能从Spring容器生成文档的工具可能无法使用装配信息。</li>
<li>容器中的多个bean定义可能与由setter方法或构造方法参数指定的类型相匹配，从而进行自动装配。对于数组，集合或Map，这不一定是问题。然而，对于期望单个值的依赖，这种歧义不是任意解决的。如果没有唯一的bean定义可用，则抛出异常。</li>
</ul>
<p>在后一种情况下，你有几个选项：</p>
<ul>
<li>放弃自动装配，明确写明依赖。</li>
<li>通过设置一个bean的<strong>autowire-candidate</strong>属性为false（如下一节描述），避免该bean被自动装配。</li>
<li>通过将其**&lt;bean&#x2F;&gt;<strong>元素的</strong>primary**属性设置为true，将单个bean定义指定为主要候选。</li>
<li>使用基于注解的配置实现更细粒度的控制，如<a href="#%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE">“基于注解的容器配置”</a>中所描述的。</li>
</ul>
<h3 id="从自动装配中排除一个bean"><a href="#从自动装配中排除一个bean" class="headerlink" title="从自动装配中排除一个bean"></a>从自动装配中排除一个bean</h3><p>在每个bean的基础上，你可以将bean从自动装配中排除。在Spring的XML格式中，将**&lt;bean&#x2F;&gt;<strong>元素上的</strong>autowire-candidate<strong>属性设置为false;容器使这个指定的bean定义不可用于自动装配基础架构（包括注解样式配置，例如</strong>@Autowired**）。</p>
<blockquote>
<p><strong>autowire-candidate</strong>属性被设计为仅影响基于类型的自动装配。它不会影响通过名称的明确引用，即使指定的bean没有被标记为一个自动装配候选，它也会被解析。因此，如果名称匹配的话，通过名称的自动装配依旧会注入这个bean。</p>
</blockquote>
<p>你也可以基于模式匹配而不是bean名称来限制自动装配的候选者。顶级**&lt;beans&#x2F;&gt;<strong>元素的</strong>default-autowire-candidates<strong>属性接收一个或多个模式。例如，要将自动装配候选者状态限制为任何名称以Repository结尾的bean，提供一个 *Repository的值。要提供多个模式，在一个以逗号分割的列表中定义它们。对一个bean明确定义</strong>autowire-candidate**属性的值为true或false的，这种设置始终优先，对于这样的bean，模式匹配将不再适用。</p>
<p>这些技术对于你不想通过自动装配注入其他bean的bean很有用。这并不意味着被排除的bean本身不能使用自动装配来配置。而是，这个bean它本身不是其他bean自动装配的候选者。</p>
<h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><hr>
<p>在大多数应用程序场景中，在容器中大多数的bean都是 <a href="">单例</a> 的。当一个单例bean需要和其他单例bean相协作时，或者一个非单例bean需要和其他非单例bean相协作时，你通常通过定义一个bean作为其他bean的属性来处理依赖关系。当bean的生命周期不同的时候，会发生一个问题。假设单例bean A需要使用非单例（原型）bean B，也许每个方法在A上调用。容器只会创建单例bean A一次，因此只有一次设置属性的机会。容器不能在每次需要时，向bean A提供一个新的bean B实例。</p>
<p>解决方案是放弃一些控制反转。你可以通过实现<strong>ApplicationContextAware</strong>接口使bean A对容器敏感，并且在每次bean A需要bean B的时候通过对容器调用**getBean(“B”)**来获取（通常是新的）bean B实例。以下是这种方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个使用状态命令行样式类的类执行一些处理</span></span><br><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring-API导入</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Map commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 抓取相应Command的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 注意Spring API依赖!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applicationContext.getBean(<span class="string">&quot;command&quot;</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述是不可取的，因为业务代码接触并耦合到Spring框架上。方法注入，一个Spring IoC容器的先进的功能，可以以干净的方式处理这种用例。</p>
<blockquote>
<p>你可以在此 <a target="_blank" rel="noopener" href="https://spring.io/blog/2004/08/06/method-injection/">博客条目</a> 中阅读更多关于方法注入的动机。</p>
</blockquote>
<h3 id="Lookup方法注入"><a href="#Lookup方法注入" class="headerlink" title="Lookup方法注入"></a>Lookup方法注入</h3><p>Lookup方法注入是容器重写容器所管理的bean上的方法的能力，用来返回容器中另一个命名bean的lookup结果。lookup通常涉及前一部分中描述的场景中的原型bean。Spring框架通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类来实现此方法注入。</p>
<blockquote>
<ul>
<li>为了使这个动态子类工作起来，Spring将子类化的类不能是<strong>final</strong>，并且被重写的方法也不能是<strong>final</strong>。</li>
</ul>
</blockquote>
<ul>
<li>单元测试具有抽象方法的类需要你自己对类进行子类化，并提供抽象方法的存根实现。</li>
<li>组件扫描也需要具体的方法，这需要具体的类来进行。</li>
<li>另一个关键的限制是，lookup方法不能和工厂方法一起使用，并且特别是不能和配置类中的带有@Bean方法一起使用，因为在该情况下容器不负责创建实例，因此无法动态创建一个运行时生成的子类。</li>
</ul>
<p>看前面的代码片段中的<strong>CommandManager</strong>类，你会看到Spring容器将动态地覆盖<strong>createCommand()<strong>方法的实现。你的</strong>CommandManager</strong>类将不会对Spring有任何依赖关系，在重做示例中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再有Spring导包!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 抓取相应Command接口的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧...但是这个方法的实现在哪里？</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端类包含要被注入的方法（在这个例子中是<strong>CommandManager</strong>），要注入的方法需要以下形式的签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>
<p>如果这个方法是<strong>abstranct</strong>的，动态生成子类实现了这个方法。否则，动态生成子类覆盖这个定义在原始类中的具体方法。比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 被部署为一个原型（非单例）的有状态的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myCommand&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按需在这里注入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor 使用statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;commandManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createCommand&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标识为commandManager的bean无论什么时候需要myCommand bean的一个新实例，就调用自己的<strong>creatCommond()<strong>方法。你必须小心以原型部署</strong>myCommand</strong> bean，如果它实际需要。如果它是以单例部署，则每次myCommand bean返回的是同一个实例。</p>
<p>或者，在基于注解的组件模型中，你可以通过@Lookup注释声明一个lookup 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup(&quot;myCommand&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，更为惯用的是，你可能依赖针对lookup方法声明返回类型的解析来获取目标bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，你通常会使用具体的存根实现来声明这种带注解的lookup方法，为了使它们与Spring的组件扫描规则兼容，默认情况下抽象类被忽略。此限制不适用于明确注册或明确导入的bean类的情况。</p>
<blockquote>
<p>另一种访问不同域的目标bean的方法是<strong>ObjectFactory</strong>&#x2F;<strong>Provider</strong>注入点。查看<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96">“作用域bean作为依赖”</a>一节。<br>感兴趣的读者还可以找到<strong>ServiceLocatorFactoryBean</strong>（在org.springframework.beans.factory.config包中）来使用。</p>
</blockquote>
<h3 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h3><p>比lookup方法注入更少用的一种方法注入形式是可以使用另一个方法实现来替换被管理bean中的任意方法。用户可以安全地跳过本节的剩余部分，直到实际需要该功能。</p>
<p>使用基于XML的配置元数据，对于已部署的bean你可以使用replacement-method元素将现有的方法实现替换为另一个。考虑下面的类，使用一个我们要重写的方法computeValue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValueCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">computeValue</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">// 一些真实代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些其他方法...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现org.springframework.beans.factory.support.MethodReplacer接口的类提供了新的方法定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 意在用于重写在MyValueCalculator</span></span><br><span class="line"><span class="comment"> * 中现有的computeValue(String)实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title class_">MethodReplacer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取输入值，使用它，并返回一个计算结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署原始类并指定方法重写的bean定义如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myValueCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 任意方法替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">&quot;computeValue&quot;</span> <span class="attr">replacer</span>=<span class="string">&quot;replacementComputeValue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;replacementComputeValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以在&lt;replaced-method&#x2F;&gt;元素中使用一个或多个包含的&lt;arg-type&#x2F;&gt;元素来指示被重写的方法的方法签名。只有当方法重载并且类中存在多个变体时，参数的签名才是必需的。为方便起见，参数的类型字符串可能是完全限定类型名称的子字符串。例如，以下全部匹配java.lang.String：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">String</span><br><span class="line">Str</span><br></pre></td></tr></table></figure>
<p>由于参数的数量通常足以区分每个可能的选择，所以此快捷方式可以节省大量的打字，只需键入与参数类型匹配的最短字符串即可。</p>
<hr>
<h1 id="Bean域"><a href="#Bean域" class="headerlink" title="Bean域"></a>Bean域</h1><hr>
<p>当你创建一个bean定义的时候，你创建了一个用于创建了由bean定义所定义的类的实际实例配方。bean定义是一个配方的概念很重要，因为这意味着，与类一样，你可以从单个配方创建许多对象实例。</p>
<p>你不仅可以控制要插入到由一个特殊bean定义创建的对象中的各种依赖和配置值，也可以控制这个对象的域。这种方法是强大和灵活的，你可以通过配置来选择你创建的对象的域，而不必在Java类级别上设置对象的域。bean可以被定义为部署在多个域之一中：Spring框架支持七个开箱即用的域，其中五个域只在你使用Web感知的<strong>ApplicationContext</strong>时可用。</p>
<p>以下域支持开箱即用。你还可以创建自定义域。</p>
<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#singleton%E5%9F%9F">singleton</a></td>
<td>（默认）每个Spring IoC容器将单个bean定义作为单个对象实例。</td>
</tr>
<tr>
<td><a href="#prototype%E5%9F%9F">prototype</a></td>
<td>将单个bean定义范围适用于任何数量的对象实例。</td>
</tr>
<tr>
<td><a href="#request%E5%9F%9F">request</a></td>
<td>将单个bean定义范围适用于单个HTTP请求的生命周期;也就是，每个HTTP请求都有一个它自己的bean实例，该实例是由背后的单个bean定义创建的。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#session%E5%9F%9F">session</a></td>
<td>将单个bean定义范围适用于一个HTTP Session生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#globalSession%E5%9F%9F">globalSession</a></td>
<td>将单个bean定义范围适用于一个HTTP Session生命周期中。通常仅在Portlet上下文中使用时才有效。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#application%E5%9F%9F">application</a></td>
<td>将单个bean定义范围适用于一个ServletContext生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
<tr>
<td><a href="#websocket%E5%9F%9F">websocket</a></td>
<td>将单个bean定义范围适用于一个WebSocket生命周期中。只有在一个Web感知的Spring ApplicationContext的上下文中才有效。</td>
</tr>
</tbody></table>
<blockquote>
<p>从Spring 3.0开始，一个thread域是可用的，但默认情况下未注册。有关更多信息，请参阅SimpleThreadScope的文档。有关如何注册此或任何其他自定义域的说明，请参阅<a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4">“使用自定义范围”</a>一节。</p>
</blockquote>
<h2 id="singleton域"><a href="#singleton域" class="headerlink" title="singleton域"></a>singleton域</h2><hr>
<p>单例bean只有一个共享实例被管理，并且所有对具有该id的bean或匹配到id的bean的请求都会使Spring容器返回一个指定的bean实例。</p>
<p>换句话说，当你定义一个bean定义以及它的域为singleton时，Spring IoC容器只会创建一个由该bean定义定义的对象的实例。这个单例实例被储存在一个这样的单例bean的缓存中，并且所有对这个命名bean的后续请求和引用都会返回缓存对象。<br><img src="/images/spring/singleton.png.pagespeed.ce.U0lSEQUK39.png" alt="单例bean"><br>Spring的单例bean概念不同于定义在Gang of Four (GoF)模式书中的单例模式（Singleton pattern）. GoF单例硬编码了对象的域范围，使得每个ClassLoader只会创建一个且只有一个特定类的实例。Spring单例域是描述为一个容器一个bean。这意味着如果在单个Spring容器为一个特殊类定义了一个bean，那么Spring容器只会创建一个且只有一个由该bean定义的类的实例。单例域是Spring默认的域。在XML中要定义一个bean为单例，你应该这么写，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面是等效的，尽管有些多余（单例域是默认设置）) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="prototype域"><a href="#prototype域" class="headerlink" title="prototype域"></a>prototype域</h2><hr>
<p>部署非单例，原型域的bean使每次对该特定bean进行请求时创建一个新的bean实例。也就是在容器中这个bean被注入到其他bean，或者你通过getBean()方法调用请求它。一般来说，为有状态的bean使用原型域，为无状态的bean使用单例域。</p>
<p>下面图表说明了Spring原型域。一个数据访问对象（DAO）通常不被配置为原型，因为一个典型DAO不保持任何会话状态；这只是作者简单的重用单例域的图。<br><img src="/images/spring/prototype.png" alt="原型bean"><br>下面示例在XML中定义一个bean为原型：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>与其他域相反，Spring不管理原型bean的完整生命周期：容器实例化，配置或以其他方式组装原型对象，并将其交给客户端，并不再记录该原型实例。因此，尽管不管是什么域，初始化生命周期回调方法在所有的对象上被调用，但是在原型的情况下，配置的销毁生命周期不被调用。客户端代码必须清理原型域对象并且是释放这个原型bean持有的昂贵资源。要使Spring容器释放原型bean持有的资源，尝试使用一个自定义的bean <a href="">post-processor</a>, 它涉及需要清理的bean。</p>
<p>在某些方面，Spring容器对原型域bean的作用是Java new操作符的替代。所有这之后的生命周期管理都必须由客户端处理。（有关Spring容器中bean的生命周期的详细信息，请参见第6.1节<a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83">“生命周期回调”</a>。）</p>
<h2 id="依赖原型bean的单例bean"><a href="#依赖原型bean的单例bean" class="headerlink" title="依赖原型bean的单例bean"></a>依赖原型bean的单例bean</h2><hr>
<p>当你使用依赖原型bean的单例bean的时候，要意识到依赖关系是在实例化时解析的。因此，如果你依赖注入一个原型域bean到一个单例域的bean，一个新的原型bean被实例化，然后被依赖注入到这个单例bean中。这个原型实例是曾经提供给单例域实例的唯一实例。</p>
<p>然而，假设你想要这个单例域bean在运行时期，重复去获得这个原型bean的新实例。你不能依赖注入一个原型域bean到你的单例域bean中，因为这个注入只发生一次，在Spring容器实例化这个单例bean并且解析和注入它的依赖时。如果在运行时多次需要一个原型bean的新实例，请参见第4.6节 <a href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">“方法注入”</a></p>
<h2 id="Request-session-global-session-application和-WebSocket域"><a href="#Request-session-global-session-application和-WebSocket域" class="headerlink" title="Request, session, global session, application和 WebSocket域"></a>Request, session, global session, application和 WebSocket域</h2><hr>
<p>只有使用Web感知的Spring <strong>ApplicationContext</strong>实现（如XmlWebApplicationContext），<strong>request</strong>, <strong>session</strong>, <strong>globalSession</strong>, <strong>application</strong>和 <strong>webSocket</strong>域才可用。如果你在常规Spring Ioc容器，如<strong>ClassPathXmlApplicationContext</strong>中见到这些域，那么会抛出一个<strong>IllegalStateException</strong>异常来抱怨一个未知的bean范围。</p>
<h3 id="初始web配置"><a href="#初始web配置" class="headerlink" title="初始web配置"></a>初始web配置</h3><p>要支持在<strong>request</strong>, <strong>session</strong>, <strong>globalSession</strong>, <strong>application</strong>和 <strong>webSocket</strong>级别（web域bean）bean的域，在你定义你的bean之前，需要一些次要的初始配置。（对于标准域，单例和原型不需要这些初始设置。）</p>
<p>如何完成此初始设置取决于你的特定Servlet环境。</p>
<p>如果在Spring Web MVC中访问作用域bean，实际上，其中请求由Spring的 <strong>DispatcherServlet</strong>或<strong>DispatcherPortlet</strong>来处理，这样不需要特殊的设置：DispatcherServlet和DispatcherPortlet已经显式所有相关状态。</p>
<p>如果你使用Servlet 2.5 web容器，请求在Spring的DispatcherServlet之外处理（例如，当使用JSF或Struts），你需要注册<strong>org.springframework.web.context.request.RequestContextListener</strong> <strong>ServletRequestListener</strong>。对于Servlet 3.0+,可以通过WebApplicationInitializer接口以编程方式完成。或者，对于较旧的容器，请将以下声明添加到Web应用程序的web.xml文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.request.RequestContextListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果你的监听器设置有问题，请考虑使用Spring的RequestContextFilter。过滤器映射取决于周围的Web应用程序配置，因此必须根据需要进行更改。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>DispatcherServlet</strong>，<strong>RequestContextListener</strong>和<strong>RequestContextFilter</strong>都完成相同的事情，即将HTTP请求对象绑定到为该请求提供服务的线程上。这使得request-和session域的bean在调用链上进一步可用。</p>
<h3 id="Request域"><a href="#Request域" class="headerlink" title="Request域"></a>Request域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.LoginAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用loginAction 的bean定义为每个HTTP请求创建一个新的LoginAction bean实例。也就是说，loginAction bean的作用域在HTTP request级别上。你可以根据需要更改创建的实例的内部状态，因为从同一个loginAction bean定义创建的其他实例将不会在状态中看到这些更改;它们是特定于单独请求的。当请求完成处理时，作用于该请求的bean将被丢弃。</p>
<p>使用注解驱动组件或Java Config时，可以使用@RequestScope注解指定组件为request域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAction</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Session域"><a href="#Session域" class="headerlink" title="Session域"></a>Session域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用UserPreferences的bean定义为每个HTTP会话的生命周期创建一个新的UserPreferences bean实例。换而言之，userPreferences bean的作用域在HTTP Session级别上有效。和request域的bean一样，你可以根据需要更改创建的实例的内部状态，其他HTTP Session实例使用从相同userPreferences bean定义创建的实例看不到这些状态修改，因为它们是特定于单个HTTP会话的。当HTTP Session最终被丢弃时，范围限定于该特定HTTP Session的bean也被丢弃。</p>
<p>使用注解驱动组件或Java Config时，可以使用@SessionScope注解指定组件为session域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPreferences</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="globalSession域"><a href="#globalSession域" class="headerlink" title="globalSession域"></a>globalSession域</h3><p>考虑以下bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;globalSession&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>globalSession域类似于标准的HTTP Session域（如上描述），并且仅适用于基于Portlet的Web应用程序的上下文。portlet规范定义了构成单个Portlet Web应用程序的所有portlet之间共享的全局会话的概念。定义在globalSession域上的Bean被限定（或绑定）到全局portlet Session的生命周期上。</p>
<p>如果你编写一个标准的基于Servlet的web应用程序，并且你定义一个或多个bean具有gloablSession域，那么使用的是标准HTTP Session域，并且不会发生错误。</p>
<h3 id="Application域"><a href="#Application域" class="headerlink" title="Application域"></a>Application域</h3><p>考虑以下用于bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AppPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用AppPreferences的bean定义为整个web程序创建一个新的AppPreferences bean实例。换而言之，appPreferences bean的作用域在HTTP ServletContext级别上有效，作为一个常规的ServletContext属性存储。这有些类似域Spring单例bean，但是在两个重要方式上不同：它是每一个ServletContext一个单例，而不是每一个Springd的’ApplicationContext’（在任何给定的Web应用程序中可能有几个），并且它实际上是暴露的，因此可视为ServletContext属性。<br>使用注解驱动组件或Java Config时，可以使用@ApplicationScope注解指定组件为application域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppPreferences</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域bean作为依赖"><a href="#作用域bean作为依赖" class="headerlink" title="作用域bean作为依赖"></a>作用域bean作为依赖</h3><p>Spring IoC容器不仅管理对象（bean）的实例化，还管理协作者（或依赖）的装配。如果要将HTTP request域的bean（比如）注入到另一个更长生命域的bean中，你可以选择注入AOP代理来代替作用域bean。也就是说，你需要注入一个代理对象，该对象暴露与作用域对象相同的公共接口，但也可以从相关域（例如HTTP请求）中检索真实目标对象，并将方法调用委托给真实对象。</p>
<blockquote>
<p>你还可以在作用域为<strong>singleton</strong>的bean之间使用**&lt;aop:scoped-proxy&#x2F;&gt;<strong>，然后该引用经过可序列化的中间代理，因此能够在反序列化上重新获得目标单例bean。当针对</strong>prototype<strong>域的bean声明</strong>&lt;aop:scoped-proxy&#x2F;&gt;**，共享代理上的每个方法调用将导致创建一个新的目标实例，然后调用被转发到该目标实例。<br>此外，域代理不是以生命周期安全方式从较较小域访问bean的唯一方法。你也可以简单只声明你的注入点（即构造器&#x2F;setter参数或者自动装配字段）为ObjectFactory&lt;MyTargetBean&gt;,允许getObject()调用在每次需要时根据需要检索当前实例，而不必保留实例或分别存储它。JSR-330变体称为Provider，与Provider&lt;MyTargetBean&gt;声明一起使用，并为每次检索尝试使用相应的get()调用。有关JSR-330的更多详细信息，请参阅此处。</p>
</blockquote>
<p>以下示例中的配置只有一行，但是了解“为什么”以及它背后的“如何”是很重要的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个HTTP Session域bean以一个代理暴露出来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指示容器代理包围的bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个使用上述代理注入到的单例域bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.SimpleUserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对代理的userPreferences bean的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要创建这样一个代理，你将一个子**&lt;aop:scoped-proxy&#x2F;&gt;<strong>元素插入作用域bean定义中(请参阅 <a href="">“选择要创建的代理类型”</a> 一节和第41章 <a href="">基于XML架构的配置</a>)。为什么作用域在request, session, globalSession和自定义域级别上bean定义需要</strong>&lt;aop:scoped-proxy&#x2F;&gt;**元素？让我们来检查下下面的单例bean定义并且与上述域所需要的定义的进行对比（注意下面userPreferences bean定义是不完整的）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，这个HTTP-Session域bean <strong>userPreferences</strong>的引用被注入到单例bean <strong>userManager</strong>中。这里的重点是<strong>userManager</strong> bean是单例：它只会被每个容器实例化一次，并且它的依赖（这里只有一个，userPreferences bean）同样只会被注入进一次。这意味着<strong>userManager</strong> bean将只对完全相同的<strong>userPreferences</strong>对象进行操作，也就是最初注入的那个。</p>
<p>当将一个短生存域bean注入到一个长生存域bean的时候，这不是你想要的行为，比如将一个HTTP Session域的协作bean作为依赖注入到一个单例bean中。相反，你需要一个userManager对象，并且在HTTP Session的整个生命周期中，你需要一个特定于所述HTTP Session的userPreferences对象。因此，容器创建一个对象，该对象暴露与UserPreferences类（理想情况下是UserPreferences实例的对象）完全相同的公共接口，该对象可从域机制（HTTP request，Session等）中获取真实的UserPreferences对象。这个容器将这个代理对象注入到userManager bean中，该bean不会意识到这个UserPreferences引用是一个代理。在这个例子中，当UserManager实例调用一个依赖注入的UserPreferences对象的方法时，它实际是调用代理上的方法。然后这个代理从（这个例子中）HTTP Session中获取真实UserPreferences对象，并且将方法调用委托给这个获取的真实UserPreferences对象上。</p>
<p>因此当将request-，session-和globalSession-域的bean注入到协作bean上时，你需要下面正确并且完整的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="选择要创建的代理类型"><a href="#选择要创建的代理类型" class="headerlink" title="选择要创建的代理类型"></a>选择要创建的代理类型</h4><p>默认情况下，当Spring容器为使用**&lt;aop:scoped-proxy&#x2F;&gt;**元素标记的bean创建代理时，将创建一个基于CGLIB的类代理。</p>
<blockquote>
<p>CGLIB代理只拦截公共方法调用！不要在这样的代理上调用非公开方法;它们不会被委派给实际的作用域目标对象。</p>
</blockquote>
<p>或者，你可以通过为**&lt;aop:scoped-proxy&#x2F;&gt;<strong>元素的</strong>proxy-target-class**属性的值指定为false，来配置Spring容器为这些作用域bean创建基于标准的JDK基于接口的代理。使用JDK基于接口的代理意味着你的应用程序类路径不需要额外的库来实现这种代理。然而，这也意味着作用域bean的类必须实现至少一个接口，并且所有被注入协作者的作用域bean必须通过它的一个接口引用该bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DefaultUserPreferences实现了 the UserPreferences接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultUserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有关选择基于类或基于接口的代理的更多详细信息，请参见第11.6节<a href="">“代理机制”</a>。</p>
<h2 id="自定义域"><a href="#自定义域" class="headerlink" title="自定义域"></a>自定义域</h2><hr>
<p>bean域机制是可以拓展的；你可以定义你自己的域，或者甚至可以重定义现有的bean，虽然后者被认为是不好的做法，你不能覆盖内置的单例和原型域。</p>
<h3 id="创建自定义域"><a href="#创建自定义域" class="headerlink" title="创建自定义域"></a>创建自定义域</h3><p>要将自定义域集成到Spring容器中，需要实现<strong>org.springframework.beans.factory.config.Scope</strong>接口，它将在本节讲述。有关如何实现自己的范围的想法，请参阅随Spring框架本身提供的Scope实现和Scope javadocs，它更详细地解释了需要实现的方法。</p>
<p><strong>Scope</strong>接口有四个从域中获取，移除，并且销毁对象的方法。</p>
<p>以下方法从底层域返回对象。例如，session域实现返回会话域中的bean（如果不存在，则该方法返回一个新bean实例，并将其绑定到会话以供将来引用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span><br></pre></td></tr></table></figure>
<p>以下方法从底层域中删除该对象。例如，session域实现从底层会话中移除该会话域bean。应该返回对象，但如果没有找到指定名称的对象，则可以返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">remove</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>
<p>以下方法注册域应当执行的回调，当它被销毁或者当这个域中指定的对象被销毁的时候。关销毁回调的更多信息，请参阅javadocs或Spring scope实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerDestructionCallback</span><span class="params">(String name, Runnable destructionCallback)</span></span><br></pre></td></tr></table></figure>
<p>以下方法获取底层域的对话标识符。该标识符对于每个域是不同的。对于会话域的实现，该标识符可以是session标识符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getConversationId</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="使用自定义域"><a href="#使用自定义域" class="headerlink" title="使用自定义域"></a>使用自定义域</h3><p>在编写和测试一个或多个自定义Scope实现之后，你需要使Spring容器了解你的新作用域。以下方法是使用Spring容器注册新的Scope的中心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerScope</span><span class="params">(String scopeName, Scope scope)</span>;</span><br></pre></td></tr></table></figure>
<p>此方法在<strong>ConfigurableBeanFactory</strong>接口上声明，它通过<strong>BeanFactory</strong>属性与Spring配合在大多数的<strong>ApplicationContext</strong>具体实现可用。</p>
<p><strong>registerScope(..)<strong>方法的第一个参数是与域关联的唯一名称;Spring容器中这样的名字的例子就是</strong>singleton</strong>和<strong>prototype</strong>。**registerScope(..)**方法的第二个参数是你希望注册使用的自定义Scope实现的实际实例。</p>
<p>假设你编写了自定义的Scope实现，然后像下面一样将它注册。</p>
<blockquote>
<p>下面的例子使用Spring中包含的<strong>SimpleThreadScope</strong>，但它默认情况下未注册。对于你自己的自定义Scope实现，示例将是一样的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scope</span> <span class="variable">threadScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThreadScope</span>();</span><br><span class="line">beanFactory.registerScope(<span class="string">&quot;thread&quot;</span>, threadScope);</span><br></pre></td></tr></table></figure>
<p>然后，你创建遵循自定义域域规则的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过自定义域实现，你不限于只使用域的编程式注册。你还可以声明地使用<strong>CustomScopeConfigurer</strong>类来执行Scope注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;scopes&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.SimpleThreadScope&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Bar&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;thread&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Rick&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.Foo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<strong>FactoryBean</strong>实现中放置**&lt;aop:scoped-proxy&#x2F;&gt;<strong>时，它是工厂bean本身作用域，而不是从</strong>getObject()**返回的对象。</p>
</blockquote>
<hr>
<h1 id="定制bean性质"><a href="#定制bean性质" class="headerlink" title="定制bean性质"></a>定制bean性质</h1><hr>
<h2 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h2><hr>
<p>要与容器的bean生命周期管理进行交互，可以实现Spring <strong>InitializingBean</strong>和<strong>DisposableBean</strong>接口。容器为前者调用**afterPropertiesSet()<strong>，并为后者调用</strong>destroy()**，以允许bean在初始化和销毁bean时执行某些操作。</p>
<blockquote>
<p>JSR-250 <strong>@PostConstruct</strong>和**@PreDestroy<strong>注解通常被认为是在现代Spring应用程序中接收生命周期回调的最佳做法。使用这些注解意味着你的bean没有和Spring特定接口耦合。有关详细信息，请参见第7.9.8节<a href="#@PostConstruct%E5%92%8C@PreDestroy">“@PostConstruct和@PreDestroy”</a>。如果你不想使用JSR-250注解，但你仍然希望移除耦合，请考虑使用</strong>init-method<strong>和</strong>destroy-method**对象定义元数据。</p>
</blockquote>
<p>在内部，Spring 框架使用<strong>BeanPostProcessor</strong>实现来处理它可以找到的任何回调接口，并调用适当的方法。如果你需要自定义功能或者其他生命周期行为这些Spring没有提供开箱即用的，你可以实现一个自己的<strong>BeanPostProcessor</strong>。更多信息，请参阅[容器扩展点](# 容器扩展点)。</p>
<p>除了初始化和销毁回调之外，Spring管理的对象可能还实现<strong>Lifecycle</strong>接口，这样这些对象可以参与由容器自己的生命周期驱动的启动和关闭过程。</p>
<p>在本节描述生命周期回调接口。</p>
<h3 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h3><p><strong>org.springframework.beans.factory.InitializingBean</strong>接口允许在bean上所有必须属性已经被容器设置好后，执行初始化工作。<strong>InitializingBean</strong>接口指定了一个单一方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>建议你不要使用<strong>InitializingBean</strong>接口，因为它不必要地将代码耦合到Spring上。作为选择，使用**@PostConstruct<strong>注解或指定一个POJO初始化方法。在基于XML配置元数据中，你使用</strong>init-method<strong>属性来指定具有void no-argument签名的方法的名称。在Java Config中，你可以使用</strong>@Bean<strong>的</strong>initMethod**属性，请参阅<a href="">“接收生命周期回调”</a>一节。例如，以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与下面完全一样</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前一种没有将代码与Spring耦合在一起。</p>
<h3 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h3><p>实现<strong>org.springframework.beans.factory.DisposableBean</strong>接口允许bean在包含它的容器销毁时获取一个回调。<strong>DisposableBean</strong>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>建议你不要使用<strong>DisposableBean</strong>接口，因为它不必要地将代码耦合到Spring上。作为选择，使用**@PreDestroy<strong>注解或指定一个由bean定义支持的通用方法。在基于XML配置元数据中，你使用&lt;bean&#x2F;&gt;上的</strong>destroy-method<strong>属性。在Java Config中，你可以使用</strong>@Bean<strong>的</strong>destroyMethod**属性，请参阅<a href="">“接收生命周期回调”</a>一节。例如，以下定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些销毁工作(比如释放池连接)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与下面完成一样</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些销毁工作(比如释放池连接)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前一种没有将代码与Spring耦合在一起。</p>
<blockquote>
<p>一个**&lt;bean&gt;<strong>元素的</strong>destroy-method<strong>属性可以被赋予一个特殊的(<strong>inferred</strong>)值，该值指示Spring在特定的bean类上自动检测公共的</strong>close<strong>或</strong>shutdown<strong>方法。（任何实现</strong>java.lang.AutoCloseable<strong>或</strong>java.io.Closeable<strong>的类会因此匹配）。这个特殊的（推测的）值也可以在</strong>&lt;beans&gt;<strong>元素的</strong>default-destroy-method**属性上设置，以将此行为应用于一整套bean（请参阅<a href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95">“默认初始化和销毁方法”</a>一节）。注意这是Java cofig的默认行为。</p>
</blockquote>
<h3 id="默认初始化和销毁方法"><a href="#默认初始化和销毁方法" class="headerlink" title="默认初始化和销毁方法"></a>默认初始化和销毁方法</h3><p>当你编写不使用Spring指定的<strong>InitializingBean</strong>和<strong>DisposableBean</strong>回调接口的初始化和销毁​​方法回调时，你通常用<strong>init()</strong>,<strong>initialize()</strong>,**dispose()**等这些名称。理想情况下，这些生命周期回调方法的名称贯穿整个项目，以便所有的开发者使用相同的方法名称和确保一致性。</p>
<p>你可以配置Spring容器去查找在每个bean上的命名初始化和销毁回调方法名称。这意味着你作为一个程序开发者，可以编写你的应用程序类，并且使用一个名为**init()<strong>的初始化回调，而不用必在每个bean定义上配置</strong>init-method&#x3D;“init”**属性。Spring IoC容器在bean被创建的时候调用这个方法（并按照前面描述的标准生命周期回调契约）。这个功能同样为初始化和销毁方法回调执行一致的命名约定。</p>
<p>假设你的初始化回调方法名为**init()<strong>并且销毁回调方法名为</strong>destory()**。你的类将类似于下面例子中的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title class_">BlogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlogDao blogDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlogDao</span><span class="params">(BlogDao blogDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blogDao = blogDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是（不出意料的）初始化回调方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.blogDao == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The [blogDao] property must be set.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blogService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultBlogService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于顶级**&lt;beans &#x2F;&gt;<strong>元素属性中</strong>default-init-method<strong>属性的存在，导致Spring IoC容器将bean上名为</strong>init**的方法识别为初始化方法回调。当bean被创建和组装，如果这个bean类上有这样一个方法，它会在合适的时间被调用。</p>
<p>你通过使用顶级**&lt;beans &#x2F;&gt;<strong>元素上</strong>default-init-method**属性类似的配置销毁方法回调（在XML上是这样）。</p>
<p>如果已有的bean类已经有回调方法，并且命名与约定不符的，你可以通过使用**&lt;bean&#x2F;&gt;<strong>的</strong>init-method<strong>和</strong>destroy-method**属性来指定（在XML中，是这样）方法名称来覆盖默认值。</p>
<p>Spring容器保证在bean所有的依赖被提供后，立即调用配置的初始化回调。因此这个初始化回调是在原始bean上被调用，这意味着AOP拦截器等尚未应用于该bean。目标bean首先被完全创建，然后才应用AOP代理（例如）和它的拦截器链。如果目标bean和代理被分开定义，你的代码甚至可以绕过代理，与原始目标bean进行交互。因此，将拦截器应用到init方法将会变得不一致，因为这样做会将目标bean的生命周期和它的代理&#x2F;拦截器耦合在一起，并在代码直接与原始目标bean进行交互时留下奇怪的语义。</p>
<h3 id="组合生命周期机制"><a href="#组合生命周期机制" class="headerlink" title="组合生命周期机制"></a>组合生命周期机制</h3><p>从Spring 2.5开始，你有三种控制bean生命周期行为的选项：<strong>InitializingBean</strong>和<strong>DisposableBean</strong>回调接口;自定义<strong>init()<strong>和</strong>destroy()<strong>方法;和</strong>@PostConstruct</strong>和**@PreDestroy**注解。你可以组合这些机制来控制给定的bean。</p>
<blockquote>
<p>如果为一个bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，那么每个配置的方法都按照下面列出的顺序执行。但是，如果为超过一个这些生命周期机制配置了相同的方法名称，例如初始化方法init() ，该方法将如上一节所述的只执行一次。</p>
</blockquote>
<p>使用了不同的初始化方法，为同一个bean配置的多个生命周期机制，如下被调用：</p>
<ul>
<li>被**@PostConstruct**注解的方法</li>
<li>由<strong>InitializingBean</strong>回调接口定义的<strong>afterPropertiesSet()</strong></li>
<li>自定义配置的**init()**方法</li>
</ul>
<p>销毁方法以相同的顺序被调用</p>
<ul>
<li>被**@PreDestroy**注解的方法</li>
<li>由<strong>DisposableBean</strong>回调接口定义的<strong>destroy()</strong></li>
<li>自定义配置的**destroy()**方法</li>
</ul>
<h3 id="启动和关闭回调"><a href="#启动和关闭回调" class="headerlink" title="启动和关闭回调"></a>启动和关闭回调</h3><p><strong>Lifecycle</strong>接口为任何具有自身生命周期需求的对象定义了必需方法（例如启动和停止一些后台进程）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何Spring管理的对象都可以实现这个接口。然后，当<strong>ApplicationContext</strong>本身接收到启动和停止信号时，例如，对于运行时的停止&#x2F;重新启动情况，它会将这些调用级联到在该上下文中定义的所有<strong>Lifecycle</strong>实现。它通过委托给<strong>LifecycleProcessor</strong>来执行此操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>LifecycleProcessor</strong>本身是<strong>Lifecycle</strong>接口的扩展。它还增加了另外两种方法来对正在刷新和关闭的上下文进行反应。</p>
<blockquote>
<p>请注意，常规的<strong>org.springframework.context.Lifecycle</strong>接口只是对明确的启动&#x2F;停止通知的简单合同，并不意味着在上下文刷新时自动启动。考虑实现<strong>org.springframework.context.SmartLifecycle</strong>来代替，以便对特定bean的自动启动（包括启动阶段）进行细粒度的控制。此外，请注意，停止通知不能保证在销毁之前发生：在常规关机时，所有Lifecycle bean将在广泛的销毁回调传播之前首先收到停止通知;然而，在上下文生命周期的热刷新或中止刷新尝试时，只会调用destroy方法。</p>
</blockquote>
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“depends-on”关系，则依赖方将在其依赖之后启动，并在其依赖之前停止。然而，有时直接依赖是未知的。你可能只知道某种类型的对象应该在另一种类型的对象之前开始。在这些情况下，<strong>SmartLifecycle</strong>接口定义了另一个选项，即在其父接口<strong>Phased</strong>上定义的getPhase()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phased</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span>, Phased &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAutoStartup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Runnable callback)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启动时，相位最低的对象首先启动，停止时则按照相反的顺序进行。因此，实现SmartLifecycle的对象，并且它的getPhase()方法返回值为Integer.MIN_VALUE的，将是第一个启动和最后停止的对象（可能是因为它依赖于其他进程运行）。当考虑相位值时，知道任何没有实现**SmartLifecycle **的“正常”<strong>Lifecycle</strong>对象的相位值为0是很重要的。因此，任何负相位值都表示一个对象应该在这些标准组件之前开始（并在它们之后停止），反之亦然。</p>
<p>你可以看到<strong>SmartLifecycle</strong>定义的stop方法接受回调。任何实现必须在该实现的关闭过程完成后调用该回调的run（）方法。这可以在必要时进行异步关闭，因为<strong>LifecycleProcessor</strong>接口的默认<strong>DefaultLifecycleProcessor</strong>，会对每个阶段中的对象组等待它们的超时值，以此来调用这个回调。每个相位默认超时值是30秒。你可以通过在上下文中定义名为“lifecycleProcessor”的bean来覆盖默认的生命周期处理器实例。如果你只想修改超时值，则定义以下内容就足够了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以毫秒为单位的超时值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeoutPerShutdownPhase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如前所述，LifecycleProcessor接口定义了用于刷新和关闭上下文的回调方法。后者将简单地驱动关闭过程，就像已经明确调用了stop()一样，但是它是在上下文关闭时发生。另一方面，“refresh”回调启用了SmartLifecycle bean的另一个功能。当上下文被刷新（在所有对象被实例化和初始化之后）时，该回调将被调用，并且在这个点上，默认生命周期处理器将检查每个SmartLifecycle对象的isAutoStartup()方法返回的布尔值。如果为“true”，则该对象将在该点启动，而不是等待上下文或它自己的start()方法的显式调用（与上下文刷新不同，对于标准的上下文实现上下文启动不会自动发生）。“phase”值以及任何“depends-on”关系将以与上述相同的方式决定来启动顺序。</p>
<h3 id="在非Web应用程序中正常关闭Spring-IoC容器"><a href="#在非Web应用程序中正常关闭Spring-IoC容器" class="headerlink" title="在非Web应用程序中正常关闭Spring IoC容器"></a>在非Web应用程序中正常关闭Spring IoC容器</h3><blockquote>
<p>本节仅适用于非Web应用程序。 Spring的基于Web的ApplicationContext实现已经有代码在关闭相关Web应用程序时，正常关闭Spring IoC容器。</p>
</blockquote>
<p>如果在非Web应用程序环境中使用Spring的IoC容器;例如，在富客户端桌面环境中;你为JVM注册一个关闭钩子。这样做可以确保正常关机，并在单例Bean上调用相关的destroy方法，以便释放所有资源。当然，你仍然必须正确配置和实现这些销毁回调。</p>
<p>要注册一个关闭钩子，你调用ConfigurableApplicationContext接口上声明的registerShutdownHook()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span> []&#123;<span class="string">&quot;beans.xml&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为上述上下文添加一个关闭钩子...</span></span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// app在这里运行...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要方法退出，钩子在应用程序关闭之前被调用......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationContextAware和BeanNameAware"><a href="#ApplicationContextAware和BeanNameAware" class="headerlink" title="ApplicationContextAware和BeanNameAware"></a>ApplicationContextAware和BeanNameAware</h2><hr>
<p>当<strong>ApplicationContext</strong>创建一个实现<strong>org.springframework.context.ApplicationContextAware</strong>接口的对象实例时，会提供给实例该<strong>ApplicationContext</strong>的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此bean可以编程式操作创建它们的<strong>ApplicationContext</strong>，通过<strong>ApplicationContext</strong>接口或者将个引用转换为这个接口的一个已知子类，例如<strong>ConfigurableApplicationContext</strong>，它暴露了一些额外功能。这样做的一个用途是可以编程式检索其他的bean。有时这种能力是有用的;然而，一般你应该避免这样做，因为它将代码和Spring耦合在一起，并且没有遵循将协作者作为属性提供给bean的控制反转风格。<strong>ApplicationContext</strong>的其他方法提供对文件资源的访问，发布应用程序事件和访问<strong>MessageSource</strong>。这些附加功能在第7.15节<a href="">“ApplicationContext的附加功能”</a>中描述。</p>
<p>从Spring2.5开始，自动装配是另一种获取<strong>ApplicationContext</strong>引用的可选方法。“传统”的<strong>constructor</strong>和<strong>byType</strong>自动装配模式（如第4.5节<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85">“自动装配协作者”</a>中所述）可以分别为构造方法参数或setter方法参数提供<strong>ApplicationContext</strong>类型的依赖。为了更多的灵活性，包括自动装配字段和多参数方法的能力，请使用新的基于注解的自动装配功能。如果你这样做，<strong>ApplicationContext</strong>被自动装配到一个字段，构造方法参数或者方法参数上，如果相关期望<strong>ApplicationContext</strong>类型的字段，构造方法或方法带有**@Autowired**注解的话。更多信息，请参阅第9.2节<a href="#@Autowired">“@Autowired”</a>。</p>
<p>当<strong>ApplicationContext</strong>创建一个实现<strong>org.springframework.beans.factory.BeanNameAware</strong>接口的类时，该类将被提供一个对其关联对象定义中定义名称的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个回调在普通bean属性被填充后，但是在一个初始化回调（如InitializingBean的afterPropertiesSet 或一个自定义init方法）前调用。</p>
<h2 id="其他Aware接口"><a href="#其他Aware接口" class="headerlink" title="其他Aware接口"></a>其他Aware接口</h2><p>除了上面讨论的<strong>ApplicationContextAware</strong>和<strong>BeanNameAware</strong>之外，Spring还提供了一系列Aware接口，允许bean指示容器他们需要某个基础框架依赖。最重要的Aware接口总结如下-作为通用规则，它们的名称很好的指示了依赖类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>注入的依赖</th>
<th>在…解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ApplicationContextAware</strong></td>
<td>声明ApplicationContext</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>ApplicationEventPublisherAware</strong></td>
<td>封闭的ApplicationContext事件发布&#96;器</td>
<td><a href="#ApplicationContext%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD">7.15节“ApplicationContext的附加功能”</a></td>
</tr>
<tr>
<td><strong>BeanClassLoaderAware</strong></td>
<td>用于加载bean类的类加载器。</td>
<td><a href="#">第3.2节“实例化bean”</a></td>
</tr>
<tr>
<td><strong>BeanFactoryAware</strong></td>
<td>声明的BeanFactory</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>BeanNameAware</strong></td>
<td>声明bean的名称</td>
<td><a href="#ApplicationContextAware%E5%92%8CBeanNameAware">第6.2节“ApplicationContextAware和BeanNameAware”</a></td>
</tr>
<tr>
<td><strong>BootstrapContextAware</strong></td>
<td>容器运行的资源适配器BootstrapContext。通常仅在JCA感知的ApplicationContexts中可用</td>
<td><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#cci">第32章，JCA CCI</a></td>
</tr>
<tr>
<td><strong>LoadTimeWeaverAware</strong></td>
<td>定义了加载时处理类定义的weaver</td>
<td><a href="#"></a></td>
</tr>
<tr>
<td><strong>MessageSourceAware</strong></td>
<td>解析消息的配置策略（支持参数化和国际化）</td>
<td><a href="#"></a></td>
</tr>
<tr>
<td><strong>NotificationPublisherAware</strong></td>
<td>Spring JMX通知发布器</td>
<td><a href="#">第31.7节“通知”</a></td>
</tr>
<tr>
<td><strong>PortletConfigAware</strong></td>
<td>当前容器运行的PortletConfig。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第25章Portlet MVC框架</a></td>
</tr>
<tr>
<td><strong>PortletContextAware</strong></td>
<td>当前容器运行的PortletContext。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第25章Portlet MVC框架</a></td>
</tr>
<tr>
<td><strong>ResourceLoaderAware</strong></td>
<td>用于低级别访问资源配置的loader</td>
<td><a href="#">第8章 资源</a></td>
</tr>
<tr>
<td><strong>ServletConfigAware</strong></td>
<td>当前容器运行的ServletConfig。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第22章，Web MVC框架</a></td>
</tr>
<tr>
<td><strong>ServletContextAware</strong></td>
<td>当前容器运行的ServletContext。只有在Web感知的Spring ApplicationContext中才有效</td>
<td><a href="#">第22章，Web MVC框架</a></td>
</tr>
</tbody></table>
<hr>
<h1 id="Bean定义继承"><a href="#Bean定义继承" class="headerlink" title="Bean定义继承"></a>Bean定义继承</h1><hr>
<p>一个bean定义可以包含很多配置信息，包括构造方法参数，属性值和容器特定信息，如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以根据需要覆盖某些值，或者添加其他值。使用父和子bean定义可以节省大量的输入。实际上，这是模板的一种形式。</p>
<p>如果以编程方式使用<strong>ApplicationContext</strong>接口，子Bean定义由<strong>ChildBeanDefinition</strong>类表示。大多数用户不能在这个级别上使用它们，而是以类似于<strong>ClassPathXmlApplicationContext</strong>的方式声明地配置bean定义。当你使用基于XML的配置元数据时，你通过使用<strong>parent</strong>属性指定一个子bean的定义，指定父bean作为此属性的值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 值为1的age属性会从父级继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个子bean定义如果没有指定bean类的话则使用父级的定义，但也可以覆盖父级定义。在后一种情况，这个子bean必须兼容父级，也就是，它必须接受父级的属性值。</p>
<p>子bean继承父级的域，构造方法参数值，属性值，和方法重写，并可以添加新值。你指定的任何域，初始化方法，销毁方法，和&#x2F;或静态工厂方法会覆盖父级中相应的设置。</p>
<p>其余设置始终采用自子定义：depends on，自动装配模式，依赖关系检查，单例，延迟初始化。</p>
<p>上面的例子使用<strong>abstract</strong>属性明确标示父bean定义是抽象的。如果父定义没有指定一个类，则需要将父bean定义明确标识为抽象，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age会从父bean定义中继承值为1--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父bean不能自己实例化，因为它是不完整的，它也被明确标记为<strong>abstract</strong>。当一个定义像这样是“<strong>abstract</strong>“的，它只能用作纯模板bean定义，作为子定义的父定义。尝试使用这样一个抽象的父bean，当通过引用它作为另一个bean的<strong>ref</strong>属性或使用父bean <strong>id</strong>进行显式的<strong>getBean()<strong>调用，会返回一个错误。类似地，容器的内部</strong>preInstantiateSingletons()<strong>方法忽略被定义为</strong>abstract</strong>的bean定义。</p>
<blockquote>
<p><strong>ApplicationContext</strong>默认预实例化所有的单例。因此，重要的是（至少对于单例bean），如果你有一个（父）bean定义，你打算仅作为模板使用，并且这个定义指定了一个类，则必须确保将<strong>abstract</strong>属性设置为<strong>true</strong>，否则应用程序上下文将实际（尝试）预实例化这个抽象bean。</p>
</blockquote>
<hr>
<h1 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h1><hr>
<p>通常，应用程序开发人员不需要对<strong>ApplicationContext</strong>实现类进行子类化。相反，Spring IoC容器可以通过插入特殊集成接口的实现来扩展。接下来的几节将介绍这些集成接口。</p>
<h2 id="使用BeanPostProcessor自定义bean"><a href="#使用BeanPostProcessor自定义bean" class="headerlink" title="使用BeanPostProcessor自定义bean"></a>使用BeanPostProcessor自定义bean</h2><hr>
<p><strong>BeanPostProcessor</strong>接口定义了你可以实现的回调方法，以提供自己的（或覆盖容器的默认）实例化逻辑，依赖解析逻辑等。如果要在Spring容器完成实例化，配置和初始化bean之后实现一些自定义逻辑，则可以插入一个或多个<strong>BeanPostProcessor</strong>实现。</p>
<p>你可以配置多个<strong>BeanPostProcessor</strong>实例，并且可以通过设置<strong>order</strong>属性来控制这些BeanPostProcessors执行的顺序。只有当<strong>BeanPostProcessor</strong>实现了<strong>Ordered</strong>接口时，才能设置此属性;如果你编写自己的<strong>BeanPostProcessor</strong>，你也应该考虑实现<strong>Ordered</strong>接口。有关更多详细信息，请参阅<strong>BeanPostProcessor</strong>和<strong>Ordered</strong>接口的javadocs。另请参阅下面的关于编程式注册<strong>BeanPostProcessors</strong>的注释。</p>
<blockquote>
<p><strong>BeanPostProcessor</strong>操作bean（或对象）实例；也就是说，Spring Ioc容器实例化一个bean示例，然后<strong>BeanPostProcessor</strong>执行它的工作。<br><strong>BeanPostProcessor</strong>作用域在每个容器范围。这只有在使用容器层次结构时才有用。如果你在一个容器中定义了一个BeanPostProcessor，那么它只会对该容器中的bean进行post-process。换句话说，在一个容器中定义的bean不会被另一个容器中定义的BeanPostProcessor进行post-process，即使这两个容器都是同一层次结构的一部分。<br>要更改实际的bean定义（即定义bean的蓝图），你需要使用<strong>BeanFactoryPostProcessor</strong>，如第7.8.2节<a href="#%E4%BD%BF%E7%94%A8BeanFactoryPostProcessor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE">“使用BeanFactoryPostProcessor自定义配置元数据”</a>所述。</p>
</blockquote>
<p><strong>org.springframework.beans.factory.config.BeanPostProcessor</strong>接口只由两个回调方法组成。当这样的类在容器中被注册为post-processor时，对于由容器创建的每个bean实例，post-processor在容器初始化方法（诸如InitializingBean的afterPropertiesSet()和任何声明的init方法）被调用之前以及任何bean初始化回调之后，从容器中获取回调。post-processor可以对bean实例执行任何操作，包括完全忽略回调。bean post-processor通常检查回调接口，或者可能使用一个代理来包装bean。一些Spring AOP基础框架类被实现为bean post-processor，以提供代理包装逻辑。</p>
<p><strong>ApplicationContext</strong>会自动探测任何定义在配置元数据中实现了<strong>BeanPostProcessor</strong>接口的bean。<strong>ApplicationContext</strong>注册这些bean作为post-processor，以便稍后在创建bean时可以调用它们。Bean post-processor可以像任何其他bean一样部署在容器中。</p>
<p>注意，当在配置类上使用**@Bean<strong>工厂方法声明一个</strong>BeanPostProcessor<strong>时，工厂方法的返回类型应该是实现类本身或至少是</strong>org.springframework.beans.factory.config.BeanPostProcessor<strong>接口，清楚地表明该bean的post-processor性质。否则，</strong>ApplicationContext<strong>将无法在完全创建它之前按类型自动检测到它。由于为了在上下文中应用于其他bean的初始化，所以</strong>BeanPostProcessor**需要更早的实例化，这种早期类型检测至关重要。</p>
<ul>
<li><blockquote>
<p>虽然<strong>BeanPostProcessor</strong>注册的推荐方式是通过<strong>ApplicationContext</strong>自动检测（如上所述），但也可以使用<strong>addBeanPostProcessor</strong>方法对<strong>ConfigurableBeanFactory</strong>进行编程式注册。当需要在注册之前评估条件逻辑，或者甚至在层次结构中的背景上复制bean post-processor时，这可能是有用的。但是请注意，以编程方式添加的<strong>BeanPostProcessors</strong>不遵循<strong>Ordered</strong>接口。这里注册的顺序决定执行的顺序。还要注意，以编程方式注册的<strong>BeanPostProcessors</strong>始终在通过自动检测注册的那些之前进行处理，而不管是否有明确的排序。          </p>
</blockquote>
</li>
<li><blockquote>
<p>实现<strong>BeanPostProcessor</strong>接口的类是特殊的，并且被容器不同对待。作为<strong>ApplicationContext</strong>的特殊启动阶段的一部分，它们直接引用的所有<strong>BeanPostProcessors</strong>和Bean都将在启动时实例化。接下来，所有<strong>BeanPostProcessors</strong>都以排序的方式进行注册，并应用于容器中的所有其他bean。因为AOP自动代理以<strong>BeanPostProcessor</strong>本身实现，所以<strong>BeanPostProcessors</strong>和它们直接引用的bean都不具有自动代理的资格，因此没有组织它们的方面。<br>对于任何这样的bean，你应该看到一个信息日志消息：“Bean foo不符合所有BeanPostProcessor接口处理（例如：不符合自动代理资格）”的资格。<br>注意，如果你让bean使用自动装配或者**@Resource<strong>（它可能回退进行自动装配）装配到你的</strong>BeanPostProcessor<strong>，则Spring可能会在搜索类型匹配的候选对象时访问非预期的bean，从而使该</strong>BeanPostProcessor<strong>不符合自动代理或其他类型的bean  post-processing。例如，如果你使用</strong>@Resource**注解的的依赖，其中字段&#x2F; setter名称与bean的已声明名称不直接对应，并且注解没有使用name属性，那么Spring将访问其他bean以按类型进行匹配。</p>
</blockquote>
</li>
</ul>
<p>以下示例说明如何在<strong>ApplicationContext</strong>中编写，注册和使用<strong>BeanPostProcessors</strong>。</p>
<h3 id="示例：Hello-World，BeanPostProcessor-style"><a href="#示例：Hello-World，BeanPostProcessor-style" class="headerlink" title="示例：Hello World，BeanPostProcessor-style"></a>示例：Hello World，BeanPostProcessor-style</h3><hr>
<p>第一个例子说明了基本用法。该示例展示了一个自定义<strong>BeanPostProcessor</strong>实现，它调用每个由容器创建的bean的**toString()**方法，并将生成的字符串打印到系统控制台。</p>
<p>查找下面的自定义BeanPostProcessor实现类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单地返回实例化的bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean,</span></span><br><span class="line"><span class="params">            String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// 我们可能会在这里返回任何对象引用...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean,</span></span><br><span class="line"><span class="params">            String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; created : &quot;</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:lang</span>=<span class="string">&quot;http://www.springframework.org/schema/lang&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/lang</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/lang/spring-lang.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">&quot;messenger&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">script-source</span>=<span class="string">&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Fiona Apple Is Just So Dreamy.&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当上面的bean（messenger）被实例化，这个自定义BeanPostProcessor实现将事实输出到系统控制台</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;scripting.InstantiationTracingBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意InstantiationTracingBeanPostProcessor怎么被简单的定义。它甚至没有一个名字，因为它是一个bean，它可以像任何其他bean一样被依赖注入。（上述配置还定义了一个由Groovy脚本支持的bean，Spring动态语言支持在<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#dynamic-language">第35章“动态语言支持”</a>一章中详细介绍。</p>
<p>以下简单的Java应用程序执行上述代码和配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;scripting/beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">Messenger</span> <span class="variable">messenger</span> <span class="operator">=</span> (Messenger) ctx.getBean(<span class="string">&quot;messenger&quot;</span>);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述应用程序的输出类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean &#x27;messenger&#x27; created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>

<h3 id="示例：-RequiredAnnotationBeanPostProcessor"><a href="#示例：-RequiredAnnotationBeanPostProcessor" class="headerlink" title="示例： RequiredAnnotationBeanPostProcessor"></a>示例： RequiredAnnotationBeanPostProcessor</h3><p>将回调接口或注解与自定义BeanPostProcessor结合使用是扩展Spring IoC容器的常用手段。一个例子是Spring的RequiredAnnotationBeanPostProcessor - 一个Spring分发版附带的BeanPostProcessor实现，它确保被（任意）注解标记的bean上的JavaBean属性被实际（配置为）依赖注入一个值。</p>
<h2 id="使用BeanFactoryPostProcessor自定义配置元数据"><a href="#使用BeanFactoryPostProcessor自定义配置元数据" class="headerlink" title="使用BeanFactoryPostProcessor自定义配置元数据"></a>使用BeanFactoryPostProcessor自定义配置元数据</h2><hr>
<p>我们将看到的下一个扩展点是<strong>org.springframework.beans.factory.config.BeanFactoryPostProcessor</strong>。该接口的语义与<strong>BeanPostProcessor</strong>类似，主要区别在于：<strong>BeanFactoryPostProcessor</strong>对bean配置元数据进行操作;也就是说，Spring IoC容器允许<strong>BeanFactoryPostProcessor</strong>读取配置元数据，并可能在容器实例化除<strong>BeanFactoryPostProcessors</strong>之外的任何Bean之前,会更改它。</p>
<p>你可以配置多个<strong>BeanFactoryPostProcessors</strong>，并且可以通过设置order属性来控制这些BeanFactoryPostProcessors执行的顺序。但是，你只能在BeanFactoryPostProcessor实现了Ordered接口，才能设置此属性。如果你编写自己的BeanFactoryPostProcessor，你也应该考虑实现Ordered接口。有关更多详细信息，请参阅BeanFactoryPostProcessor和Ordered接口的javadocs。</p>
<blockquote>
<p>如果要更改实际的bean实例（即从配置元数据创建的对象），则需要使用BeanPostProcessor（如第8.1节“使用BeanPostProcessor自定义bean”中所述）。尽管在技术上可以在BeanFactoryPostProcessor中使用bean实例（例如，使用BeanFactory.getBean()），但这样做会导致过早的bean实例化，违反了标准容器生命周期。这可能会导致负面的副作用，如旁路bean后处理。此外，BeanFactoryPostProcessors作用域在每个容器范围。这只有在使用容器层次结构时才有用。如果在一个容器中定义了一个BeanFactoryPostProcessor，那么它只会应用于该容器中的bean定义。一个容器中的Bean定义不会被另一个容器中的BeanFactoryPostProcessors进行post-processed，即使这两个容器都是同一层次结构的一部分。</p>
</blockquote>
<p>当在<strong>ApplicationContext</strong>中声明一个<strong>BeanFactoryPostProcessor</strong>，它会被自动执行以便对定义容器的配置元数据进行更改。Spring包括一些预定义的BeanFactoryPostProcessor，如<strong>PropertyOverrideConfigurer</strong>和<strong>PropertyPlaceholderConfigurer</strong>。例如，也可以使用自定义BeanFactoryPostProcessor来注册自定义属性编辑器。</p>
<p><strong>ApplicationContext</strong>自动检测部署到其中的任何实现<strong>BeanFactoryPostProcessor</strong>接口的bean。它在适当的时候使用这些bean作为<strong>BeanFactoryPostProcessor</strong>。你可以像任何其他bean一样部署这些后处理器bean。</p>
<blockquote>
<p>与<strong>BeanPostProcessors</strong>一样，你通常不想将<strong>BeanFactoryPostProcessors</strong>配置为延迟初始化。如果没有其他bean引用一个Bean(Factory)PostProcessor，那么后处理器根本不会被实例化。因此，它的懒加载标记会被忽略，即使在**&lt;beans&#x2F;&gt;<strong>元素的声明中将</strong>default-lazy-init**属性设置为true，Bean(Factory)PostProcessor也会被立即实例化。</p>
</blockquote>
<h3 id="示例：类名替换PropertyPlaceholderConfigurer"><a href="#示例：类名替换PropertyPlaceholderConfigurer" class="headerlink" title="示例：类名替换PropertyPlaceholderConfigurer"></a>示例：类名替换PropertyPlaceholderConfigurer</h3><p>你可以使用**PropertyPlaceholderConfigurer **在使用了标准的Java Properties格式的单独的文件中从bean定义外部化属性值。这样做使得部署应用程序的人可以自定义环境特定的属性（如数据库URL和密码），避免修改容器的主要XML定义文件或文件的复杂性及风险。</p>
<p>考虑以下基于XML的配置元数据片段，其中定义了带有占位符值的<strong>DataSource</strong>。该示例显式从外部<strong>Properties</strong>文件配置的属性。在运行时，<strong>PropertyPlaceholderConfigurer</strong>应用于将替换<strong>DataSource</strong>的某些属性的元数据。被替换的值被指定为遵循Ant&#x2F;log4j&#x2F;JSP EL风格的**${property-name}**形式的占位符。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/foo/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际值来自另一个文件，以标准Java Properties格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
<p>因此，字符串${jdbc.username}在运行时被替换为值“sa”，同样适用于与属性文件中的键匹配的其他占位符值。<strong>PropertyPlaceholderConfigurer</strong>在一个bean中多数properties和attributes中检查占位符。此外，可以定制占位符前缀和后缀。</p>
<p>使用Spring 2.5引入的<strong>context</strong>命名空间，可以使用专用配置元素配置属性占位符。一个或多个位置可以在<strong>location</strong>属性中以用逗号分隔列表提供。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/foo/jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>PropertyPlaceholderConfigurer</strong>不仅在你指定的Properties文件中查找属性。默认如果它没有在指定的属性文件中找到一个属性，它还将检查Java系统属性。你可以通过将<strong>configurer</strong>的<strong>systemPropertiesMode</strong>属性设置为以下三个支持的整数值之一来自定义此行为：</p>
<ul>
<li>从不（0）：从不检查系统属性</li>
<li>回退（1）：如果在指定的属性文件中没有可解析的，则检查系统属性。这个是默认设置</li>
<li>覆盖（2）：首先检查系统属性，然后再尝试指定的属性文件。这允许系统属性覆盖任何其他属性源。</li>
</ul>
<p>有关详细信息，请参阅PropertyPlaceholderConfigurer javadocs。</p>
<blockquote>
<p>你可以使用PropertyPlaceholderConfigurer来替换类名，这在运行时必须选择特定的实现类时有时很有用。例如：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;$&#123;custom.strategy.class&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果类不能在运行时解析为有效类，那么即将要创建的bean的解析失败，对于非延迟初始化的bean这发生在<strong>ApplicationContext</strong>的**preInstantiateSingletons()**阶段期间。</p>
<h3 id="示例：PropertyOverrideConfigurer"><a href="#示例：PropertyOverrideConfigurer" class="headerlink" title="示例：PropertyOverrideConfigurer"></a>示例：PropertyOverrideConfigurer</h3><p>另一个bean工厂后处理器的<strong>PropertyOverrideConfigurer</strong>与<strong>PropertyPlaceholderConfigurer</strong>类似，但是不像后者那样，原始bean定义可以具有默认值或根本没有任何值用于bean属性。如果一个用于覆盖的Properties文件没有某个bean属性的条目，则使用默认上下文定义。</p>
<p>请注意，bean定义感知不到被覆盖，所以从XML定义文件中不能立即显式覆盖configurer正在被使用。如果多个<strong>PropertyOverrideConfigurer</strong>实例为同一个bean属性定义不同的值，由于覆盖机制而获胜，最后一个覆盖值生效。</p>
<p>属性文件配置行采用以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanName.property=value</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql:mydb</span><br></pre></td></tr></table></figure>
<p>此示例文件可以与包含称为dataSource的bean的容器定义一起使用，这个bean有一个driver和url属性。</p>
<p>还支持复合属性名称，只要除了要被覆盖的最终属性外，路径的每个组件都已经是非null（可能由构造方法初始化）。在这个例子中…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.fred.bob.sammy=123</span><br></pre></td></tr></table></figure>
<p>foo bean的fred属性的bob属性的sammy属性设置为标量值123。</p>
<blockquote>
<p>指定的覆盖值始终为字面值;它们不会被转换为bean引用。当XML bean定义中的原始值指定一个bean引用时，此约定也适用。</p>
</blockquote>
<p>使用Spring 2.5引入的context命名空间时，可以使用专用配置元素配置属性覆盖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">&quot;classpath:override.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用FactoryBean自定义实例化逻辑"><a href="#使用FactoryBean自定义实例化逻辑" class="headerlink" title="使用FactoryBean自定义实例化逻辑"></a>使用FactoryBean自定义实例化逻辑</h2><hr>
<p>为自己的工厂的对象实现<strong>org.springframework.beans.factory.FactoryBean</strong>接口。</p>
<p><strong>FactoryBean</strong>接口是Spring IoC容器的实例化逻辑的可插入点。如果你有复杂的初始化代码，那么它可以在Java中更好的表达，而不是在一堆（可能）冗长的XML中，你可以创建自己的<strong>FactoryBean</strong>，在该类中编写复杂的初始化，然后将你的自定义<strong>FactoryBean</strong>插入容器。</p>
<p>FactoryBean接口提供三种方法：</p>
<ul>
<li><strong>Object getObject()</strong>: 返回此工厂创建的对象的实例。该实例可能是共享的，这取决于这个工厂是否返回单例或原型。</li>
<li><strong>boolean isSingleton()</strong>: 如果此FactoryBean返回单例则返回true，否则返回false。</li>
<li><strong>Class getObjectType()</strong>: 返回getObject()方法返回的对象类型，如果类型未提前知道，则返回null。</li>
</ul>
<p>FactoryBean的概念和接口在Spring Framework中的许多地方使用; FactoryBean接口的50多个实现与Spring本身一起运行。</p>
<p>当你需要向容器询问实际的<strong>FactoryBean</strong>实例本身而不是其生成的bean时，在调用<strong>ApplicationContext</strong>的<strong>getBean()<strong>方法时，使用</strong>＆</strong>符号（＆）来表示bean的id。所以对于给定的FactoryBean，其ID为myBean，在容器上调用**getBean(“myBean”)<strong>返回FactoryBean的产物;而调用</strong>getBean(“＆myBean”)**则返回FactoryBean实例本身。</p>
<hr>
<h1 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h1><hr>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">**注解比XML更适合配置Spring吗？**      
基于注解配置的引入产生了这样一个问题，这种方式比XML更好吗？短的答案是看情况。长的答案是每种方式都有它自己的优缺点，并且通常由开发人员决定哪种策略更适合他们。由于它们被定义的方式，注解在它们的声明中提供了大量的上下文，从而使配置更短，更简洁。然而，XML非常适合在不接触源代码或重新编译组件的情况下组装组件。一些开发人员喜欢将装配就近源代码，而其他开发者认为注解类不再是POJO，此外，配置变得分散化，难以控制。      
无论怎么选择，Spring都可以容纳这两种风格，甚至将它们混合在一起。需要指出的是，通过其JavaConfig选项，Spring允许以非侵入式的方式使用注解，而不用触及目标组件源代码，并且而在工具方面，Spring Tool Suite支持所有配置样式。
</div> 
基于注解的配置提供了XML配置的替代方法，这种配置依赖于字节码元数据来装配组件，而不是角括号声明。相比使用XML来声明一个bean装配，开发者通过在相关类，方法，字段声明上使用注解，将配置移动到组件类本身。正如在“示例：RequiredAnnotationBeanPostProcessor"一节中所提到的，使用** BeanPostProcessor** 结合注解是扩展Spring IoC容器的常用手段。例如，Spring 2.0使用**@Required**注解强制执行注入所需的属性。Spring 2.5使得可以遵循相同的通用方式来驱动Spring的依赖注入。实质上，**@Autowired**注解提供了与第4.5节 [“自动装配协作者"](#自动装配协作者) 中所述相同的功能，但具有更细粒度的控制和更广泛的适用性。Spring 2.5还添加了对JSR-250注解的支持，如**@PostConstruct**和**@PreDestroy**。Spring 3.0增加了javax.inject包中包含的JSR-330（用于Java的依赖注入）注解，例如**@Inject**和**@Named**。有关这些注解的详细信息，请参见 [相关章节]()。

<blockquote>
<p>注解注入在XML注入之前执行，因此通过这两种方式进行注入时，后一种配置会覆盖前面的属性装配。</p>
</blockquote>
<p>和之前一样，你可以以单独的bean定义来注册，但也可以通过在基于XML的Spring配置中包含以下标签来隐式注册（注意包含的<strong>context</strong>命名空间）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（隐式注册的post-processors包括<strong>AutowiredAnnotationBeanPostProcessor</strong>，<strong>CommonAnnotationBeanPostProcessor</strong>，<strong>PersistenceAnnotationBeanPostProcessor</strong>以及前述的<strong>RequiredAnnotationBeanPostProcessor</strong>。）</p>
<blockquote>
<p> <strong>&lt;context:annotation-config&#x2F;&gt;<strong>只在和它在同一个应用程序上下文中的bean上查找注解。这意味着，如果在</strong>DispatcherServlet</strong>的<strong>WebApplicationContext</strong>中放置了**&lt;context:annotation-config&#x2F;&gt;<strong>，它只检查conroller中的</strong>@Autowired** bean，而不在service中。更多信息请查看第22.2节 <a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc-servlet">“The 于DispatcherServlet”</a>。</p>
</blockquote>
<h2 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h2><hr>
<p><strong>@Required</strong>注解应用于bean属性的setter方法，如下面示例所示&#96;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此注解只是表示受影响的bean属性必须在配置的时候通过bean定义中的显式属性值或通过自动装配来填充。如果受影响bean属性没有被填充，容器会抛出一个异常；这允许急切和明确的失败，在以后避免<strong>NullPointerExceptions</strong>等异常。它还建议你将断言放入bean类本身，例如，将其放入<strong>init</strong>方法中。这样做确保这些必须的引用和值，即使你在容器外使用这个类。</p>
<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><hr>
<blockquote>
<p>以下示例中可以使用JSR 330的**@Inject<strong>注解来代替Spring的</strong>@Autowired**注解。请参阅 <a href="">这里</a> 了解更多详情。</p>
</blockquote>
<p>你可以将**@Autowired**注解应用到构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从Spring Framework 4.3开始，如果目标bean只定义一个构造方法，则**@Autowired**构造方法不再需要。如果有几个构造方法可用，至少必须注解一个构造方法来指导容器必须使用哪个构造方法。</p>
</blockquote>
<p>如预期的那样，你还可以将**@Autowired**注解应用于“传统”setter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以将注解应用于具有任意名称和&#x2F;或多个参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以将**@Autowired**应用于字段，甚至将其与构造方法进行混合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过将注解添加到期望特定类型数组的字段或方法上，从ApplicationContext提供该类型的所有bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样适用于类型集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你希望将数组或列表中的项目按特定顺序排序话，你的bean可以实现<strong>org.springframework.core.Ordered</strong>接口，或者要么使用**@Order<strong>要么使用标准的</strong>@Priority**。</p>
</blockquote>
<p>只要预期的键的类型为String，即使类型Map也可以自动装配。 Map值将包含预期类型的​​所有bean，键将包含相应的bean名称：Map值将包含预期类型的​​所有bean，键将包含相应的bean名称：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，自动装配会在没有候选bean可用时失败；因为默认会将被注解的方法，构造方法和字段视为必须依赖。这可以通过如下来修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个类只有一个注解的构造方法可以被标记为必须的，但是可以注解多个构造方法为非必须。在这种情况下，每个被考虑在候选之中，并且Spring使用最贪婪（greediest）的构造方法，也就是有最多参数的构造方法，该构造方法的依赖将被满足。**@AutoWired的required属性建议使用@Required注解代替。<strong>required属性表示该属性对于自动装配目的不是必需的，如果不能被自动装配，那么该属性将被忽略。另一方面，</strong>@Required**更强大，它强迫属性必须被容器支持的任何bean设置，如果没有注入值，则会引发相应的异常。</p>
</blockquote>
<p>你还可以对于众所周知的可解析的依赖接口使用@Autowired：<strong>BeanFactory</strong>, <strong>ApplicationContext</strong>, <strong>Environment</strong>,** ResourceLoader**, <strong>ApplicationEventPublisher</strong>, 和 <strong>MessageSource</strong>。这些接口以及它们的拓展接口（比如<strong>ConfigurableApplicationContext</strong>或<strong>ResourcePatternResolver</strong>）是自动解析的，不需要特殊设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> **@Autowired **， **@Inject **， **@Resource **和 **@Value **注解由Spring  **BeanPostProcessor **实现处理，这又意味着你不能在自己的 **BeanPostProcessor **或 **BeanFactoryPostProcessor **类型（如果有的话）中应用这些注解。这些类型必须通过XML或使用Spring @Bean方法显式地“装配”。</p>
</blockquote>
<h2 id="使用限定符微调基于注解的自动装配"><a href="#使用限定符微调基于注解的自动装配" class="headerlink" title="使用限定符微调基于注解的自动装配"></a>使用限定符微调基于注解的自动装配</h2><hr>
<p>因为通过类型的自动装配可能导致多个候选者，它经常需要对选择的过程有更多的控制。完成这项工作的一个方式是使用Spring的**@Primary<strong>注解。</strong>@Primary**表示当多个bean是自动装配到一个单值依赖的候选者时，给定一个特定的bean优先权。如果候选人中只存在一个“主要”bean，那么它将是自动装配的值。</p>
<p>让我们假设我们下面的配置，它定义firstMovieCatalog作为主要的MovieCatalog。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的配置，以下MovieRecommender将会使用firstMovieCatalog自动注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的bean定义如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-Qualifier微调基于注解的自动装配"><a href="#使用-Qualifier微调基于注解的自动装配" class="headerlink" title="使用@Qualifier微调基于注解的自动装配"></a>使用@Qualifier微调基于注解的自动装配</h2><hr>
<p>当使用通过类型的注解，有多个实例匹配确定一个主要候选者时，**@Primary<strong>是一种有效方式。当对选择过程需要更多控制时，可以使用Spring的</strong>@Qualifier**注解。你可以将qualifier值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的bean。在最简单的情况下，这可以是一个简单的描述性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;main&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Qualifier</strong>注解也可以在各个构造方法参数或方法参数中指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="meta">@Qualifier(&quot;main&quot;)</span>MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的bean定义如下所示。具有qualifier值“main”的bean，使用具有相同值的qualifier的构造方法参数进行装配。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;main&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;action&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于回退匹配，bean名称被认为是默认qualifier值。因此，你可以使用id“main”来定义bean，而不是嵌套的qualifier元素，这导致相同的匹配结果。但是，尽管你可以使用这个惯例通过名称引用特定的bean，但是@Autowired从根本上是关于使用可选语义qualifier的类型驱动的注入。这意味着即使使用bean名称回退，qualifier值在类型匹配集合中总是具有缩小的语义;他们没有在语义上表达对唯一bean ID的引用。良好的qualifier值是“main”或“EMEA”或“persistent”，表示独立于bean id的特定组件的特征，可以在上述示例中的匿名bean定义的情况下自动生成。</p>
<p>Qualifiers也适用于上面讨论的类型集合，例如Set&lt;MovieCatalog&gt;。在这个情况下，根据声明的qualifier所有匹配的bean作为集合被注入。这意味着qualifier不一定是唯一的;它们只是构成过滤的标准。例如，你可以使用相同的qualifier值“action”定义多个MovieCatalog bean，所有这些都将注入到使用@Qualifier(“action”)注解的Set&lt;MovieCatalog&gt;中。</p>
<blockquote>
<p>如果你打算使用按名称的注解驱动注入，那么不要主要使用@Autowired，即使在技术上能够通过@Qualifier值引用一个bean名称。而是使用JSR-250 @Resource注解，它通过它的唯一名称语义定义识别一个指定的目标组件，声明的类型和匹配过程无关。@Autowired有不同的语义：在按类型选择候选bean之后，指定的String限定符值只有在这些类型选择的候选者才会被考虑，例如，匹配一个“account”限定符与与标记有相同限定符标签的bean。对于被定义为collection&#x2F;map或数组类型的bean，@Resource是一个更好的解决方法，通过唯一名称来引用指定的集合或数组bean。也就是说，从4.3开始，只要元素类型信息保存在@Bean返回类型签名或集合继承层次结构中，就可以通过Spring的@Autowired类型匹配算法来匹配collection&#x2F;map和数组类型。在这种情况下，限定符值可用于在相同类型的集合中进行选择，如前一段所述。<br>从4.3开始，@Autowired还考虑注入自引用，即引用回目前注入的bean。注意自注入是一个回退；对其他组件的常规依赖性始终优先。在这个意义上，自我引用不参与正式的候选人选择，因此特别的从不会是primary;相反，他们总是作为最低的优先级。在实践中，仅使用自我引用只作为最后的手段。例如，通过bean的事务代理在同一个实例上调用其他方法：在这种情况下，考虑将受影响的方法分解为单独的委托bean。或者，使用@Resource，它可以通过其唯一的名称获取代理回到当前的bean。@Autowired适用于字段，构造方法和多参数方法，允许在参数级别缩小qualifier注解。相比之下，@Resource仅支持具有单个参数的字段和bean属性setter方法。因此，如果你的注入目标是构造方法或多参数方法，请坚持使用qualifier。</p>
</blockquote>
<p>你可以创建你自己的自定义qualifier注解。简单定一个一个注解，并且在你的定义中提供@Qualifier注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以在自动装配的字段和参数上提供这个自定义qualifier：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Genre(&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setComedyCatalog</span><span class="params">(<span class="meta">@Genre(&quot;Comedy&quot;)</span> MovieCatalog comedyCatalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，提供关于候选bean定义的信息。你可以添加&lt;qualifier&#x2F;&gt;标签作为&lt;bean&#x2F;&gt;标签的子元素，然后指定type和value来匹配你的自定义qualifier注解。type是匹配注解的完全限定类名。或者，如果没有名称冲突的风险存在，为了方便你也可以使用简短类名称。这两种方式都在下面的示例中演示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;Genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;example.Genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieRecommender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.MovieRecommender&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在10节<a href="">“类路径扫描和托管组件”</a>中，你将看到一个相比以XML格式提供qualifier元数据，基于注解的替代方法。具体来说，请参见第10.8节<a href="">“使用z注解提供qualifier元数据”</a>。</p>
<p>在某些情况下，使用没有value的注解可能就足够了。当注解提供更通用的目的并且可以跨几种不同类型的依赖被应用时，这可能是有用的。例如，当没有Internet连接可用时将被搜索，你可能会提供一个离线目录。首先定义这个简单的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加这个注解到需要自动装配的字段或属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Offline</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在bean定义仅需要一个qualifier type：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;Offline&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你也可以定义接收命名属性自定义qualifier注解，取代这个简单的value属性。如果要在被自动装配的一个字段或参数上指定多个属性值，则bean应以必须与所有这些属性值相匹配才会被视为自动装配候选者。作为示例，考虑下面的注解定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">genre</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Format <span class="title function_">format</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里Format是一个枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Format</span> &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要自动装配的字段被用自定义qualifier注解，并且包含这两个属性值：genre和format。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，bean定义应该包含匹配的限定符值。这个示例还说明了可以使用bean meta属性替代&lt;qualifier&#x2F;&gt;子元素。如果可用，则&lt;qualifier&#x2F;&gt;及其属性优先，但如果不存在这样的qualifier，则自动装配机制将回退在&lt;meta&#x2F;&gt;标记中提供的值上，如以下示例中的最后两个bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;MovieQualifier&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;VHS&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">&quot;MovieQualifier&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;VHS&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DVD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Action&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;format&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BLURAY&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;genre&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Comedy&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入此bean所需的任何依赖项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用泛型作为自动装配限定符"><a href="#使用泛型作为自动装配限定符" class="headerlink" title="使用泛型作为自动装配限定符"></a>使用泛型作为自动装配限定符</h2><hr>
<p>除了@Qualifier注解之外，还可以使用Java泛型类型作为隐式形式的限定。例如，假设你有以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StringStore <span class="title function_">stringStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringStore</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IntegerStore <span class="title function_">integerStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntegerStore</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设上面的bean实现了泛型接口，即Store&lt;String&gt;和Store&lt;Integer&gt;, 你可以@Autowired这个Store接口并且泛型会被用作限定符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier,注入stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier,注入integerStore bean</span></span><br></pre></td></tr></table></figure>
<p>当自动装配List，Map和Array时，泛型qualifier同样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要Store bean有一个 &lt;Integer&gt;泛型，就会注入所有的这样的Store bean</span></span><br><span class="line"><span class="comment">// Store&lt;String&gt; beans不会出现在这个list中</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h2 id="CustomAutowireConfigurer"><a href="#CustomAutowireConfigurer" class="headerlink" title="CustomAutowireConfigurer"></a>CustomAutowireConfigurer</h2><hr>
<p>CustomAutowireConfigurer是一个BeanFactoryPostProcessor，它可以使你注册你自己的自定义qualifier注解类型，即使它们没有使用Spring的@Qualifier注解进行注解。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customAutowireConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customQualifierTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>AutowireCandidateResolver通过以下方式确定自动装配候选者：</p>
<ul>
<li>每个bean定义的autowire-candidate值</li>
<li>然后在&lt;beans&#x2F;&gt;可用的default-autowire-candidates模式</li>
<li>@Qualifier注解的存在以及使用CustomAutowireConfigurer注册的所有自定义注解。</li>
</ul>
<p>当多个bean符合自动装配候选者时，决定哪一个为“primary”方式如下：如果候选人中只有一个bean定义的primary 属性设置为true，它会被选择。</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><hr>
<p>Spring还支持使用JSR-250 <strong>@Resource</strong>注解对字段或bean属性的setter方法进行注入。这是Java EE 5和6中的常见模式，例如在JSF 1.2管理的bean或JAX-WS 2.0的端点中。Spring也对Spring管理的对象支持这种模式。</p>
<p><strong>@Resource</strong>接收一个<strong>name</strong>属性，并且默认情况下，Spring将该值作为要注入的bean名称进行解释。换而言之，它遵循按名称语义，如下示例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name=&quot;myMovieFinder&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有明确指定name，则默认name来自字段名称或setter方法。在一个字段的情景下，它接收一个字段名称；在一个setter方法的情景下，它接收这个bean属性名称。所以下面示例是将名为“movieFinder”的bean注入到其setter方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该注解提供的name通过<strong>CommonAnnotationBeanPostProcessor</strong>感知的<strong>ApplicationContext</strong>解析为一个bean名称。如果明确配置Spring的<strong>SimpleJndiBeanFactory</strong>，可以通过JNDI解析名称。但是，建议你依赖默认行为，只需使用Spring的JNDI查找功能来保留间接级别。</p>
</blockquote>
<p>在**@Resource<strong>使用没有指定明确的名称的情况下，类似于</strong>@Autowires<strong>，</strong>@Resource<strong>查找一个主类型匹配，而不是一个指定的命名bean，并解析众所周知的可解析依赖：</strong>BeanFactory<strong>，</strong>ApplicationContext<strong>，</strong>ResourceLoader<strong>，</strong>ApplicationEventPublisher<strong>和</strong>MessageSource**接口。</p>
<p>因此在下面的示例中，<strong>customerPreferenceDao</strong> 字段首先查找一个命名为<strong>customerPreferenceDao</strong>的bean，然后回退到类型为<strong>CustomerPreferenceDao</strong>的主类型匹配。“<strong>context</strong>“字段是基于已知的可解析依赖类型ApplicationContext来注入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><hr>
<p><strong>CommonAnnotationBeanPostProcessor</strong>不仅可以识别**@Resource<strong>注解，还可以识别JSR-250生命周期注解。在Spring 2.5中引入，对这些注解的支持提供了在 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83">初始化回调</a>和<a href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"> 销毁回调</a>中描述的另一种替代方法。只要</strong>CommonAnnotationBeanPostProcessor**在Spring <strong>ApplicationContext</strong>中注册，带有这些注解之一的方法，是在生命周期中与相应的Spring生命周期接口方法或明确声明的回调方法相同的时间点调用。在下面示例，缓存将在初始化时预先填充，并在销毁时清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateMovieCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在初始化时填充电影缓存...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMovieCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在销毁时清除电影缓存...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关组合各种生命周期机制的影响的详细信息，请参阅<a href="#%E7%BB%84%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6">“组合生命周期机制”</a>一节。</p>
</blockquote>
<hr>
<h1 id="类路径扫描和管理的组件"><a href="#类路径扫描和管理的组件" class="headerlink" title="类路径扫描和管理的组件"></a>类路径扫描和管理的组件</h1><hr>
<p>本章中的大多数示例使用XML指定在Spring容器内生成每个<strong>BeanDifinition</strong>的配置元数据。前一节（第9节“基于注释的容器配置”）演示了如何通过源代码级注解提供大量配置元数据。然而，即使在这些例子中，“基本”bean定义也是在XML文件中明确定义的，而注解只是用来驱动依赖注入。本节介绍通过扫描类路径隐式检测候选组件的选项。候选组件是与过滤器条件匹配并且在容器内有对应的bean定义注册。这消除了使用XML来执行bean注册的需要;作为代替，你可以使用注解（例如**@Component**），AspectJ类型表达式，或者你自己的自定义过滤条件来选择哪些类会有在容器里的bean定义注册。</p>
<blockquote>
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring框架的一部分。这允许你使用Java而不是传统的XML文件定义bean。有关如何使用这些新功能的示例，请查看@Configuration，@Bean，@Import和@DependsOn注释。</p>
</blockquote>
<h2 id="Component和更多模型注解"><a href="#Component和更多模型注解" class="headerlink" title="@Component和更多模型注解"></a>@Component和更多模型注解</h2><hr>
<p><strong>@Repository</strong>注解是任何满足存储库（也称为数据访问对象或DAO）角色或原型的类的标记。该标记的用途是自动翻译异常，如第20.2.2节<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#orm-exception-translation">“异常翻译”</a>所述。</p>
<p>Spring提供了更多的模型注解：**@Component<strong>，</strong>@Service<strong>和</strong>@Controller<strong>。</strong>@Component<strong>是对任何Spring管理的组件的通用模型。</strong>@Repository<strong>，</strong>@Service<strong>和</strong>@Controller<strong>是针对更具体使用场景的专用化</strong>@Component<strong>例如，分别用于持久化，服务和表示层中。因此，你可以使用</strong>@Component<strong>对组件类进行注解，但通过使用</strong>@Repository<strong>，</strong>@Service<strong>或</strong>@Controller**注解它们，你的类更适合于通过工具或相关方面进行处理。例如，这些模型注解是切面点的理想目标。还有可能@Repository，@Service和@Controller可能会在未来的Spring框架发布版中带来额外的语义。因此，如果你在你的服务层在@Component和@Service中选择，@Service显然是更好的选择。类似的，如上所述，@Repository已被支持作为持久层中自动异常转换的标记。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><hr>
<p>许多Spring提供的注解可以在你自己的代码中用作元注解。元注解只是可以应用于其他注解的注解。例如，上面提到的**@Service<strong>注解是使用</strong>@Component**进行元注解的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元注解也可以组合起来创建组合注解。例如，Spring MVC中的**@RestController<strong>注解由</strong>@Controller<strong>和</strong>@ResponseBody**组成。</p>
<p>此外，组合注解可以可选地从元注解重新声明属性以允许用户自定义。当你只想暴露这个元注解属性的子集的时候，这特别有用。例如，Spring的**@SessionScope**注解将域名称硬编码为session，但人允许定制proxyMode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SessionScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> Scope#proxyMode&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> ScopedProxyMode#TARGET_CLASS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Scope.class)</span></span><br><span class="line">    ScopedProxyMode <span class="title function_">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以使用**@SessionScope<strong>而不声明</strong>proxyMode**，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionScopedService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或对<strong>proxyMode</strong>使用一个覆盖值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionScopedUserService</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关更多详细信息，请参阅<a href="#http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#annotation-programming-model">Spring 注解编程模型</a>。</p>
<h2 id="自动检测类和注册bean定义"><a href="#自动检测类和注册bean定义" class="headerlink" title="自动检测类和注册bean定义"></a>自动检测类和注册bean定义</h2><hr>
<p>Spring可以自动探测模型类并且在<strong>ApplicationContext</strong>中注册相应的<strong>BeanDefinition</strong>。如下，以下两个类有资格进行这种自动检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要自动探测这些类并且注册相应的bean，你需要添加**@ComponentScan<strong>到你的</strong>@Configuration<strong>类，其中</strong>basePackages**属性是两个类的公共父包。（或者，你可以指定包含每个类的父包的逗号&#x2F;分号&#x2F;空格分隔列表。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了简洁，上述可能已经使用了注解的<strong>value</strong>属性，即**@ComponentScan(“org.example”)**</p>
</blockquote>
<p>以下是使用XML</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用**&lt;context:component-scan&gt;<strong>隐式启用</strong>&lt;context:annotation-config&gt;<strong>的功能。当使用</strong>&lt;context:component-scan&gt;<strong>时通常不需要包含</strong>&lt;context:annotation-config&gt;**元素。</p>
</blockquote>
<blockquote>
<p>classpath包的扫描需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请确保不激活JAR任务的仅文件切换。此外，classpath目录基于安全策略可能不会在某些环境中暴露出来，例如JDK 1.7.0_45及更高版本的独立app（这需要你的清单中的“受信任的库”设置;请参阅<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources%EF%BC%89%E3%80%82">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources）。</a></p>
</blockquote>
<p>此外，当你使用<strong>component-scan</strong>元素时，<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>都将被隐式包含。这意味着这两个组件是一起被自动检测和装配的，它们都没有在XML中提供的任何bean配置元数据。</p>
<blockquote>
<p>你可以通过包含值为<strong>false</strong>的<strong>annotation-config</strong>属性来禁用<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>的注册。</p>
</blockquote>
<h2 id="使用过滤器来自定义扫描"><a href="#使用过滤器来自定义扫描" class="headerlink" title="使用过滤器来自定义扫描"></a>使用过滤器来自定义扫描</h2><hr>
<p>默认情况下，使用**@Component<strong>，</strong>@Repository<strong>，</strong>@Service<strong>，</strong>@Controller<strong>，或其自身用</strong>@Component<strong>注解的自定义注解，注解的类是唯一被检测到的候选组件。然而，你只需要通过应用自定义过滤器就可以修改和拓展这个行为。将它们添加为</strong>@ComponentScan<strong>注解的</strong>includeFilters<strong>或</strong>excludeFilters<strong>参数（或者作为</strong>component-scan<strong>元素的</strong>include-filter<strong>或</strong>exclude-filter<strong>子元素）。每个过滤器元素需要</strong>type<strong>和</strong>expression**属性。下面表格描述了过滤选项。</p>
<table>
<thead>
<tr>
<th>过滤器type</th>
<th>expression示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>annotation(默认)</td>
<td>org.example.SomeAnnotation</td>
<td>存在于目标组件上的注解类型级别</td>
</tr>
<tr>
<td>assignable</td>
<td>org.example.SomeClass</td>
<td>目标组件被分配（拓展&#x2F;实现）的类（或接口）.</td>
</tr>
<tr>
<td>aspectj</td>
<td>org.example..*Service+</td>
<td>匹配目标组件的AspectJ类型表达式。</td>
</tr>
<tr>
<td>regex</td>
<td>org.example.Default.*</td>
<td>匹配目标组件类名称的正则表达式。</td>
</tr>
<tr>
<td>custom</td>
<td>org.example.MyTypeFilter</td>
<td>org.springframework.core.type.TypeFilter接口的自定义实现。</td>
</tr>
</tbody></table>
<p>以下示例显式忽略所有@Repository注解，而使用“stub”repositories的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span></span><br><span class="line"><span class="meta">        excludeFilters = @Filter(Repository.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于使用XML</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;.*Stub.*Repository&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你还可以通过在注解上设置<strong>useDefaultFilters&#x3D;false</strong>或将<strong>use-default-filters&#x3D;“false”<strong>作为</strong>&lt;component-scan&#x2F;&gt;<strong>元素的属性来禁用默认过滤器。这将实际上禁用使用</strong>@Component</strong>，**@Repository<strong>，</strong>@Service<strong>，</strong>@Controller<strong>或</strong>@Configuration**注解的类的自动检测。</p>
</blockquote>
<h2 id="在组件中定义bean元数据"><a href="#在组件中定义bean元数据" class="headerlink" title="在组件中定义bean元数据"></a>在组件中定义bean元数据</h2><hr>
<p>Spring组件还可以向容器提供bean定义元数据。你可以使用与**@Configuration<strong>注解类中定义bean元数据相同的</strong>@Bean**注解来执行此操作。这有一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">publicInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 组件方法实现忽略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是一个Spring组件，它的doWork()方法中包含特定于应用程序的代码。但是，它还提供了一个bean定义，它有一个工厂方法publicInstance()。这个@Bean注解标识工厂方法和其他bean定义属性，例如通过@Qualifier注解设置限定符值。可以指定的其他方法级注解是@Scope，@Lazy和自定义限定符注解。</p>
<blockquote>
<p>除了组件初始化的角色之外，@Lazy注解也可以放置在标有@Autowired或@Inject的注入点上。在这种情况下，它导致注入了一个懒解析代理。</p>
</blockquote>
<p>如前面讨论的也支持自动装配的字段和方法，它有对@Bean方法的自动装配的额外支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">publicInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义限定符和方法参数的自动装配</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> TestBean <span class="title function_">protectedInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;public&quot;)</span> TestBean spouse,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;#&#123;privateInstance.age&#125;&quot;)</span> String country)</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;protectedInstance&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">private</span> TestBean <span class="title function_">privateInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;privateInstance&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">requestScopedInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;requestScopedInstance&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例自动将String方法参数country装配为另一个名为privateInstance的bean的Age属性的值。Spring表达式语言元素通过符号#{&lt;expression&gt;}定义属性的值。对于@Value注解，一个表达式解析器在解析表达式文本的时候被预配置来查找bean名称。</p>
<p>从Spring框架4.3开始，你还可以声明InjectionPoint类型的工厂方法参数（或其更具体的子类DependencyDescriptor），以访问触发创建当前bean的请求注入点。请注意，这仅适用于实际bean实例的创建，而不适用于注入现有实例。因此，这个功能对于原型域bean最有意义。对于其他域，工厂方法只会看到在给定域内触发一个新的bean实例创建的注入点：例如，触发创建一个懒加载单例bean的依赖。在这种情况下，使用提供的注入点元数据进行语义关注。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">prototypeInstance</span><span class="params">(InjectionPoint injectionPoint)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(<span class="string">&quot;prototypeInstance for &quot;</span> + injectionPoint.getMember());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规Spring组件中的@Bean方法的处理方式和它们在Spring @Configuration类中的对应方法不同。不同之处在于，@Component类没有使用CGLIB来增强，以拦截方法和字段的调用。CGLIB代理是@​​Configuration类中的@Bean方法中调用方法或字段的方式，它们为协作对象创建bean元数据引用;这样的方法不是使用普通的Java语义来调用的，而是通过容器来调用，为了能够提供通常的生命周期管理和Spring bean代理，即使通过对@Bean方法编程调用来引用其他bean。相反，在普通的@Component类中调用@Bean方法中的方法或字段具有标准Java语义，没有特殊的CGLIB处理或其他限制。</p>
<blockquote>
<p>你可以将@Bean方法声明为static，允许调用它们，而无需创建它们包含的配置类作为实例。当定义后处理器时这尤其有意义，例如BeanFactoryPostProcessor和BeanPostProcessor类型，因为这样的bean将在容器生命周期早期初始化，并且应该避免在此时触发配置的其他部分。请注意，静态@Bean方法的调用永远不会被容器拦截，即使在@Configuration类中（见上文）。这是由于技术限制：CGLIB子类化只能覆盖非静态方法。因此，直接调用另一个@Bean方法将具有标准的Java语义，导致独立的实例直接从工厂方法返回。@Bean方法的Java语言可见性对Spring容器中生成的bean定义并没有立即的影响。你可以在非@Configuration类中以及任何地方的静态方法上自由声明你的工厂方法。但是，@Configuration类中的常规@Bean方法必须是可覆盖的，即不能将其声明为private或final。<br>@Bean方法也将在给定组件或配置类的基类上发现，以及由组件或配置类实现的接口中声明的Java 8 default 方法。这允许在组成复杂的配置布局上有很大的灵活性，甚至可以通过Java 8 default方法（从Spring 4.2起）实现多重继承。<br>最后，请注意，单个类可以为同一个bean持有多个@Bean方法，作为多个工厂方法的安排，以在运行根据可用依赖来使用。这与在其他配置方案中选择“greediest”构造方法或工厂方法的算法相同：具有最大数量的可满足依赖关系的变体将在构建时采用，类似于容器在多个@Autowired构造方法之间进行选择</p>
</blockquote>
<h2 id="命名自动检测的组件"><a href="#命名自动检测的组件" class="headerlink" title="命名自动检测的组件"></a>命名自动检测的组件</h2><hr>
<p>当组件作为扫描过程的一部分自动检测时，其bean名称由该扫描器已知的BeanNameGenerator策略生成。默认情况下，任何Spring模型注解（@Component，@Repository，@Service和@Controller）包含一个name value，从而将该名称提供给相应的bean定义。</p>
<p>如果一个不包含名称value的注解或任何其他检测到的组件（例如由自定义过滤器发现的组件），默认的bean名称生成器返回小写形式，非完全限定的类名称。例如，如果检测到以下两个组件，则名称将为myMovieLister和movieFinderImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;myMovieLister&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你不想依赖于默认的bean命名策略，你可以提供自定义bean命名策略。首先，实现BeanNameGenerator接口，并确保包含一个默认的无参构造方法。然后，在配置扫描器时提供完全限定的类名称：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">&quot;org.example.MyNameGenerator&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作为通用规则，只要当其他组件可能会明确引用时，考虑使用注解指定组件名称。另一方面，只要容器负责装配，自动生成的名称就足够了。</p>
<h2 id="为自动检测的组件提供域"><a href="#为自动检测的组件提供域" class="headerlink" title="为自动检测的组件提供域"></a>为自动检测的组件提供域</h2><hr>
<p>与Spring管理的组件一样，自动检测组件的默认和最常见的域是singleton。但是，有时你需要一个不同的域，这时你可以通过@Scope注解来制定。只要在注解重提供域名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关Web特定域的详细信息，请参见第5.4节[“Request, session, global session, application和 WebSocket域”](#Request, session, global session, application和 WebSocket域)。</p>
<blockquote>
<p>要为域解析提供自定义策略，而不是依赖基于注解的方式，请实现ScopeMetadataResolver接口，并确保包含一个默认的无参构造方法。然后，在配置扫描器时提供完全限定的类名称：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">scope-resolver</span>=<span class="string">&quot;org.example.MyScopeResolver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当使用某些非单例域时，可能需要为作用域对象生成代理。原因在<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96">“作用域bean作为依赖”</a>一节中已经描述。为此，scoped-proxy属性可以在component-scan元素中使用。三个可能的值是：no，interfaces和targetClass。例如，以下配置将导致标准的JDK动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, scopedProxy = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">scoped-proxy</span>=<span class="string">&quot;interfaces&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用注解提供限定符元数据"><a href="#使用注解提供限定符元数据" class="headerlink" title="使用注解提供限定符元数据"></a>使用注解提供限定符元数据</h2><hr>
<p>@Qualifier注解已经在第7.9.4节<a href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E5%BE%AE%E8%B0%83%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">“使用限定符微调基于注解的自动装配”</a>。该部分中的示例演示了@Qualifier注解的使用以及在你解析自动装配候选者时使用自定义限定符注解来提供更细粒度的控制。因为这些示例基于XML bean定义，所以使用XML中的bean元素的qualifier或meta子元素在候选bean定义上提供了限定符元数据。当依赖类路径扫描来自动检测组件时，你可以在候选类上使用那个类型级别注解来提供限定符元数据。以下三个例子说明了这种技术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;Action&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Genre(&quot;Action&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Offline</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieCatalog</span> <span class="keyword">implements</span> <span class="title class_">MovieCatalog</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与大多数基于注解的替代方案一样，，请注意，注解元数据绑定到类定义本身，而使用XML允许同一类型的多个bean提供他们限定符元数据的变体，因为元数据是为每个实例，而不是每个类提供的。</p>
</blockquote>
<hr>
<h1 id="使用JSR-330标准注解"><a href="#使用JSR-330标准注解" class="headerlink" title="使用JSR 330标准注解"></a>使用JSR 330标准注解</h1><hr>
<hr>
<h1 id="基于Java的容器配置"><a href="#基于Java的容器配置" class="headerlink" title="基于Java的容器配置"></a>基于Java的容器配置</h1><hr>
<h2 id="基本概念：-Bean-和-Configuration"><a href="#基本概念：-Bean-和-Configuration" class="headerlink" title="基本概念：@Bean 和@Configuration"></a>基本概念：@Bean 和@Configuration</h2><hr>
<p>Spring的新Java配置支持中的中心构件是**@Configuration<strong>注解的类和</strong>@Bean<strong>注解的方法。<br><strong>@Bean</strong>注解用于表示一个方法实例化，配置和初始化一个新的对象，以便由Spring IoC容器管理。对于那些熟悉Spring的</strong>&lt;beans &#x2F;&gt;** XML配置的人来说，**@Bean<strong>注解和</strong>&lt;beans &#x2F;&gt;<strong>元素具有相同的作用。你可以对任何Spring @Component使用</strong>@Bean<strong>注解方法，但是，它们通常与</strong>@Configuration** bean一起使用。<br>用**@Configuration<strong>注解一个类的主要目的是表明它是作为bean定义的来源。此外，</strong>@Configuration<strong>类允许通过简单地调用同一个类中的其他</strong>@Bean<strong>方法来定义bean之间依赖关系。可能最简单的</strong>@Configuration**类将如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的AppConfig类将等同于以下Spring <strong>&lt;beans &#x2F;&gt;</strong> XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #ccc;background-color:#f8f8f8;padding:20px;">全@Configuration vs 'lite'@Bean模式<br/>当**@Bean**方法在没有使用@Configuration的类注解中声明时，它们被称为在'lite'模式下处理。例如，在**@Component**中甚至在普通的旧的类中声明的bean方法将被视为'lite'。<br/>与完整的**@Configuration**不同，lite @Bean方法不能轻松声明bean间依赖关系。在'lite'模式下运行时，通常一个@Bean方法不应该调用另一个@Bean方法。<br/>仅在**@Configuration**类中使用@Bean方法是确保始终使用“完整”模式的推荐方法。这将防止相同的**@Bean**方法被意外调用多次，并有助于减少在'精简'模式下操作时难以追踪的细微错误。</div>
**@Bean**和**@Configuration**注解将在下面的章节中深入讨论。首先，我们将介绍使用基于Java的配置创建Spring容器的各种方法。

<h2 id="使用AnnotationConfigApplicationContext实例化Spring容器"><a href="#使用AnnotationConfigApplicationContext实例化Spring容器" class="headerlink" title="使用AnnotationConfigApplicationContext实例化Spring容器"></a>使用AnnotationConfigApplicationContext实例化Spring容器</h2><hr>
<p>下面的章节介绍Spring的AnnotationConfigApplicationContext，这是Spring 3.0中的新功能。这个多功能的ApplicationContext实现不仅可以接受@Configuration类作为输入，还可以接受@Component类以及用JSR-330元数据注解的普通类。<br>当提供@Configuration类作为输入时，@Configuration类本身被注册为一个bean定义，并且该类中所有声明的@Bean方法也被注册为bean定义。<br>当提供@Component和JSR-330类时，它们被注册为bean定义，并且假定在必要时在这些类中使用DI元数据（例如@Autowired或@Inject）。</p>
<h2 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h2><p>与使用Spring XML文件作为实例化ClassPathXmlApplicationContext的输入的方式类似，@Configuration类可用作实例化AnnotationConfigApplicationContext的输入。这允许完全无XML地使用Spring容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所述，AnnotationConfigApplicationContext不仅限与@Configuration类一起使用。任何@Component或JSR-330注解类都可作为输入提供给构造函数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面假设MyServiceImpl，Dependency1和Dependency2使用Spring依赖注入注解，例如@Autowired。</p>
<h2 id="使用register-Class-lt-gt-…-编程式构建容器"><a href="#使用register-Class-lt-gt-…-编程式构建容器" class="headerlink" title="使用register(Class&lt;?&gt;…)编程式构建容器"></a>使用register(Class&lt;?&gt;…)编程式构建容器</h2><p>AnnotationConfigApplicationContext可以使用无参数构造函数实例化，然后使用register（）方法进行配置。以编程方式构建AnnotationConfigApplicationContext时，此方法特别有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用scan-String…​-启用组件扫描"><a href="#使用scan-String…​-启用组件扫描" class="headerlink" title="使用scan(String…​)启用组件扫描"></a>使用scan(String…​)启用组件扫描</h2><p>要启用组件扫描，只需注解您的@Configuration类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有经验的Spring用户会熟悉Spring的XML声明congtenx：namespace</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.acme&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，将扫描com.acme包，查找任何@ Component注解的类，并且这些类将在容器中注册为Spring bean定义。AnnotationConfigApplicationContext公开scan(String …)方法以允许使用相同的组件扫描功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请记住@Configuration类是使用@Component进行元注解的，所以它们是组件扫描的候选对象！在上面的例子中，假设AppConfig是在com.acme包（或下面的任何包）中声明的，它将在调用scan())期间被拾取，并且在refresh())后，处理其所有的@Bean方法，在容器中注册为bean定义。</p>
</blockquote>
<h2 id="使用AnnotationConfigWebApplicationContext支持Web应用程序"><a href="#使用AnnotationConfigWebApplicationContext支持Web应用程序" class="headerlink" title="使用AnnotationConfigWebApplicationContext支持Web应用程序"></a>使用AnnotationConfigWebApplicationContext支持Web应用程序</h2><p>AnnotationConfigApplicationContext的WebApplicationContext变体可与AnnotationConfigWebApplicationContext一起使用。在配置Spring ContextLoaderListener servlet侦听器，Spring MVC DispatcherServlet等时，可以使用此实现。接下来是配置典型Spring MVC Web应用程序的web.xml片段。请注意contextClass context-param和init-param的使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置ContextLoaderListener以使用AnnotationConfigWebApplicationContext         </span></span><br><span class="line"><span class="comment">    而不是默认的XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置的位置必须包含一个或多个都好或空格分隔的</span></span><br><span class="line"><span class="comment">    完全限定的@Configuration类。完全限定包也可以指定为扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 像往常一样使用ContextLoaderListener引导根应用程序上下文 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 照常声明一个Spring MVC DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置DispatcherServlet以使用AnnotationConfigWebApplicationContext             </span></span><br><span class="line"><span class="comment">        而不是默认的XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--同样，配置位置必须包含一个或多个以逗号或空格分隔的位置            </span></span><br><span class="line"><span class="comment">         和完全限定的@Configuration类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将/ app / *的所有请求映射到调度servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-Bean注解"><a href="#使用-Bean注解" class="headerlink" title="使用@Bean注解"></a>使用@Bean注解</h2><hr>
<p>@Bean是一个方法级别的注解，并且等同XML &lt;bean &#x2F;&gt;元素的。注解支持&lt;bean &#x2F;&gt;提供的一些属性，例如：init-method，destroy-method，autowiring和name。<br>您可以在带有@ Configuration注解或带有@ Component注解的类中使用@Bean注解。</p>
<h3 id="声明一个bean"><a href="#声明一个bean" class="headerlink" title="声明一个bean"></a>声明一个bean</h3><p>要声明一个bean，只需使用@Bean注解来注解一个方法即可。您可以使用此方法在指定为方法返回值的类型的ApplicationContext中注册bean定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置完全等同于以下Spring XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个声明都在ApplicationContext中创建一个名为transferService的bean，绑定到TransferServiceImpl类型的对象实例：<br>transferService - &gt; com.acme.TransferServiceImpl</p>
<h3 id="Bean依赖"><a href="#Bean依赖" class="headerlink" title="Bean依赖"></a>Bean依赖</h3><p>@Bean注解的方法可以有任意数量的参数来描述构建bean所需的依赖项。例如，如果我们的TransferService需要一个AccountRepository，我们可以通过一个方法参数实现这个依赖关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析机制与基于构造函数的依赖注入非常相似，请参阅相关部分以获取更多详细信息。</p>
<h3 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h3><p>任何使用@Bean注解定义的类都支持常规生命周期回调，并且可以使用JSR-250中的@PostConstruct和@PreDestroy注解，请参阅JSR-250注释以获取更多详细信息。<br>常规的Spring生命周期回调也被完全支持。如果一个bean实现了InitializingBean，DisposableBean或Lifecycle，那么它们各自的方法由容器调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，Java配置定义的bean如果具有公共的close或shutdown方法，会被自动列入销毁回调。如果你有一个公共的close或shutdown方法，并且你不希望在容器关闭时调用它，只需在你的bean定义中添加@Bean(destroyMethod &#x3D;“”)来禁用默认（推断）模式。<br>您可能希望为通过JNDI获取的资源默认执行此操作，因为其生命周期在应用程序外部进行管理。特别是，确保始终为DataSource执行此操作，因为它已知在Java EE应用程序服务器上存在问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="string">&quot;MyDS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，使用@Bean方法，通常会选择使用编程式JNDI查找：使用Spring的JndiTemplate &#x2F; JndiLocatorDelegate帮助程序或直接使用JNDI InitialContext，但不使用JndiObjectFactoryBean变体，这会强制您将返回类型声明为FactoryBean类型，而不是实际的目标类型，使其更难用于其他@Bean方法中的交叉引用调用，这些方法打算引用所提供的资源</p>
<p>当然，就上面的Foo而言，在构造过程中直接调用init()方法同样有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">        foo.init();</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当您直接使用Java进行工作时，您可以对您的对象执行任何您喜欢的操作，并且不总是需要依赖容器生命周期！</p>
</blockquote>
<h3 id="指定bean域"><a href="#指定bean域" class="headerlink" title="指定bean域"></a>指定bean域</h3><h4 id="使用-Scope注解"><a href="#使用-Scope注解" class="headerlink" title="使用@Scope注解"></a>使用@Scope注解</h4><p>您可以指定使用@Bean注解定义的bean应该具有特定的作用域。您可以使用Bean Scopes部分中指定的任何标准域。<br>默认域是singleton，但您可以使用@Scope注解覆盖它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Encryptor <span class="title function_">encryptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Scope和域代理"><a href="#Scope和域代理" class="headerlink" title="@Scope和域代理"></a>@Scope和域代理</h4><p>Spring提供了一种通过作用域代理来处理作用域依赖关系的便捷方式。使用XML配置时创建此类代理的最简单方法是&lt;aop:scoped-proxy &#x2F;&gt;元素。使用@Scope注解在Java中配置你的bean提供了与proxyMode属性等效的支持。默认值是无代理（ScopedProxyMode.NO），但您可以指定ScopedProxyMode.TARGET_CLASS或ScopedProxyMode.INTERFACES。<br>如果您使用Java将域代理示例从XML参考文档（请参阅前面的链接）移植到我们的@Bean，它将如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="keyword">public</span> UserPreferences <span class="title function_">userPreferences</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserPreferences</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Service <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUserService</span>();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义bean命名"><a href="#自定义bean命名" class="headerlink" title="自定义bean命名"></a>自定义bean命名</h3><p>默认情况下，配置类使用@Bean方法的名称作为结果bean的名称。但是，可以使用name属性覆盖此功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myFoo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bean别名"><a href="#bean别名" class="headerlink" title="bean别名"></a>bean别名</h3><p>正如第7.3.1节“命名bean”中所讨论的，有时需要给单个bean多个名称，称为bean别名。 @Bean注解的name属性为此接受一个String数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &#123; &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bean描述"><a href="#bean描述" class="headerlink" title="bean描述"></a>bean描述</h3><p>有时候提供一个更详细的bean的文本描述是有帮助的。当bean暴露（可能通过JMX）用于监视目的时，这可能特别有用。<br>要将描述添加到@Bean，可以使用@Description注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description(&quot;Provides a basic example of a bean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-configuration注解"><a href="#使用-configuration注解" class="headerlink" title="使用@configuration注解"></a>使用@configuration注解</h2><hr>
<p>@Configuration是一个类级注解，指示一个对象是一个bean定义的来源。 @Configuration类通过public @Bean注解方法声明bean。调用@Configuration类上的@Bean方法也可以用来定义bean间的依赖关系。</p>
<h3 id="注入bean间依赖关系"><a href="#注入bean间依赖关系" class="headerlink" title="注入bean间依赖关系"></a>注入bean间依赖关系</h3><p>当@Beans彼此依赖时，表达这种依赖就如同一个bean方法调用另一个一样简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(bar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，foo bean通过构造函数注入接收对bar的引用。</p>
<blockquote>
<p>这种声明bean间依赖关系的方法只有在@Configuration类中声明@Bean方法时才起作用。你不能用简单的@Component类来声明bean间的依赖关系。</p>
</blockquote>
<h3 id="lookup方法注入"><a href="#lookup方法注入" class="headerlink" title="lookup方法注入"></a>lookup方法注入</h3><p>如前所述，lookup方法注入是一种您很少使用的高级功能。在单例范围的bean对原型范围的bean具有依赖关系的情况下，它很有用。对这种类型的配置使用Java提供了实现这种模式的自然方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取适当的Command接口的新实例</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// 设置（希望全新的）Command实例的状态</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//好的...但这个方法的实现在哪里？</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Java配置支持，您可以创建CommandManager的子类，其中抽象的createCommand（）方法被重写，以便查找新的（原型）命令对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AsyncCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandManager <span class="title function_">commandManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span></span><br><span class="line">    <span class="comment">// to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandManager</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有关基于Java的配置如何在内部工作的更多信息"><a href="#有关基于Java的配置如何在内部工作的更多信息" class="headerlink" title="有关基于Java的配置如何在内部工作的更多信息"></a>有关基于Java的配置如何在内部工作的更多信息</h3><p>以下示例显示了一个被调用两次的@Bean注解方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">clientService1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClientServiceImpl</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">clientService2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClientServiceImpl</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">        clientService.setClientDao(clientDao());</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientDao <span class="title function_">clientDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientDao（）在clientService1（）中被调用一次，在clientService2（）中被调用一次。由于此方法创建ClientDaoImpl的新实例并将其返回，因此通常期望拥有2个实例（每个服务一个实例）。这肯定会有问题：在Spring中，实例化的bean默认为<strong>singletion</strong>作用域。这就是神奇的地方：所有@Configuration类在启动时都使用CGLIB进行子类化。在子类中，child方法在调用父方法并创建新实例之前首先检查容器是否有缓存的（域）Bean。请注意，从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已在org.springframework.cglib下重新打包，并直接包含在Spring-Core JAR中。</p>
<blockquote>
<p>根据您的bean的域，行为可能会有所不同。我们在这里讨论singleton。</p>
</blockquote>
<blockquote>
<p>由于CGLIB在启动时动态添加功能，因此存在一些限制，特别是配置类不能是最终的。但是，从4.3开始，任何构造函数都可以在配置类上使用，包括对默认注入使用@Autowired或单个非默认构造函数声明。 如果您希望避免任何CGLIB限制，请考虑在非@配置类上声明您的@Bean方法，例如而是使用简单的@Component类。 @Bean方法之间的跨方法调用不会被拦截，因此您必须在构造方法或方法级别专门依赖依赖注入。</p>
</blockquote>
<h2 id="撰写基于Java的配置"><a href="#撰写基于Java的配置" class="headerlink" title="撰写基于Java的配置"></a>撰写基于Java的配置</h2><hr>
<h3 id="使用-Import注解"><a href="#使用-Import注解" class="headerlink" title="使用@Import注解"></a>使用@Import注解</h3><p>就像在Spring XML文件中使用&lt;import &#x2F;&gt;元素以帮助模块化配置一样，@Import注解允许从另一个配置类加载@Bean定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只需要显式提供ConfigB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在beanA和B将可用...</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> ctx.getBean(A.class);</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法简化了容器实例化，因为只有一个类需要处理，而不需要开发人员在构建过程中记住大量的@Configuration类。</p>
<blockquote>
<p>从Spring Framework 4.2开始，@Import还支持对常规组件类的引用，类似于AnnotationConfigApplicationContext.register方法。如果您想要避免组件扫描，使用几个配置类作为明确定义所有组件的入口点，这特别有用。</p>
</blockquote>
<h3 id="注入对导入的-Bean定义的依赖关系"><a href="#注入对导入的-Bean定义的依赖关系" class="headerlink" title="注入对导入的@Bean定义的依赖关系"></a>注入对导入的@Bean定义的依赖关系</h3><p>上面的例子很简单。在大多数实际场景中，bean会存在跨配置类之间彼此的依赖。当使用XML时，这本身并不是一个问题，因为不涉及编译器，并且可以简单地声明ref &#x3D;”someBean”并相信Spring将在容器初始化期间解决它。当然，在使用@Configuration类时，Java编译器会对配置模型施加约束，因为对其他bean的引用必须是有效的Java语法。<br>幸运的是，解决这个问题很简单。正如我们已经讨论过的，@Bean方法可以有任意数量的描述bean依赖关系的参数。让我们考虑一个更现实的场景，其中有几个@Configuration类，每个类都依赖于其他类中声明的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// 一切都通过配置类连接起来......</span></span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种方法可以实现相同的结果。请记住@Configuration类最终只是容器中的另一个bean：这意味着它们可以像任何其他bean一样利用@Autowired和@Value注入等等！</p>
<blockquote>
<p>确保以这种方式注入的依赖关系只有最简单的类型。 @Configuration类在上下文初始化期间处理得相当早，并强制依赖性以这种方式注入可能会导致意外的早期初始化。在可能的情况下，采用基于参数的注入，如上例所示。<br>此外，通过@Bean特别小心BeanPostProcessor和BeanFactoryPostProcessor定义。这些通常应该声明为静态的@Bean方法，而不是触发其包含的配置类的实例化。否则，@Autowired和@Value将不能在配置类本身上工作，因为它太早创建为bean实例。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RepositoryConfig</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Configuration类中的构造函数注入仅在Spring Framework 4.3中受支持。另请注意，如果目标bean只定义一个构造函数，则不需要指定@Autowired;在上面的例子中，RepositoryConfig构造函数不需要@Autowired。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/07/24/Spring%20%E6%A6%82%E8%BF%B0/" rel="prev" title="Spring 概述">
      <i class="fa fa-chevron-left"></i> Spring 概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/07/29/Spring-Web%EF%BC%88%E4%B8%80%EF%BC%89MVC%E6%A1%86%E6%9E%B6/" rel="next" title="Spring Web（一）MVC框架">
      Spring Web（一）MVC框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E5%92%8Cbean%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">Spring IoC容器和bean介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">配置元数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">实例化容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.1.</span> <span class="nav-text">编写基于XML的配置元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Groovy-Bean%E5%AE%9A%E4%B9%89DSL"><span class="nav-number">2.2.2.</span> <span class="nav-text">Groovy Bean定义DSL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">使用容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean%E6%A6%82%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text">Bean概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8Dbean"><span class="nav-number">3.1.</span> <span class="nav-text">命名bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8bean%E5%AE%9A%E4%B9%89%E5%A4%96%E4%B8%BAbean%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="nav-number">3.1.1.</span> <span class="nav-text">在bean定义外为bean起别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96bean"><span class="nav-number">3.2.</span> <span class="nav-text">实例化bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.2.1.</span> <span class="nav-text">使用构造方法实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.2.2.</span> <span class="nav-text">使用静态工厂方法实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.2.3.</span> <span class="nav-text">使用实例工厂方法实例化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">4.</span> <span class="nav-text">依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">4.1.</span> <span class="nav-text">依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">4.1.1.</span> <span class="nav-text">基于构造方法的依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">构造方法参数解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESetter%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">4.1.2.</span> <span class="nav-text">基于Setter的依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">依赖解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.1.4.</span> <span class="nav-text">依赖注入示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82"><span class="nav-number">4.2.</span> <span class="nav-text">依赖和配置细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%80%BC%EF%BC%88%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%8CString%E7%AD%89%E7%AD%89%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">直接值（原始类型，String等等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#idref%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">idref元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96bean%EF%BC%88%E5%8D%8F%E4%BD%9C%E8%80%85%EF%BC%89"><span class="nav-number">4.2.2.</span> <span class="nav-text">引用其他bean（协作者）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8bean"><span class="nav-number">4.2.3.</span> <span class="nav-text">内部bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">4.2.4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%90%88%E5%B9%B6"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">集合合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null%E5%92%8C%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC"><span class="nav-number">4.2.5.</span> <span class="nav-text">null和空字符串值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.6.</span> <span class="nav-text">使用p命名空间的XML快捷方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8c%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.7.</span> <span class="nav-text">使用c命名空间的XML快捷方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0"><span class="nav-number">4.2.8.</span> <span class="nav-text">复合属性名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8depends-on"><span class="nav-number">4.3.</span> <span class="nav-text">使用depends-on</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96bean"><span class="nav-number">4.4.</span> <span class="nav-text">延迟初始化bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E8%80%85"><span class="nav-number">4.5.</span> <span class="nav-text">自动装配协作者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">4.5.1.</span> <span class="nav-text">自动装配的限制和缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%AD%E6%8E%92%E9%99%A4%E4%B8%80%E4%B8%AAbean"><span class="nav-number">4.5.2.</span> <span class="nav-text">从自动装配中排除一个bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">4.6.</span> <span class="nav-text">方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lookup%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">4.6.1.</span> <span class="nav-text">Lookup方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2"><span class="nav-number">4.6.2.</span> <span class="nav-text">任意方法替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean%E5%9F%9F"><span class="nav-number">5.</span> <span class="nav-text">Bean域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#singleton%E5%9F%9F"><span class="nav-number">5.1.</span> <span class="nav-text">singleton域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype%E5%9F%9F"><span class="nav-number">5.2.</span> <span class="nav-text">prototype域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%9E%8Bbean%E7%9A%84%E5%8D%95%E4%BE%8Bbean"><span class="nav-number">5.3.</span> <span class="nav-text">依赖原型bean的单例bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-session-global-session-application%E5%92%8C-WebSocket%E5%9F%9F"><span class="nav-number">5.4.</span> <span class="nav-text">Request, session, global session, application和 WebSocket域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8Bweb%E9%85%8D%E7%BD%AE"><span class="nav-number">5.4.1.</span> <span class="nav-text">初始web配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request%E5%9F%9F"><span class="nav-number">5.4.2.</span> <span class="nav-text">Request域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session%E5%9F%9F"><span class="nav-number">5.4.3.</span> <span class="nav-text">Session域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#globalSession%E5%9F%9F"><span class="nav-number">5.4.4.</span> <span class="nav-text">globalSession域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application%E5%9F%9F"><span class="nav-number">5.4.5.</span> <span class="nav-text">Application域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96"><span class="nav-number">5.4.6.</span> <span class="nav-text">作用域bean作为依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.6.1.</span> <span class="nav-text">选择要创建的代理类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F"><span class="nav-number">5.5.</span> <span class="nav-text">自定义域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F"><span class="nav-number">5.5.1.</span> <span class="nav-text">创建自定义域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F"><span class="nav-number">5.5.2.</span> <span class="nav-text">使用自定义域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6bean%E6%80%A7%E8%B4%A8"><span class="nav-number">6.</span> <span class="nav-text">定制bean性质</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="nav-number">6.1.</span> <span class="nav-text">生命周期回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83"><span class="nav-number">6.1.1.</span> <span class="nav-text">初始化回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="nav-number">6.1.2.</span> <span class="nav-text">销毁回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.3.</span> <span class="nav-text">默认初始化和销毁方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="nav-number">6.1.4.</span> <span class="nav-text">组合生命周期机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E5%9B%9E%E8%B0%83"><span class="nav-number">6.1.5.</span> <span class="nav-text">启动和关闭回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%9D%9EWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%ADSpring-IoC%E5%AE%B9%E5%99%A8"><span class="nav-number">6.1.6.</span> <span class="nav-text">在非Web应用程序中正常关闭Spring IoC容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ApplicationContextAware%E5%92%8CBeanNameAware"><span class="nav-number">6.2.</span> <span class="nav-text">ApplicationContextAware和BeanNameAware</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96Aware%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.3.</span> <span class="nav-text">其他Aware接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF"><span class="nav-number">7.</span> <span class="nav-text">Bean定义继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">容器扩展点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8BeanPostProcessor%E8%87%AA%E5%AE%9A%E4%B9%89bean"><span class="nav-number">8.1.</span> <span class="nav-text">使用BeanPostProcessor自定义bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9AHello-World%EF%BC%8CBeanPostProcessor-style"><span class="nav-number">8.1.1.</span> <span class="nav-text">示例：Hello World，BeanPostProcessor-style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-RequiredAnnotationBeanPostProcessor"><span class="nav-number">8.1.2.</span> <span class="nav-text">示例： RequiredAnnotationBeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8BeanFactoryPostProcessor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">8.2.</span> <span class="nav-text">使用BeanFactoryPostProcessor自定义配置元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%B1%BB%E5%90%8D%E6%9B%BF%E6%8D%A2PropertyPlaceholderConfigurer"><span class="nav-number">8.2.1.</span> <span class="nav-text">示例：类名替换PropertyPlaceholderConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9APropertyOverrideConfigurer"><span class="nav-number">8.2.2.</span> <span class="nav-text">示例：PropertyOverrideConfigurer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8FactoryBean%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%BB%E8%BE%91"><span class="nav-number">8.3.</span> <span class="nav-text">使用FactoryBean自定义实例化逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">基于注解的容器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Required"><span class="nav-number">9.1.</span> <span class="nav-text">@Required</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired"><span class="nav-number">9.2.</span> <span class="nav-text">@Autowired</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E5%BE%AE%E8%B0%83%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">9.3.</span> <span class="nav-text">使用限定符微调基于注解的自动装配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Qualifier%E5%BE%AE%E8%B0%83%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">9.4.</span> <span class="nav-text">使用@Qualifier微调基于注解的自动装配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E4%BD%9C%E4%B8%BA%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">9.5.</span> <span class="nav-text">使用泛型作为自动装配限定符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CustomAutowireConfigurer"><span class="nav-number">9.6.</span> <span class="nav-text">CustomAutowireConfigurer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resource"><span class="nav-number">9.7.</span> <span class="nav-text">@Resource</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PostConstruct%E5%92%8C-PreDestroy"><span class="nav-number">9.8.</span> <span class="nav-text">@PostConstruct和@PreDestroy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">10.</span> <span class="nav-text">类路径扫描和管理的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Component%E5%92%8C%E6%9B%B4%E5%A4%9A%E6%A8%A1%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="nav-number">10.1.</span> <span class="nav-text">@Component和更多模型注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">10.2.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%92%8C%E6%B3%A8%E5%86%8Cbean%E5%AE%9A%E4%B9%89"><span class="nav-number">10.3.</span> <span class="nav-text">自动检测类和注册bean定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9D%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F"><span class="nav-number">10.4.</span> <span class="nav-text">使用过滤器来自定义扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89bean%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">10.5.</span> <span class="nav-text">在组件中定义bean元数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">10.6.</span> <span class="nav-text">命名自动检测的组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E6%8F%90%E4%BE%9B%E5%9F%9F"><span class="nav-number">10.7.</span> <span class="nav-text">为自动检测的组件提供域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%8F%90%E4%BE%9B%E9%99%90%E5%AE%9A%E7%AC%A6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">10.8.</span> <span class="nav-text">使用注解提供限定符元数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JSR-330%E6%A0%87%E5%87%86%E6%B3%A8%E8%A7%A3"><span class="nav-number">11.</span> <span class="nav-text">使用JSR 330标准注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">12.</span> <span class="nav-text">基于Java的容器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-Bean-%E5%92%8C-Configuration"><span class="nav-number">12.1.</span> <span class="nav-text">基本概念：@Bean 和@Configuration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AnnotationConfigApplicationContext%E5%AE%9E%E4%BE%8B%E5%8C%96Spring%E5%AE%B9%E5%99%A8"><span class="nav-number">12.2.</span> <span class="nav-text">使用AnnotationConfigApplicationContext实例化Spring容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="nav-number">12.3.</span> <span class="nav-text">简单结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8register-Class-lt-gt-%E2%80%A6-%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="nav-number">12.4.</span> <span class="nav-text">使用register(Class&lt;?&gt;…)编程式构建容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8scan-String%E2%80%A6%E2%80%8B-%E5%90%AF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="nav-number">12.5.</span> <span class="nav-text">使用scan(String…​)启用组件扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AnnotationConfigWebApplicationContext%E6%94%AF%E6%8C%81Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">12.6.</span> <span class="nav-text">使用AnnotationConfigWebApplicationContext支持Web应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.7.</span> <span class="nav-text">使用@Bean注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAbean"><span class="nav-number">12.7.1.</span> <span class="nav-text">声明一个bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E4%BE%9D%E8%B5%96"><span class="nav-number">12.7.2.</span> <span class="nav-text">Bean依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="nav-number">12.7.3.</span> <span class="nav-text">接收生命周期回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9Abean%E5%9F%9F"><span class="nav-number">12.7.4.</span> <span class="nav-text">指定bean域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Scope%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.7.4.1.</span> <span class="nav-text">使用@Scope注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scope%E5%92%8C%E5%9F%9F%E4%BB%A3%E7%90%86"><span class="nav-number">12.7.4.2.</span> <span class="nav-text">@Scope和域代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89bean%E5%91%BD%E5%90%8D"><span class="nav-number">12.7.5.</span> <span class="nav-text">自定义bean命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean%E5%88%AB%E5%90%8D"><span class="nav-number">12.7.6.</span> <span class="nav-text">bean别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean%E6%8F%8F%E8%BF%B0"><span class="nav-number">12.7.7.</span> <span class="nav-text">bean描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-configuration%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.8.</span> <span class="nav-text">使用@configuration注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5bean%E9%97%B4%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">12.8.1.</span> <span class="nav-text">注入bean间依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lookup%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">12.8.2.</span> <span class="nav-text">lookup方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">12.8.3.</span> <span class="nav-text">有关基于Java的配置如何在内部工作的更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%B0%E5%86%99%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">12.9.</span> <span class="nav-text">撰写基于Java的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Import%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.9.1.</span> <span class="nav-text">使用@Import注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E5%AF%B9%E5%AF%BC%E5%85%A5%E7%9A%84-Bean%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">12.9.2.</span> <span class="nav-text">注入对导入的@Bean定义的依赖关系</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">不识</p>
  <div class="site-description" itemprop="description">初心未终，此道可成</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不识</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
